Code Review Results:

------------------------------------------------------------
Code1: push { r4 , r5 , r6 , r7 , r8 , sb , sl , lr } sub sp , sp , 0xf8 mov r5 , r0 mov sb , r1 mov r8 , r2 ldr r3 , [ pc , 0xf4 ] ldr r3 , [ r3 ] str r3 , [ sp , 0xf4 ] mov r0 , 0x8000 bl 0xffff8cf0 subs r6 , r0 , 0x0 beq 0x104 mov r1 , r8 mov r0 , sp bl 0xfffff96c mov r7 , 0x1 mov sl , 0x8000 mov r4 , 0x0 mov r3 , r5 rsb r2 , r4 , 0x8000 mov r1 , r7 add r0 , r6 , r4 bl 0xffff8cb4 add r4 , r4 , r0 cmp r4 , 0x8000 beq 0xdc cmp r0 , 0x0 beq 0xc4 mov r0 , r5 bl 0xffff8d44 cmp r0 , 0x0 beq 0x48 cmp r4 , 0x0 bne 0xf0 mov r2 , r8 mov r1 , sb mov r0 , sp bl 0xfffffd0c mov r4 , 0x0 mov r0 , r6 bl 0xffff8bdc mov r0 , r4 ldr r2 , [ sp , 0xf4 ] ldr r3 , [ pc , 0x5c ] ldr r3 , [ r3 ] cmp r2 , r3 bne 0x10c add sp , sp , 0xf8 pop { r4 , r5 , r6 , r7 , r8 , sb , sl , pc } mov r0 , r5 bl 0xffff8be8 cmp r0 , 0x0 mvnne r4 , 0x0 bne 0x9c b 0x80 mov r2 , sl mov r1 , r6 mov r0 , sp bl 0xfffffa4c b 0x44 mov r2 , r4 mov r1 , r6 mov r0 , sp bl 0xfffffa4c b 0x88 mvn r4 , 0x0 b 0xa4 bl 0xffff8c48 andeq lr , r2 , r8 , lsl 0x30
Code2: push ebp mov ebp , esp push ebx push edi push esi sub esp , 0x7c mov eax , dword ptr [ ebp + 0x10 ] mov ecx , dword ptr [ ebp + 0xc ] mov edx , dword ptr [ ebp + 0x8 ] mov dword ptr [ ebp - 0x24 ] , eax mov dword ptr [ ebp - 0x28 ] , ecx mov dword ptr [ ebp - 0x2c ] , edx mov eax , esp add eax , - 0x10 mov esp , eax mov ecx , esp add ecx , - 0x10 mov esp , ecx mov edx , esp add edx , 0xffffff10 mov esp , edx mov esi , esp add esi , - 0x10 mov esp , esi mov edi , dword ptr [ ebp - 0x2c ] mov dword ptr [ ebp - 0x14 ] , edi mov ebx , dword ptr [ ebp - 0x28 ] mov dword ptr [ ebp - 0x18 ] , ebx mov edi , dword ptr [ ebp - 0x24 ] mov dword ptr [ ebp - 0x1c ] , edi mov dword ptr [ ebp - 0x20 ] , 0xffffffff mov dword ptr [ ebp - 0x30 ] , eax mov dword ptr [ ebp - 0x34 ] , ecx mov dword ptr [ ebp - 0x38 ] , edx mov dword ptr [ ebp - 0x3c ] , esi sub esp , 0x10 mov dword ptr [ esp ] , 0x8000 call 0xffff0ce0 add esp , 0x10 mov ecx , dword ptr [ ebp - 0x3c ] mov dword ptr [ ecx ] , eax cmp dword ptr [ ecx ] , 0x0 jne 0x8b mov dword ptr [ ebp - 0x10 ] , 0xffffffff jmp 0x287 mov eax , dword ptr [ ebp - 0x1c ] sub esp , 0x10 mov ecx , dword ptr [ ebp - 0x38 ] mov dword ptr [ esp ] , ecx mov dword ptr [ esp + 0x4 ] , eax call 0xffff57a0 add esp , 0x10 mov dword ptr [ ebp - 0x40 ] , eax jmp 0xab mov eax , dword ptr [ ebp - 0x30 ] mov dword ptr [ eax ] , 0x0 jmp 0xb9 mov eax , dword ptr [ ebp - 0x3c ] mov ecx , dword ptr [ eax ] mov edx , dword ptr [ ebp - 0x30 ] add ecx , dword ptr [ edx ] mov esi , 0x8000 sub esi , dword ptr [ edx ] mov edi , dword ptr [ ebp - 0x14 ] sub esp , 0x10 mov dword ptr [ esp ] , ecx mov dword ptr [ esp + 0x4 ] , 0x1 mov dword ptr [ esp + 0x8 ] , esi mov dword ptr [ esp + 0xc ] , edi call 0xffff0c80 add esp , 0x10 mov ecx , dword ptr [ ebp - 0x34 ] mov dword ptr [ ecx ] , eax mov eax , dword ptr [ ebp - 0x34 ] mov ecx , dword ptr [ eax ] mov edx , dword ptr [ ebp - 0x30 ] add ecx , dword ptr [ edx ] mov dword ptr [ edx ] , ecx mov ecx , 0x8000 cmp ecx , dword ptr [ edx ] sete bl mov byte ptr [ ebp - 0x41 ] , bl mov al , byte ptr [ ebp - 0x41 ] test al , 0x1 jne 0x119 jmp 0x11e jmp 0x1a3 mov eax , dword ptr [ ebp - 0x34 ] mov ecx , dword ptr [ eax ] mov dword ptr [ ebp - 0x48 ] , ecx xor eax , eax mov ecx , dword ptr [ ebp - 0x48 ] cmp eax , ecx sete dl mov byte ptr [ ebp - 0x49 ] , dl mov al , byte ptr [ ebp - 0x49 ] test al , 0x1 jne 0x143 jmp 0x173 mov eax , dword ptr [ ebp - 0x14 ] mov dword ptr [ ebp - 0x50 ] , eax sub esp , 0x10 mov eax , dword ptr [ ebp - 0x50 ] mov dword ptr [ esp ] , eax call 0xffff0be0 add esp , 0x10 mov dword ptr [ ebp - 0x54 ] , eax mov eax , dword ptr [ ebp - 0x54 ] cmp eax , 0x0 je 0x16e jmp 0x25d jmp 0x1d3 mov eax , dword ptr [ ebp - 0x14 ] mov dword ptr [ ebp - 0x58 ] , eax sub esp , 0x10 mov eax , dword ptr [ ebp - 0x58 ] mov dword ptr [ esp ] , eax call 0xffff0d30 add esp , 0x10 mov dword ptr [ ebp - 0x5c ] , eax mov eax , dword ptr [ ebp - 0x5c ] cmp eax , 0x0 je 0x19e jmp 0x1d3 jmp 0xb9 mov eax , dword ptr [ ebp - 0x3c ] mov ecx , dword ptr [ eax ] mov dword ptr [ ebp - 0x60 ] , ecx sub esp , 0x10 mov eax , dword ptr [ ebp - 0x38 ] mov dword ptr [ esp ] , eax mov ecx , dword ptr [ ebp - 0x60 ] mov dword ptr [ esp + 0x4 ] , ecx mov dword ptr [ esp + 0x8 ] , 0x8000 call 0xffff5c60 add esp , 0x10 mov dword ptr [ ebp - 0x64 ] , eax jmp 0xab mov eax , dword ptr [ ebp - 0x30 ] mov ecx , dword ptr [ eax ] mov dword ptr [ ebp - 0x68 ] , ecx mov eax , dword ptr [ ebp - 0x68 ] cmp eax , 0x0 seta cl mov byte ptr [ ebp - 0x69 ] , cl mov al , byte ptr [ ebp - 0x69 ] test al , 0x1 jne 0x1f7 jmp 0x22e mov eax , dword ptr [ ebp - 0x3c ] mov ecx , dword ptr [ eax ] mov edx , dword ptr [ ebp - 0x30 ] mov esi , dword ptr [ edx ] mov dword ptr [ ebp - 0x70 ] , ecx mov dword ptr [ ebp - 0x74 ] , esi sub esp , 0x10 mov eax , dword ptr [ ebp - 0x38 ] mov dword ptr [ esp ] , eax mov ecx , dword ptr [ ebp - 0x70 ] mov dword ptr [ esp + 0x4 ] , ecx mov edx , dword ptr [ ebp - 0x74 ] mov dword ptr [ esp + 0x8 ] , edx call 0xffff5c60 add esp , 0x10 mov dword ptr [ ebp - 0x78 ] , eax jmp 0x22e mov eax , dword ptr [ ebp - 0x18 ] mov dword ptr [ ebp - 0x7c ] , eax mov eax , dword ptr [ ebp - 0x1c ] sub esp , 0x10 mov ecx , dword ptr [ ebp - 0x38 ] mov dword ptr [ esp ] , ecx mov edx , dword ptr [ ebp - 0x7c ] mov dword ptr [ esp + 0x4 ] , edx mov dword ptr [ esp + 0x8 ] , eax call 0xfffff7c0 add esp , 0x10 mov dword ptr [ ebp - 0x80 ] , eax mov dword ptr [ ebp - 0x20 ] , 0x0 mov eax , dword ptr [ ebp - 0x3c ] mov ecx , dword ptr [ eax ] sub esp , 0x10 mov dword ptr [ esp ] , ecx call 0xffff0ba0 add esp , 0x10 mov eax , dword ptr [ ebp - 0x20 ] mov dword ptr [ ebp - 0x84 ] , eax mov eax , dword ptr [ ebp - 0x84 ] mov dword ptr [ ebp - 0x10 ] , eax jmp 0x287 mov eax , dword ptr [ ebp - 0x10 ] mov dword ptr [ ebp - 0x88 ] , eax mov eax , dword ptr [ ebp - 0x88 ] lea esp , [ ebp - 0xc ] pop esi pop edi pop ebx pop ebp ret nop
Similarity: -1
Label: 1
Similarity Score: -0.9
Explanation: The two assembly codes show significant dissimilarity due to fundamental architectural differences (ARM vs x86), divergent register usage, and distinct control flow patterns. While both initialize a buffer (0x8000) and share common low-level concepts like stack manipulation and function calls, their instruction sets, calling conventions, and branching mechanisms are entirely incompatible. The ARM code uses condition flags (e.g., `beq`, `bne`) and barrel-shifted operands, while the x86 relies on `cmp`/`jne` pairs and explicit memory addressing. These structural and semantic disparities outweigh superficial similarities, indicating they implement different logic.
------------------------------------------------------------

------------------------------------------------------------
Code1: push rbp mov rbp , rsp sub rsp , 0x70 mov qword ptr [ rbp - 0x8 ] , rdi mov qword ptr [ rbp - 0x10 ] , rsi mov dword ptr [ rbp - 0x14 ] , 0x0 mov qword ptr [ rbp - 0x20 ] , 0x0 mov qword ptr [ rbp - 0x30 ] , 0x0 mov rsi , qword ptr [ rbp - 0x10 ] mov dword ptr [ rsi ] , 0x0 call 0xfffffffffffce420 mov qword ptr [ rbp - 0x20 ] , rax mov rax , qword ptr [ rbp - 0x20 ] test rax , rax sete cl movzx edx , cl mov eax , edx mov rax , qword ptr [ rax * 0x8 + 0x9c9c70 ] jmp rax mov rax , qword ptr [ rip + 0x471d26 ] jmp rax call 0xfffffffffffcc190 mov qword ptr [ rbp - 0x30 ] , rax mov rax , qword ptr [ rbp - 0x30 ] test rax , rax sete cl movzx edx , cl mov eax , edx mov rax , qword ptr [ rax * 0x8 + 0x9c9c80 ] jmp rax mov rax , qword ptr [ rip + 0x471cfb ] jmp rax mov rax , qword ptr [ rbp - 0x8 ] mov rax , qword ptr [ rax + 0x10 ] mov ecx , dword ptr [ rax + 0x8 ] sub ecx , 0x1 sete dl movzx esi , dl mov eax , esi mov rax , qword ptr [ rax * 0x8 + 0x9c9c90 ] mov dword ptr [ rbp - 0x34 ] , ecx jmp rax mov rax , qword ptr [ rbp - 0x8 ] mov rax , qword ptr [ rax + 0x10 ] mov rax , qword ptr [ rax ] mov rax , qword ptr [ rax ] sub rax , 0x2 sete cl movzx edx , cl mov esi , edx mov rsi , qword ptr [ rsi * 0x8 + 0x9c9ca0 ] mov qword ptr [ rbp - 0x40 ] , rax jmp rsi mov rax , qword ptr [ rbp - 0x8 ] mov rax , qword ptr [ rax + 0x10 ] mov ecx , dword ptr [ rax + 0x10 ] test ecx , ecx setne dl movzx ecx , dl mov eax , ecx mov rax , qword ptr [ rax * 0x8 + 0x9c9cb0 ] jmp rax mov rax , qword ptr [ rbp - 0x8 ] mov rdi , qword ptr [ rax + 0x8 ] mov esi , 0x18 call 0xfffffffffffd6000 mov qword ptr [ rbp - 0x28 ] , rax mov rax , qword ptr [ rbp - 0x28 ] sub rax , 0xb setne cl movzx edx , cl mov esi , edx mov rsi , qword ptr [ rsi * 0x8 + 0x9c9cc0 ] mov qword ptr [ rbp - 0x48 ] , rax jmp rsi mov rax , qword ptr [ rbp - 0x10 ] mov ecx , dword ptr [ rax ] or ecx , 0x8 mov dword ptr [ rax ] , ecx mov rax , qword ptr [ rip + 0x471bb9 ] jmp rax mov rax , qword ptr [ rip + 0x471c00 ] jmp rax mov rax , qword ptr [ rbp - 0x8 ] mov rax , qword ptr [ rax + 0x10 ] mov ecx , dword ptr [ rax + 0x8 ] sub ecx , 0x1 sete dl movzx esi , dl mov eax , esi mov rax , qword ptr [ rax * 0x8 + 0x9c9cd0 ] mov dword ptr [ rbp - 0x4c ] , ecx jmp rax mov rax , qword ptr [ rbp - 0x8 ] mov rax , qword ptr [ rax + 0x10 ] mov rax , qword ptr [ rax ] mov rax , qword ptr [ rax ] sub rax , 0x5 sete cl movzx edx , cl mov esi , edx mov rsi , qword ptr [ rsi * 0x8 + 0x9c9ce0 ] mov qword ptr [ rbp - 0x58 ] , rax jmp rsi mov rax , qword ptr [ rbp - 0x8 ] mov rax , qword ptr [ rax + 0x10 ] mov ecx , dword ptr [ rax + 0x10 ] test ecx , ecx setne dl movzx ecx , dl mov eax , ecx mov rax , qword ptr [ rax * 0x8 + 0x9c9cf0 ] jmp rax mov rax , qword ptr [ rbp - 0x8 ] mov rdi , qword ptr [ rax + 0x8 ] mov esi , 0xa call 0xfffffffffffd6000 mov qword ptr [ rbp - 0x28 ] , rax mov rax , qword ptr [ rbp - 0x28 ] sub rax , 0x3 setne cl movzx edx , cl mov esi , edx mov rsi , qword ptr [ rsi * 0x8 + 0x9c9d00 ] mov qword ptr [ rbp - 0x60 ] , rax jmp rsi mov rax , qword ptr [ rbp - 0x28 ] sub rax , 0x7 setne cl movzx edx , cl mov esi , edx mov rsi , qword ptr [ rsi * 0x8 + 0x9c9d10 ] mov qword ptr [ rbp - 0x68 ] , rax jmp rsi mov rax , qword ptr [ rbp - 0x10 ] mov ecx , dword ptr [ rax ] or ecx , 0x8 mov dword ptr [ rax ] , ecx mov rax , qword ptr [ rip + 0x471b18 ] jmp rax mov rax , qword ptr [ rip + 0x471b1f ] jmp rax mov rax , qword ptr [ rbp - 0x10 ] mov ecx , dword ptr [ rax ] or ecx , 0x4 mov dword ptr [ rax ] , ecx mov rax , qword ptr [ rip + 0x471b0b ] jmp rax mov rax , qword ptr [ rip + 0x471b0a ] jmp rax mov rax , qword ptr [ rbp - 0x8 ] mov rdi , qword ptr [ rax + 0x8 ] mov rdx , qword ptr [ rbp - 0x20 ] xor ecx , ecx mov eax , ecx mov esi , ecx mov rcx , rax call 0xfffffffffffd8370 test eax , eax setne r8b movzx eax , r8b mov ecx , eax mov rcx , qword ptr [ rcx * 0x8 + 0x9c9d20 ] jmp rcx mov rax , qword ptr [ rbp - 0x10 ] mov ecx , dword ptr [ rax ] or ecx , 0x1 mov dword ptr [ rax ] , ecx mov rax , qword ptr [ rip + 0x471afe ] jmp rax mov rdi , qword ptr [ rbp - 0x30 ] mov rax , qword ptr [ rbp - 0x8 ] mov rsi , qword ptr [ rax + 0x8 ] call 0xfffffffffffd5680 test eax , eax setne cl movzx eax , cl mov esi , eax mov rsi , qword ptr [ rsi * 0x8 + 0x9c9d30 ] jmp rsi mov rax , qword ptr [ rip + 0x471ad8 ] jmp rax mov rdi , qword ptr [ rbp - 0x30 ] mov rdx , qword ptr [ rbp - 0x20 ] xor eax , eax mov ecx , eax mov esi , eax call 0xfffffffffffd8370 test eax , eax setne r8b movzx eax , r8b mov ecx , eax mov rcx , qword ptr [ rcx * 0x8 + 0x9c9d40 ] jmp rcx mov rax , qword ptr [ rbp - 0x10 ] mov ecx , dword ptr [ rax ] or ecx , 0x2 mov dword ptr [ rax ] , ecx mov rax , qword ptr [ rip + 0x471a8b ] jmp rax mov rax , qword ptr [ rip + 0x471a8a ] jmp rax mov dword ptr [ rbp - 0x14 ] , 0x1 mov rax , qword ptr [ rip + 0x471a82 ] jmp rax mov rax , qword ptr [ rbp - 0x20 ] test rax , rax setne cl movzx edx , cl mov eax , edx mov rax , qword ptr [ rax * 0x8 + 0x9c9d50 ] jmp rax mov rdi , qword ptr [ rbp - 0x20 ] call 0xfffffffffffce560 mov rdi , qword ptr [ rip + 0x471a67 ] jmp rdi mov rax , qword ptr [ rbp - 0x30 ] test rax , rax setne cl movzx edx , cl mov eax , edx mov rax , qword ptr [ rax * 0x8 + 0x9c9d60 ] jmp rax mov rdi , qword ptr [ rbp - 0x30 ] call 0xfffffffffffcc090 mov rdi , qword ptr [ rip + 0x471a4c ] jmp rdi mov eax , dword ptr [ rbp - 0x14 ] add rsp , 0x70 pop rbp ret nop
Code2: push rbp mov rbp , rsp sub rsp , 0x30 mov qword ptr [ rbp - 0x8 ] , rdi mov qword ptr [ rbp - 0x10 ] , rsi mov dword ptr [ rbp - 0x14 ] , 0x0 mov qword ptr [ rbp - 0x20 ] , 0x0 mov qword ptr [ rbp - 0x30 ] , 0x0 mov rsi , qword ptr [ rbp - 0x10 ] mov dword ptr [ rsi ] , 0x0 call 0xfffffffffffd6cb0 mov qword ptr [ rbp - 0x20 ] , rax cmp qword ptr [ rbp - 0x20 ] , 0x0 jne 0x4a jmp 0x27b call 0xfffffffffffd4e80 mov qword ptr [ rbp - 0x30 ] , rax cmp qword ptr [ rbp - 0x30 ] , 0x0 jne 0x63 jmp 0x27b mov rax , qword ptr [ rbp - 0x8 ] mov rax , qword ptr [ rax + 0x10 ] cmp dword ptr [ rax + 0x8 ] , 0x1 jne 0x116 mov rax , qword ptr [ rbp - 0x8 ] mov rax , qword ptr [ rax + 0x10 ] mov rax , qword ptr [ rax ] cmp qword ptr [ rax ] , 0x2 jne 0x116 mov rax , qword ptr [ rbp - 0x8 ] mov rax , qword ptr [ rax + 0x10 ] cmp dword ptr [ rax + 0x10 ] , 0x0 jne 0x116 mov rax , qword ptr [ rbp - 0x8 ] mov rdi , qword ptr [ rax + 0x8 ] mov esi , 0x18 call 0xfffffffffffdd610 mov qword ptr [ rbp - 0x28 ] , rax cmp qword ptr [ rbp - 0x28 ] , 0xb je 0x111 mov rax , qword ptr [ rbp - 0x10 ] mov ecx , dword ptr [ rax ] mov edx , ecx xor edx , 0xffffffff mov esi , 0xffffffff mov edi , esi xor edi , 0x8 xor esi , 0x25ff5ad6 mov r8d , edx and r8d , 0x25ff5ad6 and ecx , esi mov r9d , edi and r9d , 0x25ff5ad6 mov r10d , esi and r10d , 0x8 or r8d , ecx or r9d , r10d xor r8d , r9d or edx , edi xor edx , 0xffffffff or esi , 0x25ff5ad6 and edx , esi or r8d , edx mov dword ptr [ rax ] , r8d jmp 0x1eb mov rax , qword ptr [ rbp - 0x8 ] mov rax , qword ptr [ rax + 0x10 ] cmp dword ptr [ rax + 0x8 ] , 0x1 jne 0x192 mov rax , qword ptr [ rbp - 0x8 ] mov rax , qword ptr [ rax + 0x10 ] mov rax , qword ptr [ rax ] cmp qword ptr [ rax ] , 0x5 jne 0x192 mov rax , qword ptr [ rbp - 0x8 ] mov rax , qword ptr [ rax + 0x10 ] cmp dword ptr [ rax + 0x10 ] , 0x0 jne 0x192 mov rax , qword ptr [ rbp - 0x8 ] mov rdi , qword ptr [ rax + 0x8 ] mov esi , 0xa call 0xfffffffffffdd610 mov qword ptr [ rbp - 0x28 ] , rax cmp qword ptr [ rbp - 0x28 ] , 0x3 je 0x18d cmp qword ptr [ rbp - 0x28 ] , 0x7 je 0x18d mov rax , qword ptr [ rbp - 0x10 ] mov ecx , dword ptr [ rax ] mov edx , ecx and edx , 0x8 xor ecx , 0x8 or edx , ecx mov dword ptr [ rax ] , edx jmp 0x1e6 mov rax , qword ptr [ rbp - 0x10 ] mov ecx , dword ptr [ rax ] mov edx , ecx xor edx , 0xffffffff mov esi , 0xffffffff mov edi , esi xor edi , 0x4 xor esi , 0xe74d2c2b mov r8d , edx and r8d , 0xe74d2c2b and ecx , esi mov r9d , edi and r9d , 0xe74d2c2b mov r10d , esi and r10d , 0x4 or r8d , ecx or r9d , r10d xor r8d , r9d or edx , edi xor edx , 0xffffffff or esi , 0xe74d2c2b and edx , esi or r8d , edx mov dword ptr [ rax ] , r8d jmp 0x1eb xor esi , esi xor eax , eax mov ecx , eax mov rdx , qword ptr [ rbp - 0x8 ] mov rdi , qword ptr [ rdx + 0x8 ] mov rdx , qword ptr [ rbp - 0x20 ] call 0xfffffffffffdef20 cmp eax , 0x0 jne 0x222 mov rax , qword ptr [ rbp - 0x10 ] mov ecx , dword ptr [ rax ] mov edx , ecx and edx , 0x1 xor ecx , 0x1 or edx , ecx mov dword ptr [ rax ] , edx jmp 0x274 mov rdi , qword ptr [ rbp - 0x30 ] mov rax , qword ptr [ rbp - 0x8 ] mov rsi , qword ptr [ rax + 0x8 ] call 0xfffffffffffdcdb0 cmp eax , 0x0 jne 0x241 jmp 0x27b xor esi , esi xor eax , eax mov ecx , eax mov rdi , qword ptr [ rbp - 0x30 ] mov rdx , qword ptr [ rbp - 0x20 ] call 0xfffffffffffdef20 cmp eax , 0x0 jne 0x26f mov rax , qword ptr [ rbp - 0x10 ] mov ecx , dword ptr [ rax ] mov edx , ecx and edx , 0x2 xor ecx , 0x2 or edx , ecx mov dword ptr [ rax ] , edx jmp 0x274 mov dword ptr [ rbp - 0x14 ] , 0x1 cmp qword ptr [ rbp - 0x20 ] , 0x0 je 0x28f mov rdi , qword ptr [ rbp - 0x20 ] call 0xfffffffffffd6de0 cmp qword ptr [ rbp - 0x30 ] , 0x0 je 0x2a3 mov rdi , qword ptr [ rbp - 0x30 ] call 0xfffffffffffd4da0 mov eax , dword ptr [ rbp - 0x14 ] add rsp , 0x30 pop rbp ret nop dword ptr [ rax ]
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly codes use entirely different control flow structures (jump tables in the first vs conditional branches in the second) and have different sequences of instructions, function calls, and constants. While both set bits in a flags variable and return a status, the specific conditions and operations are too dissimilar to be considered the same or similar.
------------------------------------------------------------

------------------------------------------------------------
Code1: addiu sp , sp , - 0x28 sw ra , 0x24 ( sp ) sw s1 , 0x20 ( sp ) sw s0 , 0x1c ( sp ) lui gp , 0x68 addiu gp , gp , 0x1de0 sw gp , 0x10 ( sp ) move s1 , a0 move s0 , a1 move a0 , a1 lw t9 , - 0x53bc ( gp ) jalr t9 nop lw gp , 0x10 ( sp ) move a2 , v0 move a1 , s0 move a0 , s1 jal 0x51d998 nop lw gp , 0x10 ( sp ) lw ra , 0x24 ( sp ) lw s1 , 0x20 ( sp ) lw s0 , 0x1c ( sp ) jr ra addiu sp , sp , 0x28
Code2: push { r4 , r5 , r6 , r7 , r8 , lr } mov r4 , r0 sub sp , sp , 0x8 mov r0 , r1 mov r6 , r1 bl 0xfff26580 mov r8 , r0 bl 0xfff26598 mov r3 , 0x0 ldr r5 , [ r4 , 0x20 ] str r3 , [ r0 ] ldr r3 , [ r5 , 0x1c ] mov r7 , r0 cmp r3 , 0x0 bne 0xc8 ldrh r2 , [ r5 ] ldr r0 , [ r4 , 0x1c ] cmp r2 , 0x2 movne ip , 0x1c moveq ip , 0x10 mov r1 , r6 mov r2 , r8 stm sp , { r5 , ip } bl 0xfff266ac mov r6 , r0 mov r1 , 0xf mov r0 , r4 bl 0xffff5564 cmp r6 , 0x0 ble 0x84 mov r0 , r6 add sp , sp , 0x8 pop { r4 , r5 , r6 , r7 , r8 , pc } add r3 , r6 , 0x1 cmp r3 , 0x1 bhi 0x78 ldr r3 , [ r7 ] cmp r3 , 0x47 beq 0xb0 bgt 0xe0 cmp r3 , 0x4 beq 0xb0 cmp r3 , 0xb bne 0x78 mov r0 , r4 mov r1 , 0xa bl 0xffff5580 ldr r3 , [ r7 ] str r3 , [ r5 , 0x20 ] b 0x78 mov r1 , r6 mov r2 , r8 ldr r0 , [ r4 , 0x1c ] bl 0xfff2664c mov r6 , r0 b 0x64 sub r3 , r3 , 0x72 cmp r3 , 0x1 bhi 0x78 b 0xb0
Similarity: -1
Label: 1
Similarity Score: -0.8
Explanation: The codes are from different architectures (MIPS vs ARM) with significant structural differences. While both have function prologue/epilogue (stack adjustment, register saves) and function calls (jalr/bl), the MIPS code is linear and simple, whereas the ARM code has complex branching, comparisons, and memory operations. No matching logic beyond basic setup/teardown. Architecture divergence and operational complexity make them largely dissimilar.
------------------------------------------------------------

------------------------------------------------------------
Code1: push rbp push rbx mov rbp , rdi movsxd rbx , edx sub rsp , 0x48 mov rax , qword ptr fs : [ 0x28 ] mov qword ptr [ rsp + 0x38 ] , rax xor eax , eax cmp byte ptr [ rip + 0x2852ce ] , 0x0 je 0xc0 cmp byte ptr [ rip + 0x28524b ] , 0x0 mov rdi , qword ptr [ rip + 0x285259 ] jne 0x160 call 0x56910 test ebx , ebx mov rbp , rax js 0x17c mov qword ptr [ rsp ] , 0x4 mov qword ptr [ rsp + 0x20 ] , rbx mov rdx , rsp mov esi , 0x1a mov rdi , rbp call 0x8130 mov rbx , rax mov rdi , rax call 0xfffffffffffffa70 mov rsi , rbx mov rdi , rax call 0x8230 test rax , rax mov qword ptr [ rip + 0x2851ce ] , rax je 0x190 xor esi , esi mov rdi , rax mov qword ptr [ rip + 0x2851a8 ] , 0x0 call 0x9190 mov rdi , rbp mov qword ptr [ rip + 0x2851a1 ] , rax call 0xffffffffffff5560 xor eax , eax jmp 0x143 nop dword ptr [ rax + rax ] mov eax , ebx mov edx , 0x1a4 lea rdi , [ rip + 0x5cd52 ] and eax , 0xfff test ebx , ebx cmovs eax , edx mov rdx , rsi mov esi , eax xor eax , eax call 0x56b50 mov rdi , rax mov rbx , rax call 0xfffffffffffeb690 mov rdi , qword ptr [ rip + 0x2851f2 ] mov rdx , rax mov rsi , rbx mov rcx , qword ptr [ rdi ] call qword ptr [ rcx + 0x18 ] mov rdi , rbx call 0xffffffffffff5560 mov rdi , rbp call 0xfffffffffffeb690 mov rdi , qword ptr [ rip + 0x2851cf ] mov rdx , rax mov rsi , rbp mov rcx , qword ptr [ rdi ] call qword ptr [ rcx + 0x18 ] mov rdi , qword ptr [ rip + 0x2851bc ] mov edx , 0x1 lea rsi , [ rip + 0x5fa73 ] mov rax , qword ptr [ rdi ] call qword ptr [ rax + 0x18 ] call 0xffffffffffffef70 mov rcx , qword ptr [ rsp + 0x38 ] xor rcx , qword ptr fs : [ 0x28 ] jne 0x1c9 add rsp , 0x48 pop rbx pop rbp ret nop word ptr [ rax + rax ] lea rsi , [ rip + 0x5a2ba ] xor ecx , ecx mov rdx , rbp call 0x56950 test ebx , ebx mov rbp , rax jns 0x4d mov qword ptr [ rsp ] , 0x0 jmp 0x5a nop dword ptr [ rax ] call 0x7f20 mov rdi , qword ptr [ rip + 0x284fe4 ] lea rsi , [ rip + 0x5cc61 ] mov rcx , rax mov rdx , rbp xor eax , eax call 0xffffffffffffed20 mov rdi , rbp call 0xffffffffffff5560 add dword ptr [ rip + 0x285135 ] , 0x1 mov eax , 0x1 jmp 0x143 call 0xfffffffffffeb6b0 nop
Code2: lui gp , 0x4e addiu sp , sp , - 0x60 addiu gp , gp , 0x60f0 lui v0 , 0x4e sw s1 , 0x4c ( sp ) lw s1 , - 0x7328 ( gp ) lbu v0 , - 0x10ff ( v0 ) sw s2 , 0x50 ( sp ) move s2 , a0 sw s0 , 0x48 ( sp ) sw ra , 0x5c ( sp ) sw s4 , 0x58 ( sp ) sw s3 , 0x54 ( sp ) sw gp , 0x10 ( sp ) lw v1 , ( s1 ) lw s0 , 0x70 ( sp ) sw v1 , 0x44 ( sp ) beqz v0 , 0x174 lui v0 , 0x4e lui v1 , 0x4e lbu v0 , - 0x1131 ( v0 ) bnez v0 , 0x258 lw a0 , - 0x1128 ( v1 ) lw t9 , - 0x7fb0 ( gp ) jalr t9 nop lw gp , 0x10 ( sp ) bltz s0 , 0x27c move s3 , v0 addiu v0 , zero , 0x4 sw s0 , 0x30 ( sp ) sw v0 , 0x18 ( sp ) lw t9 , - 0x7994 ( gp ) addiu a2 , sp , 0x18 addiu a1 , zero , 0x1a bal 0xf7dc move a0 , s3 lw gp , 0x10 ( sp ) move a0 , v0 lw t9 , - 0x79e4 ( gp ) bal 0xf228 move s2 , v0 lw gp , 0x10 ( sp ) lw t9 , - 0x79e0 ( gp ) bal 0xf110 nop lw gp , 0x10 ( sp ) beqz v0 , 0x2e0 move s0 , v0 lw t9 , - 0x79dc ( gp ) bal 0xf234 move a0 , s0 beq s2 , v0 , 0x108 lw gp , 0x10 ( sp ) lw t9 , - 0x79d8 ( gp ) bal 0xf330 nop lui a1 , 0x4c lw gp , 0x10 ( sp ) lui a0 , 0x4e addiu a1 , a1 , - 0x34dc addiu a0 , a0 , - 0x1fa0 lw t9 , - 0x7a1c ( gp ) bal - 0x161bc move a2 , v0 lw gp , 0x10 ( sp ) lw t9 , - 0x7990 ( gp ) move a1 , s2 bal 0xf9bc move a0 , s0 lui v1 , 0x4e lw gp , 0x10 ( sp ) beqz v0 , 0x28c sw v0 , - 0x1144 ( v1 ) move a0 , v0 lw t9 , - 0x798c ( gp ) lui v0 , 0x4e move t1 , zero move t0 , zero move a3 , zero sw t1 , - 0x114c ( v0 ) move a2 , zero bal 0x12510 sw t0 , - 0x1150 ( v0 ) lui v1 , 0x4e lw gp , 0x10 ( sp ) move a0 , s3 lw t9 , - 0x7fcc ( gp ) bal - 0x16464 sw v0 , - 0x1148 ( v1 ) move v0 , zero b 0x22c lw gp , 0x10 ( sp ) bltz s0 , 0x284 nop andi a1 , s0 , 0xfff lui a0 , 0x4c lw t9 , - 0x7f98 ( gp ) lui s0 , 0x4e jalr t9 addiu a0 , a0 , - 0x3398 lw gp , 0x10 ( sp ) move a0 , v0 lw s4 , - 0x1104 ( s0 ) lw t9 , - 0x73f4 ( gp ) jalr t9 move s3 , v0 move a1 , s3 move a2 , v0 lw v0 , ( s4 ) lw t9 , 0xc ( v0 ) jalr t9 move a0 , s4 lw gp , 0x10 ( sp ) lw t9 , - 0x7fcc ( gp ) bal - 0x16464 move a0 , s3 move a0 , s2 lw gp , 0x10 ( sp ) lw t9 , - 0x73f4 ( gp ) jalr t9 lw s3 , - 0x1104 ( s0 ) move a1 , s2 lw v1 , ( s3 ) move a0 , s3 lw t9 , 0xc ( v1 ) jalr t9 move a2 , v0 lui a1 , 0x4c lw v0 , - 0x1104 ( s0 ) addiu a2 , zero , 0x1 move a0 , v0 lw v0 , ( v0 ) lw t9 , 0xc ( v0 ) jalr t9 addiu a1 , a1 , 0x2364 jal 0x42d468 nop lw gp , 0x10 ( sp ) lw a0 , 0x44 ( sp ) lw v1 , ( s1 ) bne a0 , v1 , 0x300 lw ra , 0x5c ( sp ) lw s4 , 0x58 ( sp ) lw s3 , 0x54 ( sp ) lw s2 , 0x50 ( sp ) lw s1 , 0x4c ( sp ) lw s0 , 0x48 ( sp ) jr ra addiu sp , sp , 0x60 lui a1 , 0x4c lw t9 , - 0x7c24 ( gp ) move a3 , zero addiu a1 , a1 , - 0x33b8 jalr t9 move a2 , s2 lw gp , 0x10 ( sp ) bgez s0 , 0x74 move s3 , v0 b 0x80 sw zero , 0x18 ( sp ) b 0x180 addiu a1 , zero , 0x1a4 lw v0 , - 0x7310 ( gp ) lw t9 , - 0x79d8 ( gp ) bal 0xf330 lw s0 , ( v0 ) lui a1 , 0x4c move a3 , v0 addiu a1 , a1 , - 0x33b4 move a0 , s0 jal 0x42c72c move a2 , s3 lw gp , 0x10 ( sp ) lw t9 , - 0x7fcc ( gp ) bal - 0x16464 move a0 , s3 lui a0 , 0x4e lw gp , 0x10 ( sp ) addiu v0 , zero , 0x1 lw v1 , - 0x10fc ( a0 ) addiu v1 , v1 , 0x1 b 0x22c sw v1 , - 0x10fc ( a0 ) lui a1 , 0x4c lw t9 , - 0x7a1c ( gp ) lui a0 , 0x4e addiu a1 , a1 , - 0x3510 bal - 0x161bc addiu a0 , a0 , - 0x1fa0 b 0xc4 lw gp , 0x10 ( sp ) lw t9 , - 0x735c ( gp ) jalr t9 nop
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The codes are from different architectures (x86-64 vs MIPS) with fundamentally different instruction sets, register usage, and stack management. No structural similarities exist in control flow patterns, function calls, or data handling. The operations, branching logic, and memory access patterns show no alignment, indicating completely unrelated functionality.
------------------------------------------------------------

------------------------------------------------------------
Code1: lui gp , 0x46 addiu sp , sp , - 0x30 addiu gp , gp , - 0xc60 sw ra , 0x2c ( sp ) lw v0 , - 0x7fb8 ( gp ) sw s3 , 0x28 ( sp ) sw s2 , 0x24 ( sp ) sw s1 , 0x20 ( sp ) sw s0 , 0x1c ( sp ) sw gp , 0x10 ( sp ) lw v0 , ( v0 ) bnez v0 , 0x74 lw t9 , - 0x7df8 ( gp ) lw t9 , - 0x7d84 ( gp ) move s0 , a0 move s1 , a1 jalr t9 move s2 , a2 lw gp , 0x10 ( sp ) bnez v0 , 0x90 move s3 , v0 lw ra , 0x2c ( sp ) move v0 , s3 lw s3 , 0x28 ( sp ) lw s2 , 0x24 ( sp ) lw s1 , 0x20 ( sp ) lw s0 , 0x1c ( sp ) jr ra addiu sp , sp , 0x30 lw ra , 0x2c ( sp ) lw s3 , 0x28 ( sp ) lw s2 , 0x24 ( sp ) lw s1 , 0x20 ( sp ) lw s0 , 0x1c ( sp ) jr t9 addiu sp , sp , 0x30 lw t9 , - 0x7b8c ( gp ) jalr t9 nop addiu v1 , zero , 0x2 lw v0 , ( v0 ) beq v0 , v1 , 0xb8 lw gp , 0x10 ( sp ) addiu v1 , zero , 0x14 bne v0 , v1 , 0x58 lw ra , 0x2c ( sp ) lw t9 , - 0x7df8 ( gp ) move a2 , s2 move a1 , s1 b 0x74 move a0 , s0
Code2: push ebp mov ebp , esp push ebx push edi push esi sub esp , 0x4c mov eax , dword ptr [ ebp + 0x10 ] mov ecx , dword ptr [ ebp + 0xc ] mov edx , dword ptr [ ebp + 0x8 ] mov dword ptr [ ebp - 0x1c ] , eax mov dword ptr [ ebp - 0x20 ] , ecx mov dword ptr [ ebp - 0x24 ] , edx xor eax , eax mov ecx , esp add ecx , - 0x10 mov esp , ecx mov edx , esp add edx , - 0x10 mov esp , edx mov esi , dword ptr [ ebp - 0x24 ] mov dword ptr [ ebp - 0x14 ] , esi mov edi , dword ptr [ ebp - 0x20 ] mov dword ptr [ ebp - 0x18 ] , edi mov ebx , dword ptr [ ebp - 0x1c ] mov dword ptr [ ecx ] , ebx cmp eax , dword ptr [ 0x80a23ec ] sete al mov dword ptr [ ebp - 0x28 ] , ecx mov dword ptr [ ebp - 0x2c ] , edx mov byte ptr [ ebp - 0x2d ] , al mov al , byte ptr [ ebp - 0x2d ] test al , 0x1 jne 0x5e jmp 0x100 mov eax , dword ptr [ ebp - 0x14 ] mov ecx , dword ptr [ ebp - 0x18 ] mov dword ptr [ ebp - 0x34 ] , eax mov dword ptr [ ebp - 0x38 ] , ecx mov eax , dword ptr [ ebp - 0x28 ] mov ecx , dword ptr [ eax ] sub esp , 0x10 mov edx , dword ptr [ ebp - 0x34 ] mov dword ptr [ esp ] , edx mov esi , dword ptr [ ebp - 0x38 ] mov dword ptr [ esp + 0x4 ] , esi mov dword ptr [ esp + 0x8 ] , ecx call 0x330d0 add esp , 0x10 xor ecx , ecx mov edx , dword ptr [ ebp - 0x2c ] mov dword ptr [ edx ] , eax cmp ecx , dword ptr [ edx ] sete bl mov byte ptr [ ebp - 0x39 ] , bl mov al , byte ptr [ ebp - 0x39 ] test al , 0x1 jne 0xaa jmp 0xb6 mov dword ptr [ ebp - 0x10 ] , 0x0 jmp 0x130 mov eax , dword ptr [ ebp - 0x14 ] mov ecx , dword ptr [ ebp - 0x18 ] mov edx , dword ptr [ ebp - 0x28 ] mov esi , dword ptr [ edx ] mov dword ptr [ ebp - 0x40 ] , eax mov dword ptr [ ebp - 0x44 ] , ecx mov dword ptr [ ebp - 0x48 ] , esi mov eax , dword ptr [ ebp - 0x2c ] mov ecx , dword ptr [ eax ] mov dword ptr [ ebp - 0x4c ] , ecx sub esp , 0x10 mov eax , dword ptr [ ebp - 0x40 ] mov dword ptr [ esp ] , eax mov ecx , dword ptr [ ebp - 0x44 ] mov dword ptr [ esp + 0x4 ] , ecx mov edx , dword ptr [ ebp - 0x48 ] mov dword ptr [ esp + 0x8 ] , edx mov esi , dword ptr [ ebp - 0x4c ] mov dword ptr [ esp + 0xc ] , esi call 0x6a0 add esp , 0x10 mov dword ptr [ ebp - 0x10 ] , eax jmp 0x130 mov eax , dword ptr [ ebp - 0x14 ] mov dword ptr [ ebp - 0x50 ] , eax mov eax , dword ptr [ ebp - 0x18 ] mov ecx , dword ptr [ ebp - 0x28 ] mov edx , dword ptr [ ecx ] sub esp , 0x10 mov esi , dword ptr [ ebp - 0x50 ] mov dword ptr [ esp ] , esi mov dword ptr [ esp + 0x4 ] , eax mov dword ptr [ esp + 0x8 ] , edx call 0x33660 add esp , 0x10 mov dword ptr [ ebp - 0x54 ] , eax mov eax , dword ptr [ ebp - 0x54 ] mov dword ptr [ ebp - 0x10 ] , eax mov eax , dword ptr [ ebp - 0x10 ] mov dword ptr [ ebp - 0x58 ] , eax mov eax , dword ptr [ ebp - 0x58 ] lea esp , [ ebp - 0xc ] pop esi pop edi pop ebx pop ebp ret nop word ptr cs : [ eax + eax ] nop dword ptr [ eax + eax ]
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly code snippets are fundamentally dissimilar due to key differences:
1. Architecture: Code1 uses MIPS instructions (lui, addiu, sw, lw, jalr) with registers like gp, sp, ra, while Code2 uses x86 instructions (push, mov, cmp, call) with registers like ebp, esp, eax.
2. Structure: Code1 has MIPS-specific patterns (gp-relative addressing, delay slots) and compact branching (bnez, beq). Code2 uses x86 stack frames with ebp-based addressing and complex memory operations.
3. Control Flow: Code1 has linear branches with register-based jumps (jr ra/jr t9). Code2 has conditional jumps (jne/jmp) and function calls to absolute addresses.
4. Operations: No overlapping sequence of equivalent operations exists. Register usage, stack management, and calling conventions are entirely architecture-specific.
5. Purpose: The codes show no evidence of performing similar high-level tasks based on instruction patterns and control flow.
------------------------------------------------------------

------------------------------------------------------------
Code1: mov eax , dword ptr [ rip ] test eax , eax jne 0x10a mov al , byte ptr [ rip ] xor al , 0xc0 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x99 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x99 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x99 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xb3 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x68 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x91 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xed mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xae mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x64 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xc2 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xd4 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xae mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x74 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x16 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xb8 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x9e mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x1b mov byte ptr [ rip ] , al push rbp mov rbp , rsp push r15 push r14 push rbx push rax mov dword ptr [ rip ] , 0x1 mov r15 , rsp add r15 , - 0x10 mov rsp , r15 mov rbx , rsp add rbx , - 0x10 mov rsp , rbx mov edi , 0x0 call 0x13c mov r14d , eax cmp eax , - 0x1 jne 0x156 mov edi , 0x0 call 0x14e mov r14d , eax cmp eax , - 0x1 je 0x1b0 mov qword ptr [ rbx ] , 0x10 sub rsp , 0x8 mov esi , 0x0 mov edx , 0x10 mov ecx , 0x0 mov edi , r14d xor r8d , r8d mov r9 , r15 push rbx call 0x17f add rsp , 0x10 test eax , eax jne 0x1eb mov rsi , qword ptr [ rbx ] mov edx , 0x0 mov ecx , 0x10 mov r8d , 0x0 mov rdi , r15 xor r9d , r9d call 0x1a5 test eax , eax je 0x1b7 mov eax , 0x5 jmp 0x1eb mov eax , 0x2 jmp 0x1eb mov qword ptr [ rbx ] , 0x10 sub rsp , 0x8 mov esi , 0x0 mov edx , 0x10 mov ecx , 0x0 mov r8d , 0x10 mov edi , r14d mov r9 , r15 push rbx call 0x1e3 add rsp , 0x10 test eax , eax je 0x1f6 lea rsp , [ rbp - 0x18 ] pop rbx pop r14 pop r15 pop rbp ret mov rsi , qword ptr [ rbx ] mov edx , 0x0 mov ecx , 0x10 mov r8d , 0x0 mov rdi , r15 mov r9d , 0x1 call 0x217 test eax , eax jne 0x1a9 mov qword ptr [ rbx ] , 0x10 sub rsp , 0x8 mov esi , 0x0 mov edx , 0x10 mov ecx , 0x0 mov r8d , 0x28 mov edi , r14d mov r9 , r15 push rbx call 0x247 add rsp , 0x10 test eax , eax jne 0x1eb mov rsi , qword ptr [ rbx ] mov edx , 0x0 mov ecx , 0x10 mov r8d , 0x0 mov rdi , r15 mov r9d , 0x2 call 0x270 mov ecx , eax mov eax , 0x5 test ecx , ecx jne 0x1eb mov qword ptr [ rbx ] , 0x10 sub rsp , 0x8 mov esi , 0x0 mov edx , 0x10 mov ecx , 0x0 mov r8d , 0x40 mov edi , r14d mov r9 , r15 push rbx call 0x2ab add rsp , 0x10 test eax , eax jne 0x1eb mov rsi , qword ptr [ rbx ] mov edx , 0x0 mov ecx , 0x10 mov r8d , 0x0 mov rdi , r15 mov r9d , 0x3 call 0x2d8 xor ecx , ecx test eax , eax setne cl lea eax , [ rcx + rcx * 0x4 ] jmp 0x1eb
Code2: addiu sp , sp , - 0x60 sw ra , 0x5c ( sp ) sw s6 , 0x58 ( sp ) sw s5 , 0x54 ( sp ) sw s4 , 0x50 ( sp ) sw s3 , 0x4c ( sp ) sw s2 , 0x48 ( sp ) sw s1 , 0x44 ( sp ) sw s0 , 0x40 ( sp ) lui gp , 0x0 addiu gp , gp , 0x0 sw gp , 0x20 ( sp ) lw v0 , ( gp ) lw v1 , ( v0 ) sw v1 , 0x3c ( sp ) lui a0 , 0x0 addiu a0 , a0 , 0x0 lw t9 , ( gp ) jalr t9 nop lw gp , 0x20 ( sp ) addiu a1 , zero , - 0x1 beq v0 , a1 , 0x12c move s5 , v0 lui s0 , 0x0 addiu s0 , s0 , 0x8 move s1 , zero addiu s3 , zero , 0x10 addiu s6 , sp , 0x28 addiu s2 , sp , 0x2c lui s4 , 0x0 addiu s4 , s4 , 0x0 sw s3 , 0x28 ( sp ) sw s6 , 0x18 ( sp ) sw s2 , 0x14 ( sp ) lw t0 , - 0x4 ( s0 ) sw t0 , 0x10 ( sp ) addiu a3 , s0 , 0x10 lw a2 , - 0x8 ( s0 ) move a1 , s0 move a0 , s5 lw t9 , ( gp ) jalr t9 nop lw gp , 0x20 ( sp ) bnez v0 , 0xf4 move a3 , s3 sw s1 , 0x14 ( sp ) sw s4 , 0x10 ( sp ) addiu a2 , s0 , 0x50 lw a1 , 0x28 ( sp ) move a0 , s2 lw t9 , ( gp ) jalr t9 nop lw gp , 0x20 ( sp ) bnez v0 , 0x158 addiu t1 , zero , 0x4 addiu s1 , s1 , 0x1 bne s1 , t1 , 0x80 addiu s0 , s0 , 0x68 lw t2 , 0x3c ( sp ) lw t3 , ( gp ) lw t4 , ( t3 ) bne t2 , t4 , 0x160 lw ra , 0x5c ( sp ) lw s6 , 0x58 ( sp ) lw s5 , 0x54 ( sp ) lw s4 , 0x50 ( sp ) lw s3 , 0x4c ( sp ) lw s2 , 0x48 ( sp ) lw s1 , 0x44 ( sp ) lw s0 , 0x40 ( sp ) jr ra addiu sp , sp , 0x60 lui a2 , 0x0 addiu a0 , a2 , 0x0 lw t9 , ( gp ) jalr t9 nop lw gp , 0x20 ( sp ) addiu a3 , zero , - 0x1 bne v0 , a3 , 0x60 move s5 , v0 b 0xf4 addiu v0 , zero , 0x2 b 0xf4 addiu v0 , zero , 0x5 lw t9 , ( gp ) jalr t9 nop nop
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly code snippets are for different architectures (x86-64 vs MIPS) and exhibit entirely different core logic. The first code features a sequence of XOR operations for decryption, followed by system calls and stack manipulation. The second code focuses on function calls within a loop structure without any decryption pattern. Although both have function prologue/epilogue, this generic structure is insufficient to indicate similarity. The algorithmic differences and architecture-specific instructions result in no meaningful similarity.
------------------------------------------------------------

------------------------------------------------------------
Code1: push rbp push r15 push r14 push r13 push r12 push rbx push rax test rsi , rsi je 0x87 mov ebx , edx mov rbp , rsi mov r15 , rdi mov r13 , qword ptr [ rdi + 0x30 ] mov r12 , qword ptr [ r13 ] mov esi , 0xf call 0x45790 mov rdi , r12 mov rsi , rbp mov edx , ebx call 0xffffffffffff3770 mov r14d , eax mov rdi , r12 mov esi , eax call 0xffffffffffff5520 xor ebx , ebx cmp eax , 0x8 ja 0x117 mov eax , eax jmp qword ptr [ rax * 0x8 + 0x59f010 ] test r14d , r14d jle 0x117 mov rax , qword ptr [ r13 + 0x10 ] test rax , rax je 0xe9 movsxd rcx , r14d add rcx , qword ptr [ r13 + 0x18 ] mov qword ptr [ r13 + 0x18 ] , rcx cmp rcx , rax jbe 0xe9 mov qword ptr [ r13 + 0x18 ] , 0x0 jmp 0x10a xor r14d , r14d jmp 0x11b mov rdi , r15 mov esi , 0x9 call 0x457b0 jmp 0x117 mov rdi , r15 mov esi , 0xa call 0x457b0 jmp 0x117 mov rdi , r15 mov esi , 0xc call 0x457b0 mov ebx , 0x1 jmp 0x117 mov rdi , r15 mov esi , 0xc call 0x457b0 mov ebx , 0x2 jmp 0x117 mov rdi , r15 mov esi , 0xc call 0x457b0 mov ebx , 0x3 jmp 0x117 cmp qword ptr [ r13 + 0x20 ] , 0x0 je 0x117 xor ebx , ebx xor edi , edi call 0xfffffffffff7f6e0 mov rcx , qword ptr [ r13 + 0x20 ] add rcx , qword ptr [ r13 + 0x28 ] cmp rax , rcx jbe 0x117 mov qword ptr [ r13 + 0x28 ] , rax add dword ptr [ r13 + 0x8 ] , 0x1 mov rdi , r12 call 0xffffffffffff38e0 mov dword ptr [ r15 + 0x24 ] , ebx mov eax , r14d add rsp , 0x8 pop rbx pop r12 pop r13 pop r14 pop r15 pop rbp ret nop dword ptr [ rax ]
Code2: push rbp push r15 push r14 push r13 push r12 push rbx sub rsp , 0x58 mov dword ptr [ rsp + 0x2c ] , edx mov rbp , rdi mov qword ptr [ rsp + 0x50 ] , rsi test rsi , rsi mov eax , 0x8c79792d mov ebx , 0x880283d0 cmove ebx , eax mov eax , 0x683b2d17 mov r15d , 0x41a7f8a jmp 0x40 mov eax , 0x41a7f8a xor r13d , r13d nop cmp eax , 0x72382bf jle 0x80 cmp eax , 0x3f4eaa98 jle 0xd0 cmp eax , 0x5bda5dea jle 0x179 cmp eax , 0x766cfd1e jg 0x27c cmp eax , 0x5bda5deb je 0x2ed cmp eax , 0x683b2d17 jne 0x40 mov eax , ebx jmp 0x40 nop cmp eax , 0xb4eb4916 jle 0x140 cmp eax , 0xe5dd7291 jle 0x19f cmp eax , 0xfa95a14d jg 0x2a9 cmp eax , 0xe5dd7292 je 0x32d cmp eax , 0xe7cd140f jne 0x40 mov eax , dword ptr [ rsp + 0x8 ] cmp eax , 0x8 mov eax , 0xb4eb4917 mov ecx , 0xb23d87c4 cmove eax , ecx jmp 0x40 nop dword ptr [ rax ] cmp eax , 0x1ef5a45d jle 0x1d9 cmp eax , 0x294e8d47 jg 0x2d2 cmp eax , 0x1ef5a45e je 0x346 cmp eax , 0x2023269b jne 0x40 mov rax , qword ptr [ rsp + 0x10 ] add rax , 0x20 mov qword ptr [ rsp + 0x38 ] , rax mov rax , qword ptr [ rsp + 0x38 ] cmp qword ptr [ rax ] , 0x0 mov eax , 0x14142126 mov ecx , 0x41a7f8a cmove eax , ecx test r14d , r14d mov r15d , 0x41a7f8a cmovne eax , ecx xor r13d , r13d jmp 0x40 nop word ptr cs : [ rax + rax ] nop cmp eax , 0xa9749ff8 jg 0x23e cmp eax , 0x80d4c6cb je 0x35f cmp eax , 0x880283d0 je 0x389 cmp eax , 0x8c79792d jne 0x40 mov eax , 0x294e8d48 xor r12d , r12d jmp 0x40 cmp eax , 0x3f4eaa99 je 0x3df cmp eax , 0x40aeeb27 je 0x3f5 cmp eax , 0x5bd86601 jne 0x40 jmp 0x37 cmp eax , 0xb4eb4917 je 0x37 cmp eax , 0xc9d2d7d5 je 0x407 cmp eax , 0xd0150f12 jne 0x40 mov eax , dword ptr [ rsp + 0x8 ] cmp eax , 0x4 mov eax , 0xb4eb4917 mov ecx , 0x3211b27b cmove eax , ecx jmp 0x40 cmp eax , 0x72382c0 je 0x419 cmp eax , 0xd8e7db8 je 0x448 cmp eax , 0x14142126 jne 0x40 xor edi , edi call 0xffffffffffe937b0 mov qword ptr [ rsp + 0x40 ] , rax mov rax , qword ptr [ rsp + 0x10 ] add rax , 0x28 mov qword ptr [ rsp + 0x48 ] , rax mov rax , qword ptr [ rsp + 0x48 ] mov rax , qword ptr [ rax ] mov rcx , qword ptr [ rsp + 0x38 ] add rax , qword ptr [ rcx ] mov rcx , qword ptr [ rsp + 0x40 ] cmp rcx , rax mov eax , 0x5bd86601 mov ecx , 0x80d4c6cb cmova eax , ecx jmp 0x40 cmp eax , 0xa9749ff9 je 0x465 cmp eax , 0xb0bcc1af je 0x47e cmp eax , 0xb23d87c4 jne 0x40 mov rdi , rbp mov esi , 0xc call 0x964b0 mov eax , 0x41a7f8a mov r13d , 0x3 jmp 0x40 cmp eax , 0x766cfd1f je 0x4aa cmp eax , 0x78d8e347 jne 0x40 cmp dword ptr [ rsp + 0x8 ] , 0x0 mov eax , 0xb4eb4917 mov ecx , 0x3f4eaa99 cmove eax , ecx jmp 0x40 cmp eax , 0xfa95a14e je 0x4c3 cmp eax , 0x41a7f8a jne 0x40 mov dword ptr [ rbp + 0x24 ] , r13d mov eax , 0x294e8d48 mov r12d , dword ptr [ rsp + 0xc ] jmp 0x40 cmp eax , 0x3211b27b je 0x4dc cmp eax , 0x294e8d48 jne 0x40 jmp 0x4f9 movsxd rax , dword ptr [ rsp + 0xc ] mov rcx , qword ptr [ rsp + 0x10 ] add rcx , 0x18 mov qword ptr [ rsp + 0x20 ] , rcx mov rcx , qword ptr [ rsp + 0x20 ] add rax , qword ptr [ rcx ] mov rcx , qword ptr [ rsp + 0x20 ] mov qword ptr [ rcx ] , rax mov rcx , qword ptr [ rsp + 0x30 ] cmp rax , qword ptr [ rcx ] mov eax , 0x2023269b mov ecx , 0x72382c0 cmova eax , ecx xor r14d , r14d jmp 0x40 mov eax , dword ptr [ rsp + 0x8 ] cmp eax , 0x3 mov eax , 0xc9d2d7d5 mov ecx , 0x40aeeb27 cmovl eax , ecx jmp 0x40 mov eax , dword ptr [ rsp + 0x8 ] cmp eax , 0x2 mov eax , 0xe5dd7292 mov ecx , 0x78d8e347 cmovl eax , ecx jmp 0x40 mov rax , qword ptr [ rsp + 0x40 ] mov rcx , qword ptr [ rsp + 0x48 ] mov qword ptr [ rcx ] , rax mov rax , qword ptr [ rsp + 0x10 ] add dword ptr [ rax + 0x8 ] , 0x1 mov rdi , qword ptr [ rsp + 0x18 ] call 0xfffffffffffd6bd0 mov eax , 0x5bd86601 jmp 0x40 mov rax , qword ptr [ rbp + 0x30 ] mov qword ptr [ rsp + 0x10 ] , rax mov rax , qword ptr [ rsp + 0x10 ] mov rax , qword ptr [ rax ] mov qword ptr [ rsp + 0x18 ] , rax mov rdi , rbp mov esi , 0xf call 0x96490 mov rdi , qword ptr [ rsp + 0x18 ] mov rsi , qword ptr [ rsp + 0x50 ] mov edx , dword ptr [ rsp + 0x2c ] call 0xfffffffffffd6790 mov dword ptr [ rsp + 0xc ] , eax mov rdi , qword ptr [ rsp + 0x18 ] mov esi , dword ptr [ rsp + 0xc ] call 0xfffffffffffdd470 mov dword ptr [ rsp + 0x8 ] , eax mov eax , 0xfa95a14e jmp 0x40 cmp dword ptr [ rsp + 0xc ] , 0x0 mov eax , 0xb0bcc1af cmovle eax , r15d xor r13d , r13d jmp 0x40 mov rdi , rbp mov esi , 0x9 call 0x964b0 jmp 0x37 mov rdi , rbp mov esi , 0xa call 0x964b0 jmp 0x37 mov rax , qword ptr [ rsp + 0x20 ] mov qword ptr [ rax ] , 0x0 mov rax , qword ptr [ rsp + 0x10 ] add dword ptr [ rax + 0x8 ] , 0x1 mov rdi , qword ptr [ rsp + 0x18 ] call 0xfffffffffffd6bd0 mov eax , 0x2023269b mov r14d , 0x1 jmp 0x40 mov rdi , rbp mov esi , 0xc call 0x964b0 mov eax , 0x41a7f8a mov r13d , 0x2 jmp 0x40 mov eax , dword ptr [ rsp + 0x8 ] cmp eax , 0x7 mov eax , 0x766cfd1f mov ecx , 0xd0150f12 cmovl eax , ecx jmp 0x40 mov rax , qword ptr [ rsp + 0x10 ] add rax , 0x10 mov qword ptr [ rsp + 0x30 ] , rax mov rax , qword ptr [ rsp + 0x30 ] cmp qword ptr [ rax ] , 0x0 mov eax , 0x5bda5deb mov ecx , 0x2023269b cmove eax , ecx xor r14d , r14d jmp 0x40 mov eax , dword ptr [ rsp + 0x8 ] cmp eax , 0x8 mov eax , 0xe7cd140f mov ecx , 0xd8e7db8 cmovl eax , ecx jmp 0x40 mov eax , dword ptr [ rsp + 0x8 ] cmp eax , 0x4 mov eax , 0xa9749ff9 mov ecx , 0x1ef5a45e cmovl eax , ecx jmp 0x40 mov rdi , rbp mov esi , 0xc call 0x964b0 mov eax , 0x41a7f8a mov r13d , 0x1 jmp 0x40 mov eax , r12d add rsp , 0x58 pop rbx pop r12 pop r13 pop r14 pop r15 pop rbp ret nop dword ptr [ rax + rax ]
Similarity: -1
Label: 1
Similarity Score: 0.25
Explanation: The two assembly codes show some structural similarities in their function prologues (pushing multiple registers) and epilogues (popping registers and returning). However, their core logic differs significantly:
- Code1 has a linear control flow with conditional jumps and direct function calls to specific addresses like 0x45790 and 0x457b0.
- Code2 implements a complex state machine with numerous constants (e.g., 0x5bda5dea, 0x766cfd1e) and indirect jumps, plus different function calls (e.g., 0x964b0, 0xffffffffffe937b0). 
- Register usage patterns diverge (e.g., Code1 uses r14/r15 differently than Code2), and stack management differs (Code1 uses push rax/add rsp, while Code2 uses sub rsp, 0x58).
- Code2 is 3x longer and introduces unique elements like state constants and memory offset calculations not present in Code1.  
The limited
------------------------------------------------------------

------------------------------------------------------------
Code1: push ebp push edi push esi push ebx call 0xffffa080 add ebx , 0x2d877 sub esp , 0xc lea ecx , [ ebx + 0x1360 ] mov esi , dword ptr [ esp + 0x20 ] mov edi , dword ptr [ esp + 0x24 ] mov eax , dword ptr [ ecx + 0x10 ] cmp eax , - 0x64 je 0x2c test eax , eax js 0x91 mov edx , dword ptr [ ecx ] test edx , edx je 0x58 sub esp , 0xc push 0x100 push edi push esi push eax push 0x3 call 0xffff97a0 add esp , 0x20 mov ebp , eax add esp , 0xc mov eax , ebp pop ebx pop esi pop edi pop ebp ret nop lea esi , [ esi ] sub esp , 0xc push 0x0 push edi push esi push eax push 0x3 call 0xffff97a0 add esp , 0x20 test eax , eax mov ebp , eax je 0x49 call 0xffff9a90 mov eax , dword ptr [ eax ] cmp eax , 0x2 je 0x81 cmp eax , 0x14 jne 0x49 add esp , 0xc mov edx , edi mov eax , esi pop ebx pop esi pop edi pop ebp jmp 0xfffff830 lea eax , [ ebx - 0x11fd4 ] push eax lea eax , [ ebx - 0x12584 ] push 0x258 push eax lea eax , [ ebx - 0x124e1 ] push eax call 0xffff9d50
Code2: push ebp mov ebp , esp push ebx push edi push esi sub esp , 0x2c mov eax , dword ptr [ ebp + 0xc ] mov ecx , dword ptr [ ebp + 0x8 ] mov dword ptr [ ebp - 0x10 ] , eax mov dword ptr [ ebp - 0x14 ] , ecx mov eax , esp add eax , - 0x10 mov esp , eax mov ecx , esp add ecx , - 0x10 mov esp , ecx mov edx , esp add edx , - 0x10 mov esp , edx mov esi , esp add esi , - 0x10 mov esp , esi mov edi , dword ptr [ ebp - 0x14 ] mov dword ptr [ ecx ] , edi mov ebx , dword ptr [ ebp - 0x10 ] mov dword ptr [ edx ] , ebx mov edi , 0xffffff9c cmp edi , dword ptr [ 0x80b63fc ] setne bl mov dword ptr [ ebp - 0x18 ] , eax mov dword ptr [ ebp - 0x1c ] , ecx mov dword ptr [ ebp - 0x20 ] , edx mov dword ptr [ ebp - 0x24 ] , esi mov byte ptr [ ebp - 0x25 ] , bl mov al , byte ptr [ ebp - 0x25 ] test al , 0x1 jne 0x68 jmp 0xaf cmp dword ptr [ 0x80b63fc ] , 0x0 jl 0x7a jmp 0xaa sub esp , 0x10 lea eax , [ 0x80ad3e9 ] mov dword ptr [ esp ] , eax lea eax , [ 0x80ad29d ] mov dword ptr [ esp + 0x4 ] , eax mov dword ptr [ esp + 0x8 ] , 0x258 lea eax , [ 0x80ad3ff ] mov dword ptr [ esp + 0xc ] , eax call 0xfffec4c0 add esp , 0x10 jmp 0xaf mov eax , dword ptr [ ebp - 0x20 ] mov ecx , dword ptr [ eax ] sub esp , 0x10 mov dword ptr [ esp ] , ecx call 0xffffe980 add esp , 0x10 xor eax , eax cmp eax , dword ptr [ 0x80b63ec ] jne 0x15f xor eax , eax mov ecx , dword ptr [ 0x80b63fc ] mov edx , dword ptr [ ebp - 0x1c ] mov esi , dword ptr [ edx ] mov edi , dword ptr [ ebp - 0x20 ] mov ebx , dword ptr [ edi ] sub esp , 0x10 mov dword ptr [ esp ] , ecx mov dword ptr [ esp + 0x4 ] , esi mov dword ptr [ esp + 0x8 ] , ebx mov dword ptr [ esp + 0xc ] , 0x0 mov dword ptr [ ebp - 0x2c ] , eax call 0x4e0b0 add esp , 0x10 xor ecx , ecx mov edx , dword ptr [ ebp - 0x24 ] mov dword ptr [ edx ] , eax cmp ecx , dword ptr [ edx ] sete al mov byte ptr [ ebp - 0x2d ] , al mov al , byte ptr [ ebp - 0x2d ] test al , 0x1 jne 0x122 jmp 0x130 mov eax , dword ptr [ ebp - 0x18 ] mov dword ptr [ eax ] , 0x0 jmp 0x196 mov eax , dword ptr [ ebp - 0x1c ] mov ecx , dword ptr [ eax ] mov edx , dword ptr [ ebp - 0x20 ] mov esi , dword ptr [ edx ] mov edi , dword ptr [ ebp - 0x24 ] mov ebx , dword ptr [ edi ] sub esp , 0x10 mov dword ptr [ esp ] , ecx mov dword ptr [ esp + 0x4 ] , esi mov dword ptr [ esp + 0x8 ] , ebx call 0x280 add esp , 0x10 mov ecx , dword ptr [ ebp - 0x18 ] mov dword ptr [ ecx ] , eax jmp 0x196 mov eax , dword ptr [ 0x80b63fc ] mov ecx , dword ptr [ ebp - 0x1c ] mov edx , dword ptr [ ecx ] mov esi , dword ptr [ ebp - 0x20 ] mov edi , dword ptr [ esi ] sub esp , 0x10 mov dword ptr [ esp ] , eax mov dword ptr [ esp + 0x4 ] , edx mov dword ptr [ esp + 0x8 ] , edi mov dword ptr [ esp + 0xc ] , 0x100 call 0x4e0b0 add esp , 0x10 mov ecx , dword ptr [ ebp - 0x18 ] mov dword ptr [ ecx ] , eax jmp 0x196 mov eax , dword ptr [ ebp - 0x18 ] mov eax , dword ptr [ eax ] mov dword ptr [ ebp - 0x34 ] , eax mov eax , dword ptr [ ebp - 0x34 ] lea esp , [ ebp - 0xc ] pop esi pop edi pop ebx pop ebp ret mov eax , esp add eax , - 0x10 mov esp , eax mov eax , esp add eax , - 0x10 mov esp , eax mov ecx , esp add ecx , - 0x10 mov esp , ecx mov edx , dword ptr [ ebp - 0x14 ] mov dword ptr [ eax ] , edx mov eax , dword ptr [ ebp - 0x10 ] mov dword ptr [ ecx ] , eax jmp 0x15 jmp 0x75 xor eax , eax mov ecx , dword ptr [ 0x80b63fc ] mov edx , dword ptr [ ebp - 0x1c ] mov esi , dword ptr [ edx ] mov edi , dword ptr [ ebp - 0x20 ] mov ebx , dword ptr [ edi ] sub esp , 0x10 mov dword ptr [ esp ] , ecx mov dword ptr [ esp + 0x4 ] , esi mov dword ptr [ esp + 0x8 ] , ebx mov dword ptr [ esp + 0xc ] , 0x0 mov dword ptr [ ebp - 0x38 ] , eax call 0x4e0b0 add esp , 0x10 mov ecx , dword ptr [ ebp - 0x24 ] mov dword ptr [ ecx ] , eax jmp 0xd0 mov eax , dword ptr [ ebp - 0x1c ] mov ecx , dword ptr [ eax ] mov edx , dword ptr [ ebp - 0x20 ] mov esi , dword ptr [ edx ] mov edi , dword ptr [ ebp - 0x24 ] mov ebx , dword ptr [ edi ] sub esp , 0x10 mov dword ptr [ esp ] , ecx mov dword ptr [ esp + 0x4 ] , esi mov dword ptr [ esp + 0x8 ] , ebx call 0x280 add esp , 0x10 mov ecx , dword ptr [ ebp - 0x18 ] mov dword ptr [ ecx ] , eax jmp 0x130 mov eax , dword ptr [ 0x80b63fc ] mov ecx , dword ptr [ ebp - 0x1c ] mov edx , dword ptr [ ecx ] mov esi , dword ptr [ ebp - 0x20 ] mov edi , dword ptr [ esi ] sub esp , 0x10 mov dword ptr [ esp ] , eax mov dword ptr [ esp + 0x4 ] , edx mov dword ptr [ esp + 0x8 ] , edi mov dword ptr [ esp + 0xc ] , 0x100 call 0x4e0b0 add esp , 0x10 mov ecx , dword ptr [ ebp - 0x18 ] mov dword ptr [ ecx ] , eax jmp 0x15f jmp 0x196 nop word ptr [ eax + eax ]
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly code snippets have significantly different control flow structures, function calls, and stack manipulation patterns. Code 1 calls functions at addresses 0xffff97a0, 0xffff9a90, 0xffff9d50 and jumps to 0xfffff830, while Code 2 calls functions at 0xfffec4c0, 0xffffe980, 0x4e0b0, and 0x280. The initial setup in Code 2 includes a stack frame setup (mov ebp, esp) which is absent in Code 1, and Code 2 has more complex stack adjustments. The lack of common function calls and distinct branching structures indicate they are not similar.
------------------------------------------------------------

------------------------------------------------------------
Code1: push ebp mov ebp , esp push ebx push edi push esi sub esp , 0x9c mov eax , dword ptr [ ebp + 0xc ] mov ecx , dword ptr [ ebp + 0x8 ] mov dword ptr [ ebp - 0x1c ] , eax mov dword ptr [ ebp - 0x20 ] , ecx mov eax , esp add eax , - 0x10 mov esp , eax mov dword ptr [ ebp - 0x24 ] , eax mov eax , dword ptr [ ebp - 0x20 ] mov dword ptr [ ebp - 0x10 ] , eax mov ecx , dword ptr [ ebp - 0x1c ] mov dword ptr [ ebp - 0x14 ] , ecx mov dword ptr [ ebp - 0x18 ] , 0x1 mov eax , dword ptr [ ebp - 0x18 ] mov dword ptr [ ebp - 0x28 ] , eax mov eax , dword ptr [ ebp - 0x24 ] mov ecx , dword ptr [ ebp - 0x28 ] mov dword ptr [ eax ] , ecx mov edx , dword ptr [ ebp - 0x10 ] mov dword ptr [ ebp - 0x2c ] , edx mov eax , dword ptr [ ebp - 0x28 ] mov ecx , dword ptr [ ebp - 0x2c ] cmp eax , ecx jge 0x37b mov eax , dword ptr [ ebp - 0x14 ] mov ecx , dword ptr [ ebp - 0x18 ] mov dword ptr [ ebp - 0x30 ] , eax mov dword ptr [ ebp - 0x34 ] , ecx xor eax , eax mov ecx , dword ptr [ ebp - 0x30 ] mov edx , dword ptr [ ebp - 0x34 ] mov esi , dword ptr [ ecx + edx * 0x4 ] sub esp , 0x10 mov edi , esp mov dword ptr [ edi + 0x4 ] , esi mov dword ptr [ edi ] , 0x8119109 mov dword ptr [ ebp - 0x38 ] , eax call 0xffff0290 add esp , 0x10 mov ecx , dword ptr [ ebp - 0x38 ] cmp ecx , eax sete bl mov byte ptr [ ebp - 0x39 ] , bl mov al , byte ptr [ ebp - 0x39 ] test al , 0x1 jne 0xa2 jmp 0xb9 sub esp , 0x10 mov dword ptr [ esp ] , 0x2 call 0x6f60 add esp , 0x10 jmp 0x350 mov eax , dword ptr [ ebp - 0x14 ] mov ecx , dword ptr [ ebp - 0x18 ] mov dword ptr [ ebp - 0x40 ] , eax mov dword ptr [ ebp - 0x44 ] , ecx mov eax , dword ptr [ ebp - 0x44 ] shl eax , 0x2 mov ecx , dword ptr [ ebp - 0x40 ] add ecx , eax mov dword ptr [ ebp - 0x48 ] , ecx xor eax , eax mov ecx , dword ptr [ ebp - 0x48 ] mov edx , dword ptr [ ecx ] sub esp , 0x10 mov esi , esp mov dword ptr [ esi + 0x4 ] , edx mov dword ptr [ esi ] , 0x811910c mov dword ptr [ ebp - 0x4c ] , eax call 0xffff0290 add esp , 0x10 mov ecx , dword ptr [ ebp - 0x4c ] cmp ecx , eax jne 0x115 sub esp , 0x10 mov dword ptr [ esp ] , 0x1 call 0x6f60 add esp , 0x10 jmp 0x34b mov eax , dword ptr [ ebp - 0x14 ] mov dword ptr [ ebp - 0x50 ] , eax xor eax , eax mov ecx , dword ptr [ ebp - 0x18 ] mov edx , dword ptr [ ebp - 0x50 ] mov ecx , dword ptr [ edx + ecx * 0x4 ] sub esp , 0x10 mov esi , esp mov dword ptr [ esi + 0x4 ] , ecx mov dword ptr [ esi ] , 0x811910f mov dword ptr [ ebp - 0x54 ] , eax call 0xffff0290 add esp , 0x10 mov ecx , dword ptr [ ebp - 0x54 ] cmp ecx , eax sete bl mov byte ptr [ ebp - 0x55 ] , bl mov al , byte ptr [ ebp - 0x55 ] test al , 0x1 jne 0x15a jmp 0x176 xor eax , eax sub esp , 0x10 mov dword ptr [ esp ] , 0x0 mov dword ptr [ ebp - 0x5c ] , eax call 0x6f60 add esp , 0x10 jmp 0x346 mov eax , dword ptr [ ebp - 0x14 ] mov ecx , dword ptr [ ebp - 0x18 ] shl ecx , 0x2 add eax , ecx mov dword ptr [ ebp - 0x60 ] , eax mov eax , dword ptr [ ebp - 0x60 ] mov ecx , dword ptr [ eax ] sub esp , 0x10 mov edx , esp mov dword ptr [ edx + 0x4 ] , ecx mov dword ptr [ edx ] , 0x811e166 call 0xffff0290 add esp , 0x10 mov dword ptr [ ebp - 0x64 ] , eax xor eax , eax mov ecx , dword ptr [ ebp - 0x64 ] cmp eax , ecx jne 0x1c5 mov eax , dword ptr [ ebp - 0x18 ] add eax , 0x1 mov dword ptr [ ebp - 0x68 ] , eax mov eax , dword ptr [ ebp - 0x24 ] mov ecx , dword ptr [ ebp - 0x68 ] mov dword ptr [ eax ] , ecx jmp 0x37b mov eax , dword ptr [ ebp - 0x14 ] mov ecx , dword ptr [ ebp - 0x18 ] shl ecx , 0x2 add eax , ecx mov dword ptr [ ebp - 0x6c ] , eax mov eax , dword ptr [ ebp - 0x6c ] mov ecx , dword ptr [ eax ] sub esp , 0x10 mov edx , esp mov dword ptr [ edx + 0x4 ] , ecx mov dword ptr [ edx ] , 0x8119112 call 0xffff0290 add esp , 0x10 mov dword ptr [ ebp - 0x70 ] , eax xor eax , eax mov ecx , dword ptr [ ebp - 0x70 ] cmp eax , ecx jne 0x29c mov eax , dword ptr [ ebp - 0x10 ] mov dword ptr [ ebp - 0x74 ] , eax mov eax , dword ptr [ ebp - 0x18 ] add eax , 0x1 mov dword ptr [ ebp - 0x78 ] , eax mov eax , dword ptr [ ebp - 0x74 ] mov ecx , dword ptr [ ebp - 0x78 ] cmp eax , ecx jg 0x26a sub esp , 0x10 lea eax , [ 0x8119115 ] mov dword ptr [ esp ] , eax call 0xffff0720 add esp , 0x10 mov dword ptr [ ebp - 0x7c ] , eax xor eax , eax sub esp , 0x10 mov dword ptr [ esp ] , 0x0 mov dword ptr [ esp + 0x4 ] , 0x0 mov ecx , dword ptr [ ebp - 0x7c ] mov dword ptr [ esp + 0x8 ] , ecx mov dword ptr [ ebp - 0x80 ] , eax call 0xffff0680 add esp , 0x10 sub esp , 0x10 mov dword ptr [ esp ] , 0x1 call 0xffffe240 add esp , 0x10 mov eax , dword ptr [ ebp - 0x14 ] mov ecx , dword ptr [ ebp - 0x18 ] mov eax , dword ptr [ eax + ecx * 0x4 + 0x4 ] mov dword ptr [ ebp - 0x84 ] , eax sub esp , 0x10 mov eax , dword ptr [ ebp - 0x84 ] mov dword ptr [ esp ] , eax call 0x3a0 add esp , 0x10 mov eax , dword ptr [ ebp - 0x18 ] add eax , 0x1 mov dword ptr [ ebp - 0x18 ] , eax jmp 0x33c mov eax , dword ptr [ ebp - 0x14 ] mov dword ptr [ ebp - 0x88 ] , eax mov eax , dword ptr [ ebp - 0x18 ] mov ecx , dword ptr [ ebp - 0x88 ] mov eax , dword ptr [ ecx + eax * 0x4 ] mov dword ptr [ ebp - 0x8c ] , eax sub esp , 0x10 lea eax , [ 0x8119539 ] mov dword ptr [ esp ] , eax mov eax , dword ptr [ ebp - 0x8c ] mov dword ptr [ esp + 0x4 ] , eax mov dword ptr [ esp + 0x8 ] , 0x2 call 0xffff0a60 add esp , 0x10 xor ecx , ecx cmp ecx , eax jne 0x31e mov eax , dword ptr [ ebp - 0x14 ] mov dword ptr [ ebp - 0x90 ] , eax mov eax , dword ptr [ ebp - 0x18 ] mov ecx , dword ptr [ ebp - 0x90 ] mov eax , dword ptr [ ecx + eax * 0x4 ] add eax , 0x2 mov dword ptr [ ebp - 0x94 ] , eax sub esp , 0x10 mov eax , dword ptr [ ebp - 0x94 ] mov dword ptr [ esp ] , eax call 0x6c0 add esp , 0x10 jmp 0x337 mov eax , dword ptr [ ebp - 0x18 ] mov dword ptr [ ebp - 0x98 ] , eax mov eax , dword ptr [ ebp - 0x24 ] mov ecx , dword ptr [ ebp - 0x98 ] mov dword ptr [ eax ] , ecx jmp 0x37b jmp 0x33c jmp 0x341 jmp 0x346 jmp 0x34b jmp 0x350 jmp 0x355 mov eax , dword ptr [ ebp - 0x18 ] mov dword ptr [ ebp - 0x9c ] , eax mov eax , dword ptr [ ebp - 0x9c ] add eax , 0x1 mov dword ptr [ ebp - 0xa0 ] , eax mov eax , dword ptr [ ebp - 0xa0 ] mov dword ptr [ ebp - 0x18 ] , eax jmp 0x35 mov eax , dword ptr [ ebp - 0x24 ] mov eax , dword ptr [ eax ] mov dword ptr [ ebp - 0xa4 ] , eax mov eax , dword ptr [ ebp - 0xa4 ] lea esp , [ ebp - 0xc ] pop esi pop edi pop ebx pop ebp ret nop word ptr cs : [ eax + eax ] nop
Code2: push r15 push r14 push r13 push r12 push rbp push rbx sub rsp , 0x38 mov rcx , qword ptr fs : [ 0x28 ] mov qword ptr [ rsp + 0x28 ] , rcx xor ecx , ecx cmp edi , 0x1 mov dword ptr [ rsp + 0x8 ] , edi jle 0x3f8 lea r12 , [ rip + 0x239cce ] mov r15 , rsi mov ebp , 0x1 nop word ptr [ rax + rax ] movsxd rax , ebp lea rsi , [ rip + 0x2b4e0 ] mov ecx , 0x3 lea r8 , [ rax * 0x8 ] mov rax , qword ptr [ r15 + rax * 0x8 ] mov rdi , rax repe cmpsb byte ptr [ rsi ] , byte ptr [ rdi ] seta dl sbb dl , 0x0 test dl , dl je 0x228 lea rsi , [ rip + 0x2b4b8 ] mov ecx , 0x3 mov rdi , rax repe cmpsb byte ptr [ rsi ] , byte ptr [ rdi ] seta dl sbb dl , 0x0 test dl , dl je 0x238 lea rsi , [ rip + 0x2b49c ] mov ecx , 0x3 mov rdi , rax repe cmpsb byte ptr [ rsi ] , byte ptr [ rdi ] seta dl sbb dl , 0x0 test dl , dl je 0x248 lea rsi , [ rip + 0x2e5b3 ] mov ecx , 0x3 mov rdi , rax repe cmpsb byte ptr [ rsi ] , byte ptr [ rdi ] seta dl sbb dl , 0x0 test dl , dl je 0x3f0 lea rsi , [ rip + 0x2b461 ] mov ecx , 0x3 mov rdi , rax repe cmpsb byte ptr [ rsi ] , byte ptr [ rdi ] seta dl sbb dl , 0x0 test dl , dl jne 0x258 add ebp , 0x1 cmp ebp , dword ptr [ rsp + 0x8 ] jge 0x4c3 mov rdi , qword ptr [ r15 + r8 + 0x8 ] lea r14 , [ rsp + 0x18 ] lea r13 , [ rsp + 0x26 ] mov edx , 0x2c mov qword ptr [ rsp + 0x18 ] , 0x0 mov word ptr [ rsp + 0x26 ] , dx mov rsi , r13 mov rdx , r14 mov qword ptr [ rsp ] , rdi call 0xffffffffffff96c0 test rax , rax mov rbx , rax je 0x3c5 mov dword ptr [ rsp + 0xc ] , ebp nop dword ptr [ rax + rax ] lea rdi , [ rip + 0x2c969 ] xor ebp , ebp jmp 0x159 nop dword ptr [ rax + rax ] lea rax , [ rbp + rbp * 0x2 ] mov rdi , qword ptr [ r12 + rax * 0x8 ] mov rsi , rbx call 0xffffffffffff9730 test eax , eax je 0x210 add rbp , 0x1 cmp rbp , 0x9 jne 0x150 mov rdx , qword ptr [ rsp ] mov esi , dword ptr [ rip + 0x23cd8f ] xor edi , edi call 0x14160 lea rsi , [ rip + 0x2bccd ] mov rbx , rax mov edx , 0x5 xor edi , edi call 0xffffffffffff94b0 mov rcx , rbx mov rdx , rax xor esi , esi xor edi , edi xor eax , eax call 0xffffffffffff99a0 xor edi , edi mov rdx , r14 mov rsi , r13 call 0xffffffffffff96c0 test rax , rax mov rbx , rax jne 0x140 test byte ptr [ rip + 0x23cd19 ] , 0x10 mov ebp , dword ptr [ rsp + 0xc ] jne 0x348 nop dword ptr [ rax ] add ebp , 0x1 cmp dword ptr [ rsp + 0x8 ] , ebp jg 0x40 mov rcx , qword ptr [ rsp + 0x28 ] xor rcx , qword ptr fs : [ 0x28 ] mov eax , ebp jne 0x44a add rsp , 0x38 pop rbx pop rbp pop r12 pop r13 pop r14 pop r15 ret nop word ptr [ rax + rax ] lea rax , [ rbp + rbp * 0x2 ] movsxd rax , dword ptr [ r12 + rax * 0x8 + 0x8 ] or qword ptr [ rip + 0x23ccbf ] , rax jmp 0x1ab nop dword ptr [ rax + rax ] mov edi , 0x2 call 0x6530 jmp 0x1d8 nop dword ptr [ rax ] mov edi , 0x1 call 0x6530 jmp 0x1d8 nop dword ptr [ rax ] xor edi , edi call 0x6530 jmp 0x1d8 nop dword ptr [ rax ] lea rsi , [ rip + 0x2b2e1 ] mov ecx , 0x2 mov rdi , rax repe cmpsb byte ptr [ rsi ] , byte ptr [ rdi ] seta dl sbb dl , 0x0 test dl , dl jne 0x1e5 movzx r13d , byte ptr [ rax + 0x2 ] lea rbx , [ rax + 0x2 ] test r13b , r13b je 0x426 call 0xffffffffffff9b90 mov rax , qword ptr [ rax ] test byte ptr [ rax + r13 * 0x2 + 0x1 ] , 0x8 je 0x402 call 0xffffffffffff9330 lea rsi , [ rsp + 0x18 ] mov r14d , dword ptr [ rax ] mov edx , 0xa mov dword ptr [ rax ] , 0x0 mov rdi , rbx mov r13 , rax call 0xffffffffffff9a60 test rax , rax mov rdx , qword ptr [ rsp + 0x18 ] jne 0x2f0 cmp rbx , rdx je 0x49f cmp byte ptr [ rdx ] , 0x0 jne 0x478 mov word ptr [ rip + 0x23cc25 ] , ax mov dword ptr [ r13 ] , r14d jmp 0x1d8 nop dword ptr [ rax ] cmp byte ptr [ rdx ] , 0x0 jne 0x478 cmp rax , - 0x1 jne 0x338 mov r14 , rax mov eax , dword ptr [ r13 ] test eax , eax jne 0x44f lea rsi , [ rip + 0x2badb ] mov edx , 0x5 xor edi , edi call 0xffffffffffff94b0 mov rcx , r14 mov rdx , rax xor esi , esi mov edi , 0x1 xor eax , eax call 0xffffffffffff99a0 nop dword ptr [ rax ] cmp rax , 0xffff jbe 0x2dc mov r14 , rax jmp 0x30e nop dword ptr [ rax ] mov rbx , qword ptr [ rip + 0x23c139 ] lea rsi , [ rip + 0x2b169 ] mov edx , 0x5 xor edi , edi lea rbp , [ rip + 0x2b1d2 ] call 0xffffffffffff94b0 mov rsi , rbx lea rbx , [ rip + 0x2399a5 ] mov rdi , rax call 0xffffffffffff9610 lea r12 , [ rbx + 0xc0 ] lea rcx , [ rip + 0x2c727 ] lea r8 , [ rip + 0x2b950 ] jmp 0x3a3 nop word ptr [ rax + rax ] mov r8 , qword ptr [ rbx + 0x10 ] mov rcx , qword ptr [ rbx ] add rbx , 0x18 mov rdi , qword ptr [ rip + 0x23c0de ] xor eax , eax mov rdx , rbp mov esi , 0x1 call 0xffffffffffff9ae0 cmp rbx , r12 jne 0x398 xor edi , edi call 0xffffffffffff9ac0 lea rsi , [ rip + 0x2b984 ] mov edx , 0x5 xor edi , edi call 0xffffffffffff94b0 xor edi , edi mov rdx , rax xor esi , esi xor eax , eax call 0xffffffffffff99a0 mov edi , 0x1 call 0xfffffffffffff500 add ebp , 0x1 jmp 0x1e5 mov ebp , 0x1 jmp 0x1e5 lea rsi , [ rip + 0x2b9af ] mov edx , 0x5 xor edi , edi call 0xffffffffffff94b0 xor esi , esi mov rdx , rax mov edi , 0x1 xor eax , eax call 0xffffffffffff99a0 lea rsi , [ rip + 0x2b94b ] mov edx , 0x5 xor edi , edi call 0xffffffffffff94b0 xor esi , esi mov rdx , rax mov edi , 0x1 xor eax , eax call 0xffffffffffff99a0 call 0xffffffffffff9510 lea rsi , [ rip + 0x2b0ed ] mov edx , 0x5 xor edi , edi call 0xffffffffffff94b0 mov esi , dword ptr [ r13 ] mov rdx , rax mov rcx , rbx mov edi , 0x1 xor eax , eax call 0xffffffffffff99a0 lea rsi , [ rip + 0x2b0c4 ] mov edx , 0x5 xor edi , edi call 0xffffffffffff94b0 mov rcx , rbx mov rdx , rax xor esi , esi mov edi , 0x1 xor eax , eax call 0xffffffffffff99a0 lea rsi , [ rip + 0x2b912 ] mov edx , 0x5 xor edi , edi call 0xffffffffffff94b0 xor esi , esi mov rdx , rax mov edi , 0x1 xor eax , eax call 0xffffffffffff99a0 mov edx , 0x5 lea rsi , [ rip + 0x2b859 ] jmp 0x3d1 nop nop word ptr cs : [ rax + rax ]
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly code snippets exhibit fundamental architectural differences and structural disparities. Code1 uses 32-bit registers (ebp, eax, esp) and stack-based parameter passing, while Code2 employs 64-bit registers (rdi, rsi, rsp) and follows the System V AMD64 ABI. The control flow patterns are entirely distinct: Code1 features linear memory operations with conditional jumps, whereas Code2 contains string comparisons (repe cmpsb) and complex flag-based branching. There are no overlapping functional blocks, instruction sequences, or algorithmic similarities. The calling conventions differ significantly (e.g., Code2 uses FS segment for security cookies), and Code2 includes operations absent in Code1 (like thread-local storage access). The architectural mismatch and absence of shared logic patterns confirm these are unrelated code segments.
------------------------------------------------------------

------------------------------------------------------------
Code1: push ebp mov ebp , esp push ebx push edi push esi sub esp , 0x10c mov eax , dword ptr [ ebp + 0xc ] mov ecx , dword ptr [ ebp + 0x8 ] mov edx , dword ptr [ ebp + 0x8 ] mov dword ptr [ ebp - 0x14 ] , edx mov dword ptr [ ebp - 0x88 ] , eax mov dword ptr [ ebp - 0x8c ] , ecx mov dword ptr [ esp ] , 0x18 call 0xfffef5b0 mov dword ptr [ ebp - 0x18 ] , eax mov eax , dword ptr [ ebp - 0x18 ] mov dword ptr [ ebp - 0x90 ] , eax mov eax , dword ptr [ ebp - 0x90 ] cmp eax , 0x0 jne 0x57 mov dword ptr [ ebp - 0x10 ] , 0x0 jmp 0x353 mov eax , dword ptr [ ebp + 0xc ] mov dword ptr [ esp ] , eax call 0xfffef2c0 mov dword ptr [ ebp - 0x94 ] , eax xor eax , eax mov ecx , dword ptr [ ebp - 0x18 ] mov edx , dword ptr [ ebp - 0x94 ] mov dword ptr [ ecx + 0x10 ] , edx mov ecx , dword ptr [ ebp - 0x18 ] cmp eax , dword ptr [ ecx + 0x10 ] sete bl mov byte ptr [ ebp - 0x95 ] , bl mov al , byte ptr [ ebp - 0x95 ] test al , 0x1 jne 0x98 jmp 0xbb mov eax , dword ptr [ ebp - 0x18 ] mov dword ptr [ ebp - 0x9c ] , eax mov eax , dword ptr [ ebp - 0x9c ] mov dword ptr [ esp ] , eax call 0xfffef2b0 mov dword ptr [ ebp - 0x10 ] , 0x0 jmp 0x353 mov eax , dword ptr [ ebp + 0xc ] mov ecx , dword ptr [ ebp - 0x14 ] mov dword ptr [ ebp - 0xa0 ] , eax mov dword ptr [ ebp - 0xa4 ] , ecx mov eax , dword ptr [ ebp - 0xa4 ] mov ecx , dword ptr [ eax ] mov edx , dword ptr [ ebp - 0xa0 ] mov dword ptr [ esp ] , edx mov dword ptr [ esp + 0x4 ] , ecx call 0x16b40 mov ecx , dword ptr [ ebp - 0x18 ] mov dword ptr [ ebp - 0xa8 ] , eax mov dword ptr [ ebp - 0xac ] , ecx xor eax , eax mov ecx , dword ptr [ ebp - 0xac ] mov edx , dword ptr [ ebp - 0xa8 ] mov dword ptr [ ecx + 0x14 ] , edx cmp eax , edx jne 0x132 mov eax , dword ptr [ ebp - 0x18 ] mov dword ptr [ ebp - 0xb0 ] , eax mov eax , dword ptr [ ebp - 0xb0 ] mov dword ptr [ esp ] , eax call 0xfffef2b0 mov dword ptr [ ebp - 0x10 ] , 0x0 jmp 0x353 mov eax , dword ptr [ ebp - 0x18 ] add eax , 0x14 mov dword ptr [ ebp - 0xb4 ] , eax mov eax , dword ptr [ ebp - 0xb4 ] mov ecx , dword ptr [ eax ] mov dword ptr [ esp ] , ecx call 0xfffef780 mov dword ptr [ ebp - 0xb8 ] , eax mov eax , dword ptr [ ebp - 0xb8 ] mov dword ptr [ ebp - 0x7c ] , eax cmp dword ptr [ ebp - 0x7c ] , 0x0 jl 0x16c jmp 0x196 lea eax , [ 0x8097f23 ] mov dword ptr [ esp ] , eax lea eax , [ 0x80999e9 ] mov dword ptr [ esp + 0x4 ] , eax mov dword ptr [ esp + 0x8 ] , 0xa6 lea eax , [ 0x80999f5 ] mov dword ptr [ esp + 0xc ] , eax call 0xfffefa30 mov eax , dword ptr [ ebp - 0x7c ] mov dword ptr [ esp ] , eax mov dword ptr [ esp + 0x4 ] , 0x1 call 0x15b10 mov dword ptr [ ebp - 0xbc ] , eax mov eax , dword ptr [ ebp - 0x7c ] mov dword ptr [ esp ] , eax lea eax , [ ebp - 0x78 ] mov dword ptr [ esp + 0x4 ] , eax call 0x3d660 cmp eax , 0x0 setl cl mov byte ptr [ ebp - 0xbd ] , cl mov al , byte ptr [ ebp - 0xbd ] test al , 0x1 jne 0x1e0 jmp 0x203 mov eax , dword ptr [ ebp - 0x18 ] mov dword ptr [ ebp - 0xc4 ] , eax mov eax , dword ptr [ ebp - 0xc4 ] mov dword ptr [ esp ] , eax call 0xffffff00 mov dword ptr [ ebp - 0x10 ] , 0x0 jmp 0x353 mov eax , dword ptr [ ebp - 0x78 ] mov ecx , dword ptr [ ebp - 0x74 ] mov edx , dword ptr [ ebp - 0x18 ] mov dword ptr [ ebp - 0xc8 ] , eax mov dword ptr [ ebp - 0xcc ] , ecx mov dword ptr [ ebp - 0xd0 ] , edx mov eax , dword ptr [ ebp - 0xd0 ] mov ecx , dword ptr [ ebp - 0xc8 ] mov dword ptr [ eax ] , ecx mov edx , dword ptr [ ebp - 0xcc ] mov dword ptr [ eax + 0x4 ] , edx mov esi , dword ptr [ ebp - 0x20 ] mov edi , dword ptr [ ebp - 0x1c ] mov ebx , dword ptr [ ebp - 0x18 ] add ebx , 0x8 mov dword ptr [ ebp - 0xd4 ] , esi mov dword ptr [ ebp - 0xd8 ] , edi mov dword ptr [ ebp - 0xdc ] , ebx mov eax , dword ptr [ ebp - 0xdc ] mov ecx , dword ptr [ ebp - 0xd4 ] mov dword ptr [ eax ] , ecx mov edx , dword ptr [ ebp - 0xd8 ] mov dword ptr [ eax + 0x4 ] , edx mov esi , dword ptr [ ebp - 0x14 ] mov esi , dword ptr [ esi + 0x4 ] mov edi , dword ptr [ ebp - 0x18 ] mov dword ptr [ esp ] , esi mov dword ptr [ esp + 0x4 ] , edi call 0x17160 mov dword ptr [ ebp - 0x80 ] , eax cmp dword ptr [ ebp - 0x80 ] , 0x0 je 0x2b1 mov eax , dword ptr [ ebp - 0x18 ] mov dword ptr [ esp ] , eax call 0xffffff00 mov eax , dword ptr [ ebp - 0x80 ] mov eax , dword ptr [ eax + 0x14 ] mov dword ptr [ ebp - 0xe0 ] , eax mov eax , dword ptr [ ebp - 0xe0 ] mov dword ptr [ ebp - 0x10 ] , eax jmp 0x353 mov eax , dword ptr [ ebp - 0x14 ] mov eax , dword ptr [ eax + 0x4 ] mov dword ptr [ ebp - 0xe4 ] , eax mov eax , dword ptr [ ebp - 0x18 ] mov dword ptr [ ebp - 0xe8 ] , eax mov eax , dword ptr [ ebp - 0xe8 ] mov ecx , dword ptr [ ebp - 0xe4 ] mov dword ptr [ esp ] , ecx mov dword ptr [ esp + 0x4 ] , eax call 0x19300 cmp eax , 0x0 je 0x303 mov eax , dword ptr [ ebp - 0x18 ] add eax , 0x14 mov dword ptr [ ebp - 0xec ] , eax mov eax , dword ptr [ ebp - 0xec ] mov ecx , dword ptr [ eax ] mov dword ptr [ ebp - 0x10 ] , ecx jmp 0x353 call 0xfffef750 mov eax , dword ptr [ eax ] mov dword ptr [ ebp - 0xf0 ] , eax mov eax , dword ptr [ ebp - 0xf0 ] mov dword ptr [ ebp - 0x84 ] , eax mov ecx , dword ptr [ ebp - 0x18 ] mov dword ptr [ ebp - 0xf4 ] , ecx mov eax , dword ptr [ ebp - 0xf4 ] mov dword ptr [ esp ] , eax call 0xffffff00 mov eax , dword ptr [ ebp - 0x84 ] mov dword ptr [ ebp - 0xf8 ] , eax call 0xfffef750 mov ecx , dword ptr [ ebp - 0xf8 ] mov dword ptr [ eax ] , ecx mov dword ptr [ ebp - 0x10 ] , 0x0 mov eax , dword ptr [ ebp - 0x10 ] mov dword ptr [ ebp - 0xfc ] , eax mov eax , dword ptr [ ebp - 0xfc ] add esp , 0x10c pop esi pop edi pop ebx pop ebp ret nop nop
Code2: push ebp mov ebp , esp push ebx push edi push esi sub esp , 0x3c mov eax , dword ptr [ ebp + 0xc ] mov ecx , dword ptr [ ebp + 0x8 ] cmp dword ptr [ 0x80cab18 ] , 0x0 mov dword ptr [ ebp - 0x10 ] , eax mov dword ptr [ ebp - 0x14 ] , ecx jne 0x39a mov al , byte ptr [ 0x80c3780 ] xor al , 0x38 mov byte ptr [ 0x80c3788 ] , al mov al , byte ptr [ 0x80c3781 ] xor al , 0x8c mov byte ptr [ 0x80c3789 ] , al mov al , byte ptr [ 0x80c3782 ] xor al , 0x6e mov byte ptr [ 0x80c378a ] , al mov al , byte ptr [ 0x80c3783 ] xor al , 0x46 mov byte ptr [ 0x80c378b ] , al mov al , byte ptr [ 0x80c3784 ] xor al , 0x69 mov byte ptr [ 0x80c378c ] , al mov al , byte ptr [ 0x80c3785 ] xor al , 0xeb mov byte ptr [ 0x80c378d ] , al mov al , byte ptr [ 0x80c3786 ] xor al , 0x26 mov byte ptr [ 0x80c378e ] , al mov al , byte ptr [ 0x80c3787 ] xor al , 0x62 mov byte ptr [ 0x80c378f ] , al mov al , byte ptr [ 0x80c3790 ] xor al , 0x25 mov byte ptr [ 0x80c379c ] , al mov al , byte ptr [ 0x80c3791 ] xor al , 0x3 mov byte ptr [ 0x80c379d ] , al mov al , byte ptr [ 0x80c3792 ] xor al , 0xa5 mov byte ptr [ 0x80c379e ] , al mov al , byte ptr [ 0x80c3793 ] xor al , 0xc1 mov byte ptr [ 0x80c379f ] , al mov al , byte ptr [ 0x80c3794 ] xor al , 0xf7 mov byte ptr [ 0x80c37a0 ] , al mov al , byte ptr [ 0x80c3795 ] xor al , 0xb6 mov byte ptr [ 0x80c37a1 ] , al mov al , byte ptr [ 0x80c3796 ] xor al , 0x6c mov byte ptr [ 0x80c37a2 ] , al mov al , byte ptr [ 0x80c3797 ] xor al , 0x7d mov byte ptr [ 0x80c37a3 ] , al mov al , byte ptr [ 0x80c3798 ] xor al , 0xf3 mov byte ptr [ 0x80c37a4 ] , al mov al , byte ptr [ 0x80c3799 ] xor al , 0xf0 mov byte ptr [ 0x80c37a5 ] , al mov al , byte ptr [ 0x80c379a ] xor al , 0x45 mov byte ptr [ 0x80c37a6 ] , al mov al , byte ptr [ 0x80c379b ] xor al , 0xd8 mov byte ptr [ 0x80c37a7 ] , al mov al , byte ptr [ 0x80c37b0 ] xor al , 0xc7 mov byte ptr [ 0x80c37f0 ] , al mov al , byte ptr [ 0x80c37b1 ] xor al , 0xe9 mov byte ptr [ 0x80c37f1 ] , al mov al , byte ptr [ 0x80c37b2 ] xor al , 0x4e mov byte ptr [ 0x80c37f2 ] , al mov al , byte ptr [ 0x80c37b3 ] xor al , 0xa mov byte ptr [ 0x80c37f3 ] , al mov al , byte ptr [ 0x80c37b4 ] xor al , 0xbd mov byte ptr [ 0x80c37f4 ] , al mov al , byte ptr [ 0x80c37b5 ] xor al , 0x4b mov byte ptr [ 0x80c37f5 ] , al mov al , byte ptr [ 0x80c37b6 ] xor al , 0x1e mov byte ptr [ 0x80c37f6 ] , al mov al , byte ptr [ 0x80c37b7 ] xor al , 0x6e mov byte ptr [ 0x80c37f7 ] , al mov al , byte ptr [ 0x80c37b8 ] xor al , 0x48 mov byte ptr [ 0x80c37f8 ] , al mov al , byte ptr [ 0x80c37b9 ] xor al , 0xf6 mov byte ptr [ 0x80c37f9 ] , al mov al , byte ptr [ 0x80c37ba ] xor al , 0xd8 mov byte ptr [ 0x80c37fa ] , al mov al , byte ptr [ 0x80c37bb ] xor al , 0x43 mov byte ptr [ 0x80c37fb ] , al mov al , byte ptr [ 0x80c37bc ] xor al , 0x2e mov byte ptr [ 0x80c37fc ] , al mov al , byte ptr [ 0x80c37bd ] xor al , 0xd3 mov byte ptr [ 0x80c37fd ] , al mov al , byte ptr [ 0x80c37be ] xor al , 0x8e mov byte ptr [ 0x80c37fe ] , al mov al , byte ptr [ 0x80c37bf ] xor al , 0xaa mov byte ptr [ 0x80c37ff ] , al mov al , byte ptr [ 0x80c37c0 ] xor al , 0x50 mov byte ptr [ 0x80c3800 ] , al mov al , byte ptr [ 0x80c37c1 ] xor al , 0x1e mov byte ptr [ 0x80c3801 ] , al mov al , byte ptr [ 0x80c37c2 ] xor al , 0x4d mov byte ptr [ 0x80c3802 ] , al mov al , byte ptr [ 0x80c37c3 ] xor al , 0xfa mov byte ptr [ 0x80c3803 ] , al mov al , byte ptr [ 0x80c37c4 ] xor al , 0x2c mov byte ptr [ 0x80c3804 ] , al mov al , byte ptr [ 0x80c37c5 ] xor al , 0x2b mov byte ptr [ 0x80c3805 ] , al mov al , byte ptr [ 0x80c37c6 ] xor al , 0x8b mov byte ptr [ 0x80c3806 ] , al mov al , byte ptr [ 0x80c37c7 ] xor al , 0x38 mov byte ptr [ 0x80c3807 ] , al mov al , byte ptr [ 0x80c37c8 ] xor al , 0x23 mov byte ptr [ 0x80c3808 ] , al mov al , byte ptr [ 0x80c37c9 ] xor al , 0x1a mov byte ptr [ 0x80c3809 ] , al mov al , byte ptr [ 0x80c37ca ] xor al , 0xd6 mov byte ptr [ 0x80c380a ] , al mov al , byte ptr [ 0x80c37cb ] xor al , 0x24 mov byte ptr [ 0x80c380b ] , al mov al , byte ptr [ 0x80c37cc ] xor al , 0x51 mov byte ptr [ 0x80c380c ] , al mov al , byte ptr [ 0x80c37cd ] xor al , 0xfc mov byte ptr [ 0x80c380d ] , al mov al , byte ptr [ 0x80c37ce ] xor al , 0xbd mov byte ptr [ 0x80c380e ] , al mov al , byte ptr [ 0x80c37cf ] xor al , 0x7e mov byte ptr [ 0x80c380f ] , al mov al , byte ptr [ 0x80c37d0 ] xor al , 0x84 mov byte ptr [ 0x80c3810 ] , al mov al , byte ptr [ 0x80c37d1 ] xor al , 0xf7 mov byte ptr [ 0x80c3811 ] , al mov al , byte ptr [ 0x80c37d2 ] xor al , 0x74 mov byte ptr [ 0x80c3812 ] , al mov al , byte ptr [ 0x80c37d3 ] xor al , 0x82 mov byte ptr [ 0x80c3813 ] , al mov al , byte ptr [ 0x80c37d4 ] xor al , 0x58 mov byte ptr [ 0x80c3814 ] , al mov al , byte ptr [ 0x80c37d5 ] xor al , 0xd6 mov byte ptr [ 0x80c3815 ] , al mov al , byte ptr [ 0x80c37d6 ] xor al , 0xb3 mov byte ptr [ 0x80c3816 ] , al mov al , byte ptr [ 0x80c37d7 ] xor al , 0xe4 mov byte ptr [ 0x80c3817 ] , al mov al , byte ptr [ 0x80c37d8 ] xor al , 0x2f mov byte ptr [ 0x80c3818 ] , al mov al , byte ptr [ 0x80c37d9 ] xor al , 0xdb mov byte ptr [ 0x80c3819 ] , al mov al , byte ptr [ 0x80c37da ] xor al , 0xdd mov byte ptr [ 0x80c381a ] , al mov al , byte ptr [ 0x80c37db ] xor al , 0x11 mov byte ptr [ 0x80c381b ] , al mov al , byte ptr [ 0x80c37dc ] xor al , 0xe mov byte ptr [ 0x80c381c ] , al mov al , byte ptr [ 0x80c37dd ] xor al , 0xf4 mov byte ptr [ 0x80c381d ] , al mov al , byte ptr [ 0x80c37de ] xor al , 0xde mov byte ptr [ 0x80c381e ] , al mov al , byte ptr [ 0x80c37df ] xor al , 0xc7 mov byte ptr [ 0x80c381f ] , al mov al , byte ptr [ 0x80c37e0 ] xor al , 0x4a mov byte ptr [ 0x80c3820 ] , al mov al , byte ptr [ 0x80c37e1 ] xor al , 0x8c mov byte ptr [ 0x80c3821 ] , al mov al , byte ptr [ 0x80c37e2 ] xor al , 0x58 mov byte ptr [ 0x80c3822 ] , al mov al , byte ptr [ 0x80c37e3 ] xor al , 0x4e mov byte ptr [ 0x80c3823 ] , al mov al , byte ptr [ 0x80c37e4 ] xor al , 0xbe mov byte ptr [ 0x80c3824 ] , al mov al , byte ptr [ 0x80c37e5 ] xor al , 0x45 mov byte ptr [ 0x80c3825 ] , al mov dword ptr [ 0x80cab18 ] , 0x1 mov eax , esp add eax , - 0x10 mov esp , eax mov ecx , esp add ecx , - 0x10 mov esp , ecx mov edx , esp add edx , - 0x10 mov esp , edx mov esi , esp add esi , - 0x10 mov esp , esi mov edi , esp add edi , - 0x10 mov esp , edi mov ebx , esp add ebx , - 0x60 mov esp , ebx mov dword ptr [ ebp - 0x18 ] , eax mov eax , esp add eax , - 0x10 mov esp , eax mov dword ptr [ ebp - 0x1c ] , eax mov eax , esp add eax , - 0x10 mov esp , eax mov dword ptr [ ebp - 0x20 ] , eax mov eax , esp add eax , - 0x10 mov esp , eax mov dword ptr [ ebp - 0x24 ] , eax mov eax , dword ptr [ ebp - 0x14 ] mov dword ptr [ ecx ] , eax mov eax , dword ptr [ ebp - 0x10 ] mov dword ptr [ edx ] , eax mov ecx , dword ptr [ ecx ] mov dword ptr [ esi ] , ecx sub esp , 0x10 mov dword ptr [ esp ] , 0x18 mov dword ptr [ ebp - 0x28 ] , edx mov dword ptr [ ebp - 0x2c ] , esi mov dword ptr [ ebp - 0x30 ] , edi mov dword ptr [ ebp - 0x34 ] , ebx call 0xfffdd8c0 add esp , 0x10 mov ecx , dword ptr [ ebp - 0x30 ] mov dword ptr [ ecx ] , eax cmp dword ptr [ ecx ] , 0x0 jne 0x437 mov eax , dword ptr [ ebp - 0x18 ] mov dword ptr [ eax ] , 0x0 jmp 0x66b mov eax , dword ptr [ ebp - 0x28 ] mov ecx , dword ptr [ eax ] sub esp , 0x10 mov dword ptr [ esp ] , ecx call 0xfffdd5d0 add esp , 0x10 xor ecx , ecx mov edx , dword ptr [ ebp - 0x30 ] mov esi , dword ptr [ edx ] mov dword ptr [ esi + 0x10 ] , eax mov eax , dword ptr [ edx ] cmp ecx , dword ptr [ eax + 0x10 ] jne 0x480 mov eax , dword ptr [ ebp - 0x30 ] mov ecx , dword ptr [ eax ] sub esp , 0x10 mov dword ptr [ esp ] , ecx call 0xfffdd5c0 add esp , 0x10 mov eax , dword ptr [ ebp - 0x18 ] mov dword ptr [ eax ] , 0x0 jmp 0x66b mov eax , dword ptr [ ebp - 0x28 ] mov ecx , dword ptr [ eax ] mov edx , dword ptr [ ebp - 0x2c ] mov esi , dword ptr [ edx ] mov esi , dword ptr [ esi ] sub esp , 0x10 mov dword ptr [ esp ] , ecx mov dword ptr [ esp + 0x4 ] , esi call 0x2be70 add esp , 0x10 xor ecx , ecx mov edx , dword ptr [ ebp - 0x30 ] mov esi , dword ptr [ edx ] mov dword ptr [ esi + 0x14 ] , eax cmp ecx , eax jne 0x4d1 mov eax , dword ptr [ ebp - 0x30 ] mov ecx , dword ptr [ eax ] sub esp , 0x10 mov dword ptr [ esp ] , ecx call 0xfffdd5c0 add esp , 0x10 mov eax , dword ptr [ ebp - 0x18 ] mov dword ptr [ eax ] , 0x0 jmp 0x66b mov eax , dword ptr [ ebp - 0x30 ] mov ecx , dword ptr [ eax ] mov ecx , dword ptr [ ecx + 0x14 ] sub esp , 0x10 mov dword ptr [ esp ] , ecx call 0xfffdda90 add esp , 0x10 mov ecx , dword ptr [ ebp - 0x1c ] mov dword ptr [ ecx ] , eax cmp dword ptr [ ecx ] , 0x0 jl 0x4fa jmp 0x52a lea eax , [ 0x80c37f0 ] lea ecx , [ 0x80c379c ] lea edx , [ 0x80c3788 ] sub esp , 0x10 mov dword ptr [ esp ] , edx mov dword ptr [ esp + 0x4 ] , ecx mov dword ptr [ esp + 0x8 ] , 0xa6 mov dword ptr [ esp + 0xc ] , eax call 0xfffddd40 add esp , 0x10 mov eax , dword ptr [ ebp - 0x1c ] mov ecx , dword ptr [ eax ] sub esp , 0x10 mov dword ptr [ esp ] , ecx mov dword ptr [ esp + 0x4 ] , 0x1 call 0x2b270 add esp , 0x10 mov ecx , dword ptr [ ebp - 0x1c ] mov edx , dword ptr [ ecx ] sub esp , 0x10 mov dword ptr [ esp ] , edx mov edx , dword ptr [ ebp - 0x34 ] mov dword ptr [ esp + 0x4 ] , edx mov dword ptr [ ebp - 0x38 ] , eax call 0x4ede0 add esp , 0x10 cmp eax , 0x0 jge 0x58c mov eax , dword ptr [ ebp - 0x30 ] mov ecx , dword ptr [ eax ] sub esp , 0x10 mov dword ptr [ esp ] , ecx call 0xffffff40 add esp , 0x10 mov eax , dword ptr [ ebp - 0x18 ] mov dword ptr [ eax ] , 0x0 jmp 0x66b mov eax , dword ptr [ ebp - 0x34 ] movsd xmm0 , qword ptr [ eax ] mov ecx , dword ptr [ ebp - 0x30 ] mov edx , dword ptr [ ecx ] movsd qword ptr [ edx ] , xmm0 movsd xmm0 , qword ptr [ eax + 0x58 ] mov edx , dword ptr [ ecx ] movsd qword ptr [ edx + 0x8 ] , xmm0 mov edx , dword ptr [ ebp - 0x2c ] mov esi , dword ptr [ edx ] mov esi , dword ptr [ esi + 0x4 ] mov edi , dword ptr [ ecx ] sub esp , 0x10 mov dword ptr [ esp ] , esi mov dword ptr [ esp + 0x4 ] , edi call 0x2c830 add esp , 0x10 mov ecx , dword ptr [ ebp - 0x20 ] mov dword ptr [ ecx ] , eax cmp dword ptr [ ecx ] , 0x0 je 0x5f7 mov eax , dword ptr [ ebp - 0x30 ] mov ecx , dword ptr [ eax ] sub esp , 0x10 mov dword ptr [ esp ] , ecx call 0xffffff40 add esp , 0x10 mov eax , dword ptr [ ebp - 0x20 ] mov ecx , dword ptr [ eax ] mov ecx , dword ptr [ ecx + 0x14 ] mov edx , dword ptr [ ebp - 0x18 ] mov dword ptr [ edx ] , ecx jmp 0x66b mov eax , dword ptr [ ebp - 0x2c ] mov ecx , dword ptr [ eax ] mov ecx , dword ptr [ ecx + 0x4 ] mov edx , dword ptr [ ebp - 0x30 ] mov esi , dword ptr [ edx ] sub esp , 0x10 mov dword ptr [ esp ] , ecx mov dword ptr [ esp + 0x4 ] , esi call 0x2db40 add esp , 0x10 cmp eax , 0x0 je 0x631 mov eax , dword ptr [ ebp - 0x30 ] mov ecx , dword ptr [ eax ] mov ecx , dword ptr [ ecx + 0x14 ] mov edx , dword ptr [ ebp - 0x18 ] mov dword ptr [ edx ] , ecx jmp 0x66b call 0xfffdda60 mov eax , dword ptr [ eax ] mov ecx , dword ptr [ ebp - 0x24 ] mov dword ptr [ ecx ] , eax mov eax , dword ptr [ ebp - 0x30 ] mov edx , dword ptr [ eax ] sub esp , 0x10 mov dword ptr [ esp ] , edx call 0xffffff40 add esp , 0x10 mov eax , dword ptr [ ebp - 0x24 ] mov ecx , dword ptr [ eax ] mov dword ptr [ ebp - 0x3c ] , ecx call 0xfffdda60 mov ecx , dword ptr [ ebp - 0x3c ] mov dword ptr [ eax ] , ecx mov eax , dword ptr [ ebp - 0x18 ] mov dword ptr [ eax ] , 0x0 mov eax , dword ptr [ ebp - 0x18 ] mov eax , dword ptr [ eax ] lea esp , [ ebp - 0xc ] pop esi pop edi pop ebx pop ebp ret nop nop nop nop
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly codes are not similar. While they share a common function prologue and initial stack setup, the body of the functions are entirely different. Code2 contains a long sequence of XOR operations on memory that is absent in Code1. Additionally, the function calls in both codes are to completely different addresses, indicating different functionality and purpose. The control flow and operations diverge significantly after the initial setup.
------------------------------------------------------------

------------------------------------------------------------
Code1: push rbp push rbx sub rsp , 0x38 mov rax , qword ptr fs : [ 0x28 ] mov qword ptr [ rsp + 0x28 ] , rax xor eax , eax mov rbx , qword ptr [ rip + 0x23484d ] mov rbp , qword ptr [ rip + 0x23484e ] call 0xfffffffffffffb46 cmp eax , 0x7fffffff setne dl movzx edx , dl add eax , edx mov qword ptr [ rsp ] , rbp mov qword ptr [ rsp + 0x8 ] , rbx mov qword ptr [ rsp + 0x10 ] , 0x0 mov dword ptr [ rsp + 0x18 ] , 0xffffffff mov rcx , rsp lea rdx , [ rip - 0x2a5 ] mov esi , eax mov edi , 0x0 call 0xfffffffffffffc98 mov ebx , dword ptr [ rsp + 0x18 ] test ebx , ebx jns 0x85 mov rax , qword ptr [ rsp + 0x28 ] xor rax , qword ptr fs : [ 0x28 ] jne 0xd3 add rsp , 0x38 pop rbx pop rbp ret mov edx , 0x5 lea rsi , [ rip + 0x25bc9 ] mov edi , 0x0 call 0xffffffffffff2032 mov ecx , ebx mov rdx , rax mov esi , 0x0 mov edi , 0x0 mov eax , 0x0 call 0xffffffffffff2512 lea rcx , [ rip + 0x25c37 ] mov edx , 0x18c lea rsi , [ rip + 0x25b7f ] lea rdi , [ rip + 0x25b81 ] call 0xffffffffffff2172 call 0xffffffffffff2082
Code2: lui gp , 0x47 addiu sp , sp , - 0x40 addiu gp , gp , - 0x7a80 lui v0 , 0x46 sw s0 , 0x30 ( sp ) lui v1 , 0x46 sw s2 , 0x38 ( sp ) lw s0 , - 0x7a38 ( gp ) lw s2 , 0x1398 ( v0 ) sw s1 , 0x34 ( sp ) sw ra , 0x3c ( sp ) sw gp , 0x10 ( sp ) lw v0 , ( s0 ) lw s1 , 0x1394 ( v1 ) sw v0 , 0x2c ( sp ) jal 0x415380 nop bltz v0 , 0xb4 nop lui v1 , 0x7fff ori v1 , v1 , 0xffff beq v0 , v1 , 0x60 lui a1 , 0x41 addiu v0 , v0 , 0x1 sw s1 , 0x20 ( sp ) addiu v1 , zero , - 0x1 sw s2 , 0x1c ( sp ) addiu a2 , sp , 0x1c sw zero , 0x24 ( sp ) addiu a1 , a1 , 0x55ec sw v1 , 0x28 ( sp ) jal 0x415770 move a0 , v0 lw s1 , 0x28 ( sp ) bgez s1 , 0xd0 lw gp , 0x10 ( sp ) lw v1 , 0x2c ( sp ) lw v0 , ( s0 ) bne v1 , v0 , 0xc4 lw ra , 0x3c ( sp ) lw s2 , 0x38 ( sp ) lw s1 , 0x34 ( sp ) lw s0 , 0x30 ( sp ) jr ra addiu sp , sp , 0x40 jal 0x4156b4 nop b 0x50 lui v1 , 0x7fff lw t9 , - 0x7a78 ( gp ) jalr t9 nop lui a1 , 0x45 lw t9 , - 0x7a70 ( gp ) addiu a2 , zero , 0x5 addiu a1 , a1 , - 0x57d4 jalr t9 move a0 , zero move a1 , zero lw gp , 0x10 ( sp ) move a0 , zero move a3 , s1 lw t9 , - 0x7ae4 ( gp ) jalr t9 move a2 , v0 lui a3 , 0x45 lw gp , 0x10 ( sp ) lui a1 , 0x45 lui a0 , 0x45 addiu a3 , a3 , - 0x5720 addiu a2 , zero , 0x18c lw t9 , - 0x7c3c ( gp ) addiu a1 , a1 , - 0x573c jalr t9 addiu a0 , a0 , - 0x5730
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly codes are fundamentally dissimilar due to multiple factors:
1. **Architecture difference**: Code 1 uses x86_64 instructions (e.g., `push rbp`, `mov rax`, `call`) while Code 2 uses MIPS instructions (e.g., `lui`, `addiu`, `jal`). The instruction sets and registers are entirely incompatible.
2. **Stack/register operations**: Code 1 uses RIP-relative addressing and FS segment registers, whereas Code 2 relies on MIPS-specific global pointer (gp) conventions and explicit stack offsets.
3. **Control flow patterns**: Code 1 has conditional jumps like `jns` and `jne` with x86 flags, while Code 2 uses MIPS delay slots (`nop`) and branches like `beq`/`bgez`.
4. **System interactions**: Code 1
------------------------------------------------------------

------------------------------------------------------------
Code1: lui a3 , 0x40 lui a2 , 0x40 addiu a3 , a3 , 0x62c0 j 0x406760 addiu a2 , a2 , 0x3640
Code2: push ebp mov ebp , esp push esi sub esp , 0x24 mov eax , dword ptr [ ebp + 0xc ] mov ecx , dword ptr [ ebp + 0x8 ] mov edx , dword ptr [ ebp + 0x8 ] mov esi , dword ptr [ ebp + 0xc ] mov dword ptr [ esp ] , edx lea edx , [ 0x8055014 ] mov dword ptr [ esp + 0x4 ] , edx mov dword ptr [ esp + 0x8 ] , esi mov dword ptr [ esp + 0xc ] , 0x20 lea edx , [ 0x804b440 ] mov dword ptr [ esp + 0x10 ] , edx lea edx , [ 0x804b710 ] mov dword ptr [ esp + 0x14 ] , edx mov dword ptr [ ebp - 0x8 ] , eax mov dword ptr [ ebp - 0xc ] , ecx call 0x60 add esp , 0x24 pop esi pop ebp ret nop word ptr cs : [ eax + eax ] nop dword ptr [ eax + eax ]
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two code snippets are completely dissimilar due to fundamental differences in architecture and functionality. Code1 uses MIPS instructions (lui, addiu, j) for register manipulation and control flow, while Code2 employs x86 instructions (push, mov, lea, call) for stack management and function calls. The operations, register usage, and overall structure show no meaningful overlap. Code1 performs simple address loading and jumps, whereas Code2 sets up a complex stack frame with multiple memory operations and function calls. The architectural mismatch and absence of equivalent operations result in no discernible similarity.
------------------------------------------------------------

------------------------------------------------------------
Code1: push { r4 , r5 , r6 , lr } sub sp , sp , 0x8 bl 0xe94c cmp r0 , 0x0 beq 0xd8 ldr r0 , [ pc , 0x12c ] bl 0xeab4 mov r5 , r0 bl 0xe850 bl 0xe790 subs r4 , r0 , 0x0 beq 0x138 mov r0 , r4 bl 0xe85c cmp r5 , r0 beq 0x54 bl 0xe92c ldr r1 , [ pc , 0x100 ] mov r2 , r0 ldr r0 , [ pc , 0xfc ] bl 0xfffeff30 mov r1 , r5 mov r0 , r4 bl 0xeb0c ldr r5 , [ pc , 0xec ] cmp r0 , 0x0 mov r4 , r0 str r0 , [ r5 ] beq 0x108 ldr r3 , [ pc , 0xdc ] ldr r6 , [ r3 , 0x20 ] bl 0xfffe4fc0 str r4 , [ sp ] str r0 , [ sp , 0x4 ] add r3 , sp , 0x8 ldmdb r3 , { r1 , r2 } mov r0 , r6 bl 0x61368 subs r4 , r0 , 0x0 beq 0xb8 mov r2 , r4 ldr r1 , [ pc , 0xb0 ] mov r0 , 0x1 bl 0xfffe5080 mov r0 , r4 bl 0xfffefd54 ldr r0 , [ r5 ] bl 0x6e378 mov r3 , 0x0 ldr r2 , [ pc , 0x94 ] str r0 , [ r2 ] mov r0 , r3 add sp , sp , 0x8 pop { r4 , r5 , r6 , pc } ldr r3 , [ pc , 0x84 ] ldr r4 , [ r3 ] bl 0xe92c ldr r2 , [ pc , 0x7c ] mov r3 , r0 mov r1 , 0x1 mov r0 , r4 bl 0xfffe50b0 mov r3 , 0x1 mov r0 , r3 add sp , sp , 0x8 pop { r4 , r5 , r6 , pc } ldr r3 , [ pc , 0x54 ] ldr r4 , [ r3 ] bl 0xe92c ldr r2 , [ pc , 0x50 ] mov r3 , r0 mov r1 , 0x1 mov r0 , r4 bl 0xfffe50b0 ldr r0 , [ pc , 0x18 ] bl 0x6e378 str r0 , [ r5 ] b 0xbc ldr r1 , [ pc , 0x30 ] ldr r0 , [ pc , 0xc ] bl 0xfffeff30 b 0x30 andeq sl , sl , r8 , ror 0x8 andeq r2 , sl , r4 , lsl 0x29 andeq r5 , ip , r0 , lsl 0x5 andeq r5 , ip , r0 , lsl 0x14 andeq r5 , ip , r8 , asr 0x10 strdeq r2 , r3 , [ sl ] , -r0 andeq r5 , ip , ip , ror 0x13 andeq r5 , ip , r0 , lsl 0x10 andeq r2 , sl , r8 , lsr 0x28 andeq r2 , sl , r0 , asr 0x29 andeq r2 , sl , r0 , asr lr
Code2: addiu sp , sp , - 0x30 sw ra , 0x2c ( sp ) sw s1 , 0x28 ( sp ) sw s0 , 0x24 ( sp ) lui gp , 0x4d addiu gp , gp , - 0xcf0 sw gp , 0x10 ( sp ) lw t9 , - 0x7cbc ( gp ) bal 0xd43c nop lw gp , 0x10 ( sp ) beqz v0 , 0x130 lui a0 , 0x4b addiu a0 , a0 , - 0x4d40 lw t9 , - 0x7cb8 ( gp ) bal 0xd5c4 nop lw gp , 0x10 ( sp ) move s0 , v0 move a0 , v0 jal 0x4249c0 nop lw gp , 0x10 ( sp ) move a1 , s0 move a0 , v0 lw t9 , - 0x7cb4 ( gp ) bal 0xd678 nop lw gp , 0x10 ( sp ) move s0 , v0 lw v0 , - 0x7cb0 ( gp ) beqz s0 , 0x174 sw s0 , ( v0 ) lui v0 , 0x4d lw s1 , - 0x7ec0 ( v0 ) move a0 , s0 lw t9 , - 0x73b0 ( gp ) jalr t9 nop lw gp , 0x10 ( sp ) move a1 , s0 move a2 , v0 move a0 , s1 lw t9 , - 0x7cf0 ( gp ) jalr t9 nop lw gp , 0x10 ( sp ) beqz v0 , 0xf8 move s0 , v0 move a2 , v0 lui a1 , 0x4a addiu a1 , a1 , 0x42b8 addiu a0 , zero , 0x1 lw t9 , - 0x741c ( gp ) jalr t9 nop lw gp , 0x10 ( sp ) move a0 , s0 lw t9 , - 0x7fb0 ( gp ) bal - 0xda20 nop lw gp , 0x10 ( sp ) lw v0 , - 0x7cb0 ( gp ) lw a0 , ( v0 ) lw t9 , - 0x7fd4 ( gp ) jalr t9 nop lw gp , 0x10 ( sp ) lw v1 , - 0x7cf4 ( gp ) sw v0 , ( v1 ) move v0 , zero lw ra , 0x2c ( sp ) lw s1 , 0x28 ( sp ) lw s0 , 0x24 ( sp ) jr ra addiu sp , sp , 0x30 lw v0 , - 0x72d0 ( gp ) lw s0 , ( v0 ) lw t9 , - 0x7ce0 ( gp ) bal 0xd424 nop lw gp , 0x10 ( sp ) move a3 , v0 lui a2 , 0x4a addiu a2 , a2 , 0x4260 addiu a1 , zero , 0x1 move a0 , s0 lw t9 , - 0x747c ( gp ) jalr t9 nop lw gp , 0x10 ( sp ) b 0x11c addiu v0 , zero , 0x1 lw v0 , - 0x72d0 ( gp ) lw s0 , ( v0 ) lw t9 , - 0x7ce0 ( gp ) bal 0xd424 nop lw gp , 0x10 ( sp ) move a3 , v0 lui a2 , 0x4a addiu a2 , a2 , 0x4288 addiu a1 , zero , 0x1 move a0 , s0 lw t9 , - 0x747c ( gp ) jalr t9 nop lw gp , 0x10 ( sp ) lui a0 , 0x4b addiu a0 , a0 , - 0x4d40 lw t9 , - 0x7fd4 ( gp ) jalr t9 nop lw gp , 0x10 ( sp ) lw v1 , - 0x7cb0 ( gp ) b 0xf8 sw v0 , ( v1 )
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly code snippets are from different architectures (ARM and MIPS) and do not share a common structure beyond the very basic function prologue and epilogue. The sequence of operations, function calls, and branching patterns are significantly different, with no clear one-to-one correspondence in the control flow or data handling. Therefore, they are considered not similar.
------------------------------------------------------------

------------------------------------------------------------
Code1: push rbp mov rbp , rsp sub rsp , 0x60 mov qword ptr [ rbp - 0x20 ] , rdi mov qword ptr [ rbp - 0x28 ] , rsi mov qword ptr [ rbp - 0x30 ] , rdx mov rdx , qword ptr [ rbp - 0x28 ] mov qword ptr [ rbp - 0x10 ] , rdx mov rdx , qword ptr [ rbp - 0x30 ] mov qword ptr [ rbp - 0x8 ] , rdx mov dword ptr [ rbp - 0x3c ] , 0xccf63760 mov eax , dword ptr [ rbp - 0x3c ] mov ecx , eax sub ecx , 0x8c196bd0 mov dword ptr [ rbp - 0x40 ] , eax mov dword ptr [ rbp - 0x44 ] , ecx je 0x12f jmp 0x47 mov eax , dword ptr [ rbp - 0x40 ] sub eax , 0x9960ebee mov dword ptr [ rbp - 0x48 ] , eax je 0x11f jmp 0x5d mov eax , dword ptr [ rbp - 0x40 ] sub eax , 0xb985f84e mov dword ptr [ rbp - 0x4c ] , eax je 0x152 jmp 0x73 mov eax , dword ptr [ rbp - 0x40 ] sub eax , 0xccd8cfe7 mov dword ptr [ rbp - 0x50 ] , eax je 0x162 jmp 0x89 mov eax , dword ptr [ rbp - 0x40 ] sub eax , 0xccf63760 mov dword ptr [ rbp - 0x54 ] , eax je 0xd0 jmp 0x9f mov eax , dword ptr [ rbp - 0x40 ] sub eax , 0x2540fe49 mov dword ptr [ rbp - 0x58 ] , eax je 0xfb jmp 0xb5 mov eax , dword ptr [ rbp - 0x40 ] sub eax , 0x47066aba mov dword ptr [ rbp - 0x5c ] , eax je 0x146 jmp 0xcb jmp 0x170 mov rdi , qword ptr [ rbp - 0x10 ] mov rsi , qword ptr [ rbp - 0x8 ] lea rdx , [ rbp - 0x38 ] call 0x3010 test al , 0x1 mov ecx , 0x2540fe49 mov r8d , 0xb985f84e cmovne r8d , ecx mov dword ptr [ rbp - 0x3c ] , r8d jmp 0x170 mov rdi , qword ptr [ rbp - 0x20 ] mov rsi , qword ptr [ rbp - 0x38 ] call 0x44f0 test al , 0x1 mov ecx , 0x9960ebee mov edx , 0x8c196bd0 cmovne edx , ecx mov dword ptr [ rbp - 0x3c ] , edx jmp 0x170 mov byte ptr [ rbp - 0x11 ] , 0x1 mov dword ptr [ rbp - 0x3c ] , 0xccd8cfe7 jmp 0x170 mov rax , qword ptr [ rbp - 0x30 ] mov ecx , dword ptr [ rax ] add ecx , - 0x1 mov dword ptr [ rax ] , ecx mov dword ptr [ rbp - 0x3c ] , 0x47066aba jmp 0x170 mov dword ptr [ rbp - 0x3c ] , 0xb985f84e jmp 0x170 mov byte ptr [ rbp - 0x11 ] , 0x0 mov dword ptr [ rbp - 0x3c ] , 0xccd8cfe7 jmp 0x170 mov al , byte ptr [ rbp - 0x11 ] and al , 0x1 movzx eax , al add rsp , 0x60 pop rbp ret jmp 0x2b nop word ptr cs : [ rax + rax ] nop
Code2: push ebp mov ebp , esp push esi sub esp , 0x54 mov eax , dword ptr [ ebp + 0x10 ] mov ecx , dword ptr [ ebp + 0xc ] mov edx , dword ptr [ ebp + 0x8 ] mov esi , dword ptr [ ebp + 0xc ] add esi , 0x2 mov dword ptr [ ebp - 0x1c ] , eax mov eax , esi xor esi , esi mov dword ptr [ ebp - 0x20 ] , edx mov edx , esi mov esi , 0x3 div esi shl eax , 0x2 add eax , 0x1 mov dword ptr [ ebp - 0x14 ] , eax mov eax , dword ptr [ ebp + 0xc ] mov dword ptr [ ebp - 0xc ] , eax mov eax , dword ptr [ ebp - 0x14 ] mov dword ptr [ ebp - 0x8 ] , eax mov dword ptr [ ebp - 0x18 ] , 0xa7cb6cf5 mov dword ptr [ ebp - 0x24 ] , ecx mov eax , dword ptr [ ebp - 0x18 ] mov ecx , eax sub ecx , 0xa7cb6cf5 mov dword ptr [ ebp - 0x28 ] , eax mov dword ptr [ ebp - 0x2c ] , ecx je 0xd7 jmp 0x64 mov eax , dword ptr [ ebp - 0x28 ] sub eax , 0x1c7b284 mov dword ptr [ ebp - 0x30 ] , eax je 0xf4 jmp 0x7a mov eax , dword ptr [ ebp - 0x28 ] sub eax , 0x25116ac4 mov dword ptr [ ebp - 0x34 ] , eax je 0x184 jmp 0x90 mov eax , dword ptr [ ebp - 0x28 ] sub eax , 0x3d99f6f9 mov dword ptr [ ebp - 0x38 ] , eax je 0x110 jmp 0xa6 mov eax , dword ptr [ ebp - 0x28 ] sub eax , 0x44eefe66 mov dword ptr [ ebp - 0x3c ] , eax je 0x13b jmp 0xbc mov eax , dword ptr [ ebp - 0x28 ] sub eax , 0x69f3f38f mov dword ptr [ ebp - 0x40 ] , eax je 0x14d jmp 0xd2 jmp 0x18d mov eax , dword ptr [ ebp - 0xc ] mov ecx , dword ptr [ ebp - 0x8 ] cmp eax , ecx mov eax , 0x1c7b284 mov ecx , 0x3d99f6f9 cmova ecx , eax mov dword ptr [ ebp - 0x18 ] , ecx jmp 0x18d mov eax , dword ptr [ ebp + 0x10 ] mov dword ptr [ eax ] , 0x0 mov dword ptr [ ebp - 0x10 ] , 0x0 mov dword ptr [ ebp - 0x18 ] , 0x25116ac4 jmp 0x18d mov eax , dword ptr [ ebp - 0x14 ] mov dword ptr [ esp ] , eax call 0xffff8de0 mov ecx , dword ptr [ ebp + 0x10 ] mov dword ptr [ ecx ] , eax mov eax , dword ptr [ ebp + 0x10 ] cmp dword ptr [ eax ] , 0x0 mov eax , 0x69f3f38f mov ecx , 0x44eefe66 cmovne ecx , eax mov dword ptr [ ebp - 0x18 ] , ecx jmp 0x18d mov eax , dword ptr [ ebp - 0x14 ] mov dword ptr [ ebp - 0x10 ] , eax mov dword ptr [ ebp - 0x18 ] , 0x25116ac4 jmp 0x18d mov eax , dword ptr [ ebp + 0x8 ] mov ecx , dword ptr [ ebp + 0xc ] mov edx , dword ptr [ ebp + 0x10 ] mov edx , dword ptr [ edx ] mov esi , dword ptr [ ebp - 0x14 ] mov dword ptr [ esp ] , eax mov dword ptr [ esp + 0x4 ] , ecx mov dword ptr [ esp + 0x8 ] , edx mov dword ptr [ esp + 0xc ] , esi call 0xfffff6d0 mov eax , dword ptr [ ebp - 0x14 ] sub eax , 0x1 mov dword ptr [ ebp - 0x10 ] , eax mov dword ptr [ ebp - 0x18 ] , 0x25116ac4 jmp 0x18d mov eax , dword ptr [ ebp - 0x10 ] add esp , 0x54 pop esi pop ebp ret jmp 0x48 nop word ptr cs : [ eax + eax ] nop dword ptr [ eax ]
Similarity: 1
Label: -1
Similarity Score: 0.7
Explanation: Both codes exhibit a similar structural pattern involving stack frame setup, state variable manipulation through constant comparisons, and jump-based control flow. Key similarities include:
- Stack frame initialization with base pointer adjustments
- Use of a state variable (e.g., [rbp-0x3c] vs [ebp-0x18]) compared against multiple constants via subtraction
- Identical conditional jump patterns (je/jmp sequences)
- Common exit points (0x170/0x18d) with state updates
- Final cleanup and return sequences

Differences stem from architecture-specific implementations (x86-64 vs x86 registers), varying constant values, and distinct operations within code blocks. The shared control flow structure and state handling mechanism indicate significant algorithmic similarity despite architectural differences.
------------------------------------------------------------

------------------------------------------------------------
Code1: push rbp mov rbp , rsp sub rsp , 0x40 mov qword ptr [ rbp - 0x10 ] , rdi mov dword ptr [ rbp - 0x14 ] , 0x0 mov qword ptr [ rbp - 0x20 ] , 0x0 mov qword ptr [ rbp - 0x28 ] , 0x0 mov qword ptr [ rbp - 0x30 ] , 0x0 mov qword ptr [ rbp - 0x38 ] , 0x0 mov rdi , qword ptr [ rbp - 0x10 ] test rdi , rdi setne al movzx ecx , al mov edi , ecx mov rdi , qword ptr [ rdi * 0x8 + 0x9c12b8 ] jmp rdi mov rax , qword ptr [ rbp - 0x10 ] mov rax , qword ptr [ rax + 0x8 ] test rax , rax setne cl movzx edx , cl mov eax , edx mov rax , qword ptr [ rax * 0x8 + 0x9c12c8 ] jmp rax mov ecx , 0x6e6b98 mov edi , 0x10 mov esi , 0xb3 mov edx , 0x43 mov r8d , 0xfb call 0x30f10 mov dword ptr [ rbp - 0x4 ] , 0x0 mov rcx , qword ptr [ rip + 0x47688a ] jmp rcx call 0xfffffffffffde9f0 mov qword ptr [ rbp - 0x30 ] , rax test rax , rax sete cl movzx edx , cl mov eax , edx mov rax , qword ptr [ rax * 0x8 + 0x9c12d8 ] jmp rax mov rax , qword ptr [ rip + 0x47680b ] jmp rax call 0xfffffffffffe0700 mov qword ptr [ rbp - 0x20 ] , rax test rax , rax sete cl movzx edx , cl mov eax , edx mov rax , qword ptr [ rax * 0x8 + 0x9c12e8 ] jmp rax mov rax , qword ptr [ rip + 0x4767e4 ] jmp rax mov rax , qword ptr [ rbp - 0x10 ] mov rax , qword ptr [ rax + 0x18 ] test rax , rax sete cl movzx edx , cl mov eax , edx mov rax , qword ptr [ rax * 0x8 + 0x9c12f8 ] jmp rax call 0xfffffffffffde9f0 mov qword ptr [ rbp - 0x28 ] , rax mov rax , qword ptr [ rbp - 0x28 ] test rax , rax sete cl movzx edx , cl mov eax , edx mov rax , qword ptr [ rax * 0x8 + 0x9c1308 ] jmp rax mov rax , qword ptr [ rip + 0x47679c ] jmp rax mov rax , qword ptr [ rip + 0x47671b ] jmp rax mov rax , qword ptr [ rbp - 0x10 ] mov rax , qword ptr [ rax + 0x18 ] mov qword ptr [ rbp - 0x28 ] , rax mov rax , qword ptr [ rip + 0x476706 ] jmp rax mov rax , qword ptr [ rbp - 0x10 ] mov rdi , qword ptr [ rax + 0x8 ] mov rsi , qword ptr [ rbp - 0x30 ] mov rdx , qword ptr [ rbp - 0x20 ] call 0xffffffffffff4ea0 test eax , eax setne cl movzx eax , cl mov edx , eax mov rdx , qword ptr [ rdx * 0x8 + 0x9c1318 ] jmp rdx mov rax , qword ptr [ rip + 0x47674c ] jmp rax mov rax , qword ptr [ rip + 0x4766e3 ] jmp rax mov rdi , qword ptr [ rbp - 0x28 ] mov rsi , qword ptr [ rbp - 0x30 ] call 0xfffffffffffe7090 test eax , eax setne cl movzx eax , cl mov esi , eax mov rsi , qword ptr [ rsi * 0x8 + 0x9c1328 ] jmp rsi mov rax , qword ptr [ rip + 0x476719 ] jmp rax mov rax , qword ptr [ rip + 0x4766c8 ] jmp rax mov rax , qword ptr [ rbp - 0x28 ] mov ecx , dword ptr [ rax + 0x8 ] test ecx , ecx sete dl movzx ecx , dl mov eax , ecx mov rax , qword ptr [ rax * 0x8 + 0x9c1338 ] jmp rax mov rax , qword ptr [ rbp - 0x10 ] mov rax , qword ptr [ rax + 0x10 ] test rax , rax sete cl movzx edx , cl mov eax , edx mov rax , qword ptr [ rax * 0x8 + 0x9c1348 ] jmp rax mov rax , qword ptr [ rbp - 0x10 ] mov rdi , qword ptr [ rax + 0x8 ] call 0xffffffffffff4880 mov qword ptr [ rbp - 0x38 ] , rax mov rax , qword ptr [ rbp - 0x38 ] test rax , rax sete cl movzx edx , cl mov eax , edx mov rax , qword ptr [ rax * 0x8 + 0x9c1358 ] jmp rax mov rax , qword ptr [ rip + 0x4766a5 ] jmp rax mov rax , qword ptr [ rip + 0x476684 ] jmp rax mov rax , qword ptr [ rbp - 0x10 ] mov rax , qword ptr [ rax + 0x10 ] mov qword ptr [ rbp - 0x38 ] , rax mov rax , qword ptr [ rip + 0x47666f ] jmp rax mov rax , qword ptr [ rbp - 0x10 ] mov rdi , qword ptr [ rax + 0x8 ] mov rsi , qword ptr [ rbp - 0x38 ] mov rdx , qword ptr [ rbp - 0x28 ] mov r9 , qword ptr [ rbp - 0x20 ] xor ecx , ecx mov eax , ecx mov rcx , rax mov r8 , rax call 0xffffffffffff7150 test eax , eax setne r10b movzx eax , r10b mov ecx , eax mov rcx , qword ptr [ rcx * 0x8 + 0x9c1368 ] jmp rcx mov rax , qword ptr [ rip + 0x476645 ] jmp rax mov rax , qword ptr [ rbp - 0x28 ] mov rcx , qword ptr [ rbp - 0x10 ] mov qword ptr [ rcx + 0x18 ] , rax mov rax , qword ptr [ rbp - 0x38 ] mov rcx , qword ptr [ rbp - 0x10 ] mov qword ptr [ rcx + 0x10 ] , rax mov dword ptr [ rbp - 0x14 ] , 0x1 mov rax , qword ptr [ rip + 0x47661d ] jmp rax mov rax , qword ptr [ rbp - 0x30 ] test rax , rax setne cl movzx edx , cl mov eax , edx mov rax , qword ptr [ rax * 0x8 + 0x9c1378 ] jmp rax mov rdi , qword ptr [ rbp - 0x30 ] call 0xfffffffffffde8f0 mov rdi , qword ptr [ rip + 0x476602 ] jmp rdi mov rax , qword ptr [ rbp - 0x38 ] test rax , rax setne cl movzx edx , cl mov eax , edx mov rax , qword ptr [ rax * 0x8 + 0x9c1388 ] jmp rax mov rax , qword ptr [ rbp - 0x10 ] mov rax , qword ptr [ rax + 0x10 ] test rax , rax sete cl movzx edx , cl mov eax , edx mov rax , qword ptr [ rax * 0x8 + 0x9c1398 ] jmp rax mov rdi , qword ptr [ rbp - 0x38 ] call 0xffffffffffff3df0 mov rdi , qword ptr [ rip + 0x4765d2 ] jmp rdi mov rax , qword ptr [ rbp - 0x28 ] test rax , rax setne cl movzx edx , cl mov eax , edx mov rax , qword ptr [ rax * 0x8 + 0x9c13a8 ] jmp rax mov rax , qword ptr [ rbp - 0x10 ] mov rax , qword ptr [ rax + 0x18 ] test rax , rax sete cl movzx edx , cl mov eax , edx mov rax , qword ptr [ rax * 0x8 + 0x9c13b8 ] jmp rax mov rdi , qword ptr [ rbp - 0x28 ] call 0xfffffffffffde8f0 mov rdi , qword ptr [ rip + 0x4765a2 ] jmp rdi mov rax , qword ptr [ rbp - 0x20 ] test rax , rax setne cl movzx edx , cl mov eax , edx mov rax , qword ptr [ rax * 0x8 + 0x9c13c8 ] jmp rax mov rdi , qword ptr [ rbp - 0x20 ] call 0xfffffffffffe0840 mov rdi , qword ptr [ rip + 0x476587 ] jmp rdi mov eax , dword ptr [ rbp - 0x14 ] mov dword ptr [ rbp - 0x4 ] , eax mov rcx , qword ptr [ rip + 0x476580 ] jmp rcx mov eax , dword ptr [ rbp - 0x4 ] add rsp , 0x40 pop rbp ret nop dword ptr [ rax + rax ]
Code2: lui gp , 0x6c addiu sp , sp , - 0x40 addiu gp , gp , 0x2ee0 sw ra , 0x3c ( sp ) sw s4 , 0x38 ( sp ) sw s3 , 0x34 ( sp ) sw s2 , 0x30 ( sp ) sw s1 , 0x2c ( sp ) sw s0 , 0x28 ( sp ) beqz a0 , 0xe8 sw gp , 0x18 ( sp ) lw v0 , 0x4 ( a0 ) beqz v0 , 0xe8 move s0 , a0 lw t9 , - 0x7c30 ( gp ) bal - 0x17e44 nop lw gp , 0x18 ( sp ) beqz v0 , 0x13c move s1 , v0 lw t9 , - 0x74a0 ( gp ) bal - 0x168e8 nop lw gp , 0x18 ( sp ) beqz v0 , 0x130 move s3 , v0 lw s2 , 0xc ( s0 ) beqz s2 , 0x208 lw t9 , - 0x7c30 ( gp ) lw t9 , - 0x7bec ( gp ) move a2 , s3 lw a0 , 0x4 ( s0 ) bal - 0x7df4 move a1 , s1 bnez v0 , 0x160 lw gp , 0x18 ( sp ) lw t9 , - 0x7dc4 ( gp ) move a0 , s1 bal - 0x17ee8 sw v0 , 0x24 ( sp ) lw gp , 0x18 ( sp ) lw v0 , 0x24 ( sp ) lw v1 , 0xc ( s0 ) beqz v1 , 0x1f0 lw t9 , - 0x7dc4 ( gp ) lw t9 , - 0x74a4 ( gp ) move a0 , s3 bal - 0x16848 sw v0 , 0x24 ( sp ) lw ra , 0x3c ( sp ) lw v0 , 0x24 ( sp ) lw s4 , 0x38 ( sp ) lw s3 , 0x34 ( sp ) lw s2 , 0x30 ( sp ) lw s1 , 0x2c ( sp ) lw s0 , 0x28 ( sp ) jr ra addiu sp , sp , 0x40 lui a3 , 0x68 lw t9 , - 0x6ebc ( gp ) addiu v0 , zero , 0xfb addiu a3 , a3 , - 0x5afc addiu a2 , zero , 0x43 sw v0 , 0x10 ( sp ) addiu a1 , zero , 0xb3 jalr t9 addiu a0 , zero , 0x10 move v0 , zero lw ra , 0x3c ( sp ) lw s4 , 0x38 ( sp ) lw s3 , 0x34 ( sp ) lw s2 , 0x30 ( sp ) lw s1 , 0x2c ( sp ) lw s0 , 0x28 ( sp ) jr ra addiu sp , sp , 0x40 lw t9 , - 0x7dc4 ( gp ) bal - 0x17ee8 move a0 , s1 lw ra , 0x3c ( sp ) move v0 , zero lw s4 , 0x38 ( sp ) lw s3 , 0x34 ( sp ) lw s2 , 0x30 ( sp ) lw s1 , 0x2c ( sp ) lw s0 , 0x28 ( sp ) jr ra addiu sp , sp , 0x40 lw t9 , - 0x6730 ( gp ) move a1 , s1 bal - 0x10a44 move a0 , s2 beqz v0 , 0x90 lw gp , 0x18 ( sp ) lw v0 , 0x4 ( s2 ) beqz v0 , 0x164 lw t9 , - 0x6730 ( gp ) lw s4 , 0x8 ( s0 ) beqz s4 , 0x254 lw a0 , 0x4 ( s0 ) lw t9 , - 0x6774 ( gp ) move a3 , zero sw s3 , 0x14 ( sp ) move a2 , s2 sw zero , 0x10 ( sp ) bal - 0x6548 move a1 , s4 bnez v0 , 0x234 lw gp , 0x18 ( sp ) lw t9 , - 0x7dc4 ( gp ) move a0 , s1 bal - 0x17ee8 sw v0 , 0x24 ( sp ) lw gp , 0x18 ( sp ) lw v0 , 0x24 ( sp ) lw v1 , 0x8 ( s0 ) bnez v1 , 0xa8 lw t9 , - 0x6da8 ( gp ) move a0 , s4 bal - 0x7070 sw v0 , 0x24 ( sp ) lw gp , 0x18 ( sp ) b 0xa8 lw v0 , 0x24 ( sp ) move a0 , s2 bal - 0x17ee8 sw v0 , 0x24 ( sp ) lw gp , 0x18 ( sp ) b 0xb4 lw v0 , 0x24 ( sp ) bal - 0x17e44 nop lw gp , 0x18 ( sp ) bnez v0 , 0x74 move s2 , v0 lw t9 , - 0x7dc4 ( gp ) bal - 0x17ee8 move a0 , s1 move v0 , zero b 0xb4 lw gp , 0x18 ( sp ) lw t9 , - 0x7dc4 ( gp ) move a0 , s1 sw s2 , 0xc ( s0 ) bal - 0x17ee8 sw s4 , 0x8 ( s0 ) addiu v0 , zero , 0x1 b 0x1cc lw gp , 0x18 ( sp ) lw t9 , - 0x6da0 ( gp ) bal - 0x7188 nop lw gp , 0x18 ( sp ) beqz v0 , 0x274 move s4 , v0 b 0x190 lw a0 , 0x4 ( s0 ) lw t9 , - 0x7dc4 ( gp ) bal - 0x17ee8 move a0 , s1 move v0 , zero b 0xa8 lw gp , 0x18 ( sp )
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly codes are for different architectures (x86_64 and MIPS) and exhibit entirely different instruction sets, register usage, and control flow patterns. There is no significant similarity in the structure or sequence of operations.
------------------------------------------------------------

------------------------------------------------------------
Code1: addiu sp , sp , - 0x28 lui v0 , 0x44 sw s0 , 0x1c ( sp ) sw ra , 0x24 ( sp ) sw s1 , 0x20 ( sp ) lw s0 , 0x5490 ( v0 ) beqz s0 , 0x60 move s1 , a0 b 0x34 lw t9 , ( s0 ) beqz s0 , 0x50 lw ra , 0x24 ( sp ) lw t9 , ( s0 ) move a0 , s1 jalr t9 lw a1 , 0x4 ( s0 ) andi v1 , v0 , 0x3 bnez v1 , 0x28 lw s0 , 0x8 ( s0 ) lw ra , 0x24 ( sp ) lw s1 , 0x20 ( sp ) lw s0 , 0x1c ( sp ) jr ra addiu sp , sp , 0x28 b 0x4c addiu v0 , zero , 0x3
Code2: push ebp mov ebp , esp push esi sub esp , 0x24 mov eax , dword ptr [ ebp + 0x8 ] xor ecx , ecx mov edx , dword ptr [ 0x80608c0 ] mov esi , dword ptr [ ebp + 0x8 ] mov dword ptr [ esp ] , edx mov dword ptr [ esp + 0x4 ] , 0x3 mov dword ptr [ esp + 0x8 ] , esi mov dword ptr [ esp + 0xc ] , 0x0 mov dword ptr [ ebp - 0x8 ] , eax mov dword ptr [ ebp - 0xc ] , ecx call 0x8b0 add esp , 0x24 pop esi pop ebp ret nop dword ptr [ eax ]
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly codes are fundamentally dissimilar due to multiple factors:
1. Architecture differences: Code1 uses MIPS instructions (addiu, lui, sw, lw, jalr) while Code2 uses x86 instructions (push, mov, sub, call).
2. Control flow divergence: Code1 features conditional branches (beqz, bnez) and jump register (jr) operations indicating complex branching logic, while Code2 follows a linear execution path with a single function call.
3. Register usage mismatch: Code1 utilizes MIPS registers (v0, s0, s1, ra, t9), whereas Code2 employs x86 registers (ebp, esp, esi, eax, ecx, edx).
4. Stack management contrast: Code1 adjusts the stack by fixed offsets (addiu sp, sp, -0x28) while Code2 uses variable-based stack allocation (sub esp, 0x24) and explicit pushes/pops.
5. Functional purpose: Code1 appears to implement a function pointer loop with conditional jumps, while Code2 prepares arguments for a single function call. No meaningful algorithmic or structural similarities exist.
------------------------------------------------------------

------------------------------------------------------------
Code1: push ebp mov ebp , esp sub esp , 0x28 mov eax , dword ptr [ ebp + 0x8 ] mov ecx , dword ptr [ ebp + 0x8 ] add ecx , 0x8 mov dword ptr [ ebp - 0x8 ] , ecx mov ecx , dword ptr [ ebp - 0x8 ] cmp ecx , dword ptr [ ebp + 0x8 ] mov dword ptr [ ebp - 0x18 ] , eax jb 0x9d mov eax , dword ptr [ ebp - 0x8 ] mov dword ptr [ esp ] , eax call 0xfff9f2c0 mov dword ptr [ ebp - 0xc ] , eax cmp dword ptr [ ebp - 0xc ] , 0x0 setne cl mov byte ptr [ ebp - 0x19 ] , cl mov al , byte ptr [ ebp - 0x19 ] test al , 0x1 jne 0x49 jmp 0x98 mov eax , dword ptr [ ebp - 0xc ] mov dword ptr [ ebp - 0x14 ] , eax mov eax , dword ptr [ ebp - 0x14 ] add eax , 0x8 mov dword ptr [ ebp - 0xc ] , eax mov eax , dword ptr [ ebp - 0x14 ] mov dword ptr [ eax + 0x4 ] , 0x1415fb4a mov eax , dword ptr [ ebp - 0xc ] xor edx , edx mov ecx , 0x101 div ecx mov dword ptr [ ebp - 0x10 ] , edx mov ecx , dword ptr [ ebp - 0x10 ] mov ecx , dword ptr [ ecx * 0x4 + 0x80b5fe4 ] mov edx , dword ptr [ ebp - 0x14 ] mov dword ptr [ edx ] , ecx mov ecx , dword ptr [ ebp - 0xc ] mov edx , dword ptr [ ebp - 0x10 ] mov dword ptr [ edx * 0x4 + 0x80b5fe4 ] , ecx mov ecx , dword ptr [ ebp - 0xc ] mov dword ptr [ ebp - 0x4 ] , ecx jmp 0xa9 jmp 0x9d mov dword ptr [ ebp - 0x4 ] , 0x0 jmp 0xa9 mov eax , dword ptr [ ebp - 0x4 ] mov dword ptr [ ebp - 0x20 ] , eax mov eax , dword ptr [ ebp - 0x20 ] add esp , 0x28 pop ebp ret mov eax , dword ptr [ ebp - 0x8 ] mov dword ptr [ esp ] , eax call 0xfff9f2c0 mov dword ptr [ ebp - 0xc ] , eax jmp 0x21 mov eax , dword ptr [ ebp - 0xc ] mov dword ptr [ ebp - 0x14 ] , eax mov eax , dword ptr [ ebp - 0x14 ] add eax , 0x8 mov dword ptr [ ebp - 0xc ] , eax mov eax , dword ptr [ ebp - 0x14 ] mov dword ptr [ eax + 0x4 ] , 0x1415fb4a mov eax , dword ptr [ ebp - 0xc ] xor edx , edx mov ecx , 0x101 div ecx mov dword ptr [ ebp - 0x10 ] , edx mov ecx , dword ptr [ ebp - 0x10 ] mov ecx , dword ptr [ ecx * 0x4 + 0x80b5fe4 ] mov edx , dword ptr [ ebp - 0x14 ] mov dword ptr [ edx ] , ecx mov ecx , dword ptr [ ebp - 0xc ] mov edx , dword ptr [ ebp - 0x10 ] mov dword ptr [ edx * 0x4 + 0x80b5fe4 ] , ecx mov ecx , dword ptr [ ebp - 0xc ] mov dword ptr [ ebp - 0x4 ] , ecx jmp 0x49 jmp 0x98 mov dword ptr [ ebp - 0x4 ] , 0x0 jmp 0x9d jmp 0xa9 nop
Code2: mov r3 , 0x8 adds r0 , r0 , r3 bhs 0x58 push { r4 , r5 , r6 , lr } bl 0xfffd2270 subs r2 , r0 , 0x0 beq 0x50 ldr r3 , [ pc , 0x3c ] add r0 , r2 , 0x8 umull r4 , r5 , r0 , r3 lsr r3 , r5 , 0x8 ldr r1 , [ pc , 0x30 ] add r3 , r3 , r3 , lsl 0x8 sub r3 , r0 , r3 ldr lr , [ r1 , r3 , lsl 0x2 ] ldr ip , [ pc , 0x24 ] str lr , [ r2 ] str r0 , [ r1 , r3 , lsl 0x2 ] str ip , [ r2 , 0x4 ] pop { r4 , r5 , r6 , pc } mov r0 , 0x0 pop { r4 , r5 , r6 , pc } mov r0 , 0x0 bx lr
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The codes are fundamentally dissimilar due to different architectures (x86 vs ARM), completely distinct instruction sets, and no overlapping algorithmic patterns. Code1 uses x86-specific operations like `dword ptr`, `ebp/esp` stack management, and complex memory addressing, while Code2 uses ARM-specific features like `r0-r6` registers, `umull`, and conditional execution (`bhs`, `beq`). There are no common control flow structures, equivalent operations, or shared constants to indicate similarity. The only superficial parallels (like `push`/`pop` and jumps) are architecture-specific implementations of basic concepts, not evidence of functional equivalence.
------------------------------------------------------------

------------------------------------------------------------
Code1: addiu sp , sp , - 0x28 sw ra , 0x24 ( sp ) sw fp , 0x20 ( sp ) move fp , sp lui gp , 0x45 addiu gp , gp , - 0xdf0 sw gp , 0x10 ( sp ) sw a0 , 0x28 ( fp ) sw a1 , 0x2c ( fp ) lw a0 , 0x28 ( fp ) jal 0x40a16c nop lw gp , 0x10 ( fp ) sb v0 , 0x1e ( fp ) lw a0 , 0x2c ( fp ) jal 0x40a16c nop lw gp , 0x10 ( fp ) sb v0 , 0x1f ( fp ) lbu v0 , 0x1e ( fp ) beqz v0 , 0x78 nop lbu v0 , 0x1f ( fp ) xori v0 , v0 , 0x1 andi v0 , v0 , 0xff beqz v0 , 0x78 nop addiu v0 , zero , - 0x1 b 0xbc nop lbu v0 , 0x1e ( fp ) xori v0 , v0 , 0x1 andi v0 , v0 , 0xff beqz v0 , 0xa4 nop lbu v0 , 0x1f ( fp ) beqz v0 , 0xa4 nop addiu v0 , zero , 0x1 b 0xbc nop lw a2 , - 0x7bd8 ( gp ) lw a1 , 0x28 ( fp ) lw a0 , 0x2c ( fp ) jal 0x40ad7c nop lw gp , 0x10 ( fp ) move sp , fp lw ra , 0x24 ( sp ) lw fp , 0x20 ( sp ) addiu sp , sp , 0x28 jr ra nop
Code2: lw v0 , 0xb0 ( a0 ) addiu a2 , zero , 0x3 beq v0 , a2 , 0xdc lw v1 , 0xb0 ( a1 ) beq v1 , a2 , 0xc8 addiu a2 , zero , 0x9 beq v1 , a2 , 0x11c nop beq v0 , a2 , 0xec nop lui gp , 0x45 addiu sp , sp , - 0x28 addiu gp , gp , - 0x6e20 sw s1 , 0x1c ( sp ) sw ra , 0x24 ( sp ) sw s2 , 0x20 ( sp ) sw s0 , 0x18 ( sp ) move s0 , a0 sw gp , 0x10 ( sp ) lw s1 , ( a1 ) addiu a1 , zero , 0x2e lw t9 , - 0x7d8c ( gp ) jalr t9 move a0 , s1 addiu a1 , zero , 0x2e lw gp , 0x10 ( sp ) lw s2 , ( s0 ) move s0 , v0 lw t9 , - 0x7d8c ( gp ) jalr t9 move a0 , s2 beqz s0 , 0xf4 lw gp , 0x10 ( sp ) beqz v0 , 0x12c nop lw t9 , - 0x7c3c ( gp ) move a1 , v0 jalr t9 move a0 , s0 bnez v0 , 0x104 lw gp , 0x10 ( sp ) lw ra , 0x24 ( sp ) move a1 , s2 lw s0 , 0x18 ( sp ) move a0 , s1 lw s2 , 0x20 ( sp ) lw s1 , 0x1c ( sp ) lw t9 , - 0x7c3c ( gp ) jr t9 addiu sp , sp , 0x28 addiu v1 , zero , 0x9 beq v0 , v1 , 0x28 addiu v0 , zero , 0x1 jr ra nop beq v1 , v0 , 0x28 addiu v0 , zero , 0x9 beq v1 , v0 , 0x2c lui gp , 0x45 jr ra addiu v0 , zero , - 0x1 beqz v0 , 0xa4 lui s0 , 0x43 b 0x8c addiu s0 , s0 , 0x448 lw ra , 0x24 ( sp ) lw s2 , 0x20 ( sp ) lw s1 , 0x1c ( sp ) lw s0 , 0x18 ( sp ) jr ra addiu sp , sp , 0x28 beq v0 , v1 , 0x28 addiu v0 , zero , 0x1 b 0xd4 nop lui v0 , 0x43 b 0x8c addiu v0 , v0 , 0x448
Similarity: -1
Label: 1
Similarity Score: 0.15
Explanation: Both codes show some structural similarities typical of MIPS assembly, such as stack frame management (adjusting SP by 0x28) and register saving conventions. However, the core logic differs significantly: Code1 features two consecutive function calls (0x40a16c) followed by conditional checks on results, while Code2 has complex branching logic (multiple BEQ instructions) and distinct function calls via T9 register jumps. The register usage patterns, branching structures, and called functions show minimal overlap. Only about 15% similarity exists in boilerplate setup/teardown routines, while functional implementation diverges completely.
------------------------------------------------------------

------------------------------------------------------------
Code1: push ebp mov ebp , esp sub esp , 0x18 mov eax , dword ptr [ ebp + 0xc ] mov ecx , dword ptr [ ebp + 0x8 ] mov edx , dword ptr [ 0x8086d70 ] mov dword ptr [ ebp - 0x8 ] , eax mov dword ptr [ ebp - 0xc ] , ecx jmp edx mov eax , dword ptr [ ebp + 0x8 ] mov ecx , eax inc ecx mov dword ptr [ ebp + 0x8 ] , ecx movsx eax , byte ptr [ eax ] mov ecx , eax sub ecx , 0x7d mov dword ptr [ ebp - 0x10 ] , eax mov dword ptr [ ebp - 0x14 ] , ecx ja 0x128 mov eax , dword ptr [ ebp - 0x10 ] mov ecx , dword ptr [ eax * 0x4 + 0x8082530 ] jmp ecx mov al , byte ptr [ ebp + 0xf ] and al , 0x8 shr al , 0x3 movzx ecx , al mov ecx , dword ptr [ ecx * 0x4 + 0x8087088 ] jmp ecx mov byte ptr [ ebp - 0x1 ] , 0x1 mov eax , dword ptr [ 0x8086db4 ] jmp eax mov eax , dword ptr [ 0x8086db0 ] jmp eax mov al , byte ptr [ ebp + 0xf ] and al , 0x8 shr al , 0x3 movzx ecx , al mov ecx , dword ptr [ ecx * 0x4 + 0x8087090 ] jmp ecx mov eax , dword ptr [ 0x8086d70 ] jmp eax mov al , byte ptr [ ebp + 0xc ] and al , 0x2 shr al , 0x1 movzx ecx , al mov ecx , dword ptr [ ecx * 0x4 + 0x8087098 ] xor edx , edx mov al , dl mov byte ptr [ ebp - 0x15 ] , al jmp ecx mov eax , dword ptr [ ebp + 0x8 ] mov cl , byte ptr [ eax ] test cl , cl setne cl mov eax , dword ptr [ 0x8086d90 ] mov byte ptr [ ebp - 0x15 ] , cl jmp eax mov al , byte ptr [ ebp - 0x15 ] movzx ecx , al and ecx , 0x1 mov edx , dword ptr [ ebp + 0x8 ] add edx , ecx mov dword ptr [ ebp + 0x8 ] , edx mov ecx , dword ptr [ 0x8086d94 ] jmp ecx mov eax , dword ptr [ 0x8086db0 ] jmp eax mov al , byte ptr [ ebp + 0xc ] and al , 0x20 shr al , 0x5 movzx ecx , al mov ecx , dword ptr [ ecx * 0x4 + 0x80870a0 ] jmp ecx mov eax , dword ptr [ ebp + 0x8 ] mov cl , byte ptr [ eax ] sub cl , 0x28 sete dl movzx eax , dl mov eax , dword ptr [ eax * 0x4 + 0x80870a8 ] mov byte ptr [ ebp - 0x16 ] , cl jmp eax mov byte ptr [ ebp - 0x1 ] , 0x1 mov eax , dword ptr [ 0x8086db4 ] jmp eax mov eax , dword ptr [ 0x8086db0 ] jmp eax mov byte ptr [ ebp - 0x1 ] , 0x1 mov eax , dword ptr [ 0x8086db4 ] jmp eax mov byte ptr [ ebp - 0x1 ] , 0x0 mov eax , dword ptr [ 0x8086db4 ] jmp eax mov eax , dword ptr [ 0x8086d70 ] jmp eax mov al , byte ptr [ ebp - 0x1 ] and al , 0x1 movzx eax , al add esp , 0x18 pop ebp ret nop dword ptr [ eax ]
Code2: lui v1 , 0x43 addiu v1 , v1 , 0xc0 andi t0 , a1 , 0x20 addiu t1 , zero , 0x28 lui a3 , 0x800 and a3 , a1 , a3 b 0x34 andi a1 , a1 , 0x2 jr ra move v0 , zero bnez a3 , 0x9c addiu v0 , zero , 0x1 move a0 , a2 lbu v0 , ( a0 ) sltiu v0 , v0 , 0x7e beqz v0 , 0x30 addiu a2 , a0 , 0x1 lbu v0 , ( a0 ) sll v0 , v0 , 0x2 addu v0 , v1 , v0 lw v0 , ( v0 ) jr v0 nop bnez a3 , 0x30 move v0 , a3 bnez a1 , 0x74 nop lb v0 , 0x1 ( a0 ) sltu v0 , zero , v0 b 0x30 addu a2 , a2 , v0 beqz t0 , 0x30 nop lb v0 , 0x1 ( a0 ) bne v0 , t1 , 0x34 move a0 , a2 jr ra addiu v0 , zero , 0x1 addiu v0 , zero , 0x1 jr ra nop
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The codes show fundamental differences in architecture, structure, and functionality. Code1 uses x86 instructions with stack operations (ebp/esp), complex memory addressing, and jump tables. Code2 uses MIPS instructions with register-oriented operations (v1, a0, etc.), simpler branching, and no stack management. No shared control flow patterns, data handling approaches, or algorithmic similarities exist. The architectural mismatch (x86 vs MIPS) and divergent implementation strategies confirm these are entirely unrelated code segments.
------------------------------------------------------------

------------------------------------------------------------
Code1: push { r4 , r5 , r6 , r7 , r8 , sb , sl , fp , lr } sub sp , sp , 0x24 mov r2 , r1 ldr fp , [ pc , 0x2c8 ] add fp , pc , fp ldr r3 , [ pc , 0x2c4 ] ldr r3 , [ fp , r3 ] ldr r3 , [ r3 ] str r3 , [ sp , 0x1c ] subs r3 , r0 , 0x0 str r3 , [ sp , 0x4 ] beq 0x8c add r1 , sp , 0x18 ldr r0 , [ pc , 0x2a8 ] add r0 , pc , r0 bl 0xfff0fc90 subs r2 , r0 , 0x0 str r2 , [ sp , 0x10 ] moveq r0 , 0x0 beq 0x2b8 ldr r3 , [ sp , 0x18 ] cmp r3 , 0x0 ble 0x2a4 sub r6 , r2 , 0x4 mov r7 , 0x0 mov r8 , r7 ldr r3 , [ pc , 0x278 ] add r3 , pc , r3 add r3 , r3 , 0x10 str r3 , [ sp , 0xc ] ldr r3 , [ pc , 0x26c ] add r3 , pc , r3 add sl , r3 , 0x10 str fp , [ sp , 0x14 ] b 0x1e8 ldr r3 , [ pc , 0x25c ] ldr r3 , [ fp , r3 ] ldr r3 , [ r3 ] str r3 , [ sp , 0x4 ] b 0x30 ldr r2 , [ r4 , 0x8 ] cmp r2 , 0x0 beq 0xbc ldr r1 , [ pc , 0x240 ] add r1 , pc , r1 ldr r0 , [ sp , 0x4 ] bl 0xfff10440 mov r8 , 0x0 mov r4 , r8 mov sb , 0x1 ldr r3 , [ pc , 0x228 ] add r3 , pc , r3 str r3 , [ sp , 0x8 ] b 0xf0 add r4 , r4 , 0x1 cmp r4 , 0x20 beq 0x128 ldrb r3 , [ sl , r4 , lsl 0x4 ] cmp r3 , 0x0 beq 0x128 ldr r3 , [ r5 ] ldr r3 , [ r3 , 0x4 ] ands r3 , r3 , sb , lsl r4 beq 0xd8 ldr r3 , [ sp , 0xc ] add fp , r3 , r4 , lsl 0x4 mov r2 , fp ldr r1 , [ sp , 0x8 ] ldr r0 , [ sp , 0x4 ] bl 0xfff10440 mov r0 , fp bl 0xfff10944 add r8 , r8 , r0 b 0xd8 mov r4 , r8 cmp r8 , 0xc bgt 0x154 ldr r8 , [ pc , 0x1c0 ] add r8 , pc , r8 mov r1 , r8 ldr r0 , [ sp , 0x4 ] bl 0xfff10440 add r4 , r4 , 0x1 cmp r4 , 0xd bne 0x13c ldr r1 , [ pc , 0x1a4 ] add r1 , pc , r1 ldr r4 , [ sp , 0x4 ] mov r0 , r4 bl 0xfff10440 ldr r1 , [ pc , 0x194 ] add r1 , pc , r1 mov r0 , r4 bl 0xfff10440 b 0x21c ldr r1 , [ pc , 0x184 ] add r1 , pc , r1 ldr r0 , [ sp , 0x4 ] bl 0xfff10440 ldr r3 , [ r5 ] ldr r0 , [ r3 , 0x10 ] bl 0xfff10944 mov r4 , r0 cmp r0 , 0x10 bgt 0x230 ldr sb , [ pc , 0x160 ] add sb , pc , sb mov r1 , sb ldr r0 , [ sp , 0x4 ] bl 0xfff10440 add r4 , r4 , 0x1 cmp r4 , 0x11 bne 0x1ac b 0x230 ldr r1 , [ pc , 0x140 ] add r1 , pc , r1 ldr r0 , [ sp , 0x4 ] bl 0xfff10440 add r7 , r7 , 0x1 ldr r3 , [ sp , 0x18 ] cmp r3 , r7 ble 0x2a0 add r6 , r6 , 0x4 mov r5 , r6 ldr r4 , [ r6 ] ldr r3 , [ r4 , 0x2c ] cmp r3 , 0x0 bne 0x1d8 cmp r8 , 0x0 beq 0xa0 ldr r1 , [ r4 , 0x8 ] mov r0 , r8 bl 0xfff11100 cmp r0 , 0x0 bne 0xa0 ldr r3 , [ r5 ] ldr r8 , [ r3 , 0x8 ] ldr r2 , [ r3 , 0x10 ] cmp r2 , 0x0 bne 0x17c ldr r3 , [ r5 ] ldr r0 , [ r3 , 0x18 ] bl 0x1d65b8 mov r2 , r0 mov r3 , r1 ldr r1 , [ pc , 0xc8 ] add r1 , pc , r1 ldr r4 , [ sp , 0x4 ] mov r0 , r4 bl 0xfff10440 ldr r3 , [ r5 ] ldr r0 , [ r3 , 0x1c ] bl 0x1d65b8 mov r2 , r0 mov r3 , r1 ldr r1 , [ pc , 0xa4 ] add r1 , pc , r1 mov r0 , r4 bl 0xfff10440 ldr r3 , [ r5 ] ldr r2 , [ r3 , 0x14 ] cmp r2 , 0x0 beq 0x1c8 ldr r1 , [ pc , 0x88 ] add r1 , pc , r1 mov r0 , r4 bl 0xfff10440 b 0x1c8 ldr fp , [ sp , 0x14 ] ldr r0 , [ sp , 0x4 ] bl 0xfff107ac ldr r0 , [ sp , 0x10 ] bl 0xfff11508 mov r0 , 0x1 ldr r3 , [ pc , 0x20 ] ldr r3 , [ fp , r3 ] ldr r2 , [ sp , 0x1c ] ldr r3 , [ r3 ] cmp r2 , r3 bne 0x2d8 add sp , sp , 0x24 pop { r4 , r5 , r6 , r7 , r8 , sb , sl , fp , pc } bl 0xfff11304 eoreq r5 , r7 , ip , asr 0x6 andeq r0 , r0 , ip , lsr 0x27 ldrsbeq fp , [ lr ] , -r0 andseq pc , lr , ip , asr 0x12 andseq pc , lr , ip , lsr r6 andeq r0 , r0 , r8 , asr 0x27 andseq fp , sp , r0 , ror 0x23 eoreq r1 , r4 , r8 , lsr r5
Code2: push r15 mov rdx , rsi push r14 push r13 push r12 push rbp push rbx mov rbx , rdi sub rsp , 0x38 mov rax , qword ptr fs : [ 0x28 ] mov qword ptr [ rsp + 0x28 ] , rax xor eax , eax test rdi , rdi je 0x380 lea rsi , [ rsp + 0x20 ] lea rdi , [ rip + 0x1e3c70 ] call 0xfffffffffff19000 mov rcx , rax mov qword ptr [ rsp + 0x18 ] , rax xor eax , eax test rcx , rcx je 0x357 cmp qword ptr [ rsp + 0x20 ] , 0x0 jle 0x340 mov rbp , rcx xor r14d , r14d xor edi , edi lea r13 , [ rip + 0x1f8ccc ] jmp 0x117 nop dword ptr [ rax ] mov rax , qword ptr [ r15 + 0x28 ] test rax , rax js 0x1b8 pxor xmm0 , xmm0 cvtsi2sd xmm0 , rax lea rsi , [ rip + 0x1e3350 ] mov rdi , rbx mov eax , 0x1 call 0xfffffffffff19c60 mov rax , qword ptr [ rbp ] mov rax , qword ptr [ rax + 0x30 ] test rax , rax js 0x320 pxor xmm0 , xmm0 cvtsi2sd xmm0 , rax lea rsi , [ rip + 0x1e3328 ] mov rdi , rbx mov eax , 0x1 call 0xfffffffffff19c60 mov rax , qword ptr [ rbp ] mov rdx , qword ptr [ rax + 0x20 ] test rdx , rdx je 0xee lea rsi , [ rip + 0x1e0e59 ] mov rdi , rbx xor eax , eax call 0xfffffffffff19c60 lea rsi , [ rip + 0x1f2c81 ] mov rdi , rbx xor eax , eax call 0xfffffffffff19c60 mov rdi , qword ptr [ rsp + 0x8 ] add r14 , 0x1 add rbp , 0x8 cmp qword ptr [ rsp + 0x20 ] , r14 jle 0x340 mov rdx , qword ptr [ rbp ] mov eax , dword ptr [ rdx + 0x4c ] mov r15 , rdx test eax , eax jne 0x104 mov rsi , qword ptr [ rdx + 0x8 ] test rdi , rdi mov qword ptr [ rsp + 0x8 ] , rsi je 0x1e0 mov qword ptr [ rsp + 0x10 ] , rdx call 0xfffffffffff1b050 mov rdx , qword ptr [ rsp + 0x10 ] test eax , eax jne 0x1e0 mov rdx , qword ptr [ r15 + 0x18 ] test rdx , rdx je 0x78 lea rsi , [ rip + 0x1e0ddb ] mov rdi , rbx xor eax , eax call 0xfffffffffff19c60 mov r15 , qword ptr [ rbp ] mov rdi , qword ptr [ r15 + 0x18 ] call 0xfffffffffff19e40 cmp rax , 0x10 mov r12 , rax ja 0x78 nop word ptr cs : [ rax + rax ] xor eax , eax mov rsi , r13 mov rdi , rbx call 0xfffffffffff19c60 add r12 , 0x1 cmp r12 , 0x11 jne 0x190 mov r15 , qword ptr [ rbp ] mov rax , qword ptr [ r15 + 0x28 ] test rax , rax jns 0x85 mov rdx , rax and eax , 0x1 pxor xmm0 , xmm0 shr rdx , 0x1 or rdx , rax cvtsi2sd xmm0 , rdx addsd xmm0 , xmm0 jmp 0x8e nop word ptr cs : [ rax + rax ] mov rax , qword ptr [ rsp + 0x8 ] test rax , rax je 0x202 lea rsi , [ rip + 0x1beabc ] mov rdx , rax mov rdi , rbx xor eax , eax call 0xfffffffffff19c60 mov rdx , qword ptr [ rbp ] lea r12 , [ rip + 0x1e3497 ] xor ecx , ecx mov r15d , 0x1 mov qword ptr [ rsp + 0x10 ] , 0x0 jmp 0x241 nop dword ptr [ rax ] add rcx , 0x1 add r12 , 0x10 cmp rcx , 0x20 je 0x2c0 cmp byte ptr [ r12 ] , 0x0 je 0x2c0 mov rdx , qword ptr [ rbp ] mov rax , r15 shl rax , cl test dword ptr [ rdx + 0x4 ] , eax je 0x220 mov rdx , r12 mov rdi , rbx xor eax , eax mov qword ptr [ rsp + 0x8 ] , rcx lea rsi , [ rip + 0x1e0a43 ] call 0xfffffffffff19c60 mov rcx , qword ptr [ rsp + 0x8 ] mov rdx , r12 mov esi , dword ptr [ rdx ] add rdx , 0x4 lea eax , [ rsi - 0x1010101 ] not esi and eax , esi and eax , 0x80808080 je 0x26d mov esi , eax shr esi , 0x10 test eax , 0x8080 cmove eax , esi lea rsi , [ rdx + 0x2 ] mov edi , eax cmove rdx , rsi add dil , al sbb rdx , 0x3 add rcx , 0x1 sub rdx , r12 add r12 , 0x10 add qword ptr [ rsp + 0x10 ] , rdx cmp rcx , 0x20 jne 0x232 nop dword ptr [ rax ] mov r12 , qword ptr [ rsp + 0x10 ] cmp r12 , 0xc jg 0x2e7 nop dword ptr [ rax + rax ] xor eax , eax mov rsi , r13 mov rdi , rbx call 0xfffffffffff19c60 add r12 , 0x1 cmp r12 , 0xd jne 0x2d0 lea rsi , [ rip + 0x1e37a2 ] mov rdi , rbx xor eax , eax call 0xfffffffffff19c60 lea rsi , [ rip + 0x1becc9 ] mov rdi , rbx xor eax , eax call 0xfffffffffff19c60 mov r15 , qword ptr [ rbp ] mov rax , qword ptr [ r15 + 0x8 ] mov qword ptr [ rsp + 0x8 ] , rax jmp 0x14e nop dword ptr [ rax + rax ] mov rdx , rax and eax , 0x1 pxor xmm0 , xmm0 shr rdx , 0x1 or rdx , rax cvtsi2sd xmm0 , rdx addsd xmm0 , xmm0 jmp 0xbc nop mov rdi , rbx call 0xfffffffffff1c7a0 mov rdi , qword ptr [ rsp + 0x18 ] call 0xfffffffffff1c8c8 mov eax , 0x1 mov rbx , qword ptr [ rsp + 0x28 ] xor rbx , qword ptr fs : [ 0x28 ] jne 0x38f add rsp , 0x38 pop rbx pop rbp pop r12 pop r13 pop r14 pop r15 ret nop word ptr cs : [ rax + rax ] mov rax , qword ptr [ rip + 0x49ce31 ] mov rbx , qword ptr [ rax ] jmp 0x2d call 0xfffffffffff1b3f0 nop nop word ptr cs : [ rax + rax ]
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly codes show fundamental differences in architecture, structure, and functionality:
1. **Different ISAs**: Code1 uses ARM32 instructions (e.g., `ldr`, `str`, `bl`) and registers (r0-r8, fp, lr), while Code2 uses x86-64 instructions (e.g., `mov`, `lea`, `call`) and registers (rax, rdi, rbp).
2. **Stack management**: Code1 adjusts the stack with `sub sp, sp, 0x24`, while Code2 uses `sub rsp, 0x38` with additional security measures (FS segment).
3. **Control flow**: Code1 relies on ARM-specific conditionals (`beq`, `bgt`) and branching patterns, while Code2 uses x86 jumps (`je`, `jle`) with different loop structures.
4. **Function calls**: Code1 calls addresses like `0xfff10440`, while Code2 uses RIP-relative addressing (`call 0xfffffffffff19c60`).
5. **Register usage**: Critical operations (e.g., comparisons, data movement) use entirely different register sets and conventions. No significant overlap in logic or sequence exists.

The codes are compiled for different processors with no discernible functional equivalence. Similarity score reflects complete dissimilarity.
------------------------------------------------------------

------------------------------------------------------------
Code1: push rbp mov rbp , rsp sub rsp , 0x80 mov qword ptr [ rbp - 0x10 ] , rdi mov qword ptr [ rbp - 0x18 ] , rsi mov qword ptr [ rbp - 0x20 ] , rdx mov qword ptr [ rbp - 0x28 ] , rcx mov dword ptr [ rbp - 0x2c ] , r8d mov rcx , qword ptr [ rbp - 0x20 ] test rcx , rcx sete al movzx r8d , al mov ecx , r8d mov rcx , qword ptr [ rcx * 0x8 + 0x9e7f70 ] jmp rcx mov dword ptr [ rbp - 0x4 ] , 0x1 mov rax , qword ptr [ rip + 0x43b2f0 ] jmp rax mov rax , qword ptr [ rbp - 0x20 ] mov ecx , dword ptr [ rax + 0x10 ] test ecx , ecx mov eax , 0x705f0e mov edx , 0x6ae6de cmovne rdx , rax mov qword ptr [ rbp - 0x40 ] , rdx mov rdi , qword ptr [ rbp - 0x10 ] mov esi , dword ptr [ rbp - 0x2c ] mov edx , 0x80 call 0xfffffffffffbb540 test eax , eax setne r8b movzx eax , r8b mov edi , eax mov rdi , qword ptr [ rdi * 0x8 + 0x9e7f80 ] jmp rdi mov dword ptr [ rbp - 0x4 ] , 0x0 mov rax , qword ptr [ rip + 0x43b29e ] jmp rax mov rax , qword ptr [ rbp - 0x20 ] mov ecx , dword ptr [ rax + 0x8 ] test ecx , ecx sete dl movzx ecx , dl mov eax , ecx mov rax , qword ptr [ rax * 0x8 + 0x9e7f90 ] jmp rax mov rdi , qword ptr [ rbp - 0x10 ] mov rdx , qword ptr [ rbp - 0x18 ] mov esi , 0x6ef9b3 xor eax , eax mov cl , al mov al , cl call 0xfffffffffffc2080 test eax , eax setle cl movzx eax , cl mov edx , eax mov rdx , qword ptr [ rdx * 0x8 + 0x9e7fa0 ] jmp rdx mov dword ptr [ rbp - 0x4 ] , 0x0 mov rax , qword ptr [ rip + 0x43b247 ] jmp rax mov dword ptr [ rbp - 0x4 ] , 0x1 mov rax , qword ptr [ rip + 0x43b237 ] jmp rax mov rdi , qword ptr [ rbp - 0x20 ] call 0xfffffffffff7c090 mov ecx , eax add ecx , 0x7 mov edi , eax sar ecx , 0x1f shr ecx , 0x1d mov edx , ecx lea eax , [ rdi + rdx + 0x7 ] sar eax , 0x3 sub eax , 0x9 setl sil movzx ecx , sil mov edx , ecx mov rdx , qword ptr [ rdx * 0x8 + 0x9e7fb0 ] mov dword ptr [ rbp - 0x44 ] , eax jmp rdx mov rdi , qword ptr [ rbp - 0x10 ] mov rdx , qword ptr [ rbp - 0x18 ] mov rax , qword ptr [ rbp - 0x40 ] mov rcx , qword ptr [ rbp - 0x20 ] mov rcx , qword ptr [ rcx ] mov rcx , qword ptr [ rcx ] mov rsi , rsp mov qword ptr [ rsi ] , rcx mov esi , 0x6ef9b9 xor r8d , r8d mov r9b , r8b mov qword ptr [ rbp - 0x50 ] , rcx mov rcx , rax mov r8 , qword ptr [ rbp - 0x50 ] mov byte ptr [ rbp - 0x51 ] , r9b mov r9 , rax mov al , byte ptr [ rbp - 0x51 ] call 0xfffffffffffc2080 test eax , eax setle r10b movzx eax , r10b mov ecx , eax mov rcx , qword ptr [ rcx * 0x8 + 0x9e7fc0 ] jmp rcx mov dword ptr [ rbp - 0x4 ] , 0x0 mov rax , qword ptr [ rip + 0x43b197 ] jmp rax mov rax , qword ptr [ rip + 0x43b186 ] jmp rax mov rax , qword ptr [ rbp - 0x28 ] mov byte ptr [ rax ] , 0x0 mov rdi , qword ptr [ rbp - 0x10 ] mov rdx , qword ptr [ rbp - 0x18 ] mov rax , qword ptr [ rbp - 0x40 ] mov cl , byte ptr [ rax ] sub cl , 0x2d mov eax , 0x6ef6f5 mov esi , 0x6ae6de cmove rsi , rax mov eax , 0x705cb6 xor r8d , r8d mov r9b , r8b mov qword ptr [ rbp - 0x60 ] , rsi mov rsi , rax mov rax , qword ptr [ rbp - 0x60 ] mov byte ptr [ rbp - 0x61 ] , cl mov rcx , rax mov al , r9b call 0xfffffffffffc2080 test eax , eax setle r9b movzx eax , r9b mov ecx , eax mov rcx , qword ptr [ rcx * 0x8 + 0x9e7fd0 ] jmp rcx mov dword ptr [ rbp - 0x4 ] , 0x0 mov rax , qword ptr [ rip + 0x43b11e ] jmp rax mov rdi , qword ptr [ rbp - 0x20 ] mov rax , qword ptr [ rbp - 0x28 ] add rax , 0x1 mov rsi , rax call 0xfffffffffff7d120 mov dword ptr [ rbp - 0x30 ] , eax mov rsi , qword ptr [ rbp - 0x28 ] movzx eax , byte ptr [ rsi + 0x1 ] shr eax , 0x7 mov esi , eax mov rsi , qword ptr [ rsi * 0x8 + 0x9e7fe0 ] jmp rsi mov eax , dword ptr [ rbp - 0x30 ] add eax , 0x1 mov dword ptr [ rbp - 0x30 ] , eax mov rcx , qword ptr [ rip + 0x43b066 ] jmp rcx mov rax , qword ptr [ rbp - 0x28 ] add rax , 0x1 mov qword ptr [ rbp - 0x28 ] , rax mov rax , qword ptr [ rip + 0x43b051 ] jmp rax mov dword ptr [ rbp - 0x34 ] , 0x0 mov rax , qword ptr [ rip + 0x43b049 ] jmp rax mov eax , dword ptr [ rbp - 0x34 ] mov ecx , dword ptr [ rbp - 0x30 ] sub eax , ecx setl dl movzx ecx , dl mov esi , ecx mov rsi , qword ptr [ rsi * 0x8 + 0x9e7ff0 ] mov dword ptr [ rbp - 0x68 ] , eax jmp rsi movsxd rax , dword ptr [ rbp - 0x34 ] mov ecx , eax imul rax , rax , - 0x77777777 shr rax , 0x20 mov edx , eax add edx , ecx mov esi , edx shr esi , 0x1f sar edx , 0x3 add edx , esi mov eax , edx lea edx , [ rax + rax * 0x4 ] mov eax , edx lea edx , [ rax + rax * 0x2 ] sub ecx , edx sete dil movzx edx , dil mov eax , edx mov rax , qword ptr [ rax * 0x8 + 0x9e8000 ] mov dword ptr [ rbp - 0x6c ] , ecx jmp rax mov rdi , qword ptr [ rbp - 0x10 ] mov esi , 0x6b29bb call 0xfffffffffffbb180 test eax , eax setle cl movzx eax , cl mov esi , eax mov rsi , qword ptr [ rsi * 0x8 + 0x9e8010 ] jmp rsi mov rdi , qword ptr [ rbp - 0x10 ] mov eax , dword ptr [ rbp - 0x2c ] add eax , 0x4 mov edx , 0x80 mov esi , eax call 0xfffffffffffbb540 test eax , eax setne cl movzx eax , cl mov edi , eax mov rdi , qword ptr [ rdi * 0x8 + 0x9e8020 ] jmp rdi mov dword ptr [ rbp - 0x4 ] , 0x0 mov rax , qword ptr [ rip + 0x43affe ] jmp rax mov rax , qword ptr [ rip + 0x43afb5 ] jmp rax mov rdi , qword ptr [ rbp - 0x10 ] mov rax , qword ptr [ rbp - 0x28 ] movsxd rcx , dword ptr [ rbp - 0x34 ] mov edx , ecx movzx esi , byte ptr [ rax + rcx ] add edx , 0x1 mov r8d , dword ptr [ rbp - 0x30 ] sub edx , r8d mov eax , 0x6ae6de mov ecx , 0x6e6bc1 cmove rcx , rax mov eax , 0x6e6c56 xor r8d , r8d mov r9b , r8b mov dword ptr [ rbp - 0x70 ] , esi mov rsi , rax mov r8d , dword ptr [ rbp - 0x70 ] mov dword ptr [ rbp - 0x74 ] , edx mov edx , r8d mov al , r9b call 0xfffffffffffc2080 test eax , eax setle r9b movzx eax , r9b mov ecx , eax mov rcx , qword ptr [ rcx * 0x8 + 0x9e8030 ] jmp rcx mov dword ptr [ rbp - 0x4 ] , 0x0 mov rax , qword ptr [ rip + 0x43af82 ] jmp rax mov rax , qword ptr [ rip + 0x43af51 ] jmp rax mov eax , dword ptr [ rbp - 0x34 ] add eax , 0x1 mov dword ptr [ rbp - 0x34 ] , eax mov rcx , qword ptr [ rip + 0x43aef7 ] jmp rcx mov rdi , qword ptr [ rbp - 0x10 ] mov esi , 0x6b29bb mov edx , 0x1 call 0xfffffffffffbaf70 test eax , eax setle cl movzx eax , cl mov esi , eax mov rsi , qword ptr [ rsi * 0x8 + 0x9e8040 ] jmp rsi mov dword ptr [ rbp - 0x4 ] , 0x0 mov rax , qword ptr [ rip + 0x43af30 ] jmp rax mov rax , qword ptr [ rip + 0x43af1f ] jmp rax mov dword ptr [ rbp - 0x4 ] , 0x1 mov rax , qword ptr [ rip + 0x43af17 ] jmp rax mov eax , dword ptr [ rbp - 0x4 ] add rsp , 0x80 pop rbp ret nop
Code2: push ebp push edi mov eax , 0x1 push esi push ebx call 0xffeeabf0 add ebx , 0x1d479e sub esp , 0x1c mov edi , dword ptr [ esp + 0x38 ] mov esi , dword ptr [ esp + 0x30 ] test edi , edi je 0x16a mov ecx , dword ptr [ edi + 0xc ] lea ebp , [ ebx - 0xd5008 ] test ecx , ecx je 0x178 sub esp , 0x4 push 0x80 push dword ptr [ esp + 0x48 ] push esi call 0xfffc97d0 add esp , 0x10 test eax , eax je 0x168 mov edx , dword ptr [ edi + 0x4 ] test edx , edx je 0x188 sub esp , 0xc push edi call 0xfffa3af0 add esp , 0x10 cmp eax , 0x20 jle 0x1b0 mov eax , dword ptr [ esp + 0x3c ] cmp byte ptr [ ebp ] , 0x2d lea edx , [ ebx - 0x1153d5 ] mov byte ptr [ eax ] , 0x0 lea eax , [ ebx - 0xe3c7f ] cmovne eax , edx push eax lea eax , [ ebx - 0xd4e45 ] push dword ptr [ esp + 0x38 ] push eax push esi call 0xfffd0ba0 add esp , 0x10 test eax , eax jle 0x168 mov eax , dword ptr [ esp + 0x3c ] sub esp , 0x8 lea ebp , [ eax + 0x1 ] push ebp push edi call 0xfffa4930 mov dword ptr [ esp + 0x18 ] , eax add esp , 0x10 mov eax , dword ptr [ esp + 0x3c ] cmp byte ptr [ eax + 0x1 ] , 0x0 js 0x1e0 mov eax , dword ptr [ esp + 0x8 ] test eax , eax jle 0x211 lea eax , [ ebx - 0x110949 ] xor edi , edi mov dword ptr [ esp + 0xc ] , eax jmp 0x11e lea esi , [ esi ] add edi , 0x1 cmp edi , dword ptr [ esp + 0x8 ] je 0x1ec lea eax , [ ebx - 0xe6a7a ] push eax movzx eax , byte ptr [ ebp + edi - 0x1 ] push eax lea eax , [ ebx - 0xe6a31 ] push eax push esi call 0xfffd0ba0 add esp , 0x10 test eax , eax jle 0x168 mov eax , 0x88888889 mul edi shr edx , 0x3 mov eax , edx shl eax , 0x4 sub eax , edx cmp edi , eax jne 0xf0 sub esp , 0x8 push dword ptr [ esp + 0x14 ] push esi call 0xfffc9620 add esp , 0x10 test eax , eax jle 0x168 sub esp , 0x4 push 0x80 mov eax , dword ptr [ esp + 0x48 ] add eax , 0x4 push eax push esi call 0xfffc97d0 add esp , 0x10 test eax , eax jne 0xf0 lea esi , [ esi ] xor eax , eax add esp , 0x1c pop ebx pop esi pop edi pop ebp ret lea esi , [ esi ] lea ebp , [ ebx - 0x1153d5 ] jmp 0x38 nop lea esi , [ esi ] lea eax , [ ebx - 0xe39e6 ] sub esp , 0x4 push dword ptr [ esp + 0x38 ] push eax push esi call 0xfffd0ba0 add esp , 0x10 test eax , eax setg al add esp , 0x1c pop ebx movzx eax , al pop esi pop edi pop ebp ret nop mov eax , dword ptr [ edi ] sub esp , 0x4 mov eax , dword ptr [ eax ] push eax push ebp push eax lea eax , [ ebx - 0xe39e0 ] push ebp push dword ptr [ esp + 0x48 ] push eax push esi call 0xfffd0ba0 add esp , 0x20 test eax , eax setg al movzx eax , al jmp 0x16a lea esi , [ esi ] add dword ptr [ esp + 0x8 ] , 0x1 mov ebp , eax jmp 0xd2 lea eax , [ ebx - 0x1153d5 ] push eax movzx eax , byte ptr [ ebp + edi - 0x1 ] push eax lea eax , [ ebx - 0xe6a31 ] push eax push esi call 0xfffd0ba0 add esp , 0x10 test eax , eax jle 0x168 lea eax , [ ebx - 0x110949 ] sub esp , 0x4 push 0x1 push eax push esi call 0xfffc9550 add esp , 0x10 test eax , eax setg al movzx eax , al jmp 0x16a nop nop nop nop nop nop nop
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly codes show significant structural and architectural differences. The first code uses 64-bit registers (rax, rcx, rbp, etc.) and modern x86_64 instructions (qword ptr, rip-relative addressing), while the second employs 32-bit conventions (esp, ebp, dword ptr). Their control flow diverges dramatically: the first relies heavily on indirect jumps via computed pointers (e.g., `jmp rcx`, `jmp rdi`), suggesting complex state transitions, whereas the second uses direct conditional jumps (e.g., `je`, `jle`). Function call patterns also differ, with the first using absolute calls (`call 0xffff...`) and the second using relative calls (`call 0xfff...`). The stack management, register usage, and overall instruction sequences lack meaningful alignment, indicating fundamentally different implementations.
------------------------------------------------------------

------------------------------------------------------------
Code1: push ebp mov ebp , esp sub esp , 0x48 mov eax , dword ptr [ ebp + 0x8 ] mov ecx , dword ptr [ ebp + 0x8 ] mov dword ptr [ ebp - 0x4 ] , ecx mov ecx , dword ptr [ 0x80d5e5c ] mov dword ptr [ ebp - 0x8 ] , eax jmp ecx mov eax , dword ptr [ ebp - 0x4 ] test eax , eax setne cl movzx eax , cl mov eax , dword ptr [ eax * 0x4 + 0x80d621c ] jmp eax mov eax , dword ptr [ ebp - 0x4 ] mov eax , dword ptr [ eax ] test eax , eax setne cl movzx eax , cl mov eax , dword ptr [ eax * 0x4 + 0x80d6224 ] jmp eax mov eax , dword ptr [ 0x80d5e6c ] jmp eax lea eax , [ 0x80cb35c ] mov dword ptr [ esp ] , eax lea eax , [ 0x80cb034 ] mov dword ptr [ esp + 0x4 ] , eax mov dword ptr [ esp + 0x8 ] , 0x560 lea eax , [ 0x80cb371 ] mov dword ptr [ esp + 0xc ] , eax call 0xffffb320 mov eax , dword ptr [ ebp - 0x4 ] mov eax , dword ptr [ eax + 0xac ] test eax , eax setne cl movzx eax , cl mov eax , dword ptr [ eax * 0x4 + 0x80d622c ] jmp eax mov eax , dword ptr [ 0x80d5e78 ] jmp eax lea eax , [ 0x80cb3a2 ] mov dword ptr [ esp ] , eax lea eax , [ 0x80cb034 ] mov dword ptr [ esp + 0x4 ] , eax mov dword ptr [ esp + 0x8 ] , 0x563 lea eax , [ 0x80cb371 ] mov dword ptr [ esp + 0xc ] , eax call 0xffffb320 mov eax , dword ptr [ ebp - 0x4 ] mov eax , dword ptr [ eax + 0xac ] mov eax , dword ptr [ eax + 0xc ] test eax , eax setne cl movzx eax , cl mov eax , dword ptr [ eax * 0x4 + 0x80d6234 ] jmp eax mov eax , dword ptr [ ebp - 0x4 ] mov ecx , dword ptr [ eax ] mov eax , dword ptr [ eax + 0xac ] mov eax , dword ptr [ eax + 0xc ] sub eax , ecx sete dl movzx ecx , dl mov ecx , dword ptr [ ecx * 0x4 + 0x80d623c ] mov dword ptr [ ebp - 0xc ] , eax jmp ecx mov eax , dword ptr [ 0x80d5e88 ] jmp eax lea eax , [ 0x80cb3ba ] mov dword ptr [ esp ] , eax lea eax , [ 0x80cb034 ] mov dword ptr [ esp + 0x4 ] , eax mov dword ptr [ esp + 0x8 ] , 0x56c lea eax , [ 0x80cb371 ] mov dword ptr [ esp + 0xc ] , eax call 0xffffb320 mov eax , dword ptr [ 0x80d5e8c ] jmp eax mov eax , dword ptr [ ebp - 0x4 ] mov eax , dword ptr [ eax + 0xac ] mov eax , dword ptr [ eax ] test eax , eax mov dword ptr [ ebp - 0x10 ] , eax je 0x1a5 jmp 0x152 mov eax , dword ptr [ ebp - 0x10 ] sub eax , 0x1 mov dword ptr [ ebp - 0x14 ] , eax je 0x318 jmp 0x166 mov eax , dword ptr [ ebp - 0x10 ] sub eax , 0x2 mov dword ptr [ ebp - 0x18 ] , eax je 0x1a5 jmp 0x17a mov eax , dword ptr [ ebp - 0x10 ] add eax , - 0x3 sub eax , 0x3 mov dword ptr [ ebp - 0x1c ] , eax jb 0x318 jmp 0x191 mov eax , dword ptr [ ebp - 0x10 ] sub eax , 0x6 mov dword ptr [ ebp - 0x20 ] , eax je 0x24a jmp 0x3a7 mov eax , dword ptr [ ebp - 0x4 ] mov eax , dword ptr [ eax + 0xac ] mov eax , dword ptr [ eax ] test eax , eax setne cl movzx eax , cl mov eax , dword ptr [ eax * 0x4 + 0x80d6244 ] jmp eax mov eax , dword ptr [ 0x80d5e9c ] jmp eax lea eax , [ 0x80cb3e5 ] mov dword ptr [ esp ] , eax lea eax , [ 0x80cb034 ] mov dword ptr [ esp + 0x4 ] , eax mov dword ptr [ esp + 0x8 ] , 0x57c lea eax , [ 0x80cb371 ] mov dword ptr [ esp + 0xc ] , eax call 0xffffb320 mov eax , dword ptr [ ebp - 0x4 ] mov eax , dword ptr [ eax + 0xac ] mov eax , dword ptr [ eax ] sub eax , 0x2 setne cl movzx edx , cl mov edx , dword ptr [ edx * 0x4 + 0x80d624c ] mov dword ptr [ ebp - 0x24 ] , eax jmp edx mov eax , dword ptr [ 0x80d5ea8 ] jmp eax lea eax , [ 0x80cb409 ] mov dword ptr [ esp ] , eax lea eax , [ 0x80cb034 ] mov dword ptr [ esp + 0x4 ] , eax mov dword ptr [ esp + 0x8 ] , 0x57d lea eax , [ 0x80cb371 ] mov dword ptr [ esp + 0xc ] , eax call 0xffffb320 mov eax , dword ptr [ 0x80d5ef0 ] jmp eax mov eax , dword ptr [ ebp - 0x4 ] movzx eax , byte ptr [ eax + 0x10 ] and eax , 0x1 mov eax , dword ptr [ eax * 0x4 + 0x80d6254 ] jmp eax mov eax , dword ptr [ 0x80d5eb8 ] jmp eax lea eax , [ 0x80cb44e ] mov dword ptr [ esp ] , eax lea eax , [ 0x80cb034 ] mov dword ptr [ esp + 0x4 ] , eax mov dword ptr [ esp + 0x8 ] , 0x581 lea eax , [ 0x80cb371 ] mov dword ptr [ esp + 0xc ] , eax call 0xffffb320 mov eax , dword ptr [ ebp - 0x4 ] mov eax , dword ptr [ eax ] sub eax , 0x804d7f0 sete cl movzx edx , cl mov edx , dword ptr [ edx * 0x4 + 0x80d625c ] mov dword ptr [ ebp - 0x28 ] , eax jmp edx mov eax , dword ptr [ ebp - 0x4 ] mov eax , dword ptr [ eax ] sub eax , 0x804d8c0 sete cl movzx edx , cl mov edx , dword ptr [ edx * 0x4 + 0x80d6264 ] mov dword ptr [ ebp - 0x2c ] , eax jmp edx mov eax , dword ptr [ ebp - 0x4 ] movzx eax , byte ptr [ eax + 0x11 ] and eax , 0x1 mov eax , dword ptr [ eax * 0x4 + 0x80d626c ] jmp eax mov eax , dword ptr [ 0x80d5ecc ] jmp eax lea eax , [ 0x80cb439 ] mov dword ptr [ esp ] , eax lea eax , [ 0x80cb034 ] mov dword ptr [ esp + 0x4 ] , eax mov dword ptr [ esp + 0x8 ] , 0x587 lea eax , [ 0x80cb371 ] mov dword ptr [ esp + 0xc ] , eax call 0xffffb320 mov eax , dword ptr [ 0x80d5ed0 ] jmp eax mov eax , dword ptr [ 0x80d5ef0 ] jmp eax mov eax , dword ptr [ ebp - 0x4 ] movzx eax , byte ptr [ eax + 0x11 ] and eax , 0x1 mov eax , dword ptr [ eax * 0x4 + 0x80d6274 ] jmp eax mov eax , dword ptr [ 0x80d5ee0 ] jmp eax lea eax , [ 0x80cb438 ] mov dword ptr [ esp ] , eax lea eax , [ 0x80cb034 ] mov dword ptr [ esp + 0x4 ] , eax mov dword ptr [ esp + 0x8 ] , 0x595 lea eax , [ 0x80cb371 ] mov dword ptr [ esp + 0xc ] , eax call 0xffffb320 mov eax , dword ptr [ ebp - 0x4 ] movzx eax , byte ptr [ eax + 0x10 ] and eax , 0x1 mov eax , dword ptr [ eax * 0x4 + 0x80d627c ] jmp eax mov eax , dword ptr [ 0x80d5eec ] jmp eax lea eax , [ 0x80cb44d ] mov dword ptr [ esp ] , eax lea eax , [ 0x80cb034 ] mov dword ptr [ esp + 0x4 ] , eax mov dword ptr [ esp + 0x8 ] , 0x596 lea eax , [ 0x80cb371 ] mov dword ptr [ esp + 0xc ] , eax call 0xffffb320 mov eax , dword ptr [ 0x80d5ef0 ] jmp eax mov eax , dword ptr [ 0x80d5ef4 ] jmp eax mov eax , dword ptr [ ebp - 0x4 ] mov eax , dword ptr [ eax + 0x98 ] mov dword ptr [ ebp - 0x4 ] , eax mov eax , dword ptr [ 0x80d5e5c ] jmp eax add esp , 0x48 pop ebp ret nop word ptr cs : [ eax + eax ]
Code2: test rdi , rdi je 0x155 sub rsp , 0x8 mov rdx , qword ptr [ rdi ] test rdx , rdx je 0x176 mov rax , qword ptr [ rdi + 0x130 ] test rax , rax je 0x157 mov rcx , qword ptr [ rax + 0x18 ] cmp rcx , rdx je 0x3b test rcx , rcx jne 0xca lea r8 , [ rip - 0x1ad2 ] lea r9 , [ rip - 0x1ba9 ] mov esi , 0x1 nop mov ecx , dword ptr [ rax ] cmp ecx , 0x6 ja 0x90 mov rax , rsi shl rax , cl test al , 0x3a jne 0xf0 test al , 0x5 jne 0x120 test al , 0x40 je 0x90 cmp byte ptr [ rdi + 0x18 ] , 0x0 je 0x1d3 cmp rdx , r8 je 0x90 cmp rdx , r9 je 0x90 cmp byte ptr [ rdi + 0x19 ] , 0x0 je 0x1f2 nop mov rdi , qword ptr [ rdi + 0x108 ] test rdi , rdi je 0x150 mov rdx , qword ptr [ rdi ] test rdx , rdx je 0x176 mov rax , qword ptr [ rdi + 0x130 ] test rax , rax je 0x157 mov rcx , qword ptr [ rax + 0x18 ] test rcx , rcx je 0x50 cmp rdx , rcx je 0x50 lea rcx , [ rip + 0x4081f ] lea rsi , [ rip + 0x4034c ] lea rdi , [ rip + 0x40769 ] mov edx , 0x56c call 0xffffffffffffc580 nop dword ptr [ rax ] cmp byte ptr [ rdi + 0x19 ] , 0x0 jne 0x195 cmp byte ptr [ rdi + 0x18 ] , 0x0 je 0x90 lea rcx , [ rip + 0x407e9 ] lea rsi , [ rip + 0x40316 ] lea rdi , [ rip + 0x4042d ] mov edx , 0x596 call 0xffffffffffffc580 nop test ecx , ecx je 0x1b4 cmp ecx , 0x2 jne 0x90 lea rcx , [ rip + 0x407b8 ] lea rsi , [ rip + 0x402e5 ] lea rdi , [ rip + 0x4075a ] mov edx , 0x57d call 0xffffffffffffc580 add rsp , 0x8 ret repz ret lea rcx , [ rip + 0x40792 ] lea rsi , [ rip + 0x402bf ] lea rdi , [ rip + 0x403a9 ] mov edx , 0x563 call 0xffffffffffffc580 lea rcx , [ rip + 0x40773 ] lea rsi , [ rip + 0x402a0 ] lea rdi , [ rip + 0x40375 ] mov edx , 0x560 call 0xffffffffffffc580 lea rcx , [ rip + 0x40754 ] lea rsi , [ rip + 0x40281 ] lea rdi , [ rip + 0x40383 ] mov edx , 0x595 call 0xffffffffffffc580 lea rcx , [ rip + 0x40735 ] lea rsi , [ rip + 0x40262 ] lea rdi , [ rip + 0x406af ] mov edx , 0x57c call 0xffffffffffffc580 lea rcx , [ rip + 0x40716 ] lea rsi , [ rip + 0x40243 ] lea rdi , [ rip + 0x4035b ] mov edx , 0x581 call 0xffffffffffffc580 lea rcx , [ rip + 0x406f7 ] lea rsi , [ rip + 0x40224 ] lea rdi , [ rip + 0x40327 ] mov edx , 0x587 call 0xffffffffffffc580 nop word ptr cs : [ rax + rax ] nop dword ptr [ rax + rax ]
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly codes show fundamental differences in architecture (32-bit vs 64-bit), register usage, and control flow patterns. The first code uses 32-bit registers (ebp, esp, eax) with stack-based operations and direct memory addressing, while the second uses 64-bit registers (rdi, rsp, rdx) with RIP-relative addressing. The control structures differ significantly: the first relies heavily on conditional jumps via computed pointers, whereas the second uses explicit comparisons and function calls. Memory offsets (e.g., +0xac vs +0x130), constants, and call patterns show no alignment. These architectural and structural disparities indicate they implement different logic with minimal overlap.
------------------------------------------------------------

------------------------------------------------------------
Code1: push r14 push rbx push rax test rdi , rdi je 0x6b mov r14 , rsi mov rbx , rdi lea edi , [ rsi + 0x1 ] mov esi , 0x5c08aa mov edx , 0x4b call 0xfffffffffffbd610 test rax , rax je 0x75 add r14 , 0x1 mov rcx , rax cmp r14 , 0x2 jb 0x5b nop word ptr cs : [ rax + rax ] nop dword ptr [ rax ] movzx edx , byte ptr [ rbx ] test dl , dl je 0x60 mov byte ptr [ rcx ] , dl add r14 , - 0x1 add rcx , 0x1 add rbx , 0x1 cmp r14 , 0x1 ja 0x40 test r14 , r14 je 0x63 mov byte ptr [ rcx ] , 0x0 add rsp , 0x8 pop rbx pop r14 ret xor eax , eax add rsp , 0x8 pop rbx pop r14 ret mov ecx , 0x5c08aa mov edi , 0x7 mov esi , 0x68 mov edx , 0x41 mov r8d , 0x4e call 0xb710 xor eax , eax add rsp , 0x8 pop rbx pop r14 ret nop
Code2: addiu sp , sp , - 0x30 sw ra , 0x2c ( sp ) lui gp , 0x76 addiu gp , gp , 0x1380 sw gp , 0x18 ( sp ) sw a0 , 0x30 ( sp ) sw a1 , 0x34 ( sp ) lw v0 , 0x30 ( sp ) bnez v0 , 0x34 nop move v0 , zero b 0xd0 nop lw v0 , 0x34 ( sp ) addiu v1 , v0 , 0x1 addiu a2 , zero , 0x4b lui v0 , 0x71 addiu a1 , v0 , 0x64d0 move a0 , v1 lw v0 , - 0x7c7c ( gp ) move t9 , v0 jalr t9 nop lw gp , 0x18 ( sp ) sw v0 , 0x24 ( sp ) lw v0 , 0x24 ( sp ) bnez v0 , 0xac nop addiu v0 , zero , 0x4e sw v0 , 0x10 ( sp ) lui v0 , 0x71 addiu a3 , v0 , 0x64d0 addiu a2 , zero , 0x41 addiu a1 , zero , 0x68 addiu a0 , zero , 0x7 lw v0 , - 0x6eb8 ( gp ) move t9 , v0 bal 0x132cc nop lw gp , 0x18 ( sp ) move v0 , zero b 0xd0 nop lw v0 , 0x34 ( sp ) addiu v0 , v0 , 0x1 move a2 , v0 lw a1 , 0x30 ( sp ) lw a0 , 0x24 ( sp ) jal 0x590974 nop lw gp , 0x18 ( sp ) lw v0 , 0x24 ( sp ) lw ra , 0x2c ( sp ) addiu sp , sp , 0x30 jr ra nop
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two code snippets are for different processor architectures (x86-64 vs MIPS). The instruction sets and register usage are entirely different. There is no apparent similarity in the structure or operations, and without evidence of shared high-level logic, the codes are considered not similar.
------------------------------------------------------------

------------------------------------------------------------
Code1: push ebp mov ebp , esp sub esp , 0x18 mov eax , dword ptr [ ebp + 0x8 ] mov ecx , dword ptr [ ebp + 0x8 ] mov dword ptr [ esp ] , ecx mov dword ptr [ ebp - 0x4 ] , eax call 0xfffffd00 xor ecx , ecx mov edx , dword ptr [ ebp + 0x8 ] mov dword ptr [ esp ] , eax mov dword ptr [ esp + 0x4 ] , 0x0 mov dword ptr [ esp + 0x8 ] , edx mov dword ptr [ ebp - 0x8 ] , eax mov dword ptr [ ebp - 0xc ] , ecx call 0xffff4480 mov eax , dword ptr [ ebp - 0x8 ] add esp , 0x18 pop ebp ret nop
Code2: push esi push ebx sub esp , 0x10 call 0xffff8062 add ebx , 0x880c mov esi , dword ptr [ esp + 0x1c ] push esi call 0xfffffdf3 add esp , 0xc push esi push 0x0 push eax call 0xffff7e42 add esp , 0x14 pop ebx pop esi ret
Similarity: -1
Label: 1
Similarity Score: -0.85
Explanation: The two code snippets show significant structural differences:  
1. **Prologue/Epilogue**: Code1 uses `ebp` framing (`push ebp`, `mov
------------------------------------------------------------

------------------------------------------------------------
Code1: push ebp mov ebp , esp sub esp , 0x28 mov eax , dword ptr [ ebp + 0x8 ] mov dword ptr [ ebp - 0x8 ] , eax mov eax , esp add eax , - 0x10 mov esp , eax mov ecx , dword ptr [ ebp - 0x8 ] mov dword ptr [ eax ] , ecx mov edx , dword ptr [ eax ] mov dword ptr [ ebp - 0xc ] , eax mov dword ptr [ ebp - 0x10 ] , edx mov eax , dword ptr [ ebp - 0x10 ] cmp eax , 0xd jae 0x53 mov eax , dword ptr [ ebp - 0xc ] imul ecx , dword ptr [ eax ] , 0xc lea edx , [ 0x80a15b0 ] add edx , ecx add edx , 0x4 mov dword ptr [ ebp - 0x14 ] , edx mov eax , dword ptr [ ebp - 0x14 ] mov ecx , dword ptr [ eax ] mov dword ptr [ ebp - 0x18 ] , ecx mov eax , dword ptr [ ebp - 0x18 ] mov dword ptr [ ebp - 0x4 ] , eax jmp 0x5f mov dword ptr [ ebp - 0x4 ] , 0x0 jmp 0x5f mov eax , dword ptr [ ebp - 0x4 ] mov dword ptr [ ebp - 0x1c ] , eax mov eax , dword ptr [ ebp - 0x1c ] mov esp , ebp pop ebp ret nop dword ptr [ eax ]
Code2: cmp r0 , 0xc ldrls r3 , [ pc , 0x10 ] addls r0 , r0 , r0 , lsl 0x1 addls r0 , r3 , r0 , lsl 0x2 ldrls r0 , [ r0 , 0x4 ] movhi r0 , 0x0 bx lr ldrdeq sl , fp , [ r6 ] , -ip
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The code snippets show fundamental architectural differences: code1 uses x86 assembly (ebp/esp registers, dword ptr) while code2 uses ARM assembly (r0/r3 registers, ldrls/movhi instructions). There are no overlapping instructions, structural patterns, or semantic equivalences. The operations (stack management vs. conditional loads), branching logic, and memory access patterns are entirely dissimilar. The architectural mismatch and absence of common sequences result in no measurable similarity.
------------------------------------------------------------

------------------------------------------------------------
Code1: addiu sp , sp , - 0x30 sw ra , 0x2c ( sp ) sw fp , 0x28 ( sp ) move fp , sp lui gp , 0x42 addiu gp , gp , 0x40d0 sw gp , 0x10 ( sp ) sw a0 , 0x30 ( fp ) sw a1 , 0x34 ( fp ) sw a2 , 0x38 ( fp ) sw a3 , 0x3c ( fp ) lw a2 , 0x3c ( fp ) lw a1 , 0x38 ( fp ) lw a0 , 0x34 ( fp ) lw v0 , - 0x7ecc ( gp ) move t9 , v0 jalr t9 nop lw gp , 0x10 ( fp ) sw v0 , 0x1c ( fp ) lw v1 , 0x1c ( fp ) lw v0 , 0x30 ( fp ) beq v1 , v0 , 0x6c nop lw v0 , 0x1c ( fp ) bgez v0 , 0x78 nop lw v0 , 0x1c ( fp ) b 0xf0 nop lw a1 , 0x30 ( fp ) lw a0 , 0x1c ( fp ) lw v0 , - 0x7e3c ( gp ) move t9 , v0 jalr t9 nop lw gp , 0x10 ( fp ) sw v0 , 0x20 ( fp ) lw v0 , - 0x7ee0 ( gp ) move t9 , v0 jalr t9 nop lw gp , 0x10 ( fp ) lw v0 , ( v0 ) sw v0 , 0x24 ( fp ) lw a0 , 0x1c ( fp ) lw v0 , - 0x7f28 ( gp ) move t9 , v0 jalr t9 nop lw gp , 0x10 ( fp ) lw v0 , - 0x7ee0 ( gp ) move t9 , v0 jalr t9 nop lw gp , 0x10 ( fp ) move v1 , v0 lw v0 , 0x24 ( fp ) sw v0 , ( v1 ) lw v0 , 0x20 ( fp ) move sp , fp lw ra , 0x2c ( sp ) lw fp , 0x28 ( sp ) addiu sp , sp , 0x30 jr ra nop
Code2: push ebp mov ebp , esp push ebx push edi push esi sub esp , 0x5c mov eax , dword ptr [ ebp + 0x14 ] mov ecx , dword ptr [ ebp + 0x10 ] mov edx , dword ptr [ ebp + 0xc ] mov esi , dword ptr [ ebp + 0x8 ] mov dword ptr [ ebp - 0x20 ] , eax mov dword ptr [ ebp - 0x24 ] , ecx mov dword ptr [ ebp - 0x28 ] , edx mov dword ptr [ ebp - 0x2c ] , esi mov eax , esp add eax , - 0x10 mov esp , eax mov ecx , esp add ecx , - 0x10 mov esp , ecx mov edx , esp add edx , - 0x10 mov esp , edx mov esi , esp add esi , - 0x10 mov esp , esi mov edi , dword ptr [ ebp - 0x2c ] mov dword ptr [ ebp - 0x14 ] , edi mov ebx , dword ptr [ ebp - 0x28 ] mov dword ptr [ ebp - 0x18 ] , ebx mov edi , dword ptr [ ebp - 0x24 ] mov dword ptr [ ebp - 0x1c ] , edi mov edi , dword ptr [ ebp - 0x20 ] mov dword ptr [ eax ] , edi mov edi , dword ptr [ ebp - 0x18 ] mov ebx , dword ptr [ ebp - 0x1c ] mov dword ptr [ ebp - 0x30 ] , eax mov dword ptr [ ebp - 0x34 ] , ecx mov dword ptr [ ebp - 0x38 ] , edx mov dword ptr [ ebp - 0x3c ] , esi mov dword ptr [ ebp - 0x40 ] , edi mov dword ptr [ ebp - 0x44 ] , ebx mov eax , dword ptr [ ebp - 0x30 ] mov ecx , dword ptr [ eax ] sub esp , 0x10 mov edx , dword ptr [ ebp - 0x40 ] mov dword ptr [ esp ] , edx mov esi , dword ptr [ ebp - 0x44 ] mov dword ptr [ esp + 0x4 ] , esi mov dword ptr [ esp + 0x8 ] , ecx call 0xffffe900 add esp , 0x10 mov ecx , dword ptr [ ebp - 0x34 ] mov dword ptr [ ecx ] , eax mov eax , dword ptr [ ecx ] cmp eax , dword ptr [ ebp - 0x14 ] je 0xc1 mov eax , dword ptr [ ebp - 0x34 ] mov ecx , dword ptr [ eax ] mov dword ptr [ ebp - 0x48 ] , ecx mov eax , dword ptr [ ebp - 0x48 ] cmp eax , 0x0 setl cl mov byte ptr [ ebp - 0x49 ] , cl mov al , byte ptr [ ebp - 0x49 ] test al , 0x1 jne 0xc1 jmp 0xd4 mov eax , dword ptr [ ebp - 0x34 ] mov ecx , dword ptr [ eax ] mov dword ptr [ ebp - 0x50 ] , ecx mov eax , dword ptr [ ebp - 0x50 ] mov dword ptr [ ebp - 0x10 ] , eax jmp 0x135 mov eax , dword ptr [ ebp - 0x34 ] mov ecx , dword ptr [ eax ] mov edx , dword ptr [ ebp - 0x14 ] sub esp , 0x10 mov dword ptr [ esp ] , ecx mov dword ptr [ esp + 0x4 ] , edx call 0xffffe8e0 add esp , 0x10 mov ecx , dword ptr [ ebp - 0x38 ] mov dword ptr [ ecx ] , eax call 0xffffeb10 mov eax , dword ptr [ eax ] mov ecx , dword ptr [ ebp - 0x3c ] mov dword ptr [ ecx ] , eax mov eax , dword ptr [ ebp - 0x34 ] mov edx , dword ptr [ eax ] mov dword ptr [ ebp - 0x54 ] , edx sub esp , 0x10 mov eax , dword ptr [ ebp - 0x54 ] mov dword ptr [ esp ] , eax call 0xffffebd0 add esp , 0x10 mov ecx , dword ptr [ ebp - 0x3c ] mov edx , dword ptr [ ecx ] mov dword ptr [ ebp - 0x58 ] , eax mov dword ptr [ ebp - 0x5c ] , edx call 0xffffeb10 mov ecx , dword ptr [ ebp - 0x5c ] mov dword ptr [ eax ] , ecx mov eax , dword ptr [ ebp - 0x38 ] mov ecx , dword ptr [ eax ] mov dword ptr [ ebp - 0x10 ] , ecx mov eax , dword ptr [ ebp - 0x10 ] mov dword ptr [ ebp - 0x60 ] , eax mov eax , dword ptr [ ebp - 0x60 ] lea esp , [ ebp - 0xc ] pop esi pop edi pop ebx pop ebp ret nop nop nop nop nop
Similarity: -1
Label: 1
Similarity Score: 0.15
Explanation: The two assembly codes show fundamental differences in architecture (MIPS vs x86) and implementation approach. While both exhibit common low-level patterns like function prologue/epilogue and conditional branching, their instruction
------------------------------------------------------------

------------------------------------------------------------
Code1: push ebp mov ebp , esp push edi push esi push ebx sub esp , 0x2c call 0xffffc4f0 add ebx , 0x50aa2 mov eax , dword ptr [ ebp + 0x10 ] add eax , 0x28 mov dword ptr [ ebp - 0x1c ] , eax mov dword ptr [ ebp - 0x30 ] , 0x0 mov eax , dword ptr [ ebp + 0x10 ] mov eax , dword ptr [ eax ] sub esp , 0xc push eax call 0x4db5 add esp , 0x10 mov byte ptr [ ebp - 0x31 ] , al cmp byte ptr [ ebp - 0x31 ] , 0x0 je 0xdb sub esp , 0xc push dword ptr [ ebp - 0x1c ] call 0xffffff2a add esp , 0x10 xor eax , 0x1 test al , al je 0x91 sub esp , 0x8 push dword ptr [ ebp + 0x8 ] push 0x0 call 0x4de9 add esp , 0x10 mov edi , eax sub esp , 0xc lea eax , [ ebx - 0x12ad4 ] push eax call 0xffffc050 add esp , 0x10 mov esi , eax call 0xffffc180 mov eax , dword ptr [ eax ] push edi push esi push eax push 0x1 call 0xffffbfd0 add esp , 0x10 lea eax , [ ebx + 0x12b0 ] mov eax , dword ptr [ eax + 0xc ] sub esp , 0xc push eax call 0x106fb add esp , 0x10 mov dword ptr [ ebp - 0x30 ] , eax mov eax , dword ptr [ ebp - 0x30 ] mov dword ptr [ ebp - 0x2c ] , eax mov eax , dword ptr [ ebp - 0x2c ] movzx eax , byte ptr [ eax ] cmp al , 0x2f jne 0xc9 mov dword ptr [ ebp - 0x28 ] , 0x0 mov dword ptr [ ebp - 0x24 ] , 0x0 jmp 0x120 lea eax , [ ebx - 0x12a93 ] mov dword ptr [ ebp - 0x28 ] , eax mov dword ptr [ ebp - 0x24 ] , 0x2 jmp 0x120 mov eax , dword ptr [ ebp - 0x1c ] mov edx , dword ptr [ eax + 0x68 ] lea eax , [ ebx + 0x984 ] mov eax , dword ptr [ eax ] cmp edx , eax je 0x10c lea eax , [ ebx - 0x129bc ] push eax push 0x93 lea eax , [ ebx - 0x12af0 ] push eax lea eax , [ ebx - 0x12a90 ] push eax call 0xffffc470 mov eax , dword ptr [ ebp + 0x8 ] mov dword ptr [ ebp - 0x2c ] , eax mov dword ptr [ ebp - 0x28 ] , 0x0 mov dword ptr [ ebp - 0x24 ] , 0x0 mov eax , dword ptr [ ebp - 0x1c ] movzx eax , byte ptr [ eax ] test al , al je 0x17d sub esp , 0xc push dword ptr [ ebp - 0x2c ] call 0xffffc0e0 add esp , 0x10 lea ecx , [ eax + 0x1 ] mov eax , dword ptr [ ebp - 0x1c ] lea edx , [ eax + 0x30 ] mov eax , dword ptr [ ebp - 0x1c ] add eax , 0x4 sub esp , 0x4 push 0x0 push dword ptr [ ebp - 0x24 ] push dword ptr [ ebp - 0x28 ] push ecx push dword ptr [ ebp - 0x2c ] push edx push eax call 0xd6d2 add esp , 0x20 mov eax , dword ptr [ ebp - 0x1c ] mov eax , dword ptr [ eax + 0x4c ] test eax , eax je 0x174 lea eax , [ ebx + 0x12b0 ] mov byte ptr [ eax + 0x20 ] , 0x1 mov byte ptr [ ebp - 0x32 ] , 0x1 jmp 0x258 mov dword ptr [ ebp - 0x20 ] , 0x0 jmp 0x1ef sub esp , 0xc push dword ptr [ ebp - 0x2c ] call 0xffffc0e0 add esp , 0x10 mov edi , eax mov eax , dword ptr [ ebp - 0x1c ] mov eax , dword ptr [ eax + 0x5c ] mov edx , dword ptr [ ebp - 0x20 ] shl edx , 0x2 add eax , edx mov eax , dword ptr [ eax ] sub esp , 0xc push eax call 0xffffc0e0 add esp , 0x10 mov esi , eax mov eax , dword ptr [ ebp - 0x1c ] mov eax , dword ptr [ eax + 0x5c ] mov edx , dword ptr [ ebp - 0x20 ] shl edx , 0x2 add eax , edx mov eax , dword ptr [ eax ] mov edx , dword ptr [ ebp - 0x1c ] lea ecx , [ edx + 0x30 ] mov edx , dword ptr [ ebp - 0x1c ] add edx , 0x4 sub esp , 0xc push 0x0 push edi push dword ptr [ ebp - 0x2c ] push dword ptr [ ebp - 0x24 ] push dword ptr [ ebp - 0x28 ] push esi push eax push ecx push edx call 0xd164 add esp , 0x30 add dword ptr [ ebp - 0x20 ] , 0x1 mov eax , dword ptr [ ebp - 0x1c ] mov eax , dword ptr [ eax + 0x60 ] cmp dword ptr [ ebp - 0x20 ] , eax jl 0x186 mov eax , dword ptr [ ebp - 0x1c ] lea edx , [ eax + 0x30 ] mov eax , dword ptr [ ebp - 0x1c ] add eax , 0x4 sub esp , 0x8 push edx push eax call 0xd4e7 add esp , 0x10 mov eax , dword ptr [ ebp - 0x1c ] mov eax , dword ptr [ eax + 0x6c ] and eax , 0x7f test eax , eax jne 0x23c mov eax , dword ptr [ ebp - 0x1c ] mov eax , dword ptr [ eax + 0x6c ] sar eax , 0x8 movzx eax , al test eax , eax jne 0x236 mov byte ptr [ ebp - 0x32 ] , 0x1 jmp 0x240 mov byte ptr [ ebp - 0x32 ] , 0x0 jmp 0x240 mov byte ptr [ ebp - 0x32 ] , 0x0 cmp byte ptr [ ebp - 0x31 ] , 0x0 je 0x258 mov eax , dword ptr [ ebp - 0x1c ] mov eax , dword ptr [ eax + 0x68 ] sub esp , 0xc push eax call 0x1f9da add esp , 0x10 cmp dword ptr [ ebp - 0x30 ] , 0x0 je 0x291 cmp byte ptr [ ebp - 0x31 ] , 0x0 jne 0x283 lea eax , [ ebx - 0x129bc ] push eax push 0xcf lea eax , [ ebx - 0x12af0 ] push eax lea eax , [ ebx - 0x12a6f ] push eax call 0xffffc470 sub esp , 0xc push dword ptr [ ebp - 0x30 ] call 0xffffbc90 add esp , 0x10 movzx eax , byte ptr [ ebp - 0x32 ] lea esp , [ ebp - 0xc ] pop ebx pop esi pop edi pop ebp ret
Code2: push ebp mov ebp , esp push ebx push edi push esi sub esp , 0x8c mov eax , dword ptr [ ebp + 0x10 ] mov ecx , dword ptr [ ebp + 0xc ] mov edx , dword ptr [ ebp + 0x8 ] mov esi , dword ptr [ ebp + 0x10 ] add esi , 0x28 mov dword ptr [ ebp - 0x10 ] , esi mov dword ptr [ ebp - 0x14 ] , 0x0 mov esi , dword ptr [ ebp + 0x10 ] mov esi , dword ptr [ esi ] mov edi , esp mov dword ptr [ edi ] , esi mov dword ptr [ ebp - 0x2c ] , eax mov dword ptr [ ebp - 0x30 ] , ecx mov dword ptr [ ebp - 0x34 ] , edx call 0x6e10 mov byte ptr [ ebp - 0x1a ] , al movzx ecx , byte ptr [ ebp - 0x1a ] and ecx , 0x1 mov ecx , dword ptr [ ecx * 0x4 + 0x80d6408 ] jmp ecx mov eax , dword ptr [ ebp - 0x10 ] mov ecx , esp mov dword ptr [ ecx ] , eax call 0x3f0 movzx ecx , al mov ecx , dword ptr [ ecx * 0x4 + 0x80d6410 ] jmp ecx call 0xffffabd0 mov eax , dword ptr [ eax ] lea ecx , [ 0x80cb4dc ] mov dword ptr [ esp ] , ecx mov dword ptr [ ebp - 0x38 ] , eax call 0xffffaab0 xor ecx , ecx mov edx , dword ptr [ ebp + 0x8 ] mov dword ptr [ esp ] , 0x0 mov dword ptr [ esp + 0x4 ] , edx mov dword ptr [ ebp - 0x3c ] , eax mov dword ptr [ ebp - 0x40 ] , ecx call 0x6e70 mov dword ptr [ esp ] , 0x1 mov ecx , dword ptr [ ebp - 0x38 ] mov dword ptr [ esp + 0x4 ] , ecx mov ecx , dword ptr [ ebp - 0x3c ] mov dword ptr [ esp + 0x8 ] , ecx mov dword ptr [ esp + 0xc ] , eax call 0xffffaa10 mov eax , dword ptr [ 0x80f80b0 ] mov ecx , esp mov dword ptr [ ecx ] , eax call 0x16e30 mov dword ptr [ ebp - 0x14 ] , eax mov dword ptr [ ebp - 0x18 ] , eax mov eax , dword ptr [ ebp - 0x18 ] mov dl , byte ptr [ eax ] sub dl , 0x2f sete dh movzx eax , dh mov eax , dword ptr [ eax * 0x4 + 0x80d6418 ] mov byte ptr [ ebp - 0x41 ] , dl jmp eax mov dword ptr [ ebp - 0x20 ] , 0x0 mov dword ptr [ ebp - 0x24 ] , 0x0 mov eax , dword ptr [ 0x80d62b4 ] jmp eax mov dword ptr [ ebp - 0x20 ] , 0x80cb51d mov dword ptr [ ebp - 0x24 ] , 0x2 mov eax , dword ptr [ 0x80d62b4 ] jmp eax mov eax , dword ptr [ 0x80d62c8 ] jmp eax mov eax , dword ptr [ ebp - 0x10 ] mov eax , dword ptr [ eax + 0x68 ] mov ecx , dword ptr [ 0x80f7778 ] sub eax , ecx sete dl movzx ecx , dl mov ecx , dword ptr [ ecx * 0x4 + 0x80d6420 ] mov dword ptr [ ebp - 0x48 ] , eax jmp ecx mov eax , dword ptr [ 0x80d62c4 ] jmp eax lea eax , [ 0x80cb520 ] mov dword ptr [ esp ] , eax lea eax , [ 0x80d2e9a ] mov dword ptr [ esp + 0x4 ] , eax mov dword ptr [ esp + 0x8 ] , 0x93 lea eax , [ 0x80cb541 ] mov dword ptr [ esp + 0xc ] , eax call 0xffffaee0 mov eax , dword ptr [ ebp + 0x8 ] mov dword ptr [ ebp - 0x18 ] , eax mov dword ptr [ ebp - 0x20 ] , 0x0 mov dword ptr [ ebp - 0x24 ] , 0x0 mov eax , dword ptr [ 0x80d62c8 ] jmp eax mov eax , dword ptr [ ebp - 0x10 ] movzx eax , byte ptr [ eax ] and eax , 0x1 mov eax , dword ptr [ eax * 0x4 + 0x80d6428 ] jmp eax mov eax , dword ptr [ ebp - 0x10 ] mov ecx , eax add ecx , 0x4 add eax , 0x30 mov edx , dword ptr [ ebp - 0x18 ] mov esi , esp mov dword ptr [ esi ] , edx mov dword ptr [ ebp - 0x4c ] , ecx mov dword ptr [ ebp - 0x50 ] , eax mov dword ptr [ ebp - 0x54 ] , edx call 0xffffab40 inc eax mov ecx , dword ptr [ ebp - 0x20 ] mov edx , dword ptr [ ebp - 0x24 ] mov esi , esp mov dword ptr [ esi + 0x14 ] , edx mov dword ptr [ esi + 0x10 ] , ecx mov dword ptr [ esi + 0xc ] , eax mov eax , dword ptr [ ebp - 0x54 ] mov dword ptr [ esi + 0x8 ] , eax mov ecx , dword ptr [ ebp - 0x50 ] mov dword ptr [ esi + 0x4 ] , ecx mov ecx , dword ptr [ ebp - 0x4c ] mov dword ptr [ esi ] , ecx mov dword ptr [ esi + 0x18 ] , 0x0 call 0x12010 mov eax , dword ptr [ ebp - 0x10 ] mov eax , dword ptr [ eax + 0x4c ] test eax , eax setne bl movzx eax , bl mov eax , dword ptr [ eax * 0x4 + 0x80d6430 ] jmp eax mov byte ptr [ 0x80f80c4 ] , 0x1 mov eax , dword ptr [ 0x80d62d4 ] jmp eax mov byte ptr [ ebp - 0x19 ] , 0x1 mov eax , dword ptr [ 0x80d630c ] jmp eax mov dword ptr [ ebp - 0x28 ] , 0x0 mov eax , dword ptr [ 0x80d62dc ] jmp eax mov eax , dword ptr [ ebp - 0x28 ] mov ecx , dword ptr [ ebp - 0x10 ] mov ecx , dword ptr [ ecx + 0x60 ] sub eax , ecx setl dl movzx ecx , dl mov ecx , dword ptr [ ecx * 0x4 + 0x80d6438 ] mov dword ptr [ ebp - 0x58 ] , eax jmp ecx mov eax , dword ptr [ ebp - 0x10 ] mov ecx , eax add ecx , 0x4 mov edx , eax add edx , 0x30 mov eax , dword ptr [ eax + 0x5c ] mov esi , dword ptr [ ebp - 0x28 ] mov eax , dword ptr [ eax + esi * 0x4 ] mov esi , esp mov dword ptr [ esi ] , eax mov dword ptr [ ebp - 0x5c ] , ecx mov dword ptr [ ebp - 0x60 ] , edx mov dword ptr [ ebp - 0x64 ] , eax call 0xffffab40 mov ecx , dword ptr [ ebp - 0x20 ] mov edx , dword ptr [ ebp - 0x24 ] mov esi , dword ptr [ ebp - 0x18 ] mov edi , esp mov dword ptr [ edi ] , esi mov dword ptr [ ebp - 0x68 ] , eax mov dword ptr [ ebp - 0x6c ] , ecx mov dword ptr [ ebp - 0x70 ] , edx mov dword ptr [ ebp - 0x74 ] , esi call 0xffffab40 mov ecx , esp mov dword ptr [ ecx + 0x1c ] , eax mov eax , dword ptr [ ebp - 0x74 ] mov dword ptr [ ecx + 0x18 ] , eax mov edx , dword ptr [ ebp - 0x70 ] mov dword ptr [ ecx + 0x14 ] , edx mov edx , dword ptr [ ebp - 0x6c ] mov dword ptr [ ecx + 0x10 ] , edx mov edx , dword ptr [ ebp - 0x68 ] mov dword ptr [ ecx + 0xc ] , edx mov esi , dword ptr [ ebp - 0x64 ] mov dword ptr [ ecx + 0x8 ] , esi mov edi , dword ptr [ ebp - 0x60 ] mov dword ptr [ ecx + 0x4 ] , edi mov edi , dword ptr [ ebp - 0x5c ] mov dword ptr [ ecx ] , edi mov dword ptr [ ecx + 0x20 ] , 0x0 call 0x11d40 mov eax , dword ptr [ 0x80d62e4 ] jmp eax mov eax , dword ptr [ ebp - 0x28 ] inc eax mov dword ptr [ ebp - 0x28 ] , eax mov eax , dword ptr [ 0x80d62dc ] jmp eax mov eax , dword ptr [ ebp - 0x10 ] mov ecx , eax add ecx , 0x4 add eax , 0x30 mov edx , esp mov dword ptr [ edx + 0x4 ] , eax mov dword ptr [ edx ] , ecx call 0x12420 mov eax , dword ptr [ ebp - 0x10 ] mov bl , byte ptr [ eax + 0x6c ] test bl , 0x7f sete bl movzx eax , bl mov eax , dword ptr [ eax * 0x4 + 0x80d6440 ] jmp eax mov eax , dword ptr [ ebp - 0x10 ] mov cl , byte ptr [ eax + 0x6d ] test cl , cl sete cl movzx eax , cl mov eax , dword ptr [ eax * 0x4 + 0x80d6448 ] jmp eax mov byte ptr [ ebp - 0x19 ] , 0x1 mov eax , dword ptr [ 0x80d62f8 ] jmp eax mov byte ptr [ ebp - 0x19 ] , 0x0 mov eax , dword ptr [ 0x80d62f8 ] jmp eax mov eax , dword ptr [ 0x80d6300 ] jmp eax mov byte ptr [ ebp - 0x19 ] , 0x0 mov eax , dword ptr [ 0x80d6300 ] jmp eax movzx eax , byte ptr [ ebp - 0x1a ] and eax , 0x1 mov eax , dword ptr [ eax * 0x4 + 0x80d6450 ] jmp eax mov eax , dword ptr [ ebp - 0x10 ] mov eax , dword ptr [ eax + 0x68 ] mov ecx , esp mov dword ptr [ ecx ] , eax call 0x4feb0 mov eax , dword ptr [ 0x80d6308 ] jmp eax mov eax , dword ptr [ 0x80d630c ] jmp eax mov eax , dword ptr [ ebp - 0x14 ] test eax , eax setne cl movzx eax , cl mov eax , dword ptr [ eax * 0x4 + 0x80d6458 ] jmp eax movzx eax , byte ptr [ ebp - 0x1a ] and eax , 0x1 mov eax , dword ptr [ eax * 0x4 + 0x80d6460 ] jmp eax mov eax , dword ptr [ 0x80d631c ] jmp eax lea eax , [ 0x80cb587 ] mov dword ptr [ esp ] , eax lea eax , [ 0x80d2e9a ] mov dword ptr [ esp + 0x4 ] , eax mov dword ptr [ esp + 0x8 ] , 0xcf lea eax , [ 0x80cb541 ] mov dword ptr [ esp + 0xc ] , eax call 0xffffaee0 mov eax , dword ptr [ ebp - 0x14 ] mov ecx , esp mov dword ptr [ ecx ] , eax call 0xffffa6e0 mov eax , dword ptr [ 0x80d6320 ] jmp eax mov al , byte ptr [ ebp - 0x19 ] and al , 0x1 movzx eax , al add esp , 0x8c pop esi pop edi pop ebx pop ebp ret nop word ptr [ eax + eax ]
Similarity: -1
Label: 1
Similarity Score: 0.25
Explanation: The codes share some structural similarities in function setup (push ebp/mov ebp,esp) and register preservation (push edi/esi/ebx), but differ significantly in core functionality. Code1 uses direct memory operations and conditional jumps (je/jne), while Code2 implements complex jump tables (jmp ecx) and indirect addressing. The stack management differs (0x2c vs 0x8c allocation), and critical operations like handling return values (al vs eax) and local variables show minimal overlap. The control flow patterns and called functions (0xd6d2 vs 0x12010) are fundamentally distinct, indicating different underlying logic despite superficial structural parallels.
------------------------------------------------------------

------------------------------------------------------------
Code1: push ebp push edi push esi push ebx sub esp , 0x38 call 0xfff86902 add ebx , 0x1eaed2 mov esi , dword ptr [ esp + 0x4c ] mov eax , dword ptr gs : [ 0x14 ] mov dword ptr [ esp + 0x28 ] , eax xor eax , eax mov dword ptr [ esp + 0x24 ] , 0x0 lea eax , [ ebx - 0x1eb91a ] push eax call 0x4b1e8 mov ebp , eax call 0x4594c mov dword ptr [ esp ] , eax call 0x43c77 mov dword ptr [ esp + 0x18 ] , eax add esp , 0x10 test ebp , ebp je 0x7c test eax , eax je 0x7c push esi push 0x3 push 0x6c push dword ptr [ esp + 0x14 ] call 0x441ae add esp , 0x10 test eax , eax je 0x1c0 mov edi , 0x0 lea eax , [ esp + 0x18 ] mov dword ptr [ esp + 0xc ] , eax jmp 0xed sub esp , 0xc push 0x279 lea eax , [ ebx - 0xe67c0 ] push eax push 0x41 push 0xb9 push 0x14 call 0x4da70 add esp , 0x20 mov edi , 0x0 jmp 0x168 call 0x4b28e mov edi , eax test eax , eax jne 0x109 sub esp , 0xc push 0x286 lea eax , [ ebx - 0xe67c0 ] push eax push 0x41 push 0xb9 push 0x14 call 0x4da70 add esp , 0x20 jmp 0x168 sub esp , 0x8 push esi push ebp call 0x4b3e7 add esp , 0x8 push esi push edi call 0x4b3e7 add esp , 0x10 push 0x0 push 0x0 push dword ptr [ esp + 0x14 ] push dword ptr [ esp + 0x14 ] call 0x72f72 add esp , 0x10 test eax , eax je 0x168 test edi , edi je 0xa6 sub esp , 0xc push dword ptr [ esp + 0x24 ] call 0x75faa add esp , 0x10 test eax , eax je 0x14d sub esp , 0xc push eax call 0x61cfe mov esi , eax add esp , 0x10 test eax , eax je 0x14d sub esp , 0x8 push eax push ebp call 0x4b701 add esp , 0x10 test eax , eax js 0xd6 sub esp , 0xc push esi call 0x61ad0 add esp , 0x10 jmp 0xed test edi , edi je 0x168 sub esp , 0x8 push dword ptr [ ebx + 0x47c ] push edi call 0x4b56c add esp , 0x10 mov edi , 0x0 test ebp , ebp je 0x178 sub esp , 0xc push ebp call 0x4b49f add esp , 0x10 mov eax , dword ptr [ esp + 0x8 ] test eax , eax je 0x18c sub esp , 0xc push eax call 0x43ceb add esp , 0x10 mov eax , dword ptr [ esp + 0x18 ] test eax , eax je 0x1a0 sub esp , 0xc push eax call 0x61fac add esp , 0x10 test edi , edi je 0x1a9 call 0x4db51 mov eax , edi mov edx , dword ptr [ esp + 0x1c ] xor edx , dword ptr gs : [ 0x14 ] jne 0x1c7 add esp , 0x2c pop ebx pop esi pop edi pop ebp ret mov edi , 0x0 jmp 0x168 call 0xeea82
Code2: lui gp , 0x6c addiu sp , sp , - 0x48 addiu gp , gp , 0x3de0 sw s4 , 0x3c ( sp ) sw s0 , 0x2c ( sp ) move s0 , a0 lw s4 , - 0x52f8 ( gp ) lui a0 , 0x4b lw t9 , - 0x6d6c ( gp ) addiu a0 , a0 , - 0xf50 sw ra , 0x44 ( sp ) sw s3 , 0x38 ( sp ) sw s2 , 0x34 ( sp ) sw gp , 0x18 ( sp ) sw s5 , 0x40 ( sp ) sw s1 , 0x30 ( sp ) sw zero , 0x20 ( sp ) lw v0 , ( s4 ) sw v0 , 0x24 ( sp ) jalr t9 nop lw gp , 0x18 ( sp ) lw t9 , - 0x7f44 ( gp ) jalr t9 move s3 , v0 lw gp , 0x18 ( sp ) lw t9 , - 0x7f40 ( gp ) jalr t9 move a0 , v0 lw gp , 0x18 ( sp ) beqz s3 , 0x264 move s2 , v0 beqz v0 , 0x234 lw t9 , - 0x7fc8 ( gp ) addiu a2 , zero , 0x3 addiu a1 , zero , 0x6c move a3 , s0 jalr t9 move a0 , v0 move s1 , zero beqz v0 , 0x194 lw gp , 0x18 ( sp ) addiu s5 , sp , 0x20 lw t9 , - 0x7e14 ( gp ) move a3 , zero move a2 , zero move a1 , s5 jalr t9 move a0 , s2 beqz v0 , 0x194 lw gp , 0x18 ( sp ) beqz s1 , 0x158 lw t9 , - 0x7e60 ( gp ) lw t9 , - 0x7eb0 ( gp ) jalr t9 lw a0 , 0x20 ( sp ) beqz v0 , 0x218 lw gp , 0x18 ( sp ) lw t9 , - 0x7ca4 ( gp ) jalr t9 move a0 , v0 lw gp , 0x18 ( sp ) beqz v0 , 0x218 move s0 , v0 lw t9 , - 0x6d94 ( gp ) move a1 , v0 jalr t9 move a0 , s3 bltz v0 , 0x12c lw gp , 0x18 ( sp ) lw t9 , - 0x7de8 ( gp ) jalr t9 move a0 , s0 b 0xac lw gp , 0x18 ( sp ) lw t9 , - 0x7e5c ( gp ) move a1 , s0 jalr t9 move a0 , s3 move a1 , s0 lw gp , 0x18 ( sp ) lw t9 , - 0x7e5c ( gp ) jalr t9 move a0 , s1 b 0xac lw gp , 0x18 ( sp ) jalr t9 nop lw gp , 0x18 ( sp ) bnez v0 , 0xd4 move s1 , v0 lui a3 , 0x66 lw t9 , - 0x7a34 ( gp ) addiu v0 , zero , 0x286 addiu a3 , a3 , - 0x4360 addiu a2 , zero , 0x41 sw v0 , 0x10 ( sp ) addiu a1 , zero , 0xb9 jalr t9 addiu a0 , zero , 0x14 lw gp , 0x18 ( sp ) lw t9 , - 0x7f60 ( gp ) jalr t9 move a0 , s3 lw gp , 0x18 ( sp ) beqz s2 , 0x1b8 lw t9 , - 0x7f70 ( gp ) jalr t9 move a0 , s2 lw gp , 0x18 ( sp ) lw a0 , 0x20 ( sp ) beqz a0 , 0x1d0 lw t9 , - 0x7f50 ( gp ) jalr t9 nop lw gp , 0x18 ( sp ) beqz s1 , 0x1e4 lw t9 , - 0x7f00 ( gp ) jalr t9 nop lw gp , 0x18 ( sp ) lw a0 , 0x24 ( sp ) move v0 , s1 lw v1 , ( s4 ) bne a0 , v1 , 0x294 lw ra , 0x44 ( sp ) lw s5 , 0x40 ( sp ) lw s4 , 0x3c ( sp ) lw s3 , 0x38 ( sp ) lw s2 , 0x34 ( sp ) lw s1 , 0x30 ( sp ) lw s0 , 0x2c ( sp ) jr ra addiu sp , sp , 0x48 lw t9 , - 0x7d88 ( gp ) move a0 , s1 lw a1 , - 0x7de8 ( gp ) jalr t9 move s1 , zero b 0x194 lw gp , 0x18 ( sp ) lui a3 , 0x66 lw t9 , - 0x7a34 ( gp ) addiu v0 , zero , 0x279 addiu a3 , a3 , - 0x4360 addiu a2 , zero , 0x41 sw v0 , 0x10 ( sp ) addiu a1 , zero , 0xb9 addiu a0 , zero , 0x14 jalr t9 move s1 , zero b 0x194 lw gp , 0x18 ( sp ) lui a3 , 0x66 lw t9 , - 0x7a34 ( gp ) addiu v0 , zero , 0x279 addiu a3 , a3 , - 0x4360 addiu a2 , zero , 0x41 sw v0 , 0x10 ( sp ) addiu a1 , zero , 0xb9 addiu a0 , zero , 0x14 jalr t9 move s1 , zero b 0x1a4 lw gp , 0x18 ( sp ) lw t9 , - 0x5330 ( gp ) jalr t9 nop
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly codes are fundamentally dissimilar due to different architectures (x86 vs MIPS), distinct register sets (ebp/edi vs gp/t9/v0), and completely different instruction sets. The control flow patterns, function call conventions, and stack management operations show no meaningful alignment. The absence of overlapping opcodes or structural similarities confirms these are unrelated codebases.
------------------------------------------------------------

------------------------------------------------------------
Code1: push ebp mov ebp , esp sub esp , 0x18 mov eax , dword ptr [ ebp + 0x8 ] xor ecx , ecx mov edx , dword ptr [ ebp + 0x8 ] mov dword ptr [ esp ] , edx mov dword ptr [ esp + 0x4 ] , 0x0 mov dword ptr [ ebp - 0x4 ] , eax mov dword ptr [ ebp - 0x8 ] , ecx call 0xffffff90 add esp , 0x18 pop ebp ret nop dword ptr [ eax ]
Code2: sub rsp , 0x8 mov esi , 0x0 call 0xffffffffffffffc7 add rsp , 0x8 ret
Similarity: -1
Label: 1
Similarity Score: 0.2
Explanation: The codes are from different architectures (32-bit vs 64-bit) and have different stack management. Code1 sets up a full stack frame and passes arguments on the stack, while Code2 uses a simpler stack adjustment and sets one register. The common elements (stack adjustment, zeroing a register, call, and return) are insufficient to consider them similar.
------------------------------------------------------------

------------------------------------------------------------
Code1: push r15 push r14 push rbx sub rsp , 0x20 xor r15d , r15d test rdi , rdi je 0xa5 call 0xfffffffffff5dec0 test rax , rax je 0xa5 mov rbx , rax call 0xfffffffffff4d000 test rax , rax je 0xa5 mov r14 , rax xor r15d , r15d mov rdi , rbx mov rsi , rax xor edx , edx call 0xfffffffffff580b0 test eax , eax je 0x9d mov rdi , r14 call 0xfffffffffff4ce70 lea ecx , [ rax + 0x7 ] sar ecx , 0x1f shr ecx , 0x1d lea eax , [ rax + rcx ] add eax , 0x7 sar eax , 0x3 mov dword ptr [ rsp + 0x8 ] , eax lea rax , [ rsp + 0x4 ] mov qword ptr [ rsp + 0x10 ] , rax mov dword ptr [ rsp + 0xc ] , 0x2 mov byte ptr [ rsp + 0x4 ] , 0xff lea rdi , [ rsp + 0x8 ] xor esi , esi call 0xfffffffffff95170 lea esi , [ rax + rax ] mov edi , 0x1 mov edx , 0x10 call 0xfffffffffff98db0 mov r15d , eax mov rdi , r14 call 0xfffffffffff4cf50 mov eax , r15d add rsp , 0x20 pop rbx pop r14 pop r15 ret nop word ptr cs : [ rax + rax ] nop dword ptr [ rax ]
Code2: lui gp , 0x6c addiu sp , sp , - 0x48 addiu gp , gp , 0x2ee0 sw s0 , 0x38 ( sp ) lw s0 , - 0x52f0 ( gp ) sw ra , 0x44 ( sp ) sw s2 , 0x40 ( sp ) sw s1 , 0x3c ( sp ) sw gp , 0x10 ( sp ) lw v0 , ( s0 ) sw v0 , 0x34 ( sp ) beqz a0 , 0x104 lw t9 , - 0x7760 ( gp ) jalr t9 nop lw gp , 0x10 ( sp ) beqz v0 , 0x104 move s1 , v0 lw t9 , - 0x7c30 ( gp ) jalr t9 nop lw gp , 0x10 ( sp ) beqz v0 , 0x104 move s2 , v0 lw t9 , - 0x7bec ( gp ) move a2 , zero move a1 , v0 jalr t9 move a0 , s1 lw gp , 0x10 ( sp ) beqz v0 , 0x12c sw v0 , 0x1c ( sp ) lw t9 , - 0x7be4 ( gp ) jalr t9 move a0 , s2 addiu v1 , v0 , 0x7 bgez v1 , 0x9c lw gp , 0x10 ( sp ) addiu v1 , v0 , 0xe addiu v0 , zero , 0x2 lw t9 , - 0x69ec ( gp ) sra v1 , v1 , 0x3 sw v0 , 0x24 ( sp ) addiu v0 , zero , - 0x1 move a1 , zero sw v1 , 0x20 ( sp ) sb v0 , 0x30 ( sp ) addiu v0 , sp , 0x30 addiu a0 , sp , 0x20 jalr t9 sw v0 , 0x28 ( sp ) addiu a2 , zero , 0x10 lw gp , 0x10 ( sp ) sll a1 , v0 , 0x1 lw t9 , - 0x69e4 ( gp ) jalr t9 addiu a0 , zero , 0x1 move a0 , s2 lw gp , 0x10 ( sp ) lw t9 , - 0x6db0 ( gp ) jalr t9 sw v0 , 0x1c ( sp ) lw gp , 0x10 ( sp ) b 0x108 lw v0 , 0x1c ( sp ) move v0 , zero lw a0 , 0x34 ( sp ) lw v1 , ( s0 ) bne a0 , v1 , 0x144 lw ra , 0x44 ( sp ) lw s2 , 0x40 ( sp ) lw s1 , 0x3c ( sp ) lw s0 , 0x38 ( sp ) jr ra addiu sp , sp , 0x48 lw t9 , - 0x6db0 ( gp ) jalr t9 move a0 , s2 lw gp , 0x10 ( sp ) b 0x108 lw v0 , 0x1c ( sp ) lw t9 , - 0x5328 ( gp ) jalr t9 nop
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly codes are fundamentally dissimilar because they target different processor architectures. The first code uses x86_64 instructions (e.g., `push`, `sub rsp`, registers like `rdi/rax`), while the second uses MIPS instructions (e.g., `lui`, `addiu`, registers like `gp/sp`). The register usage, instruction syntax, calling conventions, and stack management conventions are entirely incompatible. No structural or functional similarities exist beyond generic low-level operations like function calls or stack adjustments, which are implemented in architecture-specific ways. The architectural mismatch alone guarantees no meaningful similarity.
------------------------------------------------------------

------------------------------------------------------------
Code1: addiu sp , sp , - 0x28 sw ra , 0x24 ( sp ) lui a3 , 0x1 addiu a3 , a3 , 0x5180 lw a0 , 0x50 ( a1 ) lw a1 , 0x54 ( a1 ) jal 0x4052dc nop lw ra , 0x24 ( sp ) jr ra addiu sp , sp , 0x28
Code2: push ebp mov ebp , esp push edi push esi sub esp , 0x30 mov eax , dword ptr [ ebp + 0x10 ] mov ecx , dword ptr [ ebp + 0xc ] mov edx , dword ptr [ ebp + 0x8 ] mov esi , dword ptr [ ebp + 0xc ] lea edi , [ ebp - 0x10 ] mov dword ptr [ esp ] , edi mov dword ptr [ esp + 0x4 ] , esi mov dword ptr [ ebp - 0x14 ] , eax mov dword ptr [ ebp - 0x18 ] , ecx mov dword ptr [ ebp - 0x1c ] , edx call 0x22780 sub esp , 0x4 mov eax , dword ptr [ ebp + 0x10 ] mov ecx , dword ptr [ ebp - 0x10 ] mov edx , dword ptr [ ebp - 0xc ] mov dword ptr [ esp ] , ecx mov dword ptr [ esp + 0x4 ] , edx mov dword ptr [ esp + 0x8 ] , eax mov dword ptr [ esp + 0xc ] , 0x15180 call 0xfffffa90 and al , 0x1 movzx eax , al add esp , 0x30 pop esi pop edi pop ebp ret nop dword ptr [ eax ]
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two code snippets are from different architectures (MIPS vs x86) and perform entirely different operations with no structural similarity beyond generic function prologue/epilogue elements. The register usage, instruction sets, and calling conventions are completely distinct, indicating no meaningful similarity.
------------------------------------------------------------

------------------------------------------------------------
Code1: push { r4 , r5 , r6 , r7 , r8 , sb , sl , lr } subs r4 , r0 , 0x0 beq 0x310 cmp r1 , 0x0 mov r6 , r1 beq 0x300 cmp r2 , 0x0 mov r7 , r2 beq 0x2f0 ldr r0 , [ r4 ] bl 0x28 subs r5 , r0 , 0x0 bne 0x5c ldr r2 , [ r4 , 0x4 ] cmp r2 , 0x80 bhi 0x58 ldr r3 , [ r4 , 0x8 ] cmp r3 , 0x80 cmple r2 , r3 movgt ip , 0x1 movle ip , 0x0 ble 0x64 mov r5 , 0x10 mov r0 , r5 pop { r4 , r5 , r6 , r7 , r8 , sb , sl , pc } cmp r2 , r3 addeq r1 , r4 , 0xc beq 0x140 mvn r0 , 0x7f add r5 , r2 , 0x1 add r1 , r4 , r2 cmp r3 , r5 str r5 , [ r4 , 0x4 ] strb r0 , [ r1 , 0xc ] addle r1 , r4 , 0xc ble 0x13c add r8 , r2 , 0xd add r1 , r4 , 0xc add r0 , r4 , r8 add sb , r1 , r3 sub lr , sb , r0 ands r8 , lr , 0x7 beq 0xfc cmp r8 , 0x1 beq 0xf0 cmp r8 , 0x2 beq 0xec cmp r8 , 0x3 beq 0xe8 cmp r8 , 0x4 beq 0xe4 cmp r8 , 0x5 beq 0xe0 cmp r8 , 0x6 strbne ip , [ r0 ] , 0x1 strb ip , [ r0 ] , 0x1 strb ip , [ r0 ] , 0x1 strb ip , [ r0 ] , 0x1 strb ip , [ r0 ] , 0x1 strb ip , [ r0 ] , 0x1 strb ip , [ r0 ] , 0x1 cmp r0 , sb beq 0x12c mov lr , r0 strb ip , [ lr ] , 0x1 add r0 , r0 , 0x8 strb ip , [ r0 , - 0x7 ] strb ip , [ lr , 0x1 ] strb ip , [ r0 , - 0x5 ] strb ip , [ r0 , - 0x4 ] strb ip , [ r0 , - 0x3 ] strb ip , [ r0 , - 0x2 ] strb ip , [ r0 , - 0x1 ] cmp r0 , sb bne 0xfc sub ip , r3 , 0x1 add r5 , ip , r5 sub r2 , r5 , r2 str r2 , [ r4 , 0x4 ] mov r5 , 0x1 cmp r3 , 0x0 beq 0x21c add sb , r4 , r5 , lsl 0x7 add r2 , r4 , 0xb ands r8 , r3 , 0x3 add r5 , sb , 0x10c add r3 , r2 , r3 add r0 , r4 , 0x8b beq 0x1ac cmp r8 , 0x1 beq 0x18c cmp r8 , 0x2 bne 0x2c4 ldrb lr , [ r2 , 0x1 ] ! ldrb r8 , [ r0 , 0x1 ] ! ldrb sb , [ r5 ] , 0x1 eor lr , lr , r8 eor sb , sb , lr strb sb , [ r2 ] ldrb lr , [ r2 , 0x1 ] ! ldrb r8 , [ r0 , 0x1 ] ! ldrb ip , [ r5 ] , 0x1 eor lr , lr , r8 eor ip , ip , lr cmp r2 , r3 strb ip , [ r2 ] beq 0x21c mov r8 , r5 ldrb sb , [ r0 , 0x1 ] ldrb sl , [ r2 , 0x1 ] ldrb lr , [ r8 ] , 0x1 eor sl , sl , sb eor lr , lr , sl strb lr , [ r2 , 0x1 ] ldrb sl , [ r0 , 0x2 ] ldrb sb , [ r2 , 0x2 ] ldrb ip , [ r5 , 0x1 ] eor sb , sb , sl eor ip , ip , sb strb ip , [ r2 , 0x2 ] ldrb sb , [ r0 , 0x3 ] ldrb lr , [ r2 , 0x3 ] ldrb r8 , [ r8 , 0x1 ] eor lr , lr , sb eor r8 , r8 , lr strb r8 , [ r2 , 0x3 ] ldrb lr , [ r2 , 0x4 ] ! ldrb sb , [ r0 , 0x4 ] ! ldrb ip , [ r5 , 0x3 ] eor lr , lr , sb eor ip , ip , lr cmp r2 , r3 strb ip , [ r2 ] add r5 , r5 , 0x4 bne 0x1ac ldr r3 , [ r4 ] ldr r8 , [ pc , 0xf8 ] add r2 , r3 , r3 , lsl 0x1 add r0 , r3 , r2 , lsl 0x2 add lr , r8 , r0 , lsl 0x3 add sb , r4 , 0x210 ldr ip , [ lr , 0x1c ] mov r2 , sb mov r0 , r1 blx ip subs r5 , r0 , 0x0 bne 0x5c ldr r1 , [ r4 ] mov r0 , sb add r3 , r1 , r1 , lsl 0x1 add r2 , r1 , r3 , lsl 0x2 add lr , r8 , r2 , lsl 0x3 ldr ip , [ lr , 0x28 ] blx ip ldr r0 , [ r4 , 0x8 ] cmp r0 , 0x0 beq 0x2e8 ldr r2 , [ r7 ] cmp r2 , 0x0 beq 0x2b8 sub r6 , r6 , 0x1 add r3 , r4 , 0xb b 0x298 ldr r0 , [ r7 ] cmp r0 , r2 bls 0x2b8 ldrb r1 , [ r3 , 0x1 ] sub lr , r3 , 0xa strb r1 , [ r6 , 0x1 ] ! ldr ip , [ r4 , 0x8 ] sub r2 , lr , r4 cmp ip , r2 add r3 , r3 , 0x1 bhi 0x28c str r2 , [ r7 ] mov r0 , r5 pop { r4 , r5 , r6 , r7 , r8 , sb , sl , pc } mov r2 , r4 mov r0 , r4 ldrb lr , [ r2 , 0xc ] ! ldrb sb , [ r0 , 0x8c ] ! ldrb ip , [ r5 ] , 0x1 eor lr , lr , sb eor ip , ip , lr strb ip , [ r2 ] b 0x174 mov r2 , r5 b 0x2b8 mov r2 , 0x20 ldr r1 , [ pc , 0x28 ] ldr r0 , [ pc , 0x28 ] bl 0x2fc mov r2 , 0x1f ldr r1 , [ pc , 0x18 ] ldr r0 , [ pc , 0x1c ] bl 0x30c mov r2 , 0x1e ldr r1 , [ pc , 0x8 ] ldr r0 , [ pc , 0x10 ] bl 0x31c andeq r0 , r0 , r8 , lsr r0 andeq r0 , r0 , ip , lsr 0x32 andeq r0 , r0 , ip , lsl r0
Code2: push r15 push r14 push r13 push r12 push rbx mov r15 , rdx mov r14 , rsi mov r13 , rdi mov eax , dword ptr [ rip ] test eax , eax jne 0x3ac mov al , byte ptr [ rip ] xor al , 0x2d mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x25 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x2c mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x90 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xb1 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x61 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x3f mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xe2 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xd6 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x62 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x61 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xca mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xc0 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x65 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x64 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x18 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xc0 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xef mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x15 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x3d mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xbc mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x7a mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x7c mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xd8 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x41 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xd7 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xc mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x9b mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x95 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x42 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xa0 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x1b mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x28 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x4d mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xe0 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x32 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xe9 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x2c mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x9c mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x82 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xe5 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x5a mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xa2 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x2e mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x64 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x56 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x4e mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xc5 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x53 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x57 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x87 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xd4 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x2a mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x2d mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xf6 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xd0 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xd1 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x5f mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xc4 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x9e mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x2b mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xab mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x2c mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x2a mov byte ptr [ rip ] , al mov dword ptr [ rip ] , 0x1 test r13 , r13 je 0x5e9 test r14 , r14 je 0x5fd test r15 , r15 je 0x611 mov edi , dword ptr [ r13 ] call 0x3da test eax , eax jne 0x5df movsxd rdx , dword ptr [ r13 + 0x4 ] mov eax , 0x10 cmp rdx , 0x80 ja 0x5df mov ecx , dword ptr [ r13 + 0x8 ] cmp ecx , 0x80 jg 0x5df cmp edx , ecx jg 0x5df cmp edx , ecx jne 0x420 xor r8d , r8d test edx , edx jne 0x464 jmp 0x56a lea eax , [ rdx + 0x1 ] mov dword ptr [ r13 + 0x4 ] , eax mov byte ptr [ r13 + rdx + 0xc ] , 0x80 mov ecx , dword ptr [ r13 + 0x4 ] mov edx , dword ptr [ r13 + 0x8 ] mov r8d , 0x1 cmp ecx , edx jge 0x45c nop lea eax , [ rcx + 0x1 ] mov dword ptr [ r13 + 0x4 ] , eax movsxd rax , ecx mov byte ptr [ r13 + rax + 0xc ] , 0x0 mov ecx , dword ptr [ r13 + 0x4 ] mov edx , dword ptr [ r13 + 0x8 ] cmp ecx , edx jl 0x440 test edx , edx je 0x56a mov r12d , edx cmp edx , 0x20 jae 0x473 xor edx , edx jmp 0x53d lea rax , [ r13 + 0xc ] lea rdx , [ r12 + r13 ] add rdx , 0xc lea r9 , [ r13 + 0x8c ] lea r11 , [ r12 + r13 ] add r11 , 0x8c mov rsi , r8 shl rsi , 0x7 lea r10 , [ rsi + r13 ] add r10 , 0x10c lea rdi , [ rsi + r12 ] add rdi , r13 add rdi , 0x10c cmp rax , r11 setb r11b cmp r9 , rdx setb r9b cmp rax , rdi setb al cmp r10 , rdx setb dil xor edx , edx test r11b , r9b jne 0x53d and al , dil jne 0x53d mov edx , r12d and edx , 0xffffffe0 add rsi , r13 add rsi , 0x11c xor edi , edi nop word ptr [ rax + rax ] movups xmm0 , xmmword ptr [ r13 + rdi + 0xc ] movups xmm1 , xmmword ptr [ r13 + rdi + 0x1c ] movups xmm2 , xmmword ptr [ r13 + rdi + 0x8c ] movups xmm3 , xmmword ptr [ r13 + rdi + 0x9c ] movups xmm4 , xmmword ptr [ rsi + rdi - 0x10 ] xorps xmm4 , xmm2 xorps xmm4 , xmm0 movups xmm0 , xmmword ptr [ rsi + rdi ] xorps xmm0 , xmm3 xorps xmm0 , xmm1 movups xmmword ptr [ r13 + rdi + 0xc ] , xmm4 movups xmmword ptr [ r13 + rdi + 0x1c ] , xmm0 add rdi , 0x20 cmp rdx , rdi jne 0x4f0 cmp rdx , r12 je 0x56a shl r8 , 0x7 lea rax , [ r8 + r13 ] add rax , 0x10c nop dword ptr [ rax + rax ] movzx ecx , byte ptr [ rax + rdx ] xor cl , byte ptr [ r13 + rdx + 0x8c ] xor byte ptr [ r13 + rdx + 0xc ] , cl add rdx , 0x1 cmp rdx , r12 jb 0x550 movsxd rax , dword ptr [ r13 ] lea rcx , [ rax + rax * 0x2 ] shl rcx , 0x6 lea rdi , [ r13 + 0xc ] lea r12 , [ r13 + 0x210 ] mov rsi , rdi mov rdx , r12 call qword ptr [ rcx ] test eax , eax jne 0x5df movsxd rax , dword ptr [ r13 ] lea rax , [ rax + rax * 0x2 ] shl rax , 0x6 mov rdi , r12 call qword ptr [ rax ] xor eax , eax cmp dword ptr [ r13 + 0x8 ] , 0x0 mov ecx , 0x0 je 0x5da xor ecx , ecx nop word ptr cs : [ rax + rax ] mov edx , ecx cmp qword ptr [ r15 ] , rdx jbe 0x5da movzx ebx , byte ptr [ r13 + rdx + 0xc ] mov byte ptr [ r14 + rdx ] , bl add ecx , 0x1 cmp ecx , dword ptr [ r13 + 0x8 ] jb 0x5c0 mov ecx , ecx mov qword ptr [ r15 ] , rcx pop rbx pop r12 pop r13 pop r14 pop r15 ret mov edi , 0x0 mov esi , 0x0 mov edx , 0x1e call 0x5fd mov edi , 0x0 mov esi , 0x0 mov edx , 0x1f call 0x611 mov edi , 0x0 mov esi , 0x0 mov edx , 0x20 call 0x625
Similarity: -1
Label: 1
Similarity Score: -0.8
Explanation: The two assembly codes show significant differences in architecture, structure, and core functionality. Code1 appears to be ARM assembly (using registers like r4-r8, conditional execution with suffixes like "le"/"gt", and blx instructions), while Code2 is x86_64 assembly (using registers like r15/r14, byte ptr syntax, and SSE instructions like xorps). 

Key dissimilarities:
1. **Architecture-Specific Operations**: Code2 uses x86-specific features (e.g., SIMD instructions like xorps, rip-relative addressing) absent in Code1.
2. **Control Flow**: Code1 relies heavily on conditional branching (beq/bne) and comparisons, while Code2 uses je/jne and complex loop structures.
3. **Core Operations**: Code2 has an extensive byte-level XOR decryption sequence (50+ operations) early in the
------------------------------------------------------------

------------------------------------------------------------
Code1: push r15 push r14 push r13 push r12 push rbp push rbx sub rsp , 0xc8 mov rax , qword ptr fs : [ 0x28 ] mov qword ptr [ rsp + 0xb8 ] , rax xor eax , eax test r8 , r8 mov qword ptr [ rsp ] , rdx mov qword ptr [ rsp + 0x28 ] , 0x0 je 0x173 mov rbp , rdi mov rbx , rsi lea rdi , [ rsp + 0x18 ] lea rsi , [ rsp + 0x20 ] xor edx , edx xor eax , eax mov dword ptr [ r8 ] , 0x0 mov r13 , rcx mov r12 , r8 mov r14 , r9 call 0x63 test eax , eax mov r15d , eax je 0xa0 mov rcx , qword ptr [ rsp + 0xb8 ] xor rcx , qword ptr fs : [ 0x28 ] mov eax , r15d jne 0x18b add rsp , 0xc8 pop rbx pop rbp pop r12 pop r13 pop r14 pop r15 ret nop word ptr cs : [ rax + rax ] mov rdx , qword ptr [ rsp + 0x20 ] mov rax , qword ptr [ rsp + 0x18 ] mov r8d , 0x1 mov ecx , 0x2 mov rsi , rbx mov rdi , rbp mov dword ptr [ rsp + 0x30 ] , 0x2 mov qword ptr [ rsp + 0x40 ] , 0x1 mov qword ptr [ rsp + 0x78 ] , rdx lea rdx , [ rsp + 0x30 ] mov qword ptr [ rsp + 0x38 ] , rax mov dword ptr [ rsp + 0x48 ] , 0x0 mov dword ptr [ rsp + 0x70 ] , 0x2 mov qword ptr [ rsp + 0x80 ] , 0x1 mov dword ptr [ rsp + 0x88 ] , 0x0 mov qword ptr [ rsp + 0x8 ] , rdx call 0x10c test eax , eax mov r15d , eax je 0x130 mov rsi , qword ptr [ rsp + 0x20 ] mov rdi , qword ptr [ rsp + 0x18 ] xor edx , edx xor eax , eax call 0x126 jmp 0x6a nop dword ptr [ rax + rax ] mov rdi , qword ptr [ rsp + 0x8 ] lea rdx , [ rsp + 0x28 ] mov esi , 0x2 call 0x144 test eax , eax mov r15d , eax mov rsi , qword ptr [ rsp + 0x20 ] mov rdi , qword ptr [ rsp + 0x18 ] jne 0x11d cmp qword ptr [ rsp + 0x28 ] , rbx jne 0x11d mov rdx , qword ptr [ rsp ] mov r9 , r14 mov r8 , r12 mov rcx , r13 call 0x16e mov r15d , eax jmp 0x113 lea rsi , [ rip ] lea rdi , [ rip ] mov edx , 0x68 call 0x18b call 0x190
Code2: push rbp mov rbp , rsp push r15 push r14 push r13 push r12 push rbx sub rsp , 0x38 mov qword ptr [ rbp - 0x50 ] , r9 mov qword ptr [ rbp - 0x48 ] , rcx mov qword ptr [ rbp - 0x40 ] , rdx mov qword ptr [ rbp - 0x58 ] , rdi mov eax , dword ptr [ rip ] test eax , eax jne 0x1b0 mov al , byte ptr [ rip ] xor al , 0x10 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x80 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xe8 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x4e mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x3a mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x9b mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xba mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xa8 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xe0 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x5c mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xb5 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x25 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x39 mov byte ptr [ rip ] , al movaps xmm0 , xmmword ptr [ rip ] xorps xmm0 , xmmword ptr [ rip ] movaps xmmword ptr [ rip ] , xmm0 mov al , byte ptr [ rip ] xor al , 0xde mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xaf mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xdb mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x11 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x81 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xde mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x32 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x29 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xd9 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x64 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x2b mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x67 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x61 mov byte ptr [ rip ] , al mov qword ptr [ rbp - 0x60 ] , rsi mov dword ptr [ rip ] , 0x1 mov r15 , rsp add r15 , - 0x10 mov rsp , r15 mov r12 , rsp add r12 , - 0x10 mov rsp , r12 mov r14 , rsp add r14 , - 0x80 mov rsp , r14 mov rax , rsp lea rcx , [ rax - 0x10 ] mov qword ptr [ rbp - 0x30 ] , rcx mov rsp , rcx mov qword ptr [ rax - 0x10 ] , 0x0 test r8 , r8 je 0x2e5 mov dword ptr [ r8 ] , 0x0 mov rdi , r15 mov rsi , r12 xor edx , edx xor eax , eax mov r13 , r8 call 0x214 mov ebx , eax test eax , eax jne 0x2d4 mov qword ptr [ rbp - 0x38 ] , r13 mov dword ptr [ r14 ] , 0x2 mov rax , qword ptr [ r15 ] mov qword ptr [ r14 + 0x8 ] , rax mov qword ptr [ r14 + 0x10 ] , 0x1 mov dword ptr [ r14 + 0x18 ] , 0x0 mov dword ptr [ r14 + 0x40 ] , 0x2 mov rax , qword ptr [ r12 ] mov qword ptr [ r14 + 0x48 ] , rax mov qword ptr [ r14 + 0x50 ] , 0x1 mov dword ptr [ r14 + 0x58 ] , 0x0 mov ecx , 0x2 mov rdi , qword ptr [ rbp - 0x58 ] mov r13 , qword ptr [ rbp - 0x60 ] mov rsi , r13 mov rdx , r14 mov r8d , 0x1 call 0x27e mov ebx , eax test eax , eax jne 0x2c4 mov esi , 0x2 mov rdi , r14 mov rdx , qword ptr [ rbp - 0x30 ] call 0x295 mov ebx , eax test eax , eax jne 0x2c4 xor ebx , ebx mov rax , qword ptr [ rbp - 0x30 ] cmp qword ptr [ rax ] , r13 jne 0x2c4 mov rdi , qword ptr [ r15 ] mov rsi , qword ptr [ r12 ] mov rdx , qword ptr [ rbp - 0x40 ] mov rcx , qword ptr [ rbp - 0x48 ] mov r8 , qword ptr [ rbp - 0x38 ] mov r9 , qword ptr [ rbp - 0x50 ] call 0xfffffffffffff990 mov ebx , eax mov rdi , qword ptr [ r15 ] mov rsi , qword ptr [ r12 ] xor edx , edx xor eax , eax call 0x2d4 mov eax , ebx lea rsp , [ rbp - 0x28 ] pop rbx pop r12 pop r13 pop r14 pop r15 pop rbp ret mov edi , 0x0 mov esi , 0x0 mov edx , 0x68 call 0x2f9
Similarity: -1
Label: 1
Similarity Score: -0.7
Explanation: The two assembly codes show some structural similarities in function prologues (register preservation) and stack management, but exhibit significant differences in core functionality. Code1 focuses on memory operations and conditional jumps with specific register usage patterns, while Code2 contains extensive byte-level XOR operations on global data that are absent in Code1. The control flow, register usage patterns, and called operations differ substantially, with Code2 showing more complex data manipulation sequences. Though both test the r8 register early, their subsequent operations diverge completely, indicating different purposes.
------------------------------------------------------------

------------------------------------------------------------
Code1: push { r4 , lr } ldr r3 , [ r2 , 0x28 ] mov r2 , 0x10 mov r1 , r0 mov r0 , r3 bl 0x1dd5c clz r0 , r0 lsr r0 , r0 , 0x5 pop { r4 , pc }
Code2: push ebp mov ebp , esp push edi push esi sub esp , 0x40 mov eax , dword ptr [ ebp + 0x10 ] mov ecx , dword ptr [ ebp + 0xc ] mov edx , dword ptr [ ebp + 0x8 ] mov esi , dword ptr [ ebp + 0x10 ] mov esi , dword ptr [ esi + 0x28 ] mov edi , dword ptr [ ebp + 0x8 ] mov dword ptr [ esp ] , esi mov dword ptr [ esp + 0x4 ] , edi mov dword ptr [ esp + 0x8 ] , 0x10 mov dword ptr [ ebp - 0x18 ] , eax mov dword ptr [ ebp - 0x1c ] , ecx mov dword ptr [ ebp - 0x20 ] , edx call 0xffffb950 mov dword ptr [ ebp - 0xc ] , eax mov dword ptr [ ebp - 0x14 ] , 0x3f4c79e0 mov eax , dword ptr [ ebp - 0x14 ] mov ecx , eax sub ecx , 0xb2b7fe9 mov dword ptr [ ebp - 0x24 ] , eax mov dword ptr [ ebp - 0x28 ] , ecx je 0xdf jmp 0x5d mov eax , dword ptr [ ebp - 0x24 ] sub eax , 0xff841fb mov dword ptr [ ebp - 0x2c ] , eax je 0xbf jmp 0x73 mov eax , dword ptr [ ebp - 0x24 ] sub eax , 0x3f4c79e0 mov dword ptr [ ebp - 0x30 ] , eax je 0xa4 jmp 0x89 mov eax , dword ptr [ ebp - 0x24 ] sub eax , 0x4e443d32 mov dword ptr [ ebp - 0x34 ] , eax je 0xcf jmp 0x9f jmp 0xee mov eax , dword ptr [ ebp - 0xc ] cmp eax , 0x0 mov eax , 0xff841fb mov ecx , 0x4e443d32 cmove ecx , eax mov dword ptr [ ebp - 0x14 ] , ecx jmp 0xee mov byte ptr [ ebp - 0xd ] , 0x1 mov dword ptr [ ebp - 0x14 ] , 0xb2b7fe9 jmp 0xee mov byte ptr [ ebp - 0xd ] , 0x0 mov dword ptr [ ebp - 0x14 ] , 0xb2b7fe9 jmp 0xee mov al , byte ptr [ ebp - 0xd ] and al , 0x1 movzx eax , al add esp , 0x40 pop esi pop edi pop ebp ret jmp 0x41 nop word ptr cs : [ eax + eax ] nop dword ptr [ eax ]
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two code snippets are fundamentally dissimilar due to multiple factors:
1. **Architecture Difference**: Code1 uses ARM instructions (e.g., `ldr`, `bl`, `clz`) while Code2 uses x86 instructions (e.g., `dword ptr`, `ebp`-based addressing).
2. **Structural Complexity**: Code1 is a concise sequence (9 instructions) focused on a function call and bit manipulation, whereas Code2 is a complex function (50+ instructions) with stack setup, multiple branches, and conditional jumps.
3. **Core Functionality Mismatch**: 
   - Code1 loads a value from memory, calls a function, then performs count-leading-zero and shift operations.
   - Code2 handles multiple comparisons, conditional jumps, and memory operations unrelated to Code1's logic.
4. **No Shared Operations**: Critical ARM-specific instructions in Code1 (`clz`, `lsr`) have no equivalents in Code2's x86 flow. The only common instructions (`push`/`pop`) are routine stack operations.
------------------------------------------------------------

------------------------------------------------------------
Code1: lui gp , 0x6c addiu gp , gp , 0x3de0 lw t9 , - 0x587c ( gp ) jr t9 lw a0 , ( a0 )
Code2: str lr , [ sp , - 0x4 ] ! sub sp , sp , 0xc str r0 , [ sp , 0x4 ] ldr r3 , [ sp , 0x4 ] ldr r3 , [ r3 ] mov r0 , r3 bl 0xffee4e50 mov r0 , r0 add sp , sp , 0xc pop { pc }
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two code snippets are from different architectures (MIPS vs ARM) and perform entirely different operations. The MIPS code loads a function pointer from a global base and jumps to it, while the ARM code sets up the stack, dereferences a pointer, and makes a direct function call. There is no significant similarity in structure, instructions, or purpose beyond the generic concept of making a function call, which is too broad to indicate similarity.
------------------------------------------------------------

------------------------------------------------------------
Code1: lui v0 , 0x68 lw a0 , - 0x1f3c ( v0 ) beqz a0 , 0x40 nop addiu sp , sp , - 0x20 sw ra , 0x1c ( sp ) sw s0 , 0x18 ( sp ) move s0 , v0 jal 0x5105c4 nop lw a0 , - 0x1f3c ( s0 ) bnez a0 , 0x20 lw ra , 0x1c ( sp ) lw s0 , 0x18 ( sp ) jr ra addiu sp , sp , 0x20 jr ra nop
Code2: addiu sp , sp , - 0x28 sw ra , 0x24 ( sp ) lui v0 , 0x76 lw v0 , - 0x2a70 ( v0 ) sw v0 , 0x1c ( sp ) b 0x34 nop lw a0 , 0x1c ( sp ) jal 0x5897c0 nop lui v0 , 0x76 lw v0 , - 0x2a70 ( v0 ) sw v0 , 0x1c ( sp ) lw v0 , 0x1c ( sp ) bnez v0 , 0x1c nop nop lw ra , 0x24 ( sp ) addiu sp , sp , 0x28 jr ra nop
Similarity: -1
Label: 1
Similarity Score: 0.2
Explanation: Both codes share a common function structure with stack adjustment and saving/restoring the return address (ra), which contributes to a low similarity score. However, the core logic is significantly different: Code1 conditionally calls a function once and returns, while Code2 contains a loop that repeatedly calls a function. This fundamental difference in control flow and purpose leads to the conclusion that the codes are not similar.
------------------------------------------------------------

------------------------------------------------------------
Code1: push edi push esi xor edx , edx push ebx mov edi , dword ptr [ esp + 0x10 ] xor ebx , ebx mov ecx , dword ptr [ edi ] mov esi , dword ptr [ edi + 0x4 ] cmp ecx , esi jae 0x41 lea esi , [ esi ] mov eax , dword ptr [ ecx ] test eax , eax je 0x3a mov eax , dword ptr [ ecx + 0x4 ] add ebx , 0x1 add edx , 0x1 test eax , eax je 0x3a nop lea esi , [ esi ] mov eax , dword ptr [ eax + 0x4 ] add edx , 0x1 test eax , eax jne 0x30 add ecx , 0x8 cmp ecx , esi jb 0x18 xor eax , eax cmp dword ptr [ edi + 0xc ] , ebx jne 0x4e cmp dword ptr [ edi + 0x10 ] , edx sete al pop ebx pop esi pop edi ret lea esi , [ esi ] lea edi , [ edi ]
Code2: push ebp mov ebp , esp sub esp , 0x54 mov eax , dword ptr [ ebp + 0x8 ] mov dword ptr [ ebp - 0xc ] , 0x0 mov dword ptr [ ebp - 0x10 ] , 0x0 mov ecx , dword ptr [ ebp + 0x8 ] mov ecx , dword ptr [ ecx ] mov dword ptr [ ebp - 0x8 ] , ecx mov dword ptr [ ebp - 0x18 ] , 0x86e1cc41 mov dword ptr [ ebp - 0x1c ] , eax mov eax , dword ptr [ ebp - 0x18 ] mov ecx , eax sub ecx , 0x8271b6d5 mov dword ptr [ ebp - 0x20 ] , eax mov dword ptr [ ebp - 0x24 ] , ecx je 0x213 jmp 0x45 mov eax , dword ptr [ ebp - 0x20 ] sub eax , 0x86e1cc41 mov dword ptr [ ebp - 0x28 ] , eax je 0x152 jmp 0x5b mov eax , dword ptr [ ebp - 0x20 ] sub eax , 0x8ea14e3f mov dword ptr [ ebp - 0x2c ] , eax je 0x1af jmp 0x71 mov eax , dword ptr [ ebp - 0x20 ] sub eax , 0x9e8e2d26 mov dword ptr [ ebp - 0x30 ] , eax je 0x1e6 jmp 0x87 mov eax , dword ptr [ ebp - 0x20 ] sub eax , 0xc443a21d mov dword ptr [ ebp - 0x34 ] , eax je 0x26f jmp 0x9d mov eax , dword ptr [ ebp - 0x20 ] sub eax , 0xf3e42fb1 mov dword ptr [ ebp - 0x38 ] , eax je 0x25f jmp 0xb3 mov eax , dword ptr [ ebp - 0x20 ] sub eax , 0x111465bd mov dword ptr [ ebp - 0x3c ] , eax je 0x1fe jmp 0xc9 mov eax , dword ptr [ ebp - 0x20 ] sub eax , 0x1a019fe1 mov dword ptr [ ebp - 0x40 ] , eax je 0x231 jmp 0xdf mov eax , dword ptr [ ebp - 0x20 ] sub eax , 0x282f7d70 mov dword ptr [ ebp - 0x44 ] , eax je 0x24f jmp 0xf5 mov eax , dword ptr [ ebp - 0x20 ] sub eax , 0x372f524c mov dword ptr [ ebp - 0x48 ] , eax je 0x170 jmp 0x10b mov eax , dword ptr [ ebp - 0x20 ] sub eax , 0x41c5318e mov dword ptr [ ebp - 0x4c ] , eax je 0x1d1 jmp 0x121 mov eax , dword ptr [ ebp - 0x20 ] sub eax , 0x698a14af mov dword ptr [ ebp - 0x50 ] , eax je 0x18b jmp 0x137 mov eax , dword ptr [ ebp - 0x20 ] sub eax , 0x778ec971 mov dword ptr [ ebp - 0x54 ] , eax je 0x1f2 jmp 0x14d jmp 0x27c mov eax , dword ptr [ ebp - 0x8 ] mov ecx , dword ptr [ ebp + 0x8 ] cmp eax , dword ptr [ ecx + 0x4 ] mov eax , 0x372f524c mov ecx , 0x8271b6d5 cmovb ecx , eax mov dword ptr [ ebp - 0x18 ] , ecx jmp 0x27c mov eax , dword ptr [ ebp - 0x8 ] cmp dword ptr [ eax ] , 0x0 mov eax , 0x698a14af mov ecx , 0x778ec971 cmovne ecx , eax mov dword ptr [ ebp - 0x18 ] , ecx jmp 0x27c mov eax , dword ptr [ ebp - 0x8 ] mov dword ptr [ ebp - 0x14 ] , eax mov eax , dword ptr [ ebp - 0xc ] add eax , 0x1 mov dword ptr [ ebp - 0xc ] , eax mov eax , dword ptr [ ebp - 0x10 ] add eax , 0x1 mov dword ptr [ ebp - 0x10 ] , eax mov dword ptr [ ebp - 0x18 ] , 0x8ea14e3f jmp 0x27c mov eax , dword ptr [ ebp - 0x14 ] mov eax , dword ptr [ eax + 0x4 ] mov dword ptr [ ebp - 0x14 ] , eax cmp dword ptr [ ebp - 0x14 ] , 0x0 mov eax , 0x41c5318e mov ecx , 0x9e8e2d26 cmovne ecx , eax mov dword ptr [ ebp - 0x18 ] , ecx jmp 0x27c mov eax , dword ptr [ ebp - 0x10 ] add eax , 0x1 mov dword ptr [ ebp - 0x10 ] , eax mov dword ptr [ ebp - 0x18 ] , 0x8ea14e3f jmp 0x27c mov dword ptr [ ebp - 0x18 ] , 0x778ec971 jmp 0x27c mov dword ptr [ ebp - 0x18 ] , 0x111465bd jmp 0x27c mov eax , dword ptr [ ebp - 0x8 ] add eax , 0x8 mov dword ptr [ ebp - 0x8 ] , eax mov dword ptr [ ebp - 0x18 ] , 0x86e1cc41 jmp 0x27c mov eax , dword ptr [ ebp - 0xc ] mov ecx , dword ptr [ ebp + 0x8 ] cmp eax , dword ptr [ ecx + 0xc ] mov eax , 0x1a019fe1 mov ecx , 0xf3e42fb1 cmove ecx , eax mov dword ptr [ ebp - 0x18 ] , ecx jmp 0x27c mov eax , dword ptr [ ebp - 0x10 ] mov ecx , dword ptr [ ebp + 0x8 ] cmp eax , dword ptr [ ecx + 0x10 ] mov eax , 0x282f7d70 mov ecx , 0xf3e42fb1 cmove ecx , eax mov dword ptr [ ebp - 0x18 ] , ecx jmp 0x27c mov byte ptr [ ebp - 0x1 ] , 0x1 mov dword ptr [ ebp - 0x18 ] , 0xc443a21d jmp 0x27c mov byte ptr [ ebp - 0x1 ] , 0x0 mov dword ptr [ ebp - 0x18 ] , 0xc443a21d jmp 0x27c mov al , byte ptr [ ebp - 0x1 ] and al , 0x1 movzx eax , al add esp , 0x54 pop ebp ret jmp 0x29 nop word ptr cs : [ eax + eax ] nop dword ptr [ eax + eax ]
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly codes show fundamental structural and functional differences. Code1 implements a loop-based structure traversal with element counting and validation checks, using direct memory access and register operations. Code2 employs a complex state-machine approach with extensive conditional jumps and hardcoded constants, resembling a switch-case mechanism. There's no significant overlap in control flow patterns, register usage, or algorithmic approaches. The purposes appear distinct: Code1 validates data structure contents, while Code2 executes multi-path conditional logic with state tracking.
------------------------------------------------------------

------------------------------------------------------------
Code1: push rbp push r15 push r14 push r12 push rbx sub rsp , 0x10 mov r12 , rdx mov r15 , rsi mov r14 , rdi mov rax , qword ptr [ rsi ] mov qword ptr [ rsp + 0x8 ] , rax test rdi , rdi je 0x2a xor ebp , ebp cmp qword ptr [ r14 ] , 0x0 jne 0x2f mov ebp , 0x1 lea rsi , [ rsp + 0x8 ] mov ecx , 0x62ccd0 mov rdi , r14 mov rdx , r12 call 0x6420 test rax , rax je 0x9f mov rbx , rax mov rax , qword ptr [ rsp + 0x8 ] mov rdx , qword ptr [ r15 ] sub rdx , rax add rdx , r12 test rdx , rdx jle 0x7d mov rdi , rbx add rdi , 0xb0 lea rsi , [ rsp + 0x8 ] call 0x2d0 test rax , rax je 0x82 mov rax , qword ptr [ rsp + 0x8 ] mov qword ptr [ r15 ] , rax jmp 0xa1 test ebp , ebp je 0x9f mov esi , 0x62ccd0 mov rdi , rbx call 0x4cf0 test r14 , r14 je 0x9f mov qword ptr [ r14 ] , 0x0 xor ebx , ebx mov rax , rbx add rsp , 0x10 pop rbx pop r12 pop r14 pop r15 pop rbp ret nop word ptr cs : [ rax + rax ] nop dword ptr [ rax + rax ]
Code2: lui gp , 0x6c lw v1 , ( a1 ) addiu sp , sp , - 0x48 addiu gp , gp , 0x3de0 sw s2 , 0x2c ( sp ) lw s2 , - 0x52f8 ( gp ) sw s7 , 0x40 ( sp ) move s7 , a1 sw s1 , 0x28 ( sp ) move s1 , a0 sw s0 , 0x24 ( sp ) move s0 , a2 sw ra , 0x44 ( sp ) sw s6 , 0x3c ( sp ) sw s5 , 0x38 ( sp ) sw s4 , 0x34 ( sp ) sw s3 , 0x30 ( sp ) sw gp , 0x10 ( sp ) sw v1 , 0x18 ( sp ) lw v0 , ( s2 ) sw v0 , 0x1c ( sp ) beqz a0 , 0x64 addiu s3 , zero , 0x1 lw s3 , ( a0 ) sltiu s3 , s3 , 0x1 lui s5 , 0x6b lw t9 , - 0x6768 ( gp ) addiu s4 , sp , 0x18 addiu a3 , s5 , - 0x6b60 move a2 , s0 move a1 , s4 bal 0x132cc move a0 , s1 lw gp , 0x10 ( sp ) beqz v0 , 0x128 move s6 , v0 lw v0 , 0x18 ( sp ) lw a2 , ( s7 ) subu a2 , v0 , a2 subu a2 , s0 , a2 blez a2 , 0xc0 lw t9 , - 0x60cc ( gp ) addiu a0 , s6 , 0x64 bal 0x1fc move a1 , s4 beqz v0 , 0x100 lw gp , 0x10 ( sp ) lw v0 , 0x18 ( sp ) sw v0 , ( s7 ) lw a0 , 0x1c ( sp ) move v0 , s6 lw v1 , ( s2 ) bne a0 , v1 , 0x130 lw ra , 0x44 ( sp ) lw s7 , 0x40 ( sp ) lw s6 , 0x3c ( sp ) lw s5 , 0x38 ( sp ) lw s4 , 0x34 ( sp ) lw s3 , 0x30 ( sp ) lw s2 , 0x2c ( sp ) lw s1 , 0x28 ( sp ) lw s0 , 0x24 ( sp ) jr ra addiu sp , sp , 0x48 beqz s3 , 0x128 lw t9 , - 0x6784 ( gp ) addiu a1 , s5 , - 0x6b60 bal 0x9c84 move a0 , s6 beqz s1 , 0x128 lw gp , 0x10 ( sp ) move s6 , zero b 0xc4 sw zero , ( s1 ) b 0xc4 move s6 , zero lw t9 , - 0x5330 ( gp ) jalr t9 nop
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two code snippets show fundamental differences in architecture, instruction sets, and structure. The first code uses x86_64 assembly (with registers like rbp, rsp, rax) and features operations like push/pop and relative addressing (e.g., [rsp+0x8]). The second uses MIPS assembly (with registers like gp, sp, v0) and includes architecture-specific operations (e.g., lui, lw/sw, bal). There are no overlapping instructions, register usage patterns, or control flow structures. The calling conventions, stack handling, and instruction mnemonics are entirely distinct, indicating they target different processors and implement unrelated functionality.
------------------------------------------------------------

------------------------------------------------------------
Code1: push ebp mov ebp , esp sub esp , 0x18 cmp dword ptr [ 0x8058384 ] , 0x0 jne 0xa3 mov al , byte ptr [ 0x8057a29 ] xor al , 0x6a mov byte ptr [ 0x8057a35 ] , al mov al , byte ptr [ 0x8057a2a ] xor al , 0xe0 mov byte ptr [ 0x8057a36 ] , al mov al , byte ptr [ 0x8057a2b ] xor al , 0xb6 mov byte ptr [ 0x8057a37 ] , al mov al , byte ptr [ 0x8057a2c ] xor al , 0x75 mov byte ptr [ 0x8057a38 ] , al mov al , byte ptr [ 0x8057a2d ] xor al , 0x2f mov byte ptr [ 0x8057a39 ] , al mov al , byte ptr [ 0x8057a2e ] xor al , 0x4e mov byte ptr [ 0x8057a3a ] , al mov al , byte ptr [ 0x8057a2f ] xor al , 0xea mov byte ptr [ 0x8057a3b ] , al mov al , byte ptr [ 0x8057a30 ] xor al , 0xcb mov byte ptr [ 0x8057a3c ] , al mov al , byte ptr [ 0x8057a31 ] xor al , 0x31 mov byte ptr [ 0x8057a3d ] , al mov al , byte ptr [ 0x8057a32 ] xor al , 0x5c mov byte ptr [ 0x8057a3e ] , al mov al , byte ptr [ 0x8057a33 ] xor al , 0xa8 mov byte ptr [ 0x8057a3f ] , al mov al , byte ptr [ 0x8057a34 ] xor al , 0xee mov byte ptr [ 0x8057a40 ] , al mov dword ptr [ 0x8058384 ] , 0x1 call 0xffffb420 lea ecx , [ 0x8057a35 ] mov eax , dword ptr [ eax ] mov dword ptr [ esp ] , ecx mov dword ptr [ ebp - 0x4 ] , eax call 0xffffb3b0 mov dword ptr [ esp ] , 0x1 mov ecx , dword ptr [ ebp - 0x4 ] mov dword ptr [ esp + 0x4 ] , ecx mov dword ptr [ esp + 0x8 ] , eax call 0xffffb360 nop nop
Code2: lui gp , 0x42 addiu sp , sp , - 0x20 addiu gp , gp , 0x60d0 sw ra , 0x1c ( sp ) sw s0 , 0x18 ( sp ) sw gp , 0x10 ( sp ) lw t9 , - 0x7ef0 ( gp ) jalr t9 nop lui a1 , 0x41 lw gp , 0x10 ( sp ) addiu a2 , zero , 0x5 addiu a1 , a1 , - 0x3ebc lw s0 , ( v0 ) lw t9 , - 0x7e94 ( gp ) jalr t9 move a0 , zero addiu a0 , zero , 0x1 lw gp , 0x10 ( sp ) move a2 , v0 lw t9 , - 0x7eb8 ( gp ) jalr t9 move a1 , s0
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The codes show no meaningful similarity due to fundamental differences:
1. Architecture: Code1 uses x86 instructions (ebp/esp registers) while Code2 uses MIPS (lui/addiu instructions)
2. Operations: Code1 performs byte-level XOR operations on fixed memory addresses, while Code2 focuses on function calls using jump registers (jalr) and stack management
3. Structure: Code1 has sequential memory manipulation without jumps (except initial jne), whereas Code2 uses multiple procedure calls via t9 register
4. Purpose: No overlapping logic - Code1 appears to be decrypting data, while Code2 manages function dispatching
------------------------------------------------------------

------------------------------------------------------------
Code1: push ebx call 0xfffffe70 add ebx , 0x28fde sub esp , 0x14 push dword ptr [ esp + 0x1c ] call 0xffffe3a0 add esp , 0x18 pop ebx ret lea esi , [ esi ]
Code2: push rbp mov rbp , rsp sub rsp , 0x10 mov qword ptr [ rbp - 0x8 ] , rdi mov rdi , qword ptr [ rbp - 0x8 ] call 0xffffffffffffcdd0 add rsp , 0x10 pop rbp ret nop dword ptr [ rax + rax ]
Similarity: -1
Label: 1
Similarity Score: 0.35
Explanation: The codes show moderate structural similarities in function setup/cleanup patterns (stack adjustment, register preservation, call/ret), but differ significantly in architecture (32-bit vs 64-bit), register usage, argument handling, and core operations. Code1 manipulates EBX for PIC and accesses arguments via stack, while Code2 uses RBP for framing and RDI for argument passing. The differing instructions (sub vs mov, add
------------------------------------------------------------

------------------------------------------------------------
Code1: push { r4 , r5 , r6 , r7 , r8 , lr } sub sp , sp , 0x8 mov r4 , r0 mov r5 , r1 mov r6 , r2 mov r8 , r3 ldr r1 , [ sp , 0x28 ] cmn r2 , 0x1 ldreq r6 , [ r0 , 0x58 ] addeq r3 , r6 , 0x1 streq r3 , [ r0 , 0x58 ] ldr r7 , [ r0 , 0x5c ] add r3 , r7 , 0x1 str r3 , [ r0 , 0x5c ] ldr r3 , [ pc , 0x334 ] cmp r5 , 0x0 moveq r5 , r3 cmp r1 , 0x0 beq 0xc4 bl 0xffffcd64 cmp r0 , 0x0 beq 0xbc ldr r3 , [ sp , 0x24 ] str r3 , [ sp ] ldr r3 , [ sp , 0x20 ] mov r2 , r8 mov r1 , r6 mov r0 , r4 bl 0xffffd0f0 cmp r0 , 0x0 beq 0xbc ldr r3 , [ r4 , 0xc ] ldr r2 , [ r3 , 0x4 ] ldr r1 , [ pc , 0x2ec ] cmp r2 , r1 bhi 0x288 add r1 , r2 , 0x1 str r1 , [ r3 , 0x4 ] add r3 , r3 , r2 mvn r2 , 0xf strb r2 , [ r3 , 0x8 ] mov r1 , r7 mov r0 , r4 bl 0xfffff720 cmp r0 , 0x0 moveq r0 , 0x0 bne 0x2a4 add sp , sp , 0x8 pop { r4 , r5 , r6 , r7 , r8 , pc } ldr r3 , [ sp , 0x24 ] cmp r3 , 0x0 beq 0x1ac ldr r3 , [ r0 , 0x28 ] cmp r3 , 0x0 beq 0xf0 add r1 , r0 , 0x28 bl 0xffffcd64 cmp r0 , 0x0 bne 0x58 b 0xbc add r1 , r0 , 0x28 bl 0xffffcd64 cmp r0 , 0x0 beq 0xbc ldr r3 , [ r4 , 0xc ] ldr r2 , [ r3 , 0x4 ] ldr r1 , [ pc , 0x268 ] cmp r2 , r1 bhi 0x17c add r1 , r2 , 0x1 str r1 , [ r3 , 0x4 ] add r3 , r3 , r2 mvn r2 , 0x7 strb r2 , [ r3 , 0x8 ] ldr r3 , [ r4 , 0xc ] ldr r2 , [ r3 , 0x4 ] ldr r1 , [ pc , 0x240 ] cmp r2 , r1 bhi 0x194 add r1 , r2 , 0x1 str r1 , [ r3 , 0x4 ] add r3 , r3 , r2 mov r2 , 0x1 strb r2 , [ r3 , 0x8 ] mov r1 , 0x0 mov r0 , r4 bl 0xfffff720 cmp r0 , 0x0 beq 0xbc ldr r1 , [ r4 , 0x14 ] mov r0 , r4 bl 0xfffffa28 cmp r0 , 0x0 bne 0x58 b 0xbc mov r1 , 0xf8 mov r0 , r4 bl 0xffffcdb0 cmp r0 , 0x0 bne 0x128 b 0xbc mov r1 , 0x1 mov r0 , r4 bl 0xffffcdb0 cmp r0 , 0x0 bne 0x150 b 0xbc ldr r3 , [ r0 , 0x18 ] cmp r3 , 0x0 beq 0x1cc add r1 , r0 , 0x18 bl 0xffffcd64 cmp r0 , 0x0 bne 0x58 b 0xbc add r1 , r0 , 0x18 bl 0xffffcd64 cmp r0 , 0x0 beq 0xbc ldr r3 , [ r4 , 0xc ] ldr r2 , [ r3 , 0x4 ] ldr r1 , [ pc , 0x18c ] cmp r2 , r1 bhi 0x258 add r1 , r2 , 0x1 str r1 , [ r3 , 0x4 ] add r3 , r3 , r2 mvn r2 , 0x7 strb r2 , [ r3 , 0x8 ] ldr r3 , [ r4 , 0xc ] ldr r2 , [ r3 , 0x4 ] ldr r1 , [ pc , 0x164 ] cmp r2 , r1 bhi 0x270 add r1 , r2 , 0x1 str r1 , [ r3 , 0x4 ] add r3 , r3 , r2 mov r2 , 0x2 strb r2 , [ r3 , 0x8 ] mov r1 , 0x0 mov r0 , r4 bl 0xfffff720 cmp r0 , 0x0 beq 0xbc ldr r1 , [ pc , 0x12c ] mov r0 , r4 bl 0xfffffa28 cmp r0 , 0x0 bne 0x58 b 0xbc mov r1 , 0xf8 mov r0 , r4 bl 0xffffcdb0 cmp r0 , 0x0 bne 0x204 b 0xbc mov r1 , 0x2 mov r0 , r4 bl 0xffffcdb0 cmp r0 , 0x0 bne 0x22c b 0xbc mov r1 , 0xf0 mov r0 , r4 bl 0xffffcdb0 cmp r0 , 0x0 moveq r0 , 0x0 bne 0xa4 b 0xbc mov r1 , r5 mov r0 , r4 bl 0xfffffa28 cmp r0 , 0x0 moveq r0 , 0x0 beq 0xbc ldr r3 , [ r4 , 0xc ] ldr r2 , [ r3 , 0x4 ] ldr r1 , [ pc , 0xac ] cmp r2 , r1 bhi 0x33c add r1 , r2 , 0x1 str r1 , [ r3 , 0x4 ] add r3 , r3 , r2 mvn r2 , 0xd strb r2 , [ r3 , 0x8 ] mov r1 , r6 mov r0 , r4 bl 0xfffff720 cmp r0 , 0x0 moveq r0 , 0x0 beq 0xbc ldr r3 , [ r4 , 0xc ] ldr r2 , [ r3 , 0x4 ] ldr r1 , [ pc , 0x6c ] cmp r2 , r1 bhi 0x358 add r1 , r2 , 0x1 str r1 , [ r3 , 0x4 ] add r3 , r3 , r2 mvn r2 , 0x31 strb r2 , [ r3 , 0x8 ] mov r1 , r7 mov r0 , r4 bl 0xfffff720 adds r0 , r0 , 0x0 movne r0 , 0x1 b 0xbc mov r1 , 0xf2 mov r0 , r4 bl 0xffffcdb0 cmp r0 , 0x0 moveq r0 , 0x0 bne 0x2e4 b 0xbc mov r1 , 0xce mov r0 , r4 bl 0xffffcdb0 cmp r0 , 0x0 moveq r0 , 0x0 bne 0x324 b 0xbc andeq r6 , lr , ip , asr r4 andeq r0 , r0 , sb , ror 0x3
Code2: push { fp , lr } add fp , sp , 0x4 sub sp , sp , 0x20 str r0 , [ fp , - 0x10 ] str r1 , [ fp , - 0x14 ] str r2 , [ fp , - 0x18 ] str r3 , [ fp , - 0x1c ] ldr r3 , [ fp , - 0x18 ] cmn r3 , 0x1 beq 0x34 ldr r3 , [ fp , - 0x18 ] str r3 , [ fp , - 0xc ] b 0x54 ldr r3 , [ fp , - 0x10 ] ldr r3 , [ r3 , 0x58 ] str r3 , [ fp , - 0xc ] ldr r3 , [ fp , - 0x10 ] ldr r3 , [ r3 , 0x58 ] add r2 , r3 , 0x1 ldr r3 , [ fp , - 0x10 ] str r2 , [ r3 , 0x58 ] ldr r3 , [ fp , - 0x10 ] ldr r3 , [ r3 , 0x5c ] str r3 , [ fp , - 0x8 ] ldr r3 , [ fp , - 0x10 ] ldr r3 , [ r3 , 0x5c ] add r2 , r3 , 0x1 ldr r3 , [ fp , - 0x10 ] str r2 , [ r3 , 0x5c ] ldr r3 , [ fp , - 0x14 ] cmp r3 , 0x0 bne 0x88 ldr r3 , [ pc , 0x48c ] str r3 , [ fp , - 0x14 ] ldr r3 , [ fp , 0xc ] cmp r3 , 0x0 beq 0xb4 ldr r1 , [ fp , 0xc ] ldr r0 , [ fp , - 0x10 ] bl 0xffffedec mov r3 , r0 cmp r3 , 0x0 bne 0x358 mov r3 , 0x0 b 0x508 ldr r3 , [ fp , 0x8 ] cmp r3 , 0x0 beq 0x210 ldr r3 , [ fp , - 0x10 ] ldr r3 , [ r3 , 0x28 ] cmp r3 , 0x0 beq 0xf8 ldr r3 , [ fp , - 0x10 ] add r3 , r3 , 0x28 mov r1 , r3 ldr r0 , [ fp , - 0x10 ] bl 0xffffedec mov r3 , r0 cmp r3 , 0x0 bne 0x358 mov r3 , 0x0 b 0x508 ldr r3 , [ fp , - 0x10 ] add r3 , r3 , 0x28 mov r1 , r3 ldr r0 , [ fp , - 0x10 ] bl 0xffffedec mov r3 , r0 cmp r3 , 0x0 beq 0x208 ldr r3 , [ fp , - 0x10 ] ldr r3 , [ r3 , 0xc ] ldr r3 , [ r3 , 0x4 ] ldr r2 , [ pc , 0x3ec ] cmp r3 , r2 bhi 0x15c ldr r3 , [ fp , - 0x10 ] ldr r1 , [ r3 , 0xc ] ldr r3 , [ fp , - 0x10 ] ldr r2 , [ r3 , 0xc ] ldr r3 , [ r2 , 0x4 ] add r0 , r3 , 0x1 str r0 , [ r2 , 0x4 ] add r3 , r1 , r3 mvn r2 , 0x7 strb r2 , [ r3 , 0x8 ] b 0x174 mov r1 , 0xf8 ldr r0 , [ fp , - 0x10 ] bl 0xffffef00 mov r3 , r0 cmp r3 , 0x0 beq 0x208 ldr r3 , [ fp , - 0x10 ] ldr r3 , [ r3 , 0xc ] ldr r3 , [ r3 , 0x4 ] ldr r2 , [ pc , 0x390 ] cmp r3 , r2 bhi 0x1b8 ldr r3 , [ fp , - 0x10 ] ldr r1 , [ r3 , 0xc ] ldr r3 , [ fp , - 0x10 ] ldr r2 , [ r3 , 0xc ] ldr r3 , [ r2 , 0x4 ] add r0 , r3 , 0x1 str r0 , [ r2 , 0x4 ] add r3 , r1 , r3 mov r2 , 0x1 strb r2 , [ r3 , 0x8 ] b 0x1d0 mov r1 , 0x1 ldr r0 , [ fp , - 0x10 ] bl 0xffffef00 mov r3 , r0 cmp r3 , 0x0 beq 0x208 mov r1 , 0x0 ldr r0 , [ fp , - 0x10 ] bl 0xfffff100 mov r3 , r0 cmp r3 , 0x0 beq 0x208 ldr r3 , [ fp , - 0x10 ] ldr r3 , [ r3 , 0x14 ] mov r1 , r3 ldr r0 , [ fp , - 0x10 ] bl 0xfffff3c4 mov r3 , r0 cmp r3 , 0x0 bne 0x358 mov r3 , 0x0 b 0x508 ldr r3 , [ fp , - 0x10 ] ldr r3 , [ r3 , 0x18 ] cmp r3 , 0x0 beq 0x248 ldr r3 , [ fp , - 0x10 ] add r3 , r3 , 0x18 mov r1 , r3 ldr r0 , [ fp , - 0x10 ] bl 0xffffedec mov r3 , r0 cmp r3 , 0x0 bne 0x358 mov r3 , 0x0 b 0x508 ldr r3 , [ fp , - 0x10 ] add r3 , r3 , 0x18 mov r1 , r3 ldr r0 , [ fp , - 0x10 ] bl 0xffffedec mov r3 , r0 cmp r3 , 0x0 beq 0x350 ldr r3 , [ fp , - 0x10 ] ldr r3 , [ r3 , 0xc ] ldr r3 , [ r3 , 0x4 ] ldr r2 , [ pc , 0x29c ] cmp r3 , r2 bhi 0x2ac ldr r3 , [ fp , - 0x10 ] ldr r1 , [ r3 , 0xc ] ldr r3 , [ fp , - 0x10 ] ldr r2 , [ r3 , 0xc ] ldr r3 , [ r2 , 0x4 ] add r0 , r3 , 0x1 str r0 , [ r2 , 0x4 ] add r3 , r1 , r3 mvn r2 , 0x7 strb r2 , [ r3 , 0x8 ] b 0x2c4 mov r1 , 0xf8 ldr r0 , [ fp , - 0x10 ] bl 0xffffef00 mov r3 , r0 cmp r3 , 0x0 beq 0x350 ldr r3 , [ fp , - 0x10 ] ldr r3 , [ r3 , 0xc ] ldr r3 , [ r3 , 0x4 ] ldr r2 , [ pc , 0x240 ] cmp r3 , r2 bhi 0x308 ldr r3 , [ fp , - 0x10 ] ldr r1 , [ r3 , 0xc ] ldr r3 , [ fp , - 0x10 ] ldr r2 , [ r3 , 0xc ] ldr r3 , [ r2 , 0x4 ] add r0 , r3 , 0x1 str r0 , [ r2 , 0x4 ] add r3 , r1 , r3 mov r2 , 0x2 strb r2 , [ r3 , 0x8 ] b 0x320 mov r1 , 0x2 ldr r0 , [ fp , - 0x10 ] bl 0xffffef00 mov r3 , r0 cmp r3 , 0x0 beq 0x350 mov r1 , 0x0 ldr r0 , [ fp , - 0x10 ] bl 0xfffff100 mov r3 , r0 cmp r3 , 0x0 beq 0x350 ldr r1 , [ pc , 0x1d4 ] ldr r0 , [ fp , - 0x10 ] bl 0xfffff3c4 mov r3 , r0 cmp r3 , 0x0 bne 0x358 mov r3 , 0x0 b 0x508 ldr r3 , [ fp , 0x8 ] str r3 , [ sp ] ldr r3 , [ fp , 0x4 ] ldr r2 , [ fp , - 0x1c ] ldr r1 , [ fp , - 0xc ] ldr r0 , [ fp , - 0x10 ] bl 0xfffff7e0 mov r3 , r0 cmp r3 , 0x0 bne 0x388 mov r3 , 0x0 b 0x508 ldr r3 , [ fp , - 0x10 ] ldr r3 , [ r3 , 0xc ] ldr r3 , [ r3 , 0x4 ] ldr r2 , [ pc , 0x17c ] cmp r3 , r2 bhi 0x3cc ldr r3 , [ fp , - 0x10 ] ldr r1 , [ r3 , 0xc ] ldr r3 , [ fp , - 0x10 ] ldr r2 , [ r3 , 0xc ] ldr r3 , [ r2 , 0x4 ] add r0 , r3 , 0x1 str r0 , [ r2 , 0x4 ] add r3 , r1 , r3 mvn r2 , 0xf strb r2 , [ r3 , 0x8 ] b 0x3e4 mov r1 , 0xf0 ldr r0 , [ fp , - 0x10 ] bl 0xffffef00 mov r3 , r0 cmp r3 , 0x0 beq 0x504 ldr r1 , [ fp , - 0x8 ] ldr r0 , [ fp , - 0x10 ] bl 0xfffff100 mov r3 , r0 cmp r3 , 0x0 beq 0x504 ldr r1 , [ fp , - 0x14 ] ldr r0 , [ fp , - 0x10 ] bl 0xfffff3c4 mov r3 , r0 cmp r3 , 0x0 beq 0x504 ldr r3 , [ fp , - 0x10 ] ldr r3 , [ r3 , 0xc ] ldr r3 , [ r3 , 0x4 ] ldr r2 , [ pc , 0xf0 ] cmp r3 , r2 bhi 0x458 ldr r3 , [ fp , - 0x10 ] ldr r1 , [ r3 , 0xc ] ldr r3 , [ fp , - 0x10 ] ldr r2 , [ r3 , 0xc ] ldr r3 , [ r2 , 0x4 ] add r0 , r3 , 0x1 str r0 , [ r2 , 0x4 ] add r3 , r1 , r3 mvn r2 , 0xd strb r2 , [ r3 , 0x8 ] b 0x470 mov r1 , 0xf2 ldr r0 , [ fp , - 0x10 ] bl 0xffffef00 mov r3 , r0 cmp r3 , 0x0 beq 0x504 ldr r1 , [ fp , - 0xc ] ldr r0 , [ fp , - 0x10 ] bl 0xfffff100 mov r3 , r0 cmp r3 , 0x0 beq 0x504 ldr r3 , [ fp , - 0x10 ] ldr r3 , [ r3 , 0xc ] ldr r3 , [ r3 , 0x4 ] ldr r2 , [ pc , 0x7c ] cmp r3 , r2 bhi 0x4cc ldr r3 , [ fp , - 0x10 ] ldr r1 , [ r3 , 0xc ] ldr r3 , [ fp , - 0x10 ] ldr r2 , [ r3 , 0xc ] ldr r3 , [ r2 , 0x4 ] add r0 , r3 , 0x1 str r0 , [ r2 , 0x4 ] add r3 , r1 , r3 mvn r2 , 0x31 strb r2 , [ r3 , 0x8 ] b 0x4e4 mov r1 , 0xce ldr r0 , [ fp , - 0x10 ] bl 0xffffef00 mov r3 , r0 cmp r3 , 0x0 beq 0x504 ldr r1 , [ fp , - 0x8 ] ldr r0 , [ fp , - 0x10 ] bl 0xfffff100 mov r3 , r0 cmp r3 , 0x0 beq 0x504 mov r3 , 0x1 b 0x508 mov r3 , 0x0 mov r0 , r3 sub sp , fp , 0x4 pop { fp , pc } andseq r8 , r6 , r8 , lsl sl andeq r0 , r0 , sb , ror 0x3
Similarity: -1
Label: 1
Similarity Score: 0.3
Explanation: Both codes share some structural similarities, like checking for -1 values and updating registers at offsets 0x58/0x5c. However, significant differences exist: Code1 uses direct register operations with minimal stack usage (only 0x8 bytes) and manages multiple registers (r4-r8), while Code2 relies heavily on frame-pointer-based stack operations (0x20 bytes) with different branching patterns. Core operations (e.g., memory writes with `mvn` vs. `mov`, function calls to distinct addresses like 0xffffcd64 vs. 0xffffedec) and control flow diverge substantially. The shared logic is insufficient to indicate similarity given these structural and operational differences.
------------------------------------------------------------

------------------------------------------------------------
Code1: push ebp mov ebp , esp sub esp , 0x8 mov eax , dword ptr [ ebp + 0x8 ] mov ecx , dword ptr [ ebp + 0x8 ] mov dword ptr [ esp ] , ecx mov dword ptr [ ebp - 0x4 ] , eax call 0xfffffe30 add esp , 0x8 pop ebp ret nop dword ptr [ eax ]
Code2: push ebp mov ebp , esp sub esp , 0x8 call 0xffffaf4d add eax , 0x7b51 sub esp , 0xc push dword ptr [ ebp + 0x8 ] call 0x20 add esp , 0x10 leave ret
Similarity: -1
Label: 1
Similarity Score: 0.25
Explanation: Both codes share a common function prologue (push ebp; mov ebp, esp; sub esp, 0x8) and epilogue (ret). However, Code1 contains argument setup via [ebp+0x8] and a single call, while Code2 has two calls with intermediate arithmetic (add eax) and different stack management (leave vs pop ebp). The core operational logic differs
------------------------------------------------------------

------------------------------------------------------------
Code1: push ebp push edi push esi push ebx call 0xfffeb3e0 add ebx , 0xd210f sub esp , 0x10 mov eax , dword ptr [ esp + 0x28 ] mov edi , dword ptr [ eax ] lea ebp , [ edi * 0x4 ] push ebp push 0x8 push 0x1 call 0xffff69e0 add esp , 0x10 test edi , edi je 0x5e mov dword ptr [ eax ] , edi mov esi , eax lea eax , [ eax + 0x8 ] sub esp , 0x8 mov dword ptr [ esi + 0x4 ] , eax push ebp push eax call 0x7f580 push esi push 0x0 push dword ptr [ esp + 0x3c ] push dword ptr [ esp + 0x3c ] call 0xffffdda0 add esp , 0x2c mov eax , esi pop ebx pop esi pop edi pop ebp ret call 0xfffeacfc lea esi , [ esi ] lea edi , [ edi ]
Code2: push r12 push rbp push rbx mov r12 , rdi mov rbp , rsi mov rdi , qword ptr [ rsi ] call 0xffffffffffffd4d3 mov rbx , rax mov rcx , rax mov edx , 0x0 mov rsi , rbp mov rdi , r12 call 0xfffffffffffff9f6 mov rax , rbx pop rbx pop rbp pop r12 ret
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The codes are fundamentally dissimilar due to architectural differences (32-bit vs 64-bit), distinct register usage, and divergent operational logic. Code1 uses 32-bit registers (e.g., eax, ebx) with stack-based operations and explicit stack cleanup (add esp), while Code2 employs 64-bit registers (e.g., r12, rbp) with register-based parameter passing and no stack cleanup. The control flow, memory operations (dword vs qword), and function prologues/epilogues also differ significantly. No meaningful overlap exists beyond basic instructions like push/call/ret, which are too generic to indicate similarity.
------------------------------------------------------------

------------------------------------------------------------
Code1: sub esp , 0x8 lea eax , [ ebp - 0x701c ] push eax lea eax , [ ebx - 0xbd952 ] push eax call 0xfff8d7b9 add esp , 0x10 test eax , eax jne 0x196 mov eax , dword ptr [ ebp - 0x72d8 ] push dword ptr [ ebp - 0x7294 ] push dword ptr [ ebp - 0x7290 ] lea edx , [ ebp - 0x72d8 ] push edx push eax call 0xfff8dbe9 add esp , 0x10 mov eax , dword ptr [ ebp - 0x7294 ] movzx eax , byte ptr [ eax ] test al , al jne 0x5f mov dword ptr [ ebp - 0x72c4 ] , 0x0 jmp 0x538f mov eax , dword ptr [ ebp - 0x72ac ] lea edx , [ eax * 0x4 ] mov eax , dword ptr [ ebp - 0x72c8 ] add eax , edx mov eax , dword ptr [ eax ] mov eax , dword ptr [ eax + 0x37c ] sub esp , 0x8 push eax push dword ptr [ ebp - 0x7294 ] call 0xfff8d7b9 add esp , 0x10 test eax , eax je 0x532e sub esp , 0x8 push dword ptr [ ebp - 0x7294 ] push dword ptr [ ebp - 0x728c ] call 0xfff8be39 add esp , 0x10 mov dword ptr [ ebp - 0x7244 ] , eax cmp dword ptr [ ebp - 0x7244 ] , 0x0 je 0x5331 mov eax , dword ptr [ ebp - 0x7310 ] cmp eax , dword ptr [ ebp - 0x72cc ] jbe 0x5331 mov edx , dword ptr [ ebp - 0x7310 ] mov eax , dword ptr [ ebp - 0x72cc ] sub edx , eax mov eax , edx mov dword ptr [ ebp - 0x7240 ] , eax sub esp , 0xc push dword ptr [ ebp - 0x72cc ] call 0xfff8bd19 add esp , 0x10 mov dword ptr [ ebp - 0x70e8 ] , eax mov edx , dword ptr [ ebp - 0x70e8 ] mov eax , dword ptr [ ebp - 0x7240 ] add eax , edx mov byte ptr [ eax ] , 0x0 sub esp , 0x8 push dword ptr [ ebp - 0x7244 ] lea eax , [ ebp - 0x70e8 ] push eax call 0xfff8cdd9 add esp , 0x10 sub esp , 0x8 lea eax , [ ebx - 0xbd94c ] push eax lea eax , [ ebp - 0x70e8 ] push eax call 0xfff8cdd9 add esp , 0x10 mov eax , dword ptr [ ebp - 0x72d8 ] sub esp , 0x8 push eax lea eax , [ ebp - 0x70e8 ] push eax call 0xfff8cdd9 add esp , 0x10 sub esp , 0xc push dword ptr [ ebp - 0x72cc ] call 0xfff8da19 add esp , 0x10 mov dword ptr [ ebp - 0x72cc ] , eax mov eax , dword ptr [ ebp - 0x70e8 ] mov dword ptr [ ebp - 0x72cc ] , eax mov edx , dword ptr [ ebp - 0x7240 ] mov eax , dword ptr [ ebp - 0x72cc ] add eax , edx mov dword ptr [ ebp - 0x72d8 ] , eax jmp 0x5331 sub esp , 0x8 lea eax , [ ebp - 0x701c ] push eax lea eax , [ ebx - 0xbd94a ] push eax call 0xfff8d7b9 add esp , 0x10 test eax , eax jne 0x3fa mov eax , dword ptr [ ebp - 0x72d8 ] push dword ptr [ ebp - 0x7294 ] push dword ptr [ ebp - 0x7290 ] lea edx , [ ebp - 0x72d8 ] push edx push eax call 0xfff8dbe9 add esp , 0x10 mov eax , dword ptr [ ebp - 0x7294 ] movzx eax , byte ptr [ eax ] test al , al jne 0x1f5 mov dword ptr [ ebp - 0x72c4 ] , 0x0 jmp 0x538f mov eax , dword ptr [ ebp - 0x72ac ] lea edx , [ eax * 0x4 ] mov eax , dword ptr [ ebp - 0x72c8 ] add eax , edx mov eax , dword ptr [ eax ] add eax , 0x278 sub esp , 0x8 push dword ptr [ ebp - 0x7294 ] push eax call 0xfff8ca59 add esp , 0x10 sub esp , 0x8 push dword ptr [ ebp - 0x7294 ] push dword ptr [ ebp - 0x728c ] call 0xfff8be39 add esp , 0x10 mov dword ptr [ ebp - 0x7248 ] , eax cmp dword ptr [ ebp - 0x7248 ] , 0x0 je 0x5334 mov eax , dword ptr [ ebp - 0x72ac ] lea edx , [ eax * 0x4 ] mov eax , dword ptr [ ebp - 0x72c8 ] add eax , edx mov eax , dword ptr [ eax ] mov eax , dword ptr [ eax + 0x370 ] test eax , eax je 0x2b4 mov eax , dword ptr [ ebp - 0x72ac ] lea edx , [ eax * 0x4 ] mov eax , dword ptr [ ebp - 0x72c8 ] add eax , edx mov eax , dword ptr [ eax ] mov edx , dword ptr [ eax + 0x370 ] mov eax , dword ptr [ ebp - 0x72ac ] lea ecx , [ eax * 0x4 ] mov eax , dword ptr [ ebp - 0x72c8 ] add eax , ecx mov esi , dword ptr [ eax ] sub esp , 0xc push edx call 0xfff8de59 add esp , 0x10 mov dword ptr [ esi + 0x370 ] , eax mov eax , dword ptr [ ebp - 0x72ac ] lea edx , [ eax * 0x4 ] mov eax , dword ptr [ ebp - 0x72c8 ] add eax , edx mov edx , dword ptr [ eax ] mov eax , dword ptr [ ebp - 0x72ac ] lea ecx , [ eax * 0x4 ] mov eax , dword ptr [ ebp - 0x72c8 ] add eax , ecx mov esi , dword ptr [ eax ] sub esp , 0xc push dword ptr [ ebp - 0x72f4 ] push dword ptr [ ebp - 0x7248 ] push dword ptr [ ebp - 0x7294 ] push edx push dword ptr [ ebp - 0x72ec ] call 0xffffd487 add esp , 0x20 mov dword ptr [ esi + 0x370 ] , eax mov eax , dword ptr [ ebp - 0x72ac ] lea edx , [ eax * 0x4 ] mov eax , dword ptr [ ebp - 0x72c8 ] add eax , edx mov eax , dword ptr [ eax ] mov eax , dword ptr [ eax + 0x374 ] cmp eax , 0x1 je 0x5334 mov eax , dword ptr [ ebp - 0x72ac ] lea edx , [ eax * 0x4 ] mov eax , dword ptr [ ebp - 0x72c8 ] add eax , edx mov eax , dword ptr [ eax ] mov eax , dword ptr [ eax + 0x278 ] sub esp , 0x8 push eax push dword ptr [ ebp - 0x728c ] call 0xfff8be39 add esp , 0x10 mov dword ptr [ ebp - 0x7248 ] , eax cmp dword ptr [ ebp - 0x7248 ] , 0x0 je 0x3a5 mov eax , dword ptr [ ebp - 0x72ac ] lea edx , [ eax * 0x4 ] mov eax , dword ptr [ ebp - 0x72c8 ] add eax , edx mov eax , dword ptr [ eax ] mov eax , dword ptr [ eax + 0x278 ] sub esp , 0x4 push dword ptr [ ebp - 0x7248 ] push eax push dword ptr [ ebp - 0x72ec ] call 0xfff8e3f9 add esp , 0x10 mov eax , dword ptr [ ebp - 0x72ac ] lea edx , [ eax * 0x4 ] mov eax , dword ptr [ ebp - 0x72c8 ] add eax , edx mov eax , dword ptr [ eax ] mov edx , dword ptr [ eax + 0x278 ] mov eax , dword ptr [ ebp - 0x72ac ] lea ecx , [ eax * 0x4 ] mov eax , dword ptr [ ebp - 0x72c8 ] add eax , ecx mov eax , dword ptr [ eax ] push dword ptr [ ebp - 0x72f4 ] push edx push eax push dword ptr [ ebp - 0x72ec ] call 0xfff8d3f9 add esp , 0x10 and dword ptr [ ebp - 0x72c4 ] , eax jmp 0x5334 sub esp , 0x8 lea eax , [ ebp - 0x701c ] push eax lea eax , [ ebx - 0xbd940 ] push eax call 0xfff8d7b9 add esp , 0x10 test eax , eax jne 0x494 mov eax , dword ptr [ ebp - 0x72d8 ] push dword ptr [ ebp - 0x7294 ] push dword ptr [ ebp - 0x7290 ] lea edx , [ ebp - 0x72d8 ] push edx push eax call 0xfff8dbe9 add esp , 0x10 sub esp , 0x4 push dword ptr [ ebp - 0x7294 ] push 0x0 push 0x1a call 0xfff8c2a9 add esp , 0x10 mov dword ptr [ ebp - 0x724c ] , eax cmp dword ptr [ ebp - 0x724c ] , - 0x1 jne 0x46c mov dword ptr [ ebp - 0x72c4 ] , 0x0 jmp 0x538f mov eax , dword ptr [ ebp - 0x72ac ] lea edx , [ eax * 0x4 ] mov eax , dword ptr [ ebp - 0x72c8 ] add eax , edx mov eax , dword ptr [ eax ] mov edx , dword ptr [ ebp - 0x724c ] mov dword ptr [ eax + 0x218 ] , edx jmp 0x538f sub esp , 0x8 lea eax , [ ebp - 0x701c ] push eax lea eax , [ ebx - 0xbd936 ] push eax call 0xfff8d7b9 add esp , 0x10 test eax , eax jne 0x599 mov eax , dword ptr [ ebp - 0x72d8 ] push dword ptr [ ebp - 0x7294 ] push dword ptr [ ebp - 0x7290 ] lea edx , [ ebp - 0x72d8 ] push edx push eax call 0xfff8dbe9 add esp , 0x10 sub esp , 0x4 push dword ptr [ ebp - 0x7294 ] push 0x0 push 0x6 call 0xfff8c2a9 add esp , 0x10 mov dword ptr [ ebp - 0x7250 ] , eax cmp dword ptr [ ebp - 0x7250 ] , - 0x1 jne 0x50a mov dword ptr [ ebp - 0x72c4 ] , 0x0 jmp 0x538f mov eax , dword ptr [ ebp - 0x72ac ] lea edx , [ eax * 0x4 ] mov eax , dword ptr [ ebp - 0x72c8 ] add eax , edx mov eax , dword ptr [ eax ] mov edx , dword ptr [ ebp - 0x7250 ] mov dword ptr [ eax + 0x29c ] , edx cmp dword ptr [ ebp - 0x7250 ] , 0x3 jne 0x5337 sub esp , 0xc lea eax , [ ebp - 0x7118 ] push eax call 0xfff8e2b9 add esp , 0x10 mov eax , dword ptr [ ebp - 0x72f0 ] fld qword ptr [ eax + 0x28c ] fstp qword ptr [ ebp - 0x7148 ] mov eax , dword ptr [ ebp - 0x72f0 ] fld qword ptr [ eax + 0x294 ] fstp qword ptr [ ebp - 0x7130 ] mov eax , dword ptr [ ebp - 0x72f0 ] fld qword ptr [ eax + 0x27c ] fstp qword ptr [ ebp - 0x7128 ] mov eax , dword ptr [ ebp - 0x72f0 ] fld qword ptr [ eax + 0x284 ] fstp qword ptr [ ebp - 0x7120 ] jmp 0x538f sub esp , 0x8 lea eax , [ ebp - 0x701c ] push eax lea eax , [ ebx - 0xbd92b ] push eax call 0xfff8d7b9 add esp , 0x10 test eax , eax jne 0x5c5 mov dword ptr [ ebp - 0x72c0 ] , 0x4 jmp 0x538f sub esp , 0x8 lea eax , [ ebp - 0x701c ] push eax lea eax , [ ebx - 0xbd924 ] push eax call 0xfff8d7b9 add esp , 0x10 test eax , eax jne 0x5f1 mov dword ptr [ ebp - 0x72c0 ] , 0x5 jmp 0x538f sub esp , 0x8 lea eax , [ ebp - 0x701c ] push eax lea eax , [ ebx - 0xbd91e ] push eax call 0xfff8d7b9 add esp , 0x10 test eax , eax jne 0x66b mov eax , dword ptr [ ebp - 0x72d8 ] push dword ptr [ ebp - 0x7294 ] push dword ptr [ ebp - 0x7290 ] lea edx , [ ebp - 0x72d8 ] push edx push eax call 0xfff8dbe9 add esp , 0x10 sub esp , 0x4 push dword ptr [ ebp - 0x7294 ] push 0x0 push 0xc call 0xfff8c2a9 add esp , 0x10 mov ecx , eax mov eax , dword ptr [ ebp - 0x72ac ] lea edx , [ eax * 0x4 ] mov eax , dword ptr [ ebp - 0x72c8 ] add eax , edx mov eax , dword ptr [ eax ] mov edx , ecx mov dword ptr [ eax + 0x374 ] , edx jmp 0x538f mov dword ptr [ ebp - 0x72c4 ] , 0x0 jmp 0x538f
Code2: fld qword ptr [ esi ] fmul st ( 0x4 ) fld st ( 0x3 ) fsubr dword ptr [ ebx - 0x137dc8 ] fmulp st ( 0x1 ) fld qword ptr [ esp + 0xdc ] fmul st ( 0x4 ) faddp st ( 0x1 ) fmul st ( 0x1 ) fstp qword ptr [ esi ] jmp 0xfffffce0 lea esi , [ esi ]
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two code snippets are fundamentally dissimilar. The first is a complex sequence with multiple function calls (call instructions), stack operations (push/pop), conditional jumps (jne/je), and extensive memory manipulation using ebp/esp registers. The second snippet exclusively performs floating-point operations (fld/fmul/faddp) using x87 FPU instructions and has no function calls, conditionals, or stack management. There are no overlapping instructions, control flow patterns, or functional similarities between them.
------------------------------------------------------------

------------------------------------------------------------
Code1: push ebp mov ebp , esp push ebx push edi push esi sub esp , 0x1c mov eax , dword ptr [ ebp + 0xc ] mov ecx , dword ptr [ ebp + 0x8 ] cmp dword ptr [ 0x80caab4 ] , 0x0 mov dword ptr [ ebp - 0x10 ] , eax mov dword ptr [ ebp - 0x14 ] , ecx jne 0x3a6 mov al , byte ptr [ 0x80c303b ] xor al , 0xee mov byte ptr [ 0x80c3042 ] , al mov al , byte ptr [ 0x80c303c ] xor al , 0xac mov byte ptr [ 0x80c3043 ] , al mov al , byte ptr [ 0x80c303d ] xor al , 0x1d mov byte ptr [ 0x80c3044 ] , al mov al , byte ptr [ 0x80c303e ] xor al , 0xec mov byte ptr [ 0x80c3045 ] , al mov al , byte ptr [ 0x80c303f ] xor al , 0x58 mov byte ptr [ 0x80c3046 ] , al mov al , byte ptr [ 0x80c3040 ] xor al , 0x89 mov byte ptr [ 0x80c3047 ] , al mov al , byte ptr [ 0x80c3041 ] xor al , 0xa9 mov byte ptr [ 0x80c3048 ] , al mov al , byte ptr [ 0x80c3050 ] xor al , 0x6d mov byte ptr [ 0x80c3070 ] , al mov al , byte ptr [ 0x80c3051 ] xor al , 0x9a mov byte ptr [ 0x80c3071 ] , al mov al , byte ptr [ 0x80c3052 ] xor al , 0x91 mov byte ptr [ 0x80c3072 ] , al mov al , byte ptr [ 0x80c3053 ] xor al , 0x10 mov byte ptr [ 0x80c3073 ] , al mov al , byte ptr [ 0x80c3054 ] xor al , 0xe8 mov byte ptr [ 0x80c3074 ] , al mov al , byte ptr [ 0x80c3055 ] xor al , 0xa5 mov byte ptr [ 0x80c3075 ] , al mov al , byte ptr [ 0x80c3056 ] xor al , 0xdc mov byte ptr [ 0x80c3076 ] , al mov al , byte ptr [ 0x80c3057 ] xor al , 0xda mov byte ptr [ 0x80c3077 ] , al mov al , byte ptr [ 0x80c3058 ] xor al , 0xf3 mov byte ptr [ 0x80c3078 ] , al mov al , byte ptr [ 0x80c3059 ] xor al , 0xb1 mov byte ptr [ 0x80c3079 ] , al mov al , byte ptr [ 0x80c305a ] xor al , 0xd4 mov byte ptr [ 0x80c307a ] , al mov al , byte ptr [ 0x80c305b ] xor al , 0xc8 mov byte ptr [ 0x80c307b ] , al mov al , byte ptr [ 0x80c305c ] xor al , 0xee mov byte ptr [ 0x80c307c ] , al mov al , byte ptr [ 0x80c305d ] xor al , 0x40 mov byte ptr [ 0x80c307d ] , al mov al , byte ptr [ 0x80c305e ] xor al , 0x92 mov byte ptr [ 0x80c307e ] , al mov al , byte ptr [ 0x80c305f ] xor al , 0x80 mov byte ptr [ 0x80c307f ] , al mov al , byte ptr [ 0x80c3060 ] xor al , 0x21 mov byte ptr [ 0x80c3080 ] , al mov al , byte ptr [ 0x80c3061 ] xor al , 0xe0 mov byte ptr [ 0x80c3081 ] , al mov al , byte ptr [ 0x80c3062 ] xor al , 0x17 mov byte ptr [ 0x80c3082 ] , al mov al , byte ptr [ 0x80c3063 ] xor al , 0xdc mov byte ptr [ 0x80c3083 ] , al mov al , byte ptr [ 0x80c3064 ] xor al , 0x7f mov byte ptr [ 0x80c3084 ] , al mov al , byte ptr [ 0x80c3065 ] xor al , 0x66 mov byte ptr [ 0x80c3085 ] , al mov al , byte ptr [ 0x80c3090 ] xor al , 0x32 mov byte ptr [ 0x80c30c0 ] , al mov al , byte ptr [ 0x80c3091 ] xor al , 0xf7 mov byte ptr [ 0x80c30c1 ] , al mov al , byte ptr [ 0x80c3092 ] xor al , 0x56 mov byte ptr [ 0x80c30c2 ] , al mov al , byte ptr [ 0x80c3093 ] xor al , 0x31 mov byte ptr [ 0x80c30c3 ] , al mov al , byte ptr [ 0x80c3094 ] xor al , 0xbf mov byte ptr [ 0x80c30c4 ] , al mov al , byte ptr [ 0x80c3095 ] xor al , 0x84 mov byte ptr [ 0x80c30c5 ] , al mov al , byte ptr [ 0x80c3096 ] xor al , 0x99 mov byte ptr [ 0x80c30c6 ] , al mov al , byte ptr [ 0x80c3097 ] xor al , 0xef mov byte ptr [ 0x80c30c7 ] , al mov al , byte ptr [ 0x80c3098 ] xor al , 0x73 mov byte ptr [ 0x80c30c8 ] , al mov al , byte ptr [ 0x80c3099 ] xor al , 0x4a mov byte ptr [ 0x80c30c9 ] , al mov al , byte ptr [ 0x80c309a ] xor al , 0x7b mov byte ptr [ 0x80c30ca ] , al mov al , byte ptr [ 0x80c309b ] xor al , 0xc4 mov byte ptr [ 0x80c30cb ] , al mov al , byte ptr [ 0x80c309c ] xor al , 0xe7 mov byte ptr [ 0x80c30cc ] , al mov al , byte ptr [ 0x80c309d ] xor al , 0xbf mov byte ptr [ 0x80c30cd ] , al mov al , byte ptr [ 0x80c309e ] xor al , 0xf3 mov byte ptr [ 0x80c30ce ] , al mov al , byte ptr [ 0x80c309f ] xor al , 0xa5 mov byte ptr [ 0x80c30cf ] , al mov al , byte ptr [ 0x80c30a0 ] xor al , 0x32 mov byte ptr [ 0x80c30d0 ] , al mov al , byte ptr [ 0x80c30a1 ] xor al , 0x49 mov byte ptr [ 0x80c30d1 ] , al mov al , byte ptr [ 0x80c30a2 ] xor al , 0xd3 mov byte ptr [ 0x80c30d2 ] , al mov al , byte ptr [ 0x80c30a3 ] xor al , 0x45 mov byte ptr [ 0x80c30d3 ] , al mov al , byte ptr [ 0x80c30a4 ] xor al , 0xd4 mov byte ptr [ 0x80c30d4 ] , al mov al , byte ptr [ 0x80c30a5 ] xor al , 0x32 mov byte ptr [ 0x80c30d5 ] , al mov al , byte ptr [ 0x80c30a6 ] xor al , 0x48 mov byte ptr [ 0x80c30d6 ] , al mov al , byte ptr [ 0x80c30a7 ] xor al , 0xda mov byte ptr [ 0x80c30d7 ] , al mov al , byte ptr [ 0x80c30a8 ] xor al , 0x7f mov byte ptr [ 0x80c30d8 ] , al mov al , byte ptr [ 0x80c30a9 ] xor al , 0x71 mov byte ptr [ 0x80c30d9 ] , al mov al , byte ptr [ 0x80c30aa ] xor al , 0x1f mov byte ptr [ 0x80c30da ] , al mov al , byte ptr [ 0x80c30ab ] xor al , 0x84 mov byte ptr [ 0x80c30db ] , al mov al , byte ptr [ 0x80c30ac ] xor al , 0x54 mov byte ptr [ 0x80c30dc ] , al mov al , byte ptr [ 0x80c30ad ] xor al , 0x1d mov byte ptr [ 0x80c30dd ] , al mov al , byte ptr [ 0x80c30ae ] xor al , 0xb1 mov byte ptr [ 0x80c30de ] , al mov al , byte ptr [ 0x80c30af ] xor al , 0xe0 mov byte ptr [ 0x80c30df ] , al mov al , byte ptr [ 0x80c30b0 ] xor al , 0xa4 mov byte ptr [ 0x80c30e0 ] , al mov al , byte ptr [ 0x80c30b1 ] xor al , 0x86 mov byte ptr [ 0x80c30e1 ] , al mov al , byte ptr [ 0x80c30b2 ] xor al , 0xea mov byte ptr [ 0x80c30e2 ] , al mov al , byte ptr [ 0x80c30b3 ] xor al , 0xe7 mov byte ptr [ 0x80c30e3 ] , al mov al , byte ptr [ 0x80c30b4 ] xor al , 0xb7 mov byte ptr [ 0x80c30e4 ] , al mov al , byte ptr [ 0x80c30b5 ] xor al , 0x2e mov byte ptr [ 0x80c30e5 ] , al mov al , byte ptr [ 0x80c30b6 ] xor al , 0xc mov byte ptr [ 0x80c30e6 ] , al mov al , byte ptr [ 0x80c30b7 ] xor al , 0x32 mov byte ptr [ 0x80c30e7 ] , al mov al , byte ptr [ 0x80c30b8 ] xor al , 0xf0 mov byte ptr [ 0x80c30e8 ] , al mov al , byte ptr [ 0x80c30b9 ] xor al , 0xd0 mov byte ptr [ 0x80c30e9 ] , al mov al , byte ptr [ 0x80c30ba ] xor al , 0xed mov byte ptr [ 0x80c30ea ] , al mov al , byte ptr [ 0x80c30bb ] xor al , 0x2e mov byte ptr [ 0x80c30eb ] , al mov al , byte ptr [ 0x80c30bc ] xor al , 0x70 mov byte ptr [ 0x80c30ec ] , al mov al , byte ptr [ 0x80c30bd ] xor al , 0x4f mov byte ptr [ 0x80c30ed ] , al mov dword ptr [ 0x80caab4 ] , 0x1 mov eax , esp add eax , - 0x10 mov esp , eax mov ecx , esp add ecx , - 0x10 mov esp , ecx mov edx , esp add edx , - 0x10 mov esp , edx mov esi , esp add esi , - 0x10 mov esp , esi mov edi , dword ptr [ ebp - 0x14 ] mov dword ptr [ ecx ] , edi mov ebx , dword ptr [ ebp - 0x10 ] mov dword ptr [ edx ] , ebx mov edi , 0xffffff9c cmp edi , dword ptr [ 0x80cbfa4 ] mov dword ptr [ ebp - 0x18 ] , eax mov dword ptr [ ebp - 0x1c ] , ecx mov dword ptr [ ebp - 0x20 ] , edx mov dword ptr [ ebp - 0x24 ] , esi je 0x43a cmp dword ptr [ 0x80cbfa4 ] , 0x0 jl 0x405 jmp 0x435 lea eax , [ 0x80c30c0 ] lea ecx , [ 0x80c3042 ] lea edx , [ 0x80c3070 ] sub esp , 0x10 mov dword ptr [ esp ] , edx mov dword ptr [ esp + 0x4 ] , ecx mov dword ptr [ esp + 0x8 ] , 0x277 mov dword ptr [ esp + 0xc ] , eax call 0xfffe1bc0 add esp , 0x10 jmp 0x43a mov eax , dword ptr [ ebp - 0x20 ] mov ecx , dword ptr [ eax ] sub esp , 0x10 mov dword ptr [ esp ] , ecx call 0xffffd770 add esp , 0x10 xor eax , eax mov ecx , dword ptr [ 0x80cbfa4 ] mov edx , dword ptr [ ebp - 0x1c ] mov esi , dword ptr [ edx ] mov edi , dword ptr [ ebp - 0x20 ] mov ebx , dword ptr [ edi ] sub esp , 0x10 mov dword ptr [ esp ] , ecx mov dword ptr [ esp + 0x4 ] , esi mov dword ptr [ esp + 0x8 ] , ebx mov dword ptr [ esp + 0xc ] , 0x0 mov dword ptr [ ebp - 0x28 ] , eax call 0x52cc0 add esp , 0x10 xor ecx , ecx mov edx , dword ptr [ ebp - 0x24 ] mov dword ptr [ edx ] , eax cmp ecx , dword ptr [ edx ] jne 0x49d mov eax , dword ptr [ ebp - 0x18 ] mov dword ptr [ eax ] , 0x0 jmp 0x4c7 mov eax , dword ptr [ ebp - 0x1c ] mov ecx , dword ptr [ eax ] mov edx , dword ptr [ ebp - 0x20 ] mov esi , dword ptr [ edx ] mov edi , dword ptr [ ebp - 0x24 ] mov ebx , dword ptr [ edi ] sub esp , 0x10 mov dword ptr [ esp ] , ecx mov dword ptr [ esp + 0x4 ] , esi mov dword ptr [ esp + 0x8 ] , ebx call 0xfffffba0 add esp , 0x10 mov ecx , dword ptr [ ebp - 0x18 ] mov dword ptr [ ecx ] , eax mov eax , dword ptr [ ebp - 0x18 ] mov eax , dword ptr [ eax ] lea esp , [ ebp - 0xc ] pop esi pop edi pop ebx pop ebp ret nop word ptr cs : [ eax + eax ] nop
Code2: push edi push esi push ebx call 0xffffa7f3 add ebx , 0x2d28b mov esi , dword ptr [ esp + 0x10 ] mov edi , dword ptr [ esp + 0x14 ] lea eax , [ ebx + 0x1360 ] mov eax , dword ptr [ eax + 0x10 ] test eax , eax jns 0x28 cmp eax , - 0x64 jne 0x42 sub esp , 0xc push 0x0 push edi push esi push eax push 0x3 call 0xffffa1b3 add esp , 0x20 test eax , eax jne 0x61 pop ebx pop esi pop edi ret lea eax , [ ebx - 0x12cf4 ] push eax push 0x277 lea eax , [ ebx - 0x13294 ] push eax lea eax , [ ebx - 0x1320b ] push eax call 0xffffa753 mov ecx , eax mov edx , edi mov eax , esi call 0xfffffb90 jmp 0x3e
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly codes show fundamental structural and functional differences. Code1 features extensive byte-level XOR operations across multiple fixed memory addresses (0x80c303b-0x80c30bb), complex stack manipulation through repeated ESP adjustments, and calls to absolute addresses (0xfffe1bc0, 0x52cc0). Code2 uses position-independent addressing via EBX-relative offsets, simpler stack operations, and entirely different call targets (0xffffa1b3, 0xffffa753). The control flow in Code1 involves conditional jumps based on global variables, while Code2 relies on register-based comparisons. No significant overlap exists in operations, memory patterns, or control structures, indicating completely distinct functionalities.
------------------------------------------------------------

------------------------------------------------------------
Code1: push { fp , lr } add fp , sp , 0x4 sub sp , sp , 0x10 str r0 , [ fp , - 0x8 ] str r1 , [ fp , - 0xc ] str r2 , [ fp , - 0x10 ] bl 0xffff6b44 mov r3 , r0 ldr r3 , [ r3 ] cmp r3 , 0x2 beq 0x34 cmp r3 , 0x14 bne 0x80 ldr r3 , [ pc , 0x54 ] ldr r3 , [ r3 , 0x2c ] and r3 , r3 , 0x2 cmp r3 , 0x0 beq 0x60 ldr r3 , [ pc , 0x44 ] ldr r3 , [ r3 ] ldr r2 , [ fp , - 0x8 ] ldr r1 , [ pc , 0x3c ] mov r0 , r3 bl 0xffff6b2c ldr r3 , [ pc , 0x34 ] ldr r0 , [ r3 , 0x10 ] mov r3 , 0x100 ldr r2 , [ fp , - 0xc ] ldr r1 , [ fp , - 0x8 ] bl 0x4df0c mov r3 , r0 b 0x84 ldr r3 , [ fp , - 0x10 ] mov r0 , r3 sub sp , fp , 0x4 pop { fp , pc } andeq r2 , r8 , r0 , lsl r2 andeq r1 , r8 , r0 , ror 0x17 andeq fp , r6 , r4 , asr 0x13 andeq r2 , r8 , r4 , ror 0x3
Code2: push ebp mov ebp , esp push esi sub esp , 0x44 mov eax , dword ptr [ ebp + 0x10 ] mov ecx , dword ptr [ ebp + 0xc ] mov edx , dword ptr [ ebp + 0x8 ] mov dword ptr [ ebp - 0xc ] , eax mov dword ptr [ ebp - 0x10 ] , ecx mov dword ptr [ ebp - 0x14 ] , edx call 0xffff4fe0 mov eax , dword ptr [ eax ] mov ecx , eax sub ecx , 0x2 mov dword ptr [ ebp - 0x18 ] , eax mov dword ptr [ ebp - 0x1c ] , ecx je 0xae jmp 0x36 mov eax , dword ptr [ ebp - 0x18 ] sub eax , 0x5 mov dword ptr [ ebp - 0x20 ] , eax je 0x114 jmp 0x4a mov eax , dword ptr [ ebp - 0x18 ] sub eax , 0xd mov dword ptr [ ebp - 0x24 ] , eax je 0x114 jmp 0x5e mov eax , dword ptr [ ebp - 0x18 ] sub eax , 0x14 mov dword ptr [ ebp - 0x28 ] , eax je 0xae jmp 0x72 mov eax , dword ptr [ ebp - 0x18 ] sub eax , 0x24 mov dword ptr [ ebp - 0x2c ] , eax je 0x114 jmp 0x86 mov eax , dword ptr [ ebp - 0x18 ] sub eax , 0x28 mov dword ptr [ ebp - 0x30 ] , eax je 0x114 jmp 0x9a mov eax , dword ptr [ ebp - 0x18 ] sub eax , 0x4b mov dword ptr [ ebp - 0x34 ] , eax je 0x114 jmp 0x11b mov al , byte ptr [ 0x80f80fc ] and al , 0x2 shr al , 0x1 movzx ecx , al mov ecx , dword ptr [ ecx * 0x4 + 0x80d7c08 ] jmp ecx mov eax , dword ptr [ 0x80f7730 ] mov ecx , dword ptr [ ebp + 0x8 ] mov edx , esp mov dword ptr [ edx + 0x8 ] , ecx mov dword ptr [ edx ] , eax mov dword ptr [ edx + 0x4 ] , 0x80ccceb call 0xffff4f90 mov ecx , dword ptr [ 0x80d77b4 ] mov dword ptr [ ebp - 0x38 ] , eax jmp ecx mov eax , dword ptr [ 0x80f80b4 ] mov ecx , dword ptr [ ebp + 0x8 ] mov edx , dword ptr [ ebp + 0xc ] mov esi , esp mov dword ptr [ esi + 0x8 ] , edx mov dword ptr [ esi + 0x4 ] , ecx mov dword ptr [ esi ] , eax mov dword ptr [ esi + 0xc ] , 0x100 call 0x759a0 mov dword ptr [ ebp - 0x8 ] , eax mov eax , dword ptr [ 0x80d77c0 ] jmp eax mov eax , dword ptr [ 0x80d77bc ] jmp eax mov eax , dword ptr [ ebp + 0x10 ] mov dword ptr [ ebp - 0x8 ] , eax mov eax , dword ptr [ 0x80d77c0 ] jmp eax mov eax , dword ptr [ ebp - 0x8 ] add esp , 0x44 pop esi pop ebp ret nop word ptr cs : [ eax + eax ] nop dword ptr [ eax + eax ]
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two code snippets are from different architectures (ARM and x86) and have significantly different instruction sets and control flow structures. The first code uses a two-way branch after comparing a value with 0x2 and 0x14, while the second code implements a jump table with multiple comparisons and indirect jumps. The stack frame setup and function calls are common to many functions but do not indicate substantial similarity. The inherent architectural differences and distinct control flow patterns result in no meaningful similarity.
------------------------------------------------------------

------------------------------------------------------------
Code1: push ebx sub esp , 0x8 call 0xfffce03c add ebx , 0x23092f call 0xe5764 sub esp , 0xc push eax call 0xe4c5a add esp , 0x4 push dword ptr [ esp + 0x1c ] call eax add esp , 0x18 pop ebx ret
Code2: push rbx mov rbx , rdi call 0x12a260 mov rdi , rax call 0x129780 mov rdi , rbx pop rbx jmp rax nop word ptr [ rax + rax ]
Similarity: -1
Label: 1
Similarity Score: 0.15
Explanation: The codes show structural similarities in register preservation (push/pop ebx/rbx) and indirect control flow (call eax/jmp rax). However, significant differences exist: Code1 uses 32-bit architecture with stack-based operations (sub esp/add esp) and direct calls to fixed addresses, while Code2 uses 64-bit architecture with register-based parameter passing (mov rdi) and tail call optimization (jmp rax). The architectural mismatch and operational differences outweigh the limited structural parallels.
------------------------------------------------------------

------------------------------------------------------------
Code1: push ebp mov ebp , esp sub esp , 0x78 mov eax , dword ptr [ ebp + 0xc ] mov ecx , dword ptr [ ebp + 0x8 ] mov edx , dword ptr [ ebp + 0x8 ] mov edx , dword ptr [ edx + 0xc ] mov dword ptr [ esp ] , edx lea edx , [ ebp - 0x68 ] mov dword ptr [ esp + 0x4 ] , edx mov dword ptr [ ebp - 0x6c ] , eax mov dword ptr [ ebp - 0x70 ] , ecx call 0x27b20 cmp eax , 0x0 jne 0x3c mov dword ptr [ ebp - 0x4 ] , 0x4 jmp 0x43 mov dword ptr [ ebp - 0x4 ] , 0x1 mov eax , dword ptr [ ebp - 0x4 ] add esp , 0x78 pop ebp ret nop dword ptr [ eax + eax ]
Code2: push rbp mov rbp , rsp sub rsp , 0xc0 mov qword ptr [ rbp - 0x10 ] , rdi mov qword ptr [ rbp - 0x18 ] , rsi mov rsi , qword ptr [ rbp - 0x10 ] mov rdi , qword ptr [ rsi + 0x10 ] lea rsi , [ rbp - 0xa8 ] call 0x4fe50 mov dword ptr [ rbp - 0x4 ] , eax mov dword ptr [ rbp - 0xac ] , 0x84f6e216 mov eax , dword ptr [ rbp - 0xac ] mov ecx , eax sub ecx , 0x84f6e216 mov dword ptr [ rbp - 0xb0 ] , eax mov dword ptr [ rbp - 0xb4 ] , ecx je 0xb2 jmp 0x59 mov eax , dword ptr [ rbp - 0xb0 ] sub eax , 0xa8d2f021 mov dword ptr [ rbp - 0xb8 ] , eax je 0xe6 jmp 0x75 mov eax , dword ptr [ rbp - 0xb0 ] sub eax , 0xdb02c7c5 mov dword ptr [ rbp - 0xbc ] , eax je 0xfc jmp 0x91 mov eax , dword ptr [ rbp - 0xb0 ] sub eax , 0x626840fb mov dword ptr [ rbp - 0xc0 ] , eax je 0xd0 jmp 0xad jmp 0x108 mov eax , dword ptr [ rbp - 0x4 ] cmp eax , 0x0 mov eax , 0x626840fb mov ecx , 0xa8d2f021 cmove ecx , eax mov dword ptr [ rbp - 0xac ] , ecx jmp 0x108 mov dword ptr [ rbp - 0x8 ] , 0x4 mov dword ptr [ rbp - 0xac ] , 0xdb02c7c5 jmp 0x108 mov dword ptr [ rbp - 0x8 ] , 0x1 mov dword ptr [ rbp - 0xac ] , 0xdb02c7c5 jmp 0x108 mov eax , dword ptr [ rbp - 0x8 ] add rsp , 0xc0 pop rbp ret jmp 0x34 nop dword ptr [ rax ]
Similarity: -1
Label: 1
Similarity Score: 0.1
Explanation: The two code snippets share a common structure of function prologue and epilogue, and both call a function and conditionally set a return value. However, the 32-bit code is simple and direct, while the 64-bit code is heavily obfuscated with multiple constants and conditional jumps that do not appear in the first code. The instructions and control flow are significantly different, leading to the conclusion that they are not similar.
------------------------------------------------------------

------------------------------------------------------------
Code1: push rbp mov rbp , rsp sub rsp , 0x230 mov qword ptr [ rbp - 0x10 ] , rdi mov qword ptr [ rbp - 0x80 ] , rsi mov rax , qword ptr [ rbp - 0x80 ] mov qword ptr [ rbp - 0x18 ] , rax mov rcx , qword ptr [ rbp - 0x10 ] add rcx , 0x98 mov qword ptr [ rbp - 0x88 ] , rcx mov rax , qword ptr [ rbp - 0x88 ] mov rcx , qword ptr [ rax ] mov qword ptr [ rbp - 0x20 ] , rcx mov qword ptr [ rbp - 0x30 ] , 0x0 mov rax , qword ptr [ rbp - 0x30 ] mov rcx , qword ptr [ rbp - 0x18 ] mov qword ptr [ rbp - 0x90 ] , rax mov qword ptr [ rbp - 0x98 ] , rcx mov rax , qword ptr [ rbp - 0x90 ] mov rcx , qword ptr [ rbp - 0x98 ] cmp rax , qword ptr [ rcx + 0x10 ] setl dl mov byte ptr [ rbp - 0x99 ] , dl mov al , byte ptr [ rbp - 0x99 ] test al , 0x1 jne 0x87 jmp 0x760 mov rax , qword ptr [ rbp - 0x18 ] mov rax , qword ptr [ rax + 0x18 ] mov rcx , qword ptr [ rbp - 0x30 ] mov qword ptr [ rbp - 0xa8 ] , rax mov qword ptr [ rbp - 0xb0 ] , rcx mov rax , qword ptr [ rbp - 0xa8 ] mov rcx , qword ptr [ rbp - 0xb0 ] mov rdx , qword ptr [ rax + rcx * 0x8 ] mov qword ptr [ rbp - 0x58 ] , rdx mov rdx , qword ptr [ rbp - 0x20 ] mov rdx , qword ptr [ rdx ] mov rsi , qword ptr [ rbp - 0x58 ] mov qword ptr [ rbp - 0xb8 ] , rdx mov qword ptr [ rbp - 0xc0 ] , rsi mov rax , qword ptr [ rbp - 0xc0 ] shl rax , 0x4 mov rcx , qword ptr [ rbp - 0xb8 ] add rcx , rax mov edx , dword ptr [ rcx + 0x8 ] shr edx , 0x14 and edx , 0x1 cmp edx , 0x0 jne 0xfc jmp 0x733 mov rax , qword ptr [ rbp - 0x20 ] mov rax , qword ptr [ rax ] mov rcx , qword ptr [ rbp - 0x58 ] mov qword ptr [ rbp - 0xc8 ] , rax mov qword ptr [ rbp - 0xd0 ] , rcx mov rax , qword ptr [ rbp - 0xd0 ] shl rax , 0x4 mov rcx , qword ptr [ rbp - 0xc8 ] add rcx , rax add rcx , 0x8 mov qword ptr [ rbp - 0xd8 ] , rcx mov rax , qword ptr [ rbp - 0xd8 ] mov ecx , dword ptr [ rax ] shr ecx , 0x8 and ecx , 0x3ff cmp ecx , 0x0 je 0x359 mov rdi , qword ptr [ rbp - 0x10 ] mov rax , qword ptr [ rbp - 0x10 ] mov rsi , qword ptr [ rax + 0x48 ] mov rax , qword ptr [ rbp - 0x10 ] mov edx , dword ptr [ rax + 0xa0 ] call 0xffffffffffff7a30 mov dword ptr [ rbp - 0x6c ] , eax mov rsi , qword ptr [ rbp - 0x20 ] mov rsi , qword ptr [ rsi ] mov qword ptr [ rbp - 0xe0 ] , rsi mov rax , qword ptr [ rbp - 0x58 ] shl rax , 0x4 mov rcx , qword ptr [ rbp - 0xe0 ] add rcx , rax mov edx , dword ptr [ rcx + 0x8 ] shr edx , 0x8 and edx , 0x3ff and edx , 0x4 cmp edx , 0x0 setne sil mov byte ptr [ rbp - 0xe1 ] , sil mov al , byte ptr [ rbp - 0xe1 ] test al , 0x1 jne 0x1be jmp 0x1ef mov eax , dword ptr [ rbp - 0x6c ] mov dword ptr [ rbp - 0xe8 ] , eax mov eax , dword ptr [ rbp - 0xe8 ] and eax , 0x1 cmp eax , 0x0 setne cl mov byte ptr [ rbp - 0xe9 ] , cl mov al , byte ptr [ rbp - 0xe9 ] test al , 0x1 jne 0x1ef jmp 0x34f mov rax , qword ptr [ rbp - 0x20 ] mov rax , qword ptr [ rax ] mov rcx , qword ptr [ rbp - 0x58 ] shl rcx , 0x4 add rax , rcx add rax , 0x8 mov qword ptr [ rbp - 0xf8 ] , rax mov rax , qword ptr [ rbp - 0xf8 ] mov ecx , dword ptr [ rax ] mov dword ptr [ rbp - 0xfc ] , ecx mov eax , dword ptr [ rbp - 0xfc ] shr eax , 0x8 and eax , 0x3ff and eax , 0x8 cmp eax , 0x0 je 0x266 mov eax , dword ptr [ rbp - 0x6c ] and eax , 0x1 mov dword ptr [ rbp - 0x100 ] , eax mov eax , dword ptr [ rbp - 0x100 ] cmp eax , 0x0 setne cl mov byte ptr [ rbp - 0x101 ] , cl mov al , byte ptr [ rbp - 0x101 ] test al , 0x1 jne 0x34f jmp 0x266 mov rax , qword ptr [ rbp - 0x20 ] mov rax , qword ptr [ rax ] mov rcx , qword ptr [ rbp - 0x58 ] shl rcx , 0x4 add rax , rcx mov edx , dword ptr [ rax + 0x8 ] shr edx , 0x8 mov dword ptr [ rbp - 0x108 ] , edx mov eax , dword ptr [ rbp - 0x108 ] and eax , 0x3ff and eax , 0x20 cmp eax , 0x0 setne cl mov byte ptr [ rbp - 0x109 ] , cl mov al , byte ptr [ rbp - 0x109 ] test al , 0x1 jne 0x2b1 jmp 0x2d8 mov eax , dword ptr [ rbp - 0x6c ] mov dword ptr [ rbp - 0x110 ] , eax mov eax , dword ptr [ rbp - 0x110 ] and eax , 0x2 mov dword ptr [ rbp - 0x114 ] , eax mov eax , dword ptr [ rbp - 0x114 ] cmp eax , 0x0 je 0x34f mov rax , qword ptr [ rbp - 0x20 ] mov rax , qword ptr [ rax ] mov qword ptr [ rbp - 0x120 ] , rax mov rax , qword ptr [ rbp - 0x58 ] shl rax , 0x4 mov rcx , qword ptr [ rbp - 0x120 ] add rcx , rax mov edx , dword ptr [ rcx + 0x8 ] shr edx , 0x8 and edx , 0x3ff mov dword ptr [ rbp - 0x124 ] , edx mov eax , dword ptr [ rbp - 0x124 ] and eax , 0x80 cmp eax , 0x0 je 0x354 mov eax , dword ptr [ rbp - 0x6c ] and eax , 0x8 mov dword ptr [ rbp - 0x128 ] , eax mov eax , dword ptr [ rbp - 0x128 ] cmp eax , 0x0 setne cl mov byte ptr [ rbp - 0x129 ] , cl mov al , byte ptr [ rbp - 0x129 ] test al , 0x1 jne 0x354 jmp 0x34f jmp 0x733 jmp 0x359 mov rdi , qword ptr [ rbp - 0x20 ] mov rsi , qword ptr [ rbp - 0x58 ] mov rdx , qword ptr [ rbp - 0x10 ] mov qword ptr [ rbp - 0x138 ] , rdi mov qword ptr [ rbp - 0x140 ] , rsi mov qword ptr [ rbp - 0x148 ] , rdx mov rax , qword ptr [ rbp - 0x10 ] add rax , 0x48 mov qword ptr [ rbp - 0x150 ] , rax mov rax , qword ptr [ rbp - 0x150 ] mov rcx , qword ptr [ rax ] mov rdi , qword ptr [ rbp - 0x138 ] mov rsi , qword ptr [ rbp - 0x140 ] mov rdx , qword ptr [ rbp - 0x148 ] call 0xffffffffffffeec0 mov dword ptr [ rbp - 0x5c ] , eax cmp dword ptr [ rbp - 0x5c ] , 0x0 jne 0x3bf jmp 0x733 mov rax , qword ptr [ rbp - 0x10 ] mov qword ptr [ rbp - 0x158 ] , rax mov rax , qword ptr [ rbp - 0x158 ] mov rcx , qword ptr [ rax + 0x48 ] movsxd rdx , dword ptr [ rbp - 0x5c ] add rcx , rdx mov qword ptr [ rbp - 0x68 ] , rcx mov rcx , qword ptr [ rbp - 0x10 ] mov qword ptr [ rbp - 0x160 ] , rcx mov rax , qword ptr [ rbp - 0x160 ] mov ecx , dword ptr [ rax + 0xe0 ] cmp ecx , dword ptr [ rbp - 0x5c ] jge 0x41b mov eax , dword ptr [ rbp - 0x5c ] mov dword ptr [ rbp - 0x164 ] , eax mov eax , dword ptr [ rbp - 0x164 ] mov dword ptr [ rbp - 0x168 ] , eax jmp 0x44a mov rax , qword ptr [ rbp - 0x10 ] mov qword ptr [ rbp - 0x170 ] , rax mov rax , qword ptr [ rbp - 0x170 ] mov ecx , dword ptr [ rax + 0xe0 ] mov dword ptr [ rbp - 0x174 ] , ecx mov eax , dword ptr [ rbp - 0x174 ] mov dword ptr [ rbp - 0x168 ] , eax jmp 0x44a mov eax , dword ptr [ rbp - 0x168 ] mov rcx , qword ptr [ rbp - 0x10 ] mov dword ptr [ rcx + 0xe0 ] , eax mov rdi , qword ptr [ rbp - 0x10 ] mov rsi , qword ptr [ rbp - 0x68 ] call 0xffffffffffffb600 mov dword ptr [ rbp - 0x24 ] , eax cmp dword ptr [ rbp - 0x24 ] , 0x0 setne dl and dl , 0x1 movzx eax , dl movsxd rcx , eax cmp rcx , 0x0 je 0x49b mov eax , dword ptr [ rbp - 0x24 ] mov dword ptr [ rbp - 0x178 ] , eax mov eax , dword ptr [ rbp - 0x178 ] mov dword ptr [ rbp - 0x4 ] , eax jmp 0x76c mov rax , qword ptr [ rbp - 0x20 ] mov rax , qword ptr [ rax + 0x30 ] mov rcx , qword ptr [ rbp - 0x20 ] add rcx , 0x18 mov qword ptr [ rbp - 0x180 ] , rax mov qword ptr [ rbp - 0x188 ] , rcx mov rax , qword ptr [ rbp - 0x188 ] mov rcx , qword ptr [ rax ] mov rdx , qword ptr [ rbp - 0x58 ] imul rcx , qword ptr [ rcx + rdx * 0x8 ] , 0x18 mov rdx , qword ptr [ rbp - 0x180 ] add rdx , rcx mov qword ptr [ rbp - 0x50 ] , rdx mov rcx , qword ptr [ rbp - 0x10 ] mov rcx , qword ptr [ rcx + 0xb8 ] mov rdx , qword ptr [ rbp - 0x68 ] shl rdx , 0x3 add rcx , rdx mov qword ptr [ rbp - 0x190 ] , rcx mov rax , qword ptr [ rbp - 0x190 ] mov rcx , qword ptr [ rax ] mov qword ptr [ rbp - 0x78 ] , rcx cmp qword ptr [ rbp - 0x78 ] , 0x0 jne 0x54f mov rax , qword ptr [ rbp - 0x50 ] lea rcx , [ rbp - 0x48 ] mov qword ptr [ rbp - 0x198 ] , rcx mov qword ptr [ rbp - 0x1a0 ] , rax mov rax , qword ptr [ rbp - 0x1a0 ] mov rcx , qword ptr [ rax ] mov rdx , qword ptr [ rbp - 0x198 ] mov qword ptr [ rdx ] , rcx mov rcx , qword ptr [ rax + 0x8 ] mov qword ptr [ rdx + 0x8 ] , rcx mov rcx , qword ptr [ rax + 0x10 ] mov qword ptr [ rdx + 0x10 ] , rcx jmp 0x5b7 mov rax , qword ptr [ rbp - 0x78 ] mov rsi , qword ptr [ rax + 0x50 ] mov rdx , qword ptr [ rbp - 0x50 ] lea rdi , [ rbp - 0x48 ] call 0xffffffffffffad20 mov dword ptr [ rbp - 0x24 ] , eax cmp dword ptr [ rbp - 0x24 ] , 0x0 setne cl and cl , 0x1 movzx eax , cl mov dword ptr [ rbp - 0x1a4 ] , eax mov eax , dword ptr [ rbp - 0x1a4 ] movsxd rcx , eax mov qword ptr [ rbp - 0x1b0 ] , rcx mov rax , qword ptr [ rbp - 0x1b0 ] cmp rax , 0x0 je 0x5b2 mov eax , dword ptr [ rbp - 0x24 ] mov dword ptr [ rbp - 0x1b4 ] , eax mov eax , dword ptr [ rbp - 0x1b4 ] mov dword ptr [ rbp - 0x4 ] , eax jmp 0x76c jmp 0x5b7 mov rdi , qword ptr [ rbp - 0x10 ] mov rax , qword ptr [ rbp - 0x68 ] sub rax , 0x1 mov rcx , qword ptr [ rbp - 0x10 ] mov qword ptr [ rbp - 0x1c0 ] , rdi mov qword ptr [ rbp - 0x1c8 ] , rax mov qword ptr [ rbp - 0x1d0 ] , rcx mov rax , qword ptr [ rbp - 0x1d0 ] mov edx , dword ptr [ rax + 0xa0 ] mov rdi , qword ptr [ rbp - 0x1c0 ] mov rsi , qword ptr [ rbp - 0x1c8 ] call 0xffffffffffff7a30 mov dword ptr [ rbp - 0x6c ] , eax mov rsi , qword ptr [ rbp - 0x20 ] mov ecx , dword ptr [ rbp - 0x6c ] lea rdi , [ rbp - 0x24 ] lea rdx , [ rbp - 0x48 ] call 0xffffffffffff2550 mov rdx , qword ptr [ rbp - 0x10 ] mov qword ptr [ rbp - 0x1d8 ] , rax mov qword ptr [ rbp - 0x1e0 ] , rdx mov rax , qword ptr [ rbp - 0x1e0 ] mov rcx , qword ptr [ rax + 0xb8 ] mov rdx , qword ptr [ rbp - 0x68 ] mov rsi , qword ptr [ rbp - 0x1d8 ] mov qword ptr [ rcx + rdx * 0x8 ] , rsi cmp qword ptr [ rbp - 0x78 ] , 0x0 je 0x67c lea rax , [ rbp - 0x48 ] add rax , 0x10 mov qword ptr [ rbp - 0x1e8 ] , rax mov rax , qword ptr [ rbp - 0x1e8 ] mov rcx , qword ptr [ rax ] mov qword ptr [ rbp - 0x1f0 ] , rcx mov rax , qword ptr [ rbp - 0x1f0 ] mov rdi , rax call 0xfffffffffff3d6f0 mov rax , qword ptr [ rbp - 0x10 ] mov rax , qword ptr [ rax + 0xb8 ] mov rcx , qword ptr [ rbp - 0x68 ] mov qword ptr [ rbp - 0x1f8 ] , rax mov qword ptr [ rbp - 0x200 ] , rcx mov rax , qword ptr [ rbp - 0x1f8 ] mov rcx , qword ptr [ rbp - 0x200 ] cmp qword ptr [ rax + rcx * 0x8 ] , 0x0 sete dl mov byte ptr [ rbp - 0x201 ] , dl xor eax , eax mov cl , al mov dl , byte ptr [ rbp - 0x201 ] test dl , 0x1 mov byte ptr [ rbp - 0x202 ] , cl jne 0x6d3 jmp 0x6ff mov eax , dword ptr [ rbp - 0x24 ] mov dword ptr [ rbp - 0x208 ] , eax mov eax , dword ptr [ rbp - 0x208 ] cmp eax , 0x0 setne cl mov byte ptr [ rbp - 0x209 ] , cl mov al , byte ptr [ rbp - 0x209 ] mov byte ptr [ rbp - 0x202 ] , al jmp 0x6ff mov al , byte ptr [ rbp - 0x202 ] and al , 0x1 movzx ecx , al movsxd rdx , ecx cmp rdx , 0x0 je 0x72e mov eax , dword ptr [ rbp - 0x24 ] mov dword ptr [ rbp - 0x210 ] , eax mov eax , dword ptr [ rbp - 0x210 ] mov dword ptr [ rbp - 0x4 ] , eax jmp 0x76c jmp 0x733 mov rax , qword ptr [ rbp - 0x30 ] mov qword ptr [ rbp - 0x218 ] , rax mov rax , qword ptr [ rbp - 0x218 ] add rax , 0x1 mov qword ptr [ rbp - 0x220 ] , rax mov rax , qword ptr [ rbp - 0x220 ] mov qword ptr [ rbp - 0x30 ] , rax jmp 0x43 mov dword ptr [ rbp - 0x4 ] , 0x0 jmp 0x76c mov eax , dword ptr [ rbp - 0x4 ] mov dword ptr [ rbp - 0x224 ] , eax mov eax , dword ptr [ rbp - 0x224 ] add rsp , 0x230 pop rbp ret nop word ptr cs : [ rax + rax ] nop
Code2: push ebp mov ebp , esp push edi push esi sub esp , 0x110 mov eax , dword ptr [ ebp + 0xc ] mov ecx , dword ptr [ ebp + 0x8 ] mov dword ptr [ ebp - 0x24 ] , eax mov dword ptr [ ebp - 0x28 ] , ecx mov eax , esp add eax , - 0x10 mov esp , eax mov ecx , esp add ecx , - 0x10 mov esp , ecx mov edx , esp add edx , - 0x10 mov esp , edx mov esi , esp add esi , - 0x10 mov esp , esi mov edi , esp add edi , - 0x10 mov esp , edi mov dword ptr [ ebp - 0x2c ] , eax mov dword ptr [ ebp - 0x30 ] , ecx mov dword ptr [ ebp - 0x34 ] , edx mov dword ptr [ ebp - 0x38 ] , esi mov dword ptr [ ebp - 0x3c ] , edi mov eax , esp add eax , - 0x10 mov esp , eax mov ecx , esp add ecx , - 0x10 mov esp , ecx mov edx , dword ptr [ ebp - 0x28 ] mov dword ptr [ ebp - 0x10 ] , edx mov esi , dword ptr [ ebp - 0x24 ] mov dword ptr [ ebp - 0x14 ] , esi mov edi , dword ptr [ ebp - 0x10 ] mov edi , dword ptr [ edi + 0x54 ] mov dword ptr [ ebp - 0x18 ] , edi mov dword ptr [ ebp - 0x20 ] , 0x0 mov dword ptr [ ebp - 0x40 ] , eax mov dword ptr [ ebp - 0x44 ] , ecx mov eax , dword ptr [ ebp - 0x20 ] mov dword ptr [ ebp - 0x48 ] , eax mov eax , dword ptr [ ebp - 0x14 ] mov eax , dword ptr [ eax + 0x8 ] mov dword ptr [ ebp - 0x4c ] , eax mov eax , dword ptr [ ebp - 0x48 ] mov ecx , dword ptr [ ebp - 0x4c ] cmp eax , ecx jge 0x656 mov eax , dword ptr [ ebp - 0x14 ] mov eax , dword ptr [ eax + 0xc ] mov dword ptr [ ebp - 0x50 ] , eax mov eax , dword ptr [ ebp - 0x20 ] mov ecx , dword ptr [ ebp - 0x50 ] mov eax , dword ptr [ ecx + eax * 0x4 ] mov edx , dword ptr [ ebp - 0x34 ] mov dword ptr [ edx ] , eax mov eax , dword ptr [ ebp - 0x18 ] mov eax , dword ptr [ eax ] mov esi , dword ptr [ edx ] mov eax , dword ptr [ eax + esi * 0x8 + 0x4 ] shr eax , 0x14 mov dword ptr [ ebp - 0x54 ] , eax mov eax , dword ptr [ ebp - 0x54 ] and eax , 0x1 cmp eax , 0x0 jne 0xd2 jmp 0x63c mov eax , dword ptr [ ebp - 0x18 ] mov dword ptr [ ebp - 0x58 ] , eax mov eax , dword ptr [ ebp - 0x58 ] mov ecx , dword ptr [ eax ] mov edx , dword ptr [ ebp - 0x34 ] mov esi , dword ptr [ edx ] mov dword ptr [ ebp - 0x5c ] , ecx mov dword ptr [ ebp - 0x60 ] , esi mov eax , dword ptr [ ebp - 0x5c ] mov ecx , dword ptr [ ebp - 0x60 ] mov edx , dword ptr [ eax + ecx * 0x8 + 0x4 ] shr edx , 0x8 and edx , 0x3ff cmp edx , 0x0 je 0x2ca mov eax , dword ptr [ ebp - 0x10 ] mov ecx , dword ptr [ ebp - 0x10 ] mov ecx , dword ptr [ ecx + 0x28 ] mov edx , dword ptr [ ebp - 0x10 ] mov edx , dword ptr [ edx + 0x58 ] sub esp , 0x10 mov dword ptr [ esp ] , eax mov dword ptr [ esp + 0x4 ] , ecx mov dword ptr [ esp + 0x8 ] , edx call 0xffff9350 add esp , 0x10 mov ecx , dword ptr [ ebp - 0x40 ] mov dword ptr [ ecx ] , eax mov eax , dword ptr [ ebp - 0x18 ] mov eax , dword ptr [ eax ] mov dword ptr [ ebp - 0x64 ] , eax mov eax , dword ptr [ ebp - 0x34 ] mov ecx , dword ptr [ eax ] shl ecx , 0x3 mov edx , dword ptr [ ebp - 0x64 ] add edx , ecx add edx , 0x4 mov dword ptr [ ebp - 0x68 ] , edx mov eax , dword ptr [ ebp - 0x68 ] mov ecx , dword ptr [ eax ] shr ecx , 0x8 and ecx , 0x3ff and ecx , 0x4 cmp ecx , 0x0 je 0x18a mov eax , dword ptr [ ebp - 0x40 ] mov ecx , dword ptr [ eax ] mov dword ptr [ ebp - 0x6c ] , ecx mov eax , dword ptr [ ebp - 0x6c ] and eax , 0x1 cmp eax , 0x0 setne cl mov byte ptr [ ebp - 0x6d ] , cl mov al , byte ptr [ ebp - 0x6d ] test al , 0x1 jne 0x18a jmp 0x2c0 mov eax , dword ptr [ ebp - 0x18 ] mov eax , dword ptr [ eax ] mov dword ptr [ ebp - 0x74 ] , eax mov eax , dword ptr [ ebp - 0x34 ] mov ecx , dword ptr [ eax ] shl ecx , 0x3 mov edx , dword ptr [ ebp - 0x74 ] add edx , ecx add edx , 0x4 mov dword ptr [ ebp - 0x78 ] , edx mov eax , dword ptr [ ebp - 0x78 ] mov ecx , dword ptr [ eax ] shr ecx , 0x8 and ecx , 0x3ff and ecx , 0x8 cmp ecx , 0x0 je 0x1e6 mov eax , dword ptr [ ebp - 0x40 ] mov ecx , dword ptr [ eax ] and ecx , 0x1 mov dword ptr [ ebp - 0x7c ] , ecx mov eax , dword ptr [ ebp - 0x7c ] cmp eax , 0x0 setne cl mov byte ptr [ ebp - 0x7d ] , cl mov al , byte ptr [ ebp - 0x7d ] test al , 0x1 jne 0x2c0 jmp 0x1e6 mov eax , dword ptr [ ebp - 0x18 ] mov eax , dword ptr [ eax ] mov dword ptr [ ebp - 0x84 ] , eax mov eax , dword ptr [ ebp - 0x34 ] mov ecx , dword ptr [ eax ] mov edx , dword ptr [ ebp - 0x84 ] mov ecx , dword ptr [ edx + ecx * 0x8 + 0x4 ] shr ecx , 0x8 mov dword ptr [ ebp - 0x88 ] , ecx mov eax , dword ptr [ ebp - 0x88 ] and eax , 0x3ff and eax , 0x20 cmp eax , 0x0 je 0x253 mov eax , dword ptr [ ebp - 0x40 ] mov ecx , dword ptr [ eax ] mov dword ptr [ ebp - 0x8c ] , ecx mov eax , dword ptr [ ebp - 0x8c ] and eax , 0x2 cmp eax , 0x0 setne cl mov byte ptr [ ebp - 0x8d ] , cl mov al , byte ptr [ ebp - 0x8d ] test al , 0x1 jne 0x253 jmp 0x2c0 mov eax , dword ptr [ ebp - 0x18 ] mov eax , dword ptr [ eax ] mov dword ptr [ ebp - 0x94 ] , eax mov eax , dword ptr [ ebp - 0x34 ] mov ecx , dword ptr [ eax ] shl ecx , 0x3 mov edx , dword ptr [ ebp - 0x94 ] add edx , ecx add edx , 0x4 mov dword ptr [ ebp - 0x98 ] , edx mov eax , dword ptr [ ebp - 0x98 ] mov ecx , dword ptr [ eax ] shr ecx , 0x8 and ecx , 0x3ff and ecx , 0x80 cmp ecx , 0x0 je 0x2c5 mov eax , dword ptr [ ebp - 0x40 ] mov ecx , dword ptr [ eax ] mov dword ptr [ ebp - 0x9c ] , ecx mov eax , dword ptr [ ebp - 0x9c ] and eax , 0x8 mov dword ptr [ ebp - 0xa0 ] , eax mov eax , dword ptr [ ebp - 0xa0 ] cmp eax , 0x0 jne 0x2c5 jmp 0x63c jmp 0x2ca mov eax , dword ptr [ ebp - 0x18 ] mov ecx , dword ptr [ ebp - 0x34 ] mov edx , dword ptr [ ecx ] mov dword ptr [ ebp - 0xa4 ] , eax mov dword ptr [ ebp - 0xa8 ] , edx mov eax , dword ptr [ ebp - 0x10 ] mov ecx , dword ptr [ ebp - 0x10 ] mov ecx , dword ptr [ ecx + 0x28 ] mov dword ptr [ ebp - 0xac ] , eax mov dword ptr [ ebp - 0xb0 ] , ecx sub esp , 0x10 mov eax , dword ptr [ ebp - 0xa4 ] mov dword ptr [ esp ] , eax mov ecx , dword ptr [ ebp - 0xa8 ] mov dword ptr [ esp + 0x4 ] , ecx mov edx , dword ptr [ ebp - 0xac ] mov dword ptr [ esp + 0x8 ] , edx mov esi , dword ptr [ ebp - 0xb0 ] mov dword ptr [ esp + 0xc ] , esi call 0xffffefa0 add esp , 0x10 mov ecx , dword ptr [ ebp - 0x38 ] mov dword ptr [ ecx ] , eax cmp dword ptr [ ecx ] , 0x0 jne 0x338 jmp 0x63c mov eax , dword ptr [ ebp - 0x10 ] mov eax , dword ptr [ eax + 0x28 ] mov ecx , dword ptr [ ebp - 0x38 ] add eax , dword ptr [ ecx ] mov edx , dword ptr [ ebp - 0x3c ] mov dword ptr [ edx ] , eax mov eax , dword ptr [ ebp - 0x10 ] add eax , 0x78 mov dword ptr [ ebp - 0xb4 ] , eax mov eax , dword ptr [ ebp - 0xb4 ] mov ecx , dword ptr [ eax ] mov dword ptr [ ebp - 0xb8 ] , ecx mov eax , dword ptr [ ebp - 0xb8 ] mov ecx , dword ptr [ ebp - 0x38 ] cmp eax , dword ptr [ ecx ] jge 0x38f mov eax , dword ptr [ ebp - 0x38 ] mov ecx , dword ptr [ eax ] mov dword ptr [ ebp - 0xbc ] , ecx mov eax , dword ptr [ ebp - 0xbc ] mov dword ptr [ ebp - 0xc0 ] , eax jmp 0x3ba mov eax , dword ptr [ ebp - 0x10 ] add eax , 0x78 mov dword ptr [ ebp - 0xc4 ] , eax mov eax , dword ptr [ ebp - 0xc4 ] mov ecx , dword ptr [ eax ] mov dword ptr [ ebp - 0xc8 ] , ecx mov eax , dword ptr [ ebp - 0xc8 ] mov dword ptr [ ebp - 0xc0 ] , eax jmp 0x3ba mov eax , dword ptr [ ebp - 0xc0 ] mov ecx , dword ptr [ ebp - 0x10 ] mov dword ptr [ ecx + 0x78 ] , eax mov eax , dword ptr [ ebp - 0x10 ] mov ecx , dword ptr [ ebp - 0x3c ] mov edx , dword ptr [ ecx ] sub esp , 0x10 mov dword ptr [ esp ] , eax mov dword ptr [ esp + 0x4 ] , edx call 0xffffc2c0 add esp , 0x10 mov dword ptr [ ebp - 0x1c ] , eax cmp dword ptr [ ebp - 0x1c ] , 0x0 je 0x404 mov eax , dword ptr [ ebp - 0x1c ] mov dword ptr [ ebp - 0xcc ] , eax mov eax , dword ptr [ ebp - 0xcc ] mov dword ptr [ ebp - 0xc ] , eax jmp 0x662 mov eax , dword ptr [ ebp - 0x18 ] mov eax , dword ptr [ eax + 0x18 ] mov ecx , dword ptr [ ebp - 0x18 ] mov ecx , dword ptr [ ecx + 0xc ] mov edx , dword ptr [ ebp - 0x34 ] mov esi , dword ptr [ edx ] mov ecx , dword ptr [ ecx + esi * 0x4 ] mov dword ptr [ ebp - 0xd0 ] , eax mov dword ptr [ ebp - 0xd4 ] , ecx mov eax , dword ptr [ ebp - 0xd4 ] imul ecx , eax , 0xc mov edx , dword ptr [ ebp - 0xd0 ] add edx , ecx mov dword ptr [ ebp - 0xd8 ] , edx mov eax , dword ptr [ ebp - 0x30 ] mov ecx , dword ptr [ ebp - 0xd8 ] mov dword ptr [ eax ] , ecx mov edx , dword ptr [ ebp - 0x10 ] mov edx , dword ptr [ edx + 0x64 ] mov esi , dword ptr [ ebp - 0x3c ] mov edi , dword ptr [ esi ] mov edx , dword ptr [ edx + edi * 0x4 ] mov edi , dword ptr [ ebp - 0x44 ] mov dword ptr [ edi ] , edx cmp dword ptr [ edi ] , 0x0 jne 0x497 mov eax , dword ptr [ ebp - 0x30 ] mov ecx , dword ptr [ eax ] mov edx , dword ptr [ ebp - 0x2c ] mov dword ptr [ ebp - 0xdc ] , edx mov dword ptr [ ebp - 0xe0 ] , ecx mov eax , dword ptr [ ebp - 0xe0 ] mov ecx , dword ptr [ eax ] mov edx , dword ptr [ ebp - 0xdc ] mov dword ptr [ edx ] , ecx mov ecx , dword ptr [ eax + 0x4 ] mov dword ptr [ edx + 0x4 ] , ecx mov ecx , dword ptr [ eax + 0x8 ] mov dword ptr [ edx + 0x8 ] , ecx jmp 0x4f2 mov eax , dword ptr [ ebp - 0x44 ] mov ecx , dword ptr [ eax ] mov dword ptr [ ebp - 0xe4 ] , ecx mov eax , dword ptr [ ebp - 0xe4 ] mov ecx , dword ptr [ eax + 0x28 ] mov edx , dword ptr [ ebp - 0x30 ] mov esi , dword ptr [ edx ] sub esp , 0x10 mov edi , dword ptr [ ebp - 0x2c ] mov dword ptr [ esp ] , edi mov dword ptr [ esp + 0x4 ] , ecx mov dword ptr [ esp + 0x8 ] , esi call 0xffffbb70 add esp , 0x10 mov dword ptr [ ebp - 0x1c ] , eax cmp dword ptr [ ebp - 0x1c ] , 0x0 je 0x4ed mov eax , dword ptr [ ebp - 0x1c ] mov dword ptr [ ebp - 0xe8 ] , eax mov eax , dword ptr [ ebp - 0xe8 ] mov dword ptr [ ebp - 0xc ] , eax jmp 0x662 jmp 0x4f2 mov eax , dword ptr [ ebp - 0x10 ] mov ecx , dword ptr [ ebp - 0x3c ] mov edx , dword ptr [ ecx ] sub edx , 0x1 mov dword ptr [ ebp - 0xec ] , eax mov dword ptr [ ebp - 0xf0 ] , edx mov eax , dword ptr [ ebp - 0x10 ] mov eax , dword ptr [ eax + 0x58 ] sub esp , 0x10 mov ecx , dword ptr [ ebp - 0xec ] mov dword ptr [ esp ] , ecx mov edx , dword ptr [ ebp - 0xf0 ] mov dword ptr [ esp + 0x4 ] , edx mov dword ptr [ esp + 0x8 ] , eax call 0xffff9350 add esp , 0x10 mov ecx , dword ptr [ ebp - 0x40 ] mov dword ptr [ ecx ] , eax mov eax , dword ptr [ ebp - 0x18 ] mov edx , dword ptr [ ecx ] sub esp , 0x10 lea esi , [ ebp - 0x1c ] mov dword ptr [ esp ] , esi mov dword ptr [ esp + 0x4 ] , eax mov eax , dword ptr [ ebp - 0x2c ] mov dword ptr [ esp + 0x8 ] , eax mov dword ptr [ esp + 0xc ] , edx call 0xffff4a80 add esp , 0x10 mov ecx , dword ptr [ ebp - 0x10 ] mov ecx , dword ptr [ ecx + 0x64 ] mov edx , dword ptr [ ebp - 0x3c ] mov esi , dword ptr [ edx ] mov dword ptr [ ecx + esi * 0x4 ] , eax mov eax , dword ptr [ ebp - 0x44 ] mov ecx , dword ptr [ eax ] mov dword ptr [ ebp - 0xf4 ] , ecx mov eax , dword ptr [ ebp - 0xf4 ] cmp eax , 0x0 je 0x5a8 mov eax , dword ptr [ ebp - 0x2c ] mov ecx , dword ptr [ eax + 0x8 ] mov dword ptr [ ebp - 0xf8 ] , ecx sub esp , 0x10 mov eax , dword ptr [ ebp - 0xf8 ] mov dword ptr [ esp ] , eax call 0xfff43ff0 add esp , 0x10 jmp 0x5a8 mov eax , dword ptr [ ebp - 0x10 ] mov dword ptr [ ebp - 0xfc ] , eax mov eax , dword ptr [ ebp - 0xfc ] mov ecx , dword ptr [ eax + 0x64 ] mov edx , dword ptr [ ebp - 0x3c ] mov esi , dword ptr [ edx ] mov ecx , dword ptr [ ecx + esi * 0x4 ] mov dword ptr [ ebp - 0x100 ] , ecx xor eax , eax mov cl , al mov eax , dword ptr [ ebp - 0x100 ] cmp eax , 0x0 mov byte ptr [ ebp - 0x101 ] , cl jne 0x60d mov eax , dword ptr [ ebp - 0x1c ] mov dword ptr [ ebp - 0x108 ] , eax mov eax , dword ptr [ ebp - 0x108 ] cmp eax , 0x0 setne cl mov byte ptr [ ebp - 0x109 ] , cl mov al , byte ptr [ ebp - 0x109 ] mov byte ptr [ ebp - 0x101 ] , al jmp 0x60d mov al , byte ptr [ ebp - 0x101 ] test al , 0x1 jne 0x620 jmp 0x637 mov eax , dword ptr [ ebp - 0x1c ] mov dword ptr [ ebp - 0x110 ] , eax mov eax , dword ptr [ ebp - 0x110 ] mov dword ptr [ ebp - 0xc ] , eax jmp 0x662 jmp 0x63c mov eax , dword ptr [ ebp - 0x20 ] mov dword ptr [ ebp - 0x114 ] , eax mov eax , dword ptr [ ebp - 0x114 ] add eax , 0x1 mov dword ptr [ ebp - 0x20 ] , eax jmp 0x79 mov dword ptr [ ebp - 0xc ] , 0x0 jmp 0x662 mov eax , dword ptr [ ebp - 0xc ] mov dword ptr [ ebp - 0x118 ] , eax mov eax , dword ptr [ ebp - 0x118 ] lea esp , [ ebp - 0x8 ] pop esi pop edi pop ebp ret nop dword ptr [ eax + eax ]
Similarity: -1
Label: 1
Similarity Score: 0.3
Explanation: The two assembly codes are for different architectures (64-bit vs 32-bit) and use different registers and instruction sets. However, both exhibit similar structural patterns such as function prologue/epilogue, a loop with index counter, and multiple conditional checks using bit masks. Despite these high-level similarities, the differences in instruction sets, register usage, and calling conventions make the codes fundamentally different. Therefore, they are not considered similar in the binary sense (-1), but there is a low degree of algorithmic similarity (score 0.3).
------------------------------------------------------------

------------------------------------------------------------
Code1: push ebp push edi push esi push ebx call 0xfffe2d90 add ebx , 0x16587 sub esp , 0x1c call 0xfffe27a0 test dword ptr [ esp + 0x34 ] , 0xffffdfff mov esi , dword ptr [ esp + 0x30 ] mov edi , eax jne 0x120 mov edx , dword ptr [ esi ] mov dword ptr [ eax ] , 0x0 test byte ptr [ esi + 0x2d ] , 0x40 jne 0xb8 movzx eax , word ptr [ edx + 0x3c ] cmp ax , 0x9 je 0xa8 cmp ax , 0x1 jne 0xb8 mov eax , dword ptr [ esi + 0x4 ] test eax , eax je 0x5d mov dword ptr [ esp + 0xc ] , edx call 0xffffde30 mov edx , dword ptr [ esp + 0xc ] cmp dword ptr [ esp + 0x34 ] , 0x2000 mov ebp , 0x1 jne 0x78 or dword ptr [ esi + 0x2c ] , 0x2000 mov ebp , 0x2 mov eax , dword ptr [ edx + 0x30 ] test eax , eax jne 0x8f mov eax , dword ptr [ edx + 0x18 ] cmp byte ptr [ eax ] , 0x2f je 0x8f mov edx , dword ptr [ esi + 0x2c ] test dl , 0x4 je 0xc8 mov edx , ebp mov eax , esi call 0xffffe620 mov dword ptr [ esi + 0x4 ] , eax add esp , 0x1c pop ebx pop esi pop edi pop ebp ret nop lea esi , [ esi ] mov eax , dword ptr [ edx + 0x8 ] add esp , 0x1c pop ebx pop esi pop edi pop ebp ret nop lea esi , [ esi ] add esp , 0x1c xor eax , eax pop ebx pop esi pop edi pop ebp ret lea esi , [ esi ] mov eax , dword ptr [ esi + 0x1c ] lea ecx , [ ebx - 0xe530 ] call 0xffffe0c0 test eax , eax mov dword ptr [ esp + 0xc ] , eax js 0x142 mov edx , ebp mov eax , esi call 0xffffe620 test byte ptr [ esi + 0x2d ] , 0x2 mov dword ptr [ esi + 0x4 ] , eax jne 0x130 sub esp , 0xc push dword ptr [ esp + 0x18 ] call 0xfffe28f0 add esp , 0x10 test eax , eax jne 0x150 sub esp , 0xc push dword ptr [ esp + 0x18 ] call 0xfffe2a10 add esp , 0x10 mov eax , dword ptr [ esi + 0x4 ] jmp 0x9b mov esi , esi lea edi , [ edi ] mov dword ptr [ eax ] , 0x16 xor eax , eax jmp 0x9b lea esi , [ esi ] mov edx , dword ptr [ esp + 0xc ] mov ecx , 0x1 mov eax , esi call 0xffffded0 jmp 0x112 mov dword ptr [ esi + 0x4 ] , 0x0 xor eax , eax jmp 0x9b mov esi , dword ptr [ edi ] sub esp , 0xc push dword ptr [ esp + 0x18 ] call 0xfffe2a10 mov dword ptr [ edi ] , esi add esp , 0x10 xor eax , eax jmp 0x9b nop nop nop
Code2: push ebp mov ebp , esp sub esp , 0xa8 mov eax , dword ptr [ ebp + 0xc ] mov ecx , dword ptr [ ebp + 0x8 ] mov edx , dword ptr [ ebp + 0xc ] mov dword ptr [ ebp - 0x4 ] , edx mov dword ptr [ ebp - 0x18 ] , 0x23b878ca mov dword ptr [ ebp - 0x1c ] , eax mov dword ptr [ ebp - 0x20 ] , ecx mov eax , dword ptr [ ebp - 0x18 ] mov ecx , eax sub ecx , 0x80863067 mov dword ptr [ ebp - 0x24 ] , eax mov dword ptr [ ebp - 0x28 ] , ecx je 0x549 jmp 0x3e mov eax , dword ptr [ ebp - 0x24 ] sub eax , 0x8bceb042 mov dword ptr [ ebp - 0x2c ] , eax je 0x2a6 jmp 0x54 mov eax , dword ptr [ ebp - 0x24 ] sub eax , 0xaa34c78a mov dword ptr [ ebp - 0x30 ] , eax je 0x5e2 jmp 0x6a mov eax , dword ptr [ ebp - 0x24 ] sub eax , 0xaa9c7727 mov dword ptr [ ebp - 0x34 ] , eax je 0x4e8 jmp 0x80 mov eax , dword ptr [ ebp - 0x24 ] sub eax , 0xc07dae16 mov dword ptr [ ebp - 0x38 ] , eax je 0x523 jmp 0x96 mov eax , dword ptr [ ebp - 0x24 ] sub eax , 0xcac0594c mov dword ptr [ ebp - 0x3c ] , eax je 0x5b0 jmp 0xac mov eax , dword ptr [ ebp - 0x24 ] sub eax , 0xee231b30 mov dword ptr [ ebp - 0x40 ] , eax je 0x56c jmp 0xc2 mov eax , dword ptr [ ebp - 0x24 ] sub eax , 0xf4537e00 mov dword ptr [ ebp - 0x44 ] , eax je 0x38f jmp 0xd8 mov eax , dword ptr [ ebp - 0x24 ] sub eax , 0xf737409a mov dword ptr [ ebp - 0x48 ] , eax je 0x3c5 jmp 0xee mov eax , dword ptr [ ebp - 0x24 ] sub eax , 0x113158a mov dword ptr [ ebp - 0x4c ] , eax je 0x403 jmp 0x104 mov eax , dword ptr [ ebp - 0x24 ] sub eax , 0x62fba6a mov dword ptr [ ebp - 0x50 ] , eax je 0x5cd jmp 0x11a mov eax , dword ptr [ ebp - 0x24 ] sub eax , 0x69f9239 mov dword ptr [ ebp - 0x54 ] , eax je 0x3e1 jmp 0x130 mov eax , dword ptr [ ebp - 0x24 ] sub eax , 0xcd1c8fd mov dword ptr [ ebp - 0x58 ] , eax je 0x316 jmp 0x146 mov eax , dword ptr [ ebp - 0x24 ] sub eax , 0xff6d957 mov dword ptr [ ebp - 0x5c ] , eax je 0x416 jmp 0x15c mov eax , dword ptr [ ebp - 0x24 ] sub eax , 0x137831fc mov dword ptr [ ebp - 0x60 ] , eax je 0x49b jmp 0x172 mov eax , dword ptr [ ebp - 0x24 ] sub eax , 0x23b878ca mov dword ptr [ ebp - 0x64 ] , eax je 0x28b jmp 0x188 mov eax , dword ptr [ ebp - 0x24 ] sub eax , 0x257e63bd mov dword ptr [ ebp - 0x68 ] , eax je 0x453 jmp 0x19e mov eax , dword ptr [ ebp - 0x24 ] sub eax , 0x2680fc31 mov dword ptr [ ebp - 0x6c ] , eax je 0x35d jmp 0x1b4 mov eax , dword ptr [ ebp - 0x24 ] sub eax , 0x2725cb39 mov dword ptr [ ebp - 0x70 ] , eax je 0x432 jmp 0x1ca mov eax , dword ptr [ ebp - 0x24 ] sub eax , 0x290deeaa mov dword ptr [ ebp - 0x74 ] , eax je 0x2e0 jmp 0x1e0 mov eax , dword ptr [ ebp - 0x24 ] sub eax , 0x2bbbafc0 mov dword ptr [ ebp - 0x78 ] , eax je 0x37c jmp 0x1f6 mov eax , dword ptr [ ebp - 0x24 ] sub eax , 0x3a1c4713 mov dword ptr [ ebp - 0x7c ] , eax je 0x3ab jmp 0x20c mov eax , dword ptr [ ebp - 0x24 ] sub eax , 0x4558a1f2 mov dword ptr [ ebp - 0x80 ] , eax je 0x2c2 jmp 0x222 mov eax , dword ptr [ ebp - 0x24 ] sub eax , 0x4ba98a46 mov dword ptr [ ebp - 0x84 ] , eax je 0x329 jmp 0x23b mov eax , dword ptr [ ebp - 0x24 ] sub eax , 0x5e2dea45 mov dword ptr [ ebp - 0x88 ] , eax je 0x4cb jmp 0x254 mov eax , dword ptr [ ebp - 0x24 ] sub eax , 0x76b28e21 mov dword ptr [ ebp - 0x8c ] , eax je 0x474 jmp 0x26d mov eax , dword ptr [ ebp - 0x24 ] sub eax , 0x79eb2740 mov dword ptr [ ebp - 0x90 ] , eax je 0x348 jmp 0x286 jmp 0x5ed mov eax , dword ptr [ ebp - 0x4 ] cmp eax , 0x0 mov eax , 0x8bceb042 mov ecx , 0x290deeaa cmovne ecx , eax mov dword ptr [ ebp - 0x18 ] , ecx jmp 0x5ed cmp dword ptr [ ebp + 0xc ] , 0x2000 mov eax , 0x4558a1f2 mov ecx , 0x290deeaa cmovne ecx , eax mov dword ptr [ ebp - 0x18 ] , ecx jmp 0x5ed call 0xfffad570 mov dword ptr [ eax ] , 0x16 mov dword ptr [ ebp - 0x8 ] , 0x0 mov dword ptr [ ebp - 0x18 ] , 0xaa34c78a jmp 0x5ed mov eax , dword ptr [ ebp + 0x8 ] mov eax , dword ptr [ eax ] mov dword ptr [ ebp - 0xc ] , eax call 0xfffad570 mov dword ptr [ eax ] , 0x0 mov eax , dword ptr [ ebp + 0x8 ] mov eax , dword ptr [ eax + 0x2c ] and eax , 0x4000 cmp eax , 0x0 mov eax , 0xcd1c8fd mov ecx , 0x4ba98a46 cmovne ecx , eax mov dword ptr [ ebp - 0x18 ] , ecx jmp 0x5ed mov dword ptr [ ebp - 0x8 ] , 0x0 mov dword ptr [ ebp - 0x18 ] , 0xaa34c78a jmp 0x5ed mov eax , dword ptr [ ebp - 0xc ] movzx eax , word ptr [ eax + 0x3c ] cmp eax , 0x9 mov eax , 0x79eb2740 mov ecx , 0x2680fc31 cmove ecx , eax mov dword ptr [ ebp - 0x18 ] , ecx jmp 0x5ed mov eax , dword ptr [ ebp - 0xc ] mov eax , dword ptr [ eax + 0x8 ] mov dword ptr [ ebp - 0x8 ] , eax mov dword ptr [ ebp - 0x18 ] , 0xaa34c78a jmp 0x5ed mov eax , dword ptr [ ebp - 0xc ] movzx eax , word ptr [ eax + 0x3c ] cmp eax , 0x1 mov eax , 0x2bbbafc0 mov ecx , 0xf4537e00 cmovne ecx , eax mov dword ptr [ ebp - 0x18 ] , ecx jmp 0x5ed mov dword ptr [ ebp - 0x8 ] , 0x0 mov dword ptr [ ebp - 0x18 ] , 0xaa34c78a jmp 0x5ed mov eax , dword ptr [ ebp + 0x8 ] cmp dword ptr [ eax + 0x4 ] , 0x0 mov eax , 0x3a1c4713 mov ecx , 0xf737409a cmovne ecx , eax mov dword ptr [ ebp - 0x18 ] , ecx jmp 0x5ed mov eax , dword ptr [ ebp + 0x8 ] mov eax , dword ptr [ eax + 0x4 ] mov dword ptr [ esp ] , eax call 0xffffb290 mov dword ptr [ ebp - 0x18 ] , 0xf737409a jmp 0x5ed cmp dword ptr [ ebp + 0xc ] , 0x2000 mov eax , 0x69f9239 mov ecx , 0x113158a cmove ecx , eax mov dword ptr [ ebp - 0x18 ] , ecx jmp 0x5ed mov eax , dword ptr [ ebp + 0x8 ] mov ecx , dword ptr [ eax + 0x2c ] or ecx , 0x2000 mov dword ptr [ eax + 0x2c ] , ecx mov dword ptr [ ebp + 0xc ] , 0x2 mov dword ptr [ ebp - 0x18 ] , 0xff6d957 jmp 0x5ed mov dword ptr [ ebp + 0xc ] , 0x1 mov dword ptr [ ebp - 0x18 ] , 0xff6d957 jmp 0x5ed mov eax , dword ptr [ ebp - 0xc ] cmp dword ptr [ eax + 0x30 ] , 0x0 mov eax , 0x76b28e21 mov ecx , 0x2725cb39 cmovne ecx , eax mov dword ptr [ ebp - 0x18 ] , ecx jmp 0x5ed mov eax , dword ptr [ ebp - 0xc ] mov eax , dword ptr [ eax + 0x18 ] movsx eax , byte ptr [ eax ] cmp eax , 0x2f mov eax , 0x76b28e21 mov ecx , 0x257e63bd cmove ecx , eax mov dword ptr [ ebp - 0x18 ] , ecx jmp 0x5ed mov eax , dword ptr [ ebp + 0x8 ] mov eax , dword ptr [ eax + 0x2c ] and eax , 0x4 cmp eax , 0x0 mov eax , 0x76b28e21 mov ecx , 0x137831fc cmovne ecx , eax mov dword ptr [ ebp - 0x18 ] , ecx jmp 0x5ed mov eax , dword ptr [ ebp + 0x8 ] mov ecx , dword ptr [ ebp + 0xc ] mov dword ptr [ esp ] , eax mov dword ptr [ esp + 0x4 ] , ecx call 0xffffd090 mov ecx , dword ptr [ ebp + 0x8 ] mov dword ptr [ ecx + 0x4 ] , eax mov dword ptr [ ebp - 0x8 ] , eax mov dword ptr [ ebp - 0x18 ] , 0xaa34c78a jmp 0x5ed mov eax , dword ptr [ ebp + 0x8 ] mov dword ptr [ esp ] , eax lea eax , [ 0x80a9ff1 ] mov dword ptr [ esp + 0x4 ] , eax call 0xffffb0e0 mov dword ptr [ ebp - 0x10 ] , eax cmp eax , 0x0 mov eax , 0x5e2dea45 mov ecx , 0xaa9c7727 cmovl ecx , eax mov dword ptr [ ebp - 0x18 ] , ecx jmp 0x5ed mov eax , dword ptr [ ebp + 0x8 ] mov dword ptr [ eax + 0x4 ] , 0x0 mov dword ptr [ ebp - 0x8 ] , 0x0 mov dword ptr [ ebp - 0x18 ] , 0xaa34c78a jmp 0x5ed mov eax , dword ptr [ ebp + 0x8 ] mov ecx , dword ptr [ ebp + 0xc ] mov dword ptr [ esp ] , eax mov dword ptr [ esp + 0x4 ] , ecx call 0xffffd090 mov ecx , dword ptr [ ebp + 0x8 ] mov dword ptr [ ecx + 0x4 ] , eax mov eax , dword ptr [ ebp + 0x8 ] mov eax , dword ptr [ eax + 0x2c ] and eax , 0x200 cmp eax , 0x0 mov eax , 0xc07dae16 mov ecx , 0x80863067 cmovne ecx , eax mov dword ptr [ ebp - 0x18 ] , ecx jmp 0x5ed mov eax , dword ptr [ ebp + 0x8 ] mov ecx , dword ptr [ ebp - 0x10 ] mov dword ptr [ esp ] , eax mov dword ptr [ esp + 0x4 ] , ecx mov dword ptr [ esp + 0x8 ] , 0x1 call 0xfffffd80 mov dword ptr [ ebp - 0x18 ] , 0x62fba6a jmp 0x5ed mov eax , dword ptr [ ebp - 0x10 ] mov dword ptr [ esp ] , eax call 0xfffad6d0 cmp eax , 0x0 mov eax , 0xee231b30 mov ecx , 0xcac0594c cmovne ecx , eax mov dword ptr [ ebp - 0x18 ] , ecx jmp 0x5ed call 0xfffad570 mov eax , dword ptr [ eax ] mov dword ptr [ ebp - 0x14 ] , eax mov eax , dword ptr [ ebp - 0x10 ] mov dword ptr [ esp ] , eax call 0xfffad800 mov ecx , dword ptr [ ebp - 0x14 ] mov dword ptr [ ebp - 0x94 ] , eax mov dword ptr [ ebp - 0x98 ] , ecx call 0xfffad570 mov ecx , dword ptr [ ebp - 0x98 ] mov dword ptr [ eax ] , ecx mov dword ptr [ ebp - 0x8 ] , 0x0 mov dword ptr [ ebp - 0x18 ] , 0xaa34c78a jmp 0x5ed mov eax , dword ptr [ ebp - 0x10 ] mov dword ptr [ esp ] , eax call 0xfffad800 mov dword ptr [ ebp - 0x18 ] , 0x62fba6a mov dword ptr [ ebp - 0x9c ] , eax jmp 0x5ed mov eax , dword ptr [ ebp + 0x8 ] mov eax , dword ptr [ eax + 0x4 ] mov dword ptr [ ebp - 0x8 ] , eax mov dword ptr [ ebp - 0x18 ] , 0xaa34c78a jmp 0x5ed mov eax , dword ptr [ ebp - 0x8 ] add esp , 0xa8 pop ebp ret jmp 0x22 nop word ptr cs : [ eax + eax ] nop dword ptr [ eax ]
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly code snippets are entirely different in structure and purpose. Code1 has a linear control flow with conditional branches and direct operations on data structures, while Code2 is dominated by a jump table or switch-like structure with many conditional moves and jumps. The functions called in each code are different, and there is no overlap in the specific operations or logic. Therefore, they are not similar.
------------------------------------------------------------

------------------------------------------------------------
Code1: lui gp , 0x4e addiu sp , sp , - 0x40 addiu gp , gp , 0x30e0 sw s2 , 0x34 ( sp ) move s2 , a0 sw gp , 0x10 ( sp ) sw ra , 0x3c ( sp ) sw s3 , 0x38 ( sp ) move s3 , a1 sw s0 , 0x2c ( sp ) lw t9 , - 0x7f90 ( gp ) jalr t9 sw s1 , 0x30 ( sp ) addiu a1 , zero , 0x1 lw v1 , ( s2 ) move s0 , v0 lw v0 , ( v1 ) lw t9 , 0x44 ( v0 ) jalr t9 move a0 , v1 bnez v0 , 0x114 lw gp , 0x10 ( sp ) lui a1 , 0x4c lw t9 , - 0x7e08 ( gp ) move a2 , s3 addiu a1 , a1 , - 0x3358 jalr t9 move a0 , s0 addiu s1 , s0 , 0xc lw v0 , 0x8 ( s0 ) sltiu v0 , v0 , 0x4e beqz v0 , 0xa4 lw gp , 0x10 ( sp ) lw t9 , - 0x7fc4 ( gp ) addiu a1 , zero , 0x2d jalr t9 move a0 , s1 lw v0 , 0x8 ( s0 ) sltiu v0 , v0 , 0x4e bnez v0 , 0x84 lw gp , 0x10 ( sp ) lui v0 , 0x4c lw t9 , - 0x7dac ( gp ) addiu v1 , zero , 0x2 addiu v0 , v0 , - 0x5bac addiu a2 , zero , 0x2 sw v1 , 0x1c ( sp ) move a1 , v0 sw v0 , 0x18 ( sp ) jalr t9 move a0 , s1 addiu a1 , zero , 0x1 lw v0 , ( s2 ) lw a3 , 0x8 ( s0 ) move a0 , v0 lw v0 , ( v0 ) lw t9 , ( v0 ) jalr t9 lw a2 , 0x4 ( s0 ) move a0 , s0 lw gp , 0x10 ( sp ) lw ra , 0x3c ( sp ) lw s3 , 0x38 ( sp ) lw s2 , 0x34 ( sp ) lw s1 , 0x30 ( sp ) lw s0 , 0x2c ( sp ) lw t9 , - 0x7fac ( gp ) jr t9 addiu sp , sp , 0x40 lw t9 , - 0x74cc ( gp ) move a0 , s3 jalr t9 addiu s1 , s0 , 0xc move a1 , s3 lw gp , 0x10 ( sp ) move a2 , v0 sw s3 , 0x20 ( sp ) move a0 , s1 lw t9 , - 0x7dac ( gp ) jalr t9 sw v0 , 0x24 ( sp ) b 0xa4 lw gp , 0x10 ( sp )
Code2: push r13 push r12 mov r12 , rdi push rbp push rbx mov r13 , rsi sub rsp , 0x8 call 0x62b70 mov rdi , qword ptr [ r12 ] mov rbx , rax mov esi , 0x1 mov rax , qword ptr [ rdi ] call qword ptr [ rax + 0x88 ] test al , al jne 0xa0 lea rsi , [ rip + 0x6df2b ] xor eax , eax mov rdx , r13 mov rdi , rbx lea rbp , [ rbx + 0x18 ] call 0x62d00 cmp qword ptr [ rbx + 0x10 ] , 0x4d ja 0x64 nop dword ptr [ rax ] mov esi , 0x2d mov rdi , rbp call 0xfffffffffffccb50 cmp qword ptr [ rbx + 0x10 ] , 0x4d jbe 0x50 lea rsi , [ rip + 0x6b30f ] mov rdi , rbp mov edx , 0x2 call 0xfffffffffffccaa0 mov rdi , qword ptr [ r12 ] mov rcx , qword ptr [ rbx + 0x10 ] mov esi , 0x1 mov rdx , qword ptr [ rbx + 0x8 ] mov rax , qword ptr [ rdi ] call qword ptr [ rax ] add rsp , 0x8 mov rdi , rbx pop rbx pop rbp pop r12 pop r13 jmp 0x62c30 mov rcx , r13 mov edx , dword ptr [ rcx ] add rcx , 0x4 lea eax , [ rdx - 0x1010101 ] not edx and eax , edx and eax , 0x80808080 je 0xa3 mov edx , eax lea rbp , [ rbx + 0x18 ] shr edx , 0x10 test eax , 0x8080 cmove eax , edx lea rdx , [ rcx + 0x2 ] mov rdi , rbp mov esi , eax cmove rcx , rdx add sil , al mov rsi , r13 sbb rcx , 0x3 sub rcx , r13 mov rdx , rcx call 0xfffffffffffccaa0 jmp 0x64 nop dword ptr [ rax ] nop word ptr cs : [ rax + rax ]
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly codes are from fundamentally different architectures (MIPS-like vs x86-64), resulting in significant differences in instruction sets, register usage, and calling conventions. While both exhibit common low-level patterns like stack management and function calls, their operational sequences show no meaningful correspondence. Key differences include:
- MIPS uses explicit load/store instructions (lw/sw) and jump registers (jalr), while x86 uses push/pop and direct call instructions
- Register naming and usage patterns are entirely architecture-specific (e.g., MIPS gp/s2/t9 vs x86 r12/r13)
- Control flow mechanisms differ (MIPS bnez/beqz vs x86 jne/test)
- Memory addressing modes show no overlap in syntax or behavior
The architectural divergence and lack of matching instruction patterns indicate these implement unrelated functionality.
------------------------------------------------------------

------------------------------------------------------------
Code1: push ebp mov ebp , esp sub esp , 0x8 mov eax , dword ptr [ ebp + 0xc ] mov ecx , dword ptr [ ebp + 0x8 ] mov dword ptr [ ebp - 0x4 ] , eax mov dword ptr [ ebp - 0x8 ] , ecx mov eax , esp add eax , - 0x10 mov esp , eax mov ecx , esp add ecx , - 0x10 mov esp , ecx mov edx , dword ptr [ ebp - 0x8 ] mov dword ptr [ eax ] , edx mov eax , dword ptr [ ebp - 0x4 ] mov dword ptr [ ecx ] , eax mov eax , 0x1 mov esp , ebp pop ebp ret mov eax , esp add eax , - 0x10 mov esp , eax mov ecx , esp add ecx , - 0x10 mov esp , ecx mov edx , dword ptr [ ebp - 0x8 ] mov dword ptr [ eax ] , edx mov eax , dword ptr [ ebp - 0x4 ] mov dword ptr [ ecx ] , eax jmp 0x12
Code2: str fp , [ sp , - 0x4 ] ! add fp , sp , 0x0 sub sp , sp , 0xc str r0 , [ fp , - 0x8 ] str r1 , [ fp , - 0xc ] mov r3 , 0x1 mov r0 , r3 add sp , fp , 0x0 pop { fp } bx lr
Similarity: -1
Label: 1
Similarity Score: -0.9
Explanation: The two code snippets show minimal similarity due to fundamental differences in architecture (x86 vs ARM), register usage, stack management, and control flow. Both set up stack frames and return a value (1), but Code1 contains redundant stack operations and unreachable instructions after RET, while Code2 uses ARM-specific instructions (e.g., str!, pop {fp}, bx lr). The architectural divergence and structural differences outweigh the superficial commonalities.
------------------------------------------------------------

------------------------------------------------------------
Code1: push { r4 , r5 , r6 , r7 , r8 , sb , sl , lr } ldr r6 , [ pc , 0x19c ] sub sp , sp , 0xc8 ldr r3 , [ r6 ] mov r7 , r1 ldr r1 , [ pc , 0x190 ] str r3 , [ sp , 0xc4 ] mov r8 , r0 bl 0xffffec70 cmp r0 , 0x0 beq 0x124 cmp r7 , 0x0 bge 0x12c ldr r4 , [ pc , 0x174 ] ldr r3 , [ r4 , 0x1c ] add r5 , r4 , 0x1c cmp r3 , 0x0 beq 0x198 ldm r5 , { r0 , r1 } add r3 , sp , 0xc stm r3 , { r0 , r1 } ldr sb , [ sp , 0x10 ] mov r1 , r3 add r2 , sp , 0x14 ldr r0 , [ r4 , 0x24 ] bl 0xf69c cmp r0 , 0x0 beq 0x160 ldr r3 , [ r4 , 0x24 ] ldr r2 , [ r4 , 0x28 ] mvn r1 , 0x0 stm sp , { r3 , sb } mov r0 , 0x0 add r3 , sp , 0x14 bl 0x59a0 add sl , r0 , 0x1 mov r0 , sl bl 0xac9c ldr ip , [ r4 , 0x24 ] ldr r2 , [ r4 , 0x28 ] mov r1 , sl str sb , [ sp , 0x4 ] add r3 , sp , 0x14 str ip , [ sp ] mov r5 , r0 bl 0x59a0 ldr r0 , [ r4 , 0x2c ] bl 0xffffecac ldr r3 , [ r4 , 0x30 ] str r5 , [ r4 , 0x2c ] cmp r3 , 0x0 bne 0xdc cmp r7 , 0x0 ldr r3 , [ pc , 0xd8 ] movge r3 , r8 ldr r2 , [ pc , 0xd4 ] mov r0 , r5 mov r1 , 0x0 ldr r5 , [ r2 , 0xc ] str r3 , [ r4 , 0x34 ] bl 0x3d98 mov r1 , 0x0 sub r5 , r5 , r0 ldr r0 , [ r4 , 0x34 ] bl 0x3d98 ldr r2 , [ sp , 0xc4 ] ldr r3 , [ r6 ] sub r0 , r5 , r0 cmp r2 , r3 str r0 , [ r4 , 0x38 ] bne 0x1a4 add sp , sp , 0xc8 pop { r4 , r5 , r6 , r7 , r8 , sb , sl , pc } mvn r7 , 0x0 b 0x34 add r2 , sp , 0x40 mov r1 , r7 mov r0 , 0x3 bl 0xffffed6c cmp r0 , 0x0 bne 0x34 ldr r3 , [ sp , 0x90 ] ldr sb , [ sp , 0x94 ] str r3 , [ sp , 0xc ] str sb , [ sp , 0x10 ] ldr r4 , [ pc , 0x54 ] add r3 , sp , 0xc b 0x58 mov r0 , 0x21 bl 0xac9c mov r5 , r0 ldr r0 , [ sp , 0xc ] add r2 , sp , 0xac asr r1 , r0 , 0x1f bl 0x3a58 ldr r3 , [ pc , 0x38 ] stm sp , { r0 , sb } mov r2 , 0x21 mov r0 , r5 mov r1 , 0x1 bl 0xffffee80 b 0xb8 mov r0 , r5 bl 0x39ac b 0x48 bl 0xffffed0c andeq r6 , r3 , r8 , lsl 0x30 andeq r4 , r2 , r8 , lsl 0x8 strdeq r7 , r8 , [ r3 ] , -r0 andeq r4 , r2 , r8 , ror 0x8 andeq r7 , r3 , r8 , lsr r1 andeq r4 , r2 , ip , lsl 0x8
Code2: push ebp mov ebp , esp push edi push esi sub esp , 0x110 mov eax , dword ptr [ ebp + 0xc ] mov ecx , dword ptr [ ebp + 0x8 ] mov dword ptr [ ebp - 0xc ] , 0x0 mov edx , dword ptr [ ebp + 0x8 ] mov esi , esp mov dword ptr [ esi ] , edx mov dword ptr [ esi + 0x4 ] , 0x80620e0 mov dword ptr [ ebp - 0xd0 ] , eax mov dword ptr [ ebp - 0xd4 ] , ecx call 0xffff8020 cmp eax , 0x0 jne 0x47 mov dword ptr [ ebp + 0xc ] , 0xffffffff xor eax , eax cmp eax , dword ptr [ ebp + 0xc ] jg 0x9c mov eax , dword ptr [ ebp + 0xc ] mov dword ptr [ esp ] , eax lea eax , [ ebp - 0x70 ] mov dword ptr [ esp + 0x4 ] , eax call 0x2e00 cmp eax , 0x0 jne 0x9c lea eax , [ ebp - 0xb0 ] mov dword ptr [ esp ] , eax lea eax , [ ebp - 0x70 ] mov dword ptr [ esp + 0x4 ] , eax call 0x9890 sub esp , 0x4 mov eax , dword ptr [ ebp - 0xb0 ] mov dword ptr [ ebp - 0x78 ] , eax mov eax , dword ptr [ ebp - 0xac ] mov dword ptr [ ebp - 0x74 ] , eax jmp 0xc7 cmp dword ptr [ 0x8067274 ] , 0x0 jne 0xb7 lea eax , [ 0x8067274 ] mov dword ptr [ esp ] , eax call 0x39d0 mov eax , dword ptr [ 0x8067274 ] mov dword ptr [ ebp - 0x78 ] , eax mov eax , dword ptr [ 0x8067278 ] mov dword ptr [ ebp - 0x74 ] , eax lea eax , [ ebp - 0x78 ] mov ecx , dword ptr [ ebp - 0x74 ] mov dword ptr [ ebp - 0x7c ] , ecx mov ecx , dword ptr [ 0x806723c ] mov dword ptr [ esp ] , ecx mov dword ptr [ esp + 0x4 ] , eax lea eax , [ ebp - 0xa8 ] mov dword ptr [ esp + 0x8 ] , eax call 0xd380 cmp eax , 0x0 je 0x195 xor eax , eax mov ecx , dword ptr [ 0x806721c ] mov edx , dword ptr [ 0x806723c ] mov esi , dword ptr [ ebp - 0x7c ] mov dword ptr [ esp ] , 0x0 mov dword ptr [ esp + 0x4 ] , 0xffffffff mov dword ptr [ esp + 0x8 ] , ecx lea ecx , [ ebp - 0xa8 ] mov dword ptr [ esp + 0xc ] , ecx mov dword ptr [ esp + 0x10 ] , edx mov dword ptr [ esp + 0x14 ] , esi mov dword ptr [ ebp - 0xd8 ] , eax call 0x3fe0 add eax , 0x1 mov dword ptr [ ebp - 0xb4 ] , eax mov eax , dword ptr [ ebp - 0xb4 ] mov dword ptr [ esp ] , eax call 0xa7a0 mov dword ptr [ ebp - 0xc ] , eax mov eax , dword ptr [ ebp - 0xc ] mov ecx , dword ptr [ ebp - 0xb4 ] mov edx , dword ptr [ 0x806721c ] mov esi , dword ptr [ 0x806723c ] mov edi , dword ptr [ ebp - 0x7c ] mov dword ptr [ esp ] , eax mov dword ptr [ esp + 0x4 ] , ecx mov dword ptr [ esp + 0x8 ] , edx lea eax , [ ebp - 0xa8 ] mov dword ptr [ esp + 0xc ] , eax mov dword ptr [ esp + 0x10 ] , esi mov dword ptr [ esp + 0x14 ] , edi call 0x3fe0 mov dword ptr [ ebp - 0xdc ] , eax jmp 0x1eb mov dword ptr [ esp ] , 0x21 call 0x2e40 lea ecx , [ ebp - 0xc9 ] mov dword ptr [ ebp - 0xc ] , eax mov eax , dword ptr [ ebp - 0xc ] mov edx , dword ptr [ ebp - 0x78 ] mov dword ptr [ esp ] , edx mov dword ptr [ esp + 0x4 ] , ecx mov dword ptr [ ebp - 0xe0 ] , eax call 0x2d0 mov ecx , dword ptr [ ebp - 0x7c ] mov edx , dword ptr [ ebp - 0xe0 ] mov dword ptr [ esp ] , edx lea edx , [ 0x8060fff ] mov dword ptr [ esp + 0x4 ] , edx mov dword ptr [ esp + 0x8 ] , eax mov dword ptr [ esp + 0xc ] , ecx call 0xffff83a0 mov dword ptr [ ebp - 0xe4 ] , eax mov eax , dword ptr [ 0x806727c ] mov dword ptr [ esp ] , eax call 0xffff8070 mov eax , dword ptr [ ebp - 0xc ] mov dword ptr [ 0x806727c ] , eax cmp dword ptr [ 0x8067224 ] , 0x0 je 0x21d mov eax , dword ptr [ 0x8067224 ] mov dword ptr [ ebp - 0xe8 ] , eax jmp 0x24d cmp dword ptr [ ebp + 0xc ] , 0x0 jge 0x238 lea eax , [ 0x8060ffc ] mov dword ptr [ ebp - 0xec ] , eax jmp 0x241 mov eax , dword ptr [ ebp + 0x8 ] mov dword ptr [ ebp - 0xec ] , eax mov eax , dword ptr [ ebp - 0xec ] mov dword ptr [ ebp - 0xe8 ] , eax mov eax , dword ptr [ ebp - 0xe8 ] xor ecx , ecx mov dword ptr [ 0x8067280 ] , eax mov eax , dword ptr [ 0x806715c ] mov edx , dword ptr [ 0x806727c ] mov dword ptr [ esp ] , edx mov dword ptr [ esp + 0x4 ] , 0x0 mov dword ptr [ ebp - 0xf0 ] , ecx mov dword ptr [ ebp - 0xf4 ] , eax call 0x2e80 xor ecx , ecx mov edx , dword ptr [ ebp - 0xf4 ] sub edx , eax mov eax , dword ptr [ 0x8067280 ] mov dword ptr [ esp ] , eax mov dword ptr [ esp + 0x4 ] , 0x0 mov dword ptr [ ebp - 0xf8 ] , ecx mov dword ptr [ ebp - 0xfc ] , edx call 0x2ec0 mov ecx , dword ptr [ ebp - 0xfc ] sub ecx , eax mov dword ptr [ 0x8067284 ] , ecx add esp , 0x110 pop esi pop edi pop ebp ret nop word ptr cs : [ eax + eax ] nop
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly codes show fundamental differences that indicate they are not similar:
1. Architecture difference: Code1 uses ARM instruction set (e.g., `ldr`, `bl`, `stm`) while Code2 uses x86 instruction set (e.g., `mov dword ptr`, `call`, `jne`).
2. Register usage: ARM registers (r0-r8, sb, sl, lr) vs x86 registers (eax, ebp, esp, esi, edi).
3. Stack management: Code1 uses `sub sp, sp, 0xc8` and `add sp, sp, 0xc8` while Code2 uses `sub esp, 0x110` and `add esp, 0x110`.
4. Control flow patterns: Code1 has ARM-specific conditional branching (`beq`, `bge`) and load/store multiple (`ldm`/`stm`) instructions absent in Code2.
5. Function call conventions: Code1 uses `bl` for branch-with-link while Code2 uses `call`.
6. Memory access: Code1 uses PC-relative addressing (`ldr r6, [pc, 0x19c]`) while Code2 uses base-pointer offsets (`mov eax, dword ptr [ebp + 0xc]`).

The structural and functional differences are substantial with no overlapping logic sequences, indicating completely different implementations.
------------------------------------------------------------

------------------------------------------------------------
Code1: push rbp mov rbp , rsp push r15 push r14 push r13 push r12 push rbx sub rsp , 0x88 mov qword ptr [ rbp - 0x30 ] , rdi mov qword ptr [ rbp - 0x38 ] , rsi mov qword ptr [ rbp - 0x40 ] , rdx mov qword ptr [ rbp - 0x48 ] , rcx mov rax , rsp add rax , - 0x10 mov rsp , rax mov rcx , rsp add rcx , - 0x10 mov rsp , rcx mov rdx , rsp add rdx , - 0x10 mov rsp , rdx mov rsi , rsp add rsi , - 0x10 mov rsp , rsi mov rdi , rsp add rdi , - 0x10 mov rsp , rdi mov r8 , rsp add r8 , - 0x10 mov rsp , r8 mov r9 , rsp add r9 , - 0x10 mov rsp , r9 mov r10 , rsp add r10 , - 0x10 mov rsp , r10 mov r11 , qword ptr [ rbp - 0x30 ] mov qword ptr [ rcx ] , r11 mov rbx , qword ptr [ rbp - 0x38 ] mov qword ptr [ rdx ] , rbx mov r14 , qword ptr [ rbp - 0x40 ] mov qword ptr [ rsi ] , r14 mov r15 , qword ptr [ rbp - 0x48 ] mov qword ptr [ rdi ] , r15 mov r12 , qword ptr [ rdx ] mov qword ptr [ rbp - 0x50 ] , rdi mov rdi , r12 mov r12d , 0x40 mov qword ptr [ rbp - 0x58 ] , rsi mov rsi , r12 mov qword ptr [ rbp - 0x60 ] , rax mov qword ptr [ rbp - 0x68 ] , rcx mov qword ptr [ rbp - 0x70 ] , rdx mov qword ptr [ rbp - 0x78 ] , r8 mov qword ptr [ rbp - 0x80 ] , r9 mov qword ptr [ rbp - 0x88 ] , r10 call 0xc7 mov rcx , qword ptr [ rbp - 0x78 ] mov qword ptr [ rcx ] , rax cmp qword ptr [ rcx ] , 0x0 sete r13b mov byte ptr [ rbp - 0x89 ] , r13b mov al , byte ptr [ rbp - 0x89 ] test al , 0x1 jne 0xf0 jmp 0xff mov rax , qword ptr [ rbp - 0x60 ] mov dword ptr [ rax ] , 0xd jmp 0x224 mov rax , qword ptr [ rbp - 0x80 ] mov qword ptr [ rax ] , 0x0 mov rax , qword ptr [ rbp - 0x80 ] mov rcx , qword ptr [ rax ] mov rdx , qword ptr [ rbp - 0x70 ] cmp rcx , qword ptr [ rdx ] setb sil mov byte ptr [ rbp - 0x8a ] , sil mov al , byte ptr [ rbp - 0x8a ] test al , 0x1 jne 0x136 jmp 0x1ae mov rax , qword ptr [ rbp - 0x78 ] mov rcx , qword ptr [ rax ] mov rdx , qword ptr [ rbp - 0x80 ] mov rsi , qword ptr [ rdx ] shl rsi , 0x6 add rcx , rsi mov rsi , qword ptr [ rbp - 0x68 ] mov rdi , qword ptr [ rsi ] mov r8 , qword ptr [ rdx ] shl r8 , 0x6 add rdi , r8 mov qword ptr [ rbp - 0x98 ] , rdi mov rdi , rcx mov rsi , qword ptr [ rbp - 0x98 ] mov edx , 0x40 call 0x177 mov rax , qword ptr [ rbp - 0x80 ] mov rcx , qword ptr [ rax ] mov r9d , ecx mov rcx , qword ptr [ rbp - 0x78 ] mov rdx , qword ptr [ rcx ] mov rsi , qword ptr [ rax ] shl rsi , 0x6 add rdx , rsi mov dword ptr [ rdx + 0x18 ] , r9d jmp 0x19b mov rax , qword ptr [ rbp - 0x80 ] mov rcx , qword ptr [ rax ] add rcx , 0x1 mov qword ptr [ rax ] , rcx jmp 0x10a mov rax , qword ptr [ rbp - 0x78 ] mov rcx , qword ptr [ rax ] mov rdx , qword ptr [ rbp - 0x70 ] mov rsi , qword ptr [ rdx ] mov rdi , rcx mov edx , 0x40 movabs rcx , 0x0 call 0x1d3 mov rax , qword ptr [ rbp - 0x78 ] mov rdi , qword ptr [ rax ] mov rcx , qword ptr [ rbp - 0x70 ] mov rsi , qword ptr [ rcx ] mov rdx , qword ptr [ rbp - 0x58 ] mov rdx , qword ptr [ rdx ] mov r8 , qword ptr [ rbp - 0x50 ] mov rcx , qword ptr [ r8 ] mov r9d , 0xe mov r8d , r9d call 0x1fd mov rcx , qword ptr [ rbp - 0x88 ] mov dword ptr [ rcx ] , eax mov rdx , qword ptr [ rbp - 0x78 ] mov rsi , qword ptr [ rdx ] mov rdi , rsi call 0x215 mov rcx , qword ptr [ rbp - 0x88 ] mov eax , dword ptr [ rcx ] mov rdx , qword ptr [ rbp - 0x60 ] mov dword ptr [ rdx ] , eax mov rax , qword ptr [ rbp - 0x60 ] mov ecx , dword ptr [ rax ] mov eax , ecx lea rsp , [ rbp - 0x28 ] pop rbx pop r12 pop r13 pop r14 pop r15 pop rbp ret mov rax , rsp add rax , - 0x10 mov rsp , rax mov rax , rsp add rax , - 0x10 mov rsp , rax mov rcx , rsp add rcx , - 0x10 mov rsp , rcx mov rdx , rsp add rdx , - 0x10 mov rsp , rdx mov rsi , rsp add rsi , - 0x10 mov rsp , rsi mov rdi , rsp add rdi , - 0x10 mov rsp , rdi mov r8 , qword ptr [ rbp - 0x30 ] mov qword ptr [ rax ] , r8 mov rax , qword ptr [ rbp - 0x38 ] mov qword ptr [ rcx ] , rax mov r9 , qword ptr [ rbp - 0x40 ] mov qword ptr [ rdx ] , r9 mov rdx , qword ptr [ rbp - 0x48 ] mov qword ptr [ rsi ] , rdx mov rcx , qword ptr [ rcx ] mov qword ptr [ rbp - 0xa0 ] , rdi mov rdi , rcx mov esi , 0x40 call 0x2aa mov rcx , qword ptr [ rbp - 0xa0 ] mov qword ptr [ rcx ] , rax jmp 0x24 mov rax , qword ptr [ rbp - 0x60 ] mov dword ptr [ rax ] , 0xd jmp 0xf0 jmp 0x10a mov rax , qword ptr [ rbp - 0x78 ] mov rcx , qword ptr [ rax ] mov rdx , qword ptr [ rbp - 0x80 ] mov rsi , qword ptr [ rdx ] shl rsi , 0x6 add rcx , rsi mov rsi , qword ptr [ rbp - 0x68 ] mov rdi , qword ptr [ rsi ] mov r8 , qword ptr [ rdx ] shl r8 , 0x6 add rdi , r8 mov qword ptr [ rbp - 0xa8 ] , rdi mov rdi , rcx mov rsi , qword ptr [ rbp - 0xa8 ] mov edx , 0x40 call 0x30e mov rax , qword ptr [ rbp - 0x80 ] mov rcx , qword ptr [ rax ] mov r9d , ecx mov rcx , qword ptr [ rbp - 0x78 ] mov rdx , qword ptr [ rcx ] mov rsi , qword ptr [ rax ] shl rsi , 0x6 add rdx , rsi mov dword ptr [ rdx + 0x18 ] , r9d jmp 0x136 nop word ptr cs : [ rax + rax ] nop dword ptr [ rax ]
Code2: push rbp push r15 push r14 push r13 push r12 push rbx push rax mov r14 , rcx mov r15 , rdx mov r12 , rsi mov r13 , rdi mov esi , 0x40 mov rdi , r12 call 0x24 test rax , rax je 0x51 mov rbx , rax test r12 , r12 je 0x11a mov ecx , r12d and ecx , 0x1 cmp r12 , 0x1 jne 0x5b xor eax , eax test rcx , rcx jne 0xe4 jmp 0x11a mov eax , 0xd jmp 0x152 mov rdx , r12 sub rdx , rcx mov esi , 0x40 xor eax , eax nop dword ptr [ rax + rax ] movups xmm0 , xmmword ptr [ r13 + rsi - 0x40 ] movups xmm1 , xmmword ptr [ r13 + rsi - 0x30 ] movups xmm2 , xmmword ptr [ r13 + rsi - 0x20 ] movups xmm3 , xmmword ptr [ r13 + rsi - 0x10 ] movups xmmword ptr [ rbx + rsi - 0x30 ] , xmm1 movups xmmword ptr [ rbx + rsi - 0x10 ] , xmm3 movups xmmword ptr [ rbx + rsi - 0x20 ] , xmm2 movups xmmword ptr [ rbx + rsi - 0x40 ] , xmm0 mov dword ptr [ rbx + rsi - 0x28 ] , eax movups xmm0 , xmmword ptr [ r13 + rsi ] movups xmm1 , xmmword ptr [ r13 + rsi + 0x10 ] movups xmm2 , xmmword ptr [ r13 + rsi + 0x20 ] movups xmm3 , xmmword ptr [ r13 + rsi + 0x30 ] movups xmmword ptr [ rbx + rsi + 0x10 ] , xmm1 movups xmmword ptr [ rbx + rsi + 0x30 ] , xmm3 movups xmmword ptr [ rbx + rsi + 0x20 ] , xmm2 movups xmmword ptr [ rbx + rsi ] , xmm0 lea edi , [ rax + 0x1 ] mov dword ptr [ rbx + rsi + 0x18 ] , edi add rax , 0x2 sub rsi , - 0x80 cmp rdx , rax jne 0x70 test rcx , rcx je 0x11a mov rcx , rax shl rcx , 0x6 movups xmm0 , xmmword ptr [ r13 + rcx ] movups xmm1 , xmmword ptr [ r13 + rcx + 0x10 ] movups xmm2 , xmmword ptr [ r13 + rcx + 0x20 ] movups xmm3 , xmmword ptr [ r13 + rcx + 0x30 ] movups xmmword ptr [ rbx + rcx + 0x10 ] , xmm1 movups xmmword ptr [ rbx + rcx + 0x30 ] , xmm3 movups xmmword ptr [ rbx + rcx + 0x20 ] , xmm2 movups xmmword ptr [ rbx + rcx ] , xmm0 mov dword ptr [ rbx + rcx + 0x18 ] , eax mov edx , 0x40 mov ecx , 0x0 mov rdi , rbx mov rsi , r12 call 0x12f mov rdi , rbx mov rsi , r12 mov rdx , r15 mov rcx , r14 mov r8d , 0xe call 0x146 mov ebp , eax mov rdi , rbx call 0x150 mov eax , ebp add rsp , 0x8 pop rbx pop r12 pop r13 pop r14 pop r15 pop rbp ret nop word ptr cs : [ rax + rax ] nop dword ptr [ rax + rax ]
Similarity: -1
Label: 1
Similarity Score: 0.1
Explanation: Both codes share a standard function prologue and epilogue (saving/restoring registers) and involve memory manipulation, but the core logic differs significantly. Code1 uses a frame pointer and non-SIMD memory operations with explicit loops, while Code2 uses SIMD instructions (movups) and a different loop structure. The control flow, function calls, and register usage in the main body are distinct, indicating different implementations. The minimal similarity (0.1) is due to the common prologue/epilogue structure, but the codes are not similar overall (-1).
------------------------------------------------------------

------------------------------------------------------------
Code1: push ebp push edi push esi push ebx sub esp , 0x102c call 0xfff8dd40 add ebx , 0x331531 mov esi , dword ptr [ esp + 0x1040 ] fld qword ptr [ esp + 0x1044 ] fstp qword ptr [ esp ] fld qword ptr [ esp + 0x104c ] fstp qword ptr [ esp + 0x8 ] mov edi , dword ptr [ esp + 0x1054 ] mov eax , dword ptr gs : [ 0x14 ] mov dword ptr [ esp + 0x101c ] , eax xor eax , eax test esi , esi je 0xfa cmp dword ptr [ esi + 0x3344 ] , 0xabacadab jne 0x119 cmp dword ptr [ esi + 0x3328 ] , 0x0 jne 0x138 test edi , edi je 0x16e cmp dword ptr [ edi + 0x1c ] , 0xabacadab jne 0x18d sub esp , 0x4 push dword ptr [ esp + 0x10 ] push dword ptr [ esp + 0x10 ] push dword ptr [ esp + 0x10 ] push dword ptr [ esp + 0x10 ] lea eax , [ ebx - 0x138228 ] push eax push 0x1000 lea ebp , [ esp + 0x38 ] push ebp call 0xfff8d730 add esp , 0x18 push edi push ebp call 0xfff8cde0 mov ebp , eax add esp , 0x10 test eax , eax je 0x1ac sub esp , 0x4 push edi push eax push esi call 0xfff8c240 mov esi , eax mov dword ptr [ esp ] , ebp call 0xfff8b400 add esp , 0x10 mov eax , esi mov edx , dword ptr [ esp + 0x101c ] xor edx , dword ptr gs : [ 0x14 ] jne 0x1ec add esp , 0x102c pop ebx pop esi pop edi pop ebp ret lea eax , [ ebx - 0x12fefc ] push eax push 0x56a lea eax , [ ebx - 0x130448 ] push eax lea eax , [ ebx - 0x142c08 ] push eax call 0xfff8b680 lea eax , [ ebx - 0x12fefc ] push eax push 0x56b lea eax , [ ebx - 0x130448 ] push eax lea eax , [ ebx - 0x138108 ] push eax call 0xfff8b680 sub esp , 0x8 lea eax , [ esi + 0x318 ] push eax lea eax , [ ebx - 0x12b2fa ] push eax push 0x56d lea eax , [ ebx - 0x12ff10 ] push eax lea eax , [ ebx - 0x130448 ] push eax push 0x8000 call 0xfff8c650 add esp , 0x20 jmp 0x6c lea eax , [ ebx - 0x12fefc ] push eax push 0x56e lea eax , [ ebx - 0x130448 ] push eax lea eax , [ ebx - 0x142964 ] push eax call 0xfff8b680 lea eax , [ ebx - 0x12fefc ] push eax push 0x56f lea eax , [ ebx - 0x130448 ] push eax lea eax , [ ebx - 0x141c0c ] push eax call 0xfff8b680 add esi , 0x318 push esi lea eax , [ ebx - 0x140980 ] push eax lea eax , [ ebx - 0x142fe2 ] push eax push 0x190 push 0x574 lea eax , [ ebx - 0x12ff10 ] push eax lea eax , [ ebx - 0x130448 ] push eax push edi call 0xfff8d0f0 add esp , 0x20 mov esi , 0x0 jmp 0xd9 call 0x1edc30
Code2: push { r4 , r5 , r6 , r7 , r8 , sb , lr } ldr r1 , [ pc , 0x214 ] ldr ip , [ pc , 0x214 ] add r1 , pc , r1 sub sp , sp , 0x1000 sub sp , sp , 0x1c ldr r7 , [ r1 , ip ] mov r8 , r2 add r2 , sp , 0x1040 ldr r4 , [ r2 ] mov sb , r3 add r2 , sp , 0x1000 ldr r3 , [ r7 ] add r2 , r2 , 0x14 subs r6 , r0 , 0x0 str r3 , [ r2 ] beq 0x1b4 add r3 , r6 , 0x3000 ldr r1 , [ r3 , 0x36c ] ldr r2 , [ pc , 0x1d4 ] cmp r1 , r2 bne 0x190 ldr r3 , [ r3 , 0x350 ] cmp r3 , 0x0 bne 0x104 cmp r4 , 0x0 beq 0x1fc ldr r3 , [ pc , 0x1b4 ] ldr r2 , [ r4 , 0x1c ] cmp r2 , r3 bne 0x1d8 add r3 , sp , 0x1000 add r3 , r3 , 0x38 ldm r3 , { r2 , r3 } str r2 , [ sp , 0x8 ] str r3 , [ sp , 0xc ] ldr r2 , [ pc , 0x194 ] add r5 , sp , 0x14 mov r0 , r5 add r2 , pc , r2 mov r1 , 0x1000 stm sp , { r8 , sb } bl 0xfff584a4 mov r0 , r5 mov r1 , r4 bl 0xfff57db4 subs r5 , r0 , 0x0 beq 0x13c mov r2 , r4 mov r0 , r6 mov r1 , r5 bl 0xfff57424 mov r4 , r0 mov r0 , r5 bl 0xfff56998 add r3 , sp , 0x1000 add r3 , r3 , 0x14 ldr r2 , [ r3 ] ldr r3 , [ r7 ] mov r0 , r4 cmp r2 , r3 bne 0x18c add sp , sp , 0x1000 add sp , sp , 0x1c pop { r4 , r5 , r6 , r7 , r8 , sb , pc } add r1 , r6 , 0x340 ldr r2 , [ pc , 0x120 ] ldr r3 , [ pc , 0x120 ] str r1 , [ sp , 0x4 ] ldr r1 , [ pc , 0x11c ] add r3 , pc , r3 add r2 , pc , r2 str r3 , [ sp ] add r2 , r2 , 0x104 ldr r3 , [ pc , 0x10c ] add r1 , pc , r1 mov r0 , 0x8000 bl 0xfff57784 b 0x64 mov ip , 0x190 ldr r1 , [ pc , 0xf8 ] ldr r2 , [ pc , 0xf8 ] add r1 , pc , r1 ldr r3 , [ pc , 0xf4 ] str r1 , [ sp , 0x8 ] ldr r1 , [ pc , 0xf0 ] add r6 , r6 , 0x340 add r3 , pc , r3 add r2 , pc , r2 str r3 , [ sp , 0x4 ] str r6 , [ sp , 0xc ] mov r0 , r4 str ip , [ sp ] add r2 , r2 , 0x104 ldr r3 , [ pc , 0xd0 ] add r1 , pc , r1 mov r4 , r5 bl 0xfff57ff4 b 0xdc bl 0xfff57c28 ldr r3 , [ pc , 0xbc ] ldr r1 , [ pc , 0xbc ] ldr r0 , [ pc , 0xbc ] add r3 , pc , r3 ldr r2 , [ pc , 0xb8 ] add r3 , r3 , 0xf0 add r1 , pc , r1 add r0 , pc , r0 bl 0xfff56bcc ldr r3 , [ pc , 0xa8 ] ldr r1 , [ pc , 0xa8 ] ldr r0 , [ pc , 0xa8 ] add r3 , pc , r3 ldr r2 , [ pc , 0xa4 ] add r3 , r3 , 0xf0 add r1 , pc , r1 add r0 , pc , r0 bl 0xfff56bcc ldr r3 , [ pc , 0x94 ] ldr r1 , [ pc , 0x94 ] ldr r0 , [ pc , 0x94 ] add r3 , pc , r3 ldr r2 , [ pc , 0x90 ] add r3 , r3 , 0xf0 add r1 , pc , r1 add r0 , pc , r0 bl 0xfff56bcc ldr r3 , [ pc , 0x80 ] ldr r1 , [ pc , 0x80 ] ldr r0 , [ pc , 0x80 ] add r3 , pc , r3 ldr r2 , [ pc , 0x7c ] add r3 , r3 , 0xf0 add r1 , pc , r1 add r0 , pc , r0 bl 0xfff56bcc eoreq r8 , pc , r4 , ror ip andeq r0 , r0 , ip , lsr 0x27 blge 0xfeb2b8dc eoreq r6 , r6 , r0 , ror 0x17 eoreq sp , r6 , r8 , lsl 0x6 eoreq r0 , r7 , r8 , asr 0x28 mlaeq r6 , r0 , r5 , sp andeq r0 , r0 , sp , ror 0x10 eoreq lr , r5 , r4 , asr 0x31 eoreq sp , r6 , r4 , asr 0x5 eoreq ip , r5 , ip , lsl 0x14 eoreq sp , r6 , r0 , asr 0x10 andeq r0 , r0 , r4 , ror r5 eoreq sp , r6 , r8 , lsl 0x5 eoreq sp , r6 , r4 , lsl r5 eoreq r6 , r6 , r8 , asr r8 andeq r0 , r0 , fp , ror 0x10 eoreq sp , r6 , r4 , ror 0x4
Similarity: -1
Label: 1
Similarity Score: 0.1
Explanation: The codes show minimal similarity due to:
1. Different architectures (x86 vs ARM) with distinct instruction sets and registers
2. No matching functional sequences or control flow patterns
3. Different stack management approaches (fixed offsets vs PC-relative)
4. ARM code contains invalid instructions at the end (e.g., eoreq) not present in x86
5. Floating-point operations in x86 absent in ARM
While both check magic value 0xabacadab, this isolated similarity is insufficient to overcome fundamental architectural and structural differences.
------------------------------------------------------------

------------------------------------------------------------
Code1: addiu sp , sp , - 0x50 sw ra , 0x4c ( sp ) sw fp , 0x48 ( sp ) sw s1 , 0x44 ( sp ) sw s0 , 0x40 ( sp ) move fp , sp lui gp , 0x42 addiu gp , gp , 0x30d0 sw gp , 0x18 ( sp ) sw a0 , 0x24 ( fp ) sw a1 , 0x54 ( fp ) lw v0 , - 0x7e80 ( gp ) lw v0 , ( v0 ) sw v0 , 0x3c ( fp ) lui v0 , 0x41 addiu a1 , v0 , - 0x64b0 lw a0 , 0x24 ( fp ) lw v0 , - 0x7f30 ( gp ) move t9 , v0 jalr t9 nop lw gp , 0x18 ( fp ) sw v0 , 0x28 ( fp ) lw v1 , 0x24 ( fp ) lw v0 , 0x28 ( fp ) addu v0 , v1 , v0 sw v0 , 0x2c ( fp ) lw v0 , 0x2c ( fp ) lb v0 , ( v0 ) beqz v0 , 0x174 nop sw zero , 0x34 ( fp ) sw zero , 0x38 ( fp ) lw v1 , 0x54 ( fp ) lw v0 , 0x28 ( fp ) subu v0 , v1 , v0 addiu v1 , fp , 0x34 move a2 , v1 move a1 , v0 lw a0 , 0x2c ( fp ) lw v0 , - 0x7fb0 ( gp ) move t9 , v0 bal 0x6760 nop lw gp , 0x18 ( fp ) sw v0 , 0x30 ( fp ) lui v0 , 0x41 addiu a0 , v0 , - 0x646c lw v0 , - 0x7ecc ( gp ) move t9 , v0 jalr t9 nop lw gp , 0x18 ( fp ) move s0 , v0 lw v0 , 0x30 ( fp ) sltiu v0 , v0 , 0x11 beqz v0 , 0xf4 nop lw v0 , 0x30 ( fp ) b 0xf8 nop addiu v0 , zero , 0x1 move a3 , v0 lw a2 , 0x2c ( fp ) addiu a1 , zero , 0x8 addiu a0 , zero , 0x1 lw v0 , - 0x7fac ( gp ) move t9 , v0 bal 0x33d8 nop lw gp , 0x18 ( fp ) move s1 , v0 lw a2 , 0x24 ( fp ) addiu a1 , zero , 0x4 move a0 , zero lw v0 , - 0x7fa8 ( gp ) move t9 , v0 bal 0x3330 nop lw gp , 0x18 ( fp ) sw v0 , 0x10 ( sp ) move a3 , s1 move a2 , s0 move a1 , zero move a0 , zero lw v0 , - 0x7eb0 ( gp ) move t9 , v0 jalr t9 nop lw gp , 0x18 ( fp ) move v0 , zero b 0x178 nop addiu v0 , zero , 0x1 lw v1 , - 0x7e80 ( gp ) lw a0 , 0x3c ( fp ) lw v1 , ( v1 ) beq a0 , v1 , 0x19c nop lw v0 , - 0x7e8c ( gp ) move t9 , v0 jalr t9 nop move sp , fp lw ra , 0x4c ( sp ) lw fp , 0x48 ( sp ) lw s1 , 0x44 ( sp ) lw s0 , 0x40 ( sp ) addiu sp , sp , 0x50 jr ra nop
Code2: push ebp mov ebp , esp push ebx sub esp , 0x84 mov eax , dword ptr [ ebp + 0xc ] mov ecx , dword ptr [ ebp + 0x8 ] mov edx , dword ptr [ ebp + 0x8 ] mov dword ptr [ esp ] , edx lea edx , [ 0x8051422 ] mov dword ptr [ esp + 0x4 ] , edx mov dword ptr [ ebp - 0x30 ] , eax mov dword ptr [ ebp - 0x34 ] , ecx call 0xffffe310 mov dword ptr [ ebp - 0x14 ] , eax mov eax , dword ptr [ ebp + 0x8 ] add eax , dword ptr [ ebp - 0x14 ] mov dword ptr [ ebp - 0x18 ] , eax mov eax , dword ptr [ ebp - 0x18 ] mov bl , byte ptr [ eax ] mov byte ptr [ ebp - 0xd ] , bl mov dword ptr [ ebp - 0x28 ] , 0xbf35ae03 mov eax , dword ptr [ ebp - 0x28 ] mov ecx , eax sub ecx , 0xab378c0d mov dword ptr [ ebp - 0x38 ] , eax mov dword ptr [ ebp - 0x3c ] , ecx je 0x18b jmp 0x62 mov eax , dword ptr [ ebp - 0x38 ] sub eax , 0xae7a2c4e mov dword ptr [ ebp - 0x40 ] , eax je 0x22e jmp 0x78 mov eax , dword ptr [ ebp - 0x38 ] sub eax , 0xaf7aaea0 mov dword ptr [ ebp - 0x44 ] , eax je 0x21e jmp 0x8e mov eax , dword ptr [ ebp - 0x38 ] sub eax , 0xb69fbe97 mov dword ptr [ ebp - 0x48 ] , eax je 0x179 jmp 0xa4 mov eax , dword ptr [ ebp - 0x38 ] sub eax , 0xbf35ae03 mov dword ptr [ ebp - 0x4c ] , eax je 0xeb jmp 0xba mov eax , dword ptr [ ebp - 0x38 ] sub eax , 0x11cdc341 mov dword ptr [ ebp - 0x50 ] , eax je 0x105 jmp 0xd0 mov eax , dword ptr [ ebp - 0x38 ] sub eax , 0x56245de9 mov dword ptr [ ebp - 0x54 ] , eax je 0x19e jmp 0xe6 jmp 0x23f mov al , byte ptr [ ebp - 0xd ] cmp al , 0x0 mov ecx , 0x11cdc341 mov edx , 0xaf7aaea0 cmovne edx , ecx mov dword ptr [ ebp - 0x28 ] , edx jmp 0x23f xor eax , eax lea ecx , [ ebp - 0x20 ] mov edx , ecx mov dword ptr [ esp ] , edx mov dword ptr [ esp + 0x4 ] , 0x0 mov dword ptr [ esp + 0x8 ] , 0x8 mov dword ptr [ ebp - 0x58 ] , eax mov dword ptr [ ebp - 0x5c ] , ecx call 0xffffe250 mov eax , dword ptr [ ebp - 0x18 ] mov ecx , dword ptr [ ebp + 0xc ] sub ecx , dword ptr [ ebp - 0x14 ] mov dword ptr [ esp ] , eax mov dword ptr [ esp + 0x4 ] , ecx mov eax , dword ptr [ ebp - 0x5c ] mov dword ptr [ esp + 0x8 ] , eax call 0x43d0 mov dword ptr [ ebp - 0x24 ] , eax lea eax , [ 0x8051465 ] mov dword ptr [ esp ] , eax call 0xffffe1e0 mov dword ptr [ ebp - 0xc ] , eax mov eax , dword ptr [ ebp - 0x18 ] mov dword ptr [ ebp - 0x8 ] , eax cmp dword ptr [ ebp - 0x24 ] , 0x10 mov eax , 0xb69fbe97 mov ecx , 0xab378c0d cmovbe ecx , eax mov dword ptr [ ebp - 0x28 ] , ecx jmp 0x23f mov eax , dword ptr [ ebp - 0x24 ] mov dword ptr [ ebp - 0x28 ] , 0x56245de9 mov dword ptr [ ebp - 0x2c ] , eax jmp 0x23f mov dword ptr [ ebp - 0x28 ] , 0x56245de9 mov dword ptr [ ebp - 0x2c ] , 0x1 jmp 0x23f mov eax , dword ptr [ ebp - 0x2c ] mov ecx , dword ptr [ ebp - 0x8 ] mov dword ptr [ esp ] , 0x1 mov dword ptr [ esp + 0x4 ] , 0x8 mov dword ptr [ esp + 0x8 ] , ecx mov dword ptr [ esp + 0xc ] , eax call 0x2a50 xor ecx , ecx mov edx , dword ptr [ ebp + 0x8 ] mov dword ptr [ esp ] , 0x0 mov dword ptr [ esp + 0x4 ] , 0x4 mov dword ptr [ esp + 0x8 ] , edx mov dword ptr [ ebp - 0x60 ] , eax mov dword ptr [ ebp - 0x64 ] , ecx call 0x2990 xor ecx , ecx mov edx , dword ptr [ ebp - 0xc ] mov dword ptr [ esp ] , 0x0 mov dword ptr [ esp + 0x4 ] , 0x0 mov dword ptr [ esp + 0x8 ] , edx mov edx , dword ptr [ ebp - 0x60 ] mov dword ptr [ esp + 0xc ] , edx mov dword ptr [ esp + 0x10 ] , eax mov dword ptr [ ebp - 0x68 ] , ecx call 0xffffe190 mov byte ptr [ ebp - 0xe ] , 0x0 mov dword ptr [ ebp - 0x28 ] , 0xae7a2c4e jmp 0x23f mov byte ptr [ ebp - 0xe ] , 0x1 mov dword ptr [ ebp - 0x28 ] , 0xae7a2c4e jmp 0x23f mov al , byte ptr [ ebp - 0xe ] and al , 0x1 movzx eax , al add esp , 0x84 pop ebx pop ebp ret jmp 0x46 nop word ptr cs : [ eax + eax ] nop
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly codes are for entirely different architectures (MIPS vs x86) with no overlapping instructions or structural similarities beyond basic function prologue/epilogue conventions. The core logic, including memory operations, branching patterns, and function calls, shows no meaningful correspondence. The constants, register usage, and instruction sequences are completely dissimilar, indicating different functionality.
------------------------------------------------------------

------------------------------------------------------------
Code1: push rbx sub rsp , 0x48a0 movaps xmm0 , xmmword ptr [ rip ] movaps xmmword ptr [ rsp + 0x50 ] , xmm0 movaps xmm0 , xmmword ptr [ rip ] movaps xmmword ptr [ rsp + 0x40 ] , xmm0 movaps xmm0 , xmmword ptr [ rip ] movaps xmmword ptr [ rsp + 0x30 ] , xmm0 mov word ptr [ rsp + 0x60 ] , 0x3231 movabs rax , 0x39cbd78ba5a78231 mov qword ptr [ rsp + 0x20 ] , rax mov word ptr [ rsp + 0x28 ] , 0x1a86 movabs rax , 0xe69b62e7bc9e436b mov qword ptr [ rsp + 0x10 ] , rax mov word ptr [ rsp + 0x18 ] , 0x839b movabs rax , 0x4973b4cfc16c0e4a mov qword ptr [ rsp ] , rax mov word ptr [ rsp + 0x8 ] , 0x599 mov word ptr [ rsp + 0x4898 ] , 0x0 xorps xmm0 , xmm0 movups xmmword ptr [ rsp + 0x44c ] , xmm0 movups xmmword ptr [ rsp + 0x43c ] , xmm0 mov qword ptr [ rsp + 0x45c ] , 0x0 mov qword ptr [ rsp + 0x468 ] , 0x0 lea rdi , [ rsp + 0x30 ] lea rdx , [ rsp + 0x3a8 ] mov esi , 0x32 call 0xfffffffffffffb30 test eax , eax jne 0x196 lea rbx , [ rsp + 0x43c ] cmp word ptr [ rsp + 0x4898 ] , 0x0 je 0x104 lea rdi , [ rsp + 0x3a8 ] lea rsi , [ rsp + 0x70 ] mov edx , 0xa call 0xf2 test eax , eax je 0x168 mov eax , 0x9 add rsp , 0x48a0 pop rbx ret lea rdi , [ rsp + 0x3a8 ] mov edx , 0x20 mov rsi , rbx call 0x119 test eax , eax jne 0x196 lea rsi , [ rsp + 0x45c ] lea rdi , [ rsp + 0x3a8 ] mov edx , 0x8 call 0x137 test eax , eax jne 0x196 xorps xmm0 , xmm0 movups xmmword ptr [ rbx + 0x10 ] , xmm0 movups xmmword ptr [ rbx ] , xmm0 mov qword ptr [ rbx + 0x20 ] , 0x0 mov qword ptr [ rsp + 0x468 ] , 0x0 mov word ptr [ rsp + 0x4898 ] , 0x1 jmp 0xdb lea rdi , [ rsp + 0x70 ] lea rdx , [ rsp + 0x20 ] mov esi , 0xa mov ecx , 0xa mov r8d , 0x0 mov r9d , 0x1 call 0x18d test eax , eax je 0x19f mov eax , 0x5 add rsp , 0x48a0 pop rbx ret cmp word ptr [ rsp + 0x4898 ] , 0x0 je 0x1d3 lea rdi , [ rsp + 0x3a8 ] lea rsi , [ rsp + 0x70 ] mov edx , 0x1f4 call 0x1c1 test eax , eax je 0x1e1 mov eax , 0x9 add rsp , 0x48a0 pop rbx ret mov eax , 0x9 add rsp , 0x48a0 pop rbx ret lea rdi , [ rsp + 0x30 ] lea rdx , [ rsp + 0x3a8 ] mov esi , 0x32 call 0xfffffffffffffb30 test eax , eax jne 0x196 cmp word ptr [ rsp + 0x4898 ] , 0x0 je 0x2bf lea rdi , [ rsp + 0x3a8 ] lea rsi , [ rsp + 0x70 ] mov edx , 0x1f4 call 0x222 test eax , eax jne 0x2cd movzx eax , word ptr [ rsp + 0x4898 ] test ax , ax je 0x2db lea rdi , [ rsp + 0x3a8 ] lea rsi , [ rsp + 0x270 ] mov edx , 0x28 call 0x255 test eax , eax jne 0x2e9 movzx eax , word ptr [ rsp + 0x4898 ] test ax , ax je 0x2f7 lea rdi , [ rsp + 0x3a8 ] lea rsi , [ rsp + 0x70 ] mov edx , 0x1f4 call 0x285 test eax , eax jne 0x305 movzx eax , word ptr [ rsp + 0x4898 ] test ax , ax je 0x313 lea rdi , [ rsp + 0x3a8 ] lea rsi , [ rsp + 0x70 ] mov edx , 0xa call 0x2ad test eax , eax je 0x321 mov eax , 0x9 add rsp , 0x48a0 pop rbx ret mov eax , 0x9 add rsp , 0x48a0 pop rbx ret mov eax , 0x9 add rsp , 0x48a0 pop rbx ret mov eax , 0x9 add rsp , 0x48a0 pop rbx ret mov eax , 0x9 add rsp , 0x48a0 pop rbx ret mov eax , 0x9 add rsp , 0x48a0 pop rbx ret mov eax , 0x9 add rsp , 0x48a0 pop rbx ret mov eax , 0x9 add rsp , 0x48a0 pop rbx ret lea rdi , [ rsp + 0x70 ] lea rdx , [ rsp + 0x10 ] mov esi , 0xa mov ecx , 0xa mov r8d , 0x0 mov r9d , 0x2 call 0x346 test eax , eax je 0x358 mov eax , 0x5 add rsp , 0x48a0 pop rbx ret mov word ptr [ rsp + 0x4898 ] , 0x0 lea rdi , [ rsp + 0x3a8 ] call 0x36f test eax , eax jne 0x196 mov word ptr [ rsp + 0x4898 ] , 0x0 xorps xmm0 , xmm0 movups xmmword ptr [ rbx + 0x10 ] , xmm0 movups xmmword ptr [ rbx ] , xmm0 mov qword ptr [ rbx + 0x20 ] , 0x0 mov qword ptr [ rsp + 0x468 ] , 0x0 lea rdi , [ rsp + 0x270 ] lea rdx , [ rsp + 0x3a8 ] mov esi , 0x28 call 0xfffffffffffffb30 test eax , eax jne 0x196 cmp word ptr [ rsp + 0x4898 ] , 0x0 je 0x478 lea rdi , [ rsp + 0x3a8 ] lea rsi , [ rsp + 0x70 ] mov edx , 0x1f4 call 0x3e7 test eax , eax jne 0x4e4 movzx eax , word ptr [ rsp + 0x4898 ] test ax , ax je 0x4f2 lea rdi , [ rsp + 0x3a8 ] lea rsi , [ rsp + 0x70 ] mov edx , 0xa call 0x417 mov ecx , eax mov eax , 0x9 test ecx , ecx jne 0x196 lea rdi , [ rsp + 0x70 ] mov rdx , rsp mov esi , 0xa mov ecx , 0xa mov r8d , 0x0 mov r9d , 0x3 call 0x449 mov ecx , eax mov eax , 0x5 test ecx , ecx jne 0x196 mov word ptr [ rsp + 0x4898 ] , 0x0 lea rdi , [ rsp + 0x3a8 ] call 0x46f add rsp , 0x48a0 pop rbx ret lea rdi , [ rsp + 0x3a8 ] mov edx , 0x20 mov rsi , rbx call 0x48d test eax , eax jne 0x196 lea rsi , [ rsp + 0x45c ] lea rdi , [ rsp + 0x3a8 ] mov edx , 0x8 call 0x4af test eax , eax jne 0x196 xorps xmm0 , xmm0 movups xmmword ptr [ rbx + 0x10 ] , xmm0 movups xmmword ptr [ rbx ] , xmm0 mov qword ptr [ rbx + 0x20 ] , 0x0 mov qword ptr [ rsp + 0x468 ] , 0x0 mov word ptr [ rsp + 0x4898 ] , 0x1 jmp 0x3d0 mov eax , 0x9 add rsp , 0x48a0 pop rbx ret mov eax , 0x9 add rsp , 0x48a0 pop rbx ret
Code2: push { r4 , r5 , r6 , r7 , r8 , sb , sl , lr } sub sp , sp , 0x4800 sub sp , sp , 0x80 ldr ip , [ pc , 0x364 ] add lr , sp , 0x4500 add lr , lr , 0x28 ldm ip ! , { r0 , r1 , r2 , r3 } stm lr ! , { r0 , r1 , r2 , r3 } ldm ip ! , { r0 , r1 , r2 , r3 } stm lr ! , { r0 , r1 , r2 , r3 } ldm ip ! , { r0 , r1 , r2 , r3 } mov sb , ip mov sl , 0x12c mov r7 , 0x0 stm lr ! , { r0 , r1 , r2 , r3 } ldr r8 , [ pc , 0x338 ] ldr r2 , [ sb ] , 0x4 ldr r3 , [ r8 ] strh r2 , [ lr ] add r6 , sp , 0x4500 add lr , sp , 0x4800 ldm sb , { r0 , r1 , r2 } add r6 , r6 , 0x4 add sb , lr , 0x7c str r3 , [ sb ] str sl , [ sp , 0xc ] stm r6 ! , { r0 , r1 } add r5 , sp , 0x4500 add r0 , ip , 0x10 add r5 , r5 , 0x10 strh r2 , [ r6 ] ldm r0 , { r0 , r1 , r2 } stm r5 ! , { r0 , r1 } add r4 , sp , 0x4500 add r1 , ip , 0x1c add r4 , r4 , 0x1c strh r2 , [ r5 ] ldm r1 , { r0 , r1 , r2 } stm r4 ! , { r0 , r1 } add ip , sp , 0x880 add r6 , ip , 0x3c40 strh r2 , [ r4 ] mov r1 , r7 mov r2 , 0x28 add sl , r6 , 0x30 add r0 , sp , 0xa4 add r5 , sp , 0x4500 strh r7 , [ sl , 0x8 ] bl 0xc0 add r2 , sp , 0x10 add r0 , r5 , 0x28 mov r1 , 0x32 str r7 , [ sp , 0xcc ] bl 0xd4 cmp r0 , 0x0 beq 0x104 add r7 , sp , 0x4800 add r3 , r7 , 0x7c ldr r6 , [ r3 ] ldr r8 , [ r8 ] cmp r6 , r8 bne 0x374 add sp , sp , 0x4800 add sp , sp , 0x80 pop { r4 , r5 , r6 , r7 , r8 , sb , sl , pc } add r0 , sp , 0x10 bl 0x108 cmp r0 , 0x0 bne 0xe0 ldrsh r4 , [ sl , 0x8 ] cmp r4 , r7 beq 0x13c add r7 , sp , 0x4600 add r0 , r7 , 0x88 add r2 , sp , 0x10 mov r1 , 0xa bl 0xfffff9d0 cmp r0 , 0xa beq 0x144 mov r0 , 0x9 b 0xe0 mov r3 , 0x1 ldr sb , [ pc , 0x230 ] add lr , sp , 0x4600 add r2 , sp , 0x4500 str r3 , [ sp , 0x4 ] mov r1 , r0 mov r3 , r0 add r2 , r2 , 0x4 str sb , [ sp ] add r0 , lr , 0x88 bl 0x16c cmp r0 , 0x0 bne 0x36c ldrsh r0 , [ sl , 0x8 ] cmp r0 , 0x0 beq 0x13c add ip , sp , 0x4600 add r2 , sp , 0x10 mov r1 , 0x1f4 add r0 , ip , 0x88 bl 0xfffff9d0 cmp r0 , 0x1f4 mov r6 , r0 bne 0x13c add r1 , sp , 0x4500 add r0 , r1 , 0x28 add r2 , sp , 0x10 mov r1 , 0x32 bl 0x1b4 cmp r0 , 0x0 bne 0xe0 ldrsh sl , [ sl , 0x8 ] cmp sl , 0x0 beq 0x13c add r5 , sp , 0x4600 mov r1 , r6 add r2 , sp , 0x10 add r0 , r5 , 0x88 bl 0xfffff9d0 cmp r0 , 0x1f4 bne 0x13c add r4 , sp , 0x4500 add r1 , sp , 0xc add r0 , r4 , 0x5c add r2 , sp , 0x10 bl 0x1f8 cmp r0 , 0x0 bne 0xe0 add r7 , sp , 0x880 add r3 , r7 , 0x3c40 add r6 , r3 , 0x30 ldrsh r2 , [ r6 , 0x8 ] cmp r2 , 0x0 beq 0x13c add lr , sp , 0x4600 add r2 , sp , 0x10 mov r1 , 0x1f4 add r0 , lr , 0x88 bl 0xfffff9d0 cmp r0 , 0x1f4 bne 0x13c ldrsh r0 , [ r6 , 0x8 ] cmp r0 , 0x0 beq 0x13c add ip , sp , 0x4600 add r2 , sp , 0x10 mov r1 , 0xa add r0 , ip , 0x88 bl 0xfffff9d0 cmp r0 , 0xa mov r3 , r0 bne 0x13c mov r1 , 0x2 add sl , sp , 0x4500 add r5 , sp , 0x4600 str r1 , [ sp , 0x4 ] str sb , [ sp ] mov r1 , r0 add r2 , sl , 0x10 add r0 , r5 , 0x88 bl 0x284 subs r4 , r0 , 0x0 bne 0x36c add r0 , sp , 0x10 strh r4 , [ r6 , 0x8 ] bl 0x298 cmp r0 , 0x0 bne 0xe0 add r7 , sp , 0x4500 add r0 , r7 , 0x5c add r2 , sp , 0x10 ldr r1 , [ sp , 0xc ] bl 0x2b4 cmp r0 , 0x0 bne 0xe0 add r0 , sp , 0x10 bl 0x2c4 cmp r0 , 0x0 bne 0xe0 ldrsh r3 , [ r6 , 0x8 ] cmp r3 , 0x0 beq 0x13c add r6 , sp , 0x4600 add r2 , sp , 0x10 mov r1 , 0x1f4 add r0 , r6 , 0x88 bl 0xfffff9d0 cmp r0 , 0x1f4 bne 0x13c add r2 , sp , 0x880 add lr , r2 , 0x3c40 ldrsh r0 , [ lr , 0x38 ] add sl , lr , 0x30 cmp r0 , 0x0 beq 0x13c add ip , sp , 0x4600 add r2 , sp , 0x10 mov r1 , 0xa add r0 , ip , 0x88 bl 0xfffff9d0 cmp r0 , 0xa mov r3 , r0 bne 0x13c mov r1 , 0x3 str sb , [ sp ] add r5 , sp , 0x4600 add sb , sp , 0x4500 str r1 , [ sp , 0x4 ] add r2 , sb , 0x1c add r0 , r5 , 0x88 mov r1 , r3 bl 0x350 subs r4 , r0 , 0x0 bne 0x36c add r0 , sp , 0x10 strh r4 , [ sl , 0x8 ] bl 0x364 b 0xe0 mov r0 , 0x5 b 0xe0 bl 0x374 andeq r0 , r0 , ip , asr r0
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly codes show fundamental differences in architecture, structure, and functionality. Code1 uses x86_64 instructions (e.g., `movaps`, `call`, `jne`) with Intel syntax and typical x86 registers (`rax`, `rdi`, `xmm0`), while Code2 employs ARM assembly (e.g., `ldm`, `stm`, `bl`, `cmp`) with ARM-specific registers (`r4-r8`, `sb`, `sl`, `ip`). Their stack management differs significantly—Code1 allocates `0x48a0` bytes via `sub rsp`, while Code2 uses `sub sp` twice (`0x4800 + 0x80`). Control flow diverges completely: Code1 relies on x86 conditional jumps (`jne`, `je`), whereas Code2 uses ARM conditionals (`beq`, `bne`). Memory operations, function calls, and constant values show no overlap. These architectural and structural disparities indicate entirely different implementations with no functional similarity.
------------------------------------------------------------

------------------------------------------------------------
Code1: push rbp push r15 push r14 push r13 push r12 push rbx sub rsp , 0x18 mov r15 , r9 mov r12 , r8 mov rbp , rcx mov rbx , rdx mov r13 , rsi mov rdi , rsp call 0xfffffffffff6cb20 cmp qword ptr [ rip + 0x300dcb ] , 0x0 je 0x94 mov r14 , qword ptr [ rsp + 0x50 ] mov rdi , r13 mov rsi , rbx mov rdx , rbp mov rcx , r14 call qword ptr [ rip + 0x300dba ] xor ebp , ebp test eax , eax je 0xfa cmp qword ptr [ rip + 0x300da0 ] , 0x0 je 0xc9 mov rdi , rsp mov rsi , r12 mov rdx , r15 mov rcx , r14 call qword ptr [ rip + 0x300d94 ] test eax , eax je 0xfa mov r8 , qword ptr [ rsp + 0x58 ] mov rdx , rsp mov rdi , r13 mov rsi , r13 mov rcx , r14 call 0xfffffffffff70120 xor ebp , ebp test eax , eax setne bpl jmp 0xfa mov edi , dword ptr [ rip + 0x300d6e ] test edi , edi jne 0xab call 0xfffffffffff998c0 mov edi , eax mov dword ptr [ rip + 0x300d5d ] , eax mov ecx , 0x5d66d5 mov esi , 0x67 mov edx , 0x69 mov r8d , 0xc1 call 0xfffffffffff98530 xor ebp , ebp jmp 0xfa mov edi , dword ptr [ rip + 0x300d39 ] test edi , edi jne 0xe0 call 0xfffffffffff998c0 mov edi , eax mov dword ptr [ rip + 0x300d28 ] , eax mov ecx , 0x5d66d5 mov esi , 0x67 mov edx , 0x69 mov r8d , 0xc1 call 0xfffffffffff98530 mov rdi , rsp call 0xfffffffffff6cae0 mov eax , ebp add rsp , 0x18 pop rbx pop r12 pop r13 pop r14 pop r15 pop rbp ret nop word ptr cs : [ rax + rax ] nop dword ptr [ rax ]
Code2: addiu sp , sp , - 0x70 sw ra , 0x6c ( sp ) lui gp , 0x76 addiu gp , gp , 0x1270 sw gp , 0x18 ( sp ) sw a0 , 0x44 ( sp ) sw a1 , 0x40 ( sp ) sw a2 , 0x3c ( sp ) sw a3 , 0x38 ( sp ) lw v0 , 0x80 ( sp ) sw v0 , 0x34 ( sp ) lw v0 , 0x84 ( sp ) sw v0 , 0x30 ( sp ) lw v0 , 0x88 ( sp ) sw v0 , 0x2c ( sp ) lw v0 , 0x8c ( sp ) sw v0 , 0x28 ( sp ) lw v0 , 0x90 ( sp ) sw v0 , 0x24 ( sp ) lw v0 , - 0x52e4 ( gp ) lw v0 , ( v0 ) sw v0 , 0x64 ( sp ) sw zero , 0x4c ( sp ) addiu v0 , sp , 0x50 move a0 , v0 lw v0 , - 0x6860 ( gp ) move t9 , v0 jalr t9 nop lw gp , 0x18 ( sp ) lw v0 , 0x28 ( sp ) sw v0 , 0x10 ( sp ) lw a3 , 0x2c ( sp ) lw a2 , 0x38 ( sp ) lw a1 , 0x3c ( sp ) lw a0 , 0x40 ( sp ) jal 0x667008 nop lw gp , 0x18 ( sp ) beqz v0 , 0x11c nop addiu v1 , sp , 0x50 lw v0 , 0x28 ( sp ) sw v0 , 0x10 ( sp ) lw a3 , 0x2c ( sp ) lw a2 , 0x30 ( sp ) lw a1 , 0x34 ( sp ) move a0 , v1 jal 0x667008 nop lw gp , 0x18 ( sp ) beqz v0 , 0x128 nop addiu v1 , sp , 0x50 lw v0 , 0x28 ( sp ) sw v0 , 0x10 ( sp ) lw a3 , 0x2c ( sp ) move a2 , v1 lw a1 , 0x40 ( sp ) lw a0 , 0x40 ( sp ) lw v0 , - 0x6868 ( gp ) move t9 , v0 jalr t9 nop lw gp , 0x18 ( sp ) beqz v0 , 0x134 nop addiu v0 , zero , 0x1 sw v0 , 0x4c ( sp ) b 0x138 nop nop b 0x138 nop nop b 0x138 nop nop addiu v0 , sp , 0x50 move a0 , v0 lw v0 , - 0x7b1c ( gp ) move t9 , v0 jalr t9 nop lw gp , 0x18 ( sp ) lw v0 , 0x4c ( sp ) lw v1 , - 0x52e4 ( gp ) lw a0 , 0x64 ( sp ) lw v1 , ( v1 ) beq a0 , v1 , 0x17c nop lw v0 , - 0x5320 ( gp ) move t9 , v0 jalr t9 nop lw ra , 0x6c ( sp ) addiu sp , sp , 0x70 jr ra nop
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly code snippets are fundamentally dissimilar due to differences in architecture (x86_64 vs MIPS), instruction sets, and operational patterns. The first code uses x86-specific registers (rbp, rsp, r15) and instructions (push, call, cmp, je), while the second uses MIPS conventions (sp, ra, gp, sw, lw, addiu, jalr). No overlapping instructions or structural similarities exist in register usage, stack management, or control flow. The architectural divergence alone results in a -1 similarity score.
------------------------------------------------------------

------------------------------------------------------------
Code1: push r15 push r14 push r13 push r12 push rbp push rbx sub rsp , 0x38 mov r12 , rdi mov dword ptr [ rsp + 0xc ] , esi mov rax , qword ptr fs : [ 0x28 ] mov qword ptr [ rsp + 0x28 ] , rax xor eax , eax mov qword ptr [ rsp + 0x20 ] , rdi test rdx , rdx je 0xe8 mov rbp , rdx mov r13 , rcx mov eax , dword ptr [ rdx + 0xc ] test eax , 0xfffffffe jne 0xe8 mov r15d , dword ptr [ rdx + 0x8 ] test rcx , rcx jne 0x59 test r15d , r15d jne 0xe8 and eax , 0x1 cmp eax , 0x1 sbb r15d , - 0x1 lea rdi , [ rsp + 0x20 ] mov rsi , qword ptr [ rbp ] call 0xffffffffffff8235 mov rbx , 0xffffffffffffffff test rax , rax je 0xf8 cmp dword ptr [ rbp + 0x8 ] , 0x0 je 0xb4 mov ebx , 0x0 lea r14 , [ rsp + 0x20 ] mov qword ptr [ rsp + 0x20 ] , r12 mov rsi , qword ptr [ r13 + rbx * 0x8 ] mov rdi , r14 call 0xffffffffffff8235 test rax , rax je 0x1c4 add rbx , 0x1 mov eax , dword ptr [ rbp + 0x8 ] cmp rax , rbx ja 0x8d cmp r15d , 0xffffff ja 0x11e test r15d , r15d je 0x130 mov edi , r15d shl rdi , 0x3 call 0xfffffffffff9a95c mov r14 , rax test rax , rax jne 0x136 mov esi , 0xb mov rdi , r12 call 0xffffffffffffd5e5 mov rbx , rax jmp 0xf8 mov esi , 0x16 mov rdi , r12 call 0xffffffffffffd5e5 mov rbx , rax mov rax , rbx mov rcx , qword ptr [ rsp + 0x28 ] xor rcx , qword ptr fs : [ 0x28 ] jne 0x1d0 add rsp , 0x38 pop rbx pop rbp pop r12 pop r13 pop r14 pop r15 ret mov esi , 0x4b mov rdi , r12 call 0xffffffffffffd5e5 mov rbx , rax jmp 0xf8 mov r14d , 0x0 lea r8 , [ rsp + 0x18 ] mov ecx , 0x5 mov edx , 0x0 mov esi , dword ptr [ rsp + 0xc ] mov rdi , r12 call 0xfffffffffffff5b6 mov rbx , rax cmp rax , - 0x1 je 0x1b7 cmp dword ptr [ rsp + 0xc ] , 0x1 sbb eax , eax and eax , 0xfe000000 add eax , 0x16000000 mov r12 , qword ptr [ rsp + 0x18 ] mov edx , r15d and edx , 0xffffff or eax , edx mov dword ptr [ r12 + 0x1c ] , eax mov rax , qword ptr [ rbp ] mov dword ptr [ r12 + 0x20 ] , eax mov edx , dword ptr [ rbp + 0x8 ] shl rdx , 0x3 mov rsi , r13 mov rdi , r14 call 0xfffffffffff9a91c test byte ptr [ rbp + 0xc ] , 0x1 je 0x1ad lea eax , [ r15 - 0x1 ] mov qword ptr [ r14 + rax * 0x8 ] , 0x0 mov qword ptr [ r12 + 0x30 ] , r14 jmp 0xf8 mov rdi , r14 call 0xfffffffffff9ab3c jmp 0xf8 mov rbx , 0xffffffffffffffff jmp 0xf8 call 0xfffffffffff9a78c
Code2: lui gp , 0x4f addiu sp , sp , - 0x58 addiu gp , gp , - 0x3c00 sw s2 , 0x38 ( sp ) lw s2 , - 0x7ae0 ( gp ) sw s1 , 0x34 ( sp ) move s1 , a0 sw ra , 0x54 ( sp ) sw fp , 0x50 ( sp ) sw s7 , 0x4c ( sp ) sw s6 , 0x48 ( sp ) sw s5 , 0x44 ( sp ) sw s4 , 0x40 ( sp ) sw s3 , 0x3c ( sp ) sw s0 , 0x30 ( sp ) sw gp , 0x18 ( sp ) sw a0 , 0x28 ( sp ) lw v0 , ( s2 ) sw v0 , 0x2c ( sp ) beqz a2 , 0xec addiu v0 , zero , - 0x2 lw v1 , 0x8 ( a2 ) and v0 , v1 , v0 bnez v0 , 0xec move s7 , a2 lw s4 , 0x4 ( a2 ) move s6 , a1 beqz s4 , 0x7c move s5 , a3 beqz a3 , 0xf0 lw t9 , - 0x7e5c ( gp ) bnez v1 , 0x144 nop lw t9 , - 0x7d88 ( gp ) addiu s3 , sp , 0x28 lw a1 , ( s7 ) bal - 0x94b8 move a0 , s3 beqz v0 , 0xe4 lw gp , 0x18 ( sp ) lw v0 , 0x4 ( s7 ) beqz v0 , 0x14c move fp , zero b 0xc8 move s0 , s5 lw v0 , 0x4 ( s7 ) addiu fp , fp , 0x1 sltu v0 , fp , v0 beqz v0 , 0x14c addiu s0 , s0 , 0x4 lw t9 , - 0x7d88 ( gp ) move a0 , s3 lw a1 , ( s0 ) bal - 0x94b8 sw s1 , 0x28 ( sp ) bnez v0 , 0xb4 lw gp , 0x18 ( sp ) b 0x104 addiu s0 , zero , - 0x1 lw t9 , - 0x7e5c ( gp ) addiu a1 , zero , 0x16 bal - 0x37f8 move a0 , s1 lw gp , 0x18 ( sp ) move s0 , v0 lw a0 , 0x2c ( sp ) move v0 , s0 lw v1 , ( s2 ) bne a0 , v1 , 0x250 lw ra , 0x54 ( sp ) lw fp , 0x50 ( sp ) lw s7 , 0x4c ( sp ) lw s6 , 0x48 ( sp ) lw s5 , 0x44 ( sp ) lw s4 , 0x40 ( sp ) lw s3 , 0x3c ( sp ) lw s2 , 0x38 ( sp ) lw s1 , 0x34 ( sp ) lw s0 , 0x30 ( sp ) jr ra addiu sp , sp , 0x58 b 0x84 addiu s4 , s4 , 0x1 lui v0 , 0x100 sltu v0 , s4 , v0 beqz v0 , 0x208 lw t9 , - 0x7e5c ( gp ) beqz s4 , 0x200 lw t9 , - 0x7b4c ( gp ) jalr t9 sll a0 , s4 , 0x2 lw gp , 0x18 ( sp ) beqz v0 , 0x234 move s3 , v0 addiu v0 , sp , 0x24 addiu a3 , zero , 0x5 move a2 , zero sw v0 , 0x10 ( sp ) move a1 , s6 jal 0x48035c move a0 , s1 addiu v1 , zero , - 0x1 lw gp , 0x18 ( sp ) beq v0 , v1 , 0x220 move s0 , v0 lui a0 , 0x1600 lw a2 , 0x4 ( s7 ) lui v1 , 0x1400 lw s1 , 0x24 ( sp ) lw v0 , ( s7 ) move a1 , s5 movn v1 , a0 , s6 sll a2 , a2 , 0x2 move a0 , s3 lw t9 , - 0x7adc ( gp ) sw v0 , 0x14 ( s1 ) or s6 , s4 , v1 jalr t9 sw s6 , 0x10 ( s1 ) lw v0 , 0x8 ( s7 ) andi v0 , v0 , 0x1 beqz v0 , 0x1f8 lw gp , 0x18 ( sp ) sll s4 , s4 , 0x2 addu s4 , s3 , s4 sw zero , - 0x4 ( s4 ) b 0x104 sw s3 , 0x20 ( s1 ) b 0x178 move s3 , zero addiu a1 , zero , 0x4f bal - 0x37f8 move a0 , s1 lw gp , 0x18 ( sp ) b 0x104 move s0 , v0 lw t9 , - 0x7ad4 ( gp ) jalr t9 move a0 , s3 b 0x104 lw gp , 0x18 ( sp ) lw t9 , - 0x7e5c ( gp ) addiu a1 , zero , 0xb bal - 0x37f8 move a0 , s1 lw gp , 0x18 ( sp ) b 0x104 move s0 , v0 lw t9 , - 0x7afc ( gp ) jalr t9 nop
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly codes are fundamentally dissimilar due to targeting different processor architectures (x86_64 vs MIPS), exhibiting no overlapping instructions or register usage. The first code uses Intel-specific syntax (e.g., `push r15`, `mov qword ptr [rsp + 0x28], rax`) and x86_64 registers (rax, rdi, rsi), while the second employs MIPS conventions (e.g., `lui gp, 0x4f`, `sw s2, 0x38(sp)`) with distinct register names (s0-s7, gp) and delay slots. Control flow patterns diverge completely (x86 conditional jumps like `je` vs MIPS branches like `beqz`), and memory operations are architecturally incompatible (qword ptr vs MIPS load/store words). There is no algorithmic or structural alignment beyond basic function prologue/epilogue patterns, which are architecture-specific implementations of common stack management.
------------------------------------------------------------

------------------------------------------------------------
Code1: test rdi , rdi push r14 push r13 push r12 push rbp push rbx je 0x2a1 mov eax , 0xabacadab cmp qword ptr [ rdi + 0x3450 ] , rax mov rbp , rdi jne 0x2c0 mov eax , dword ptr [ rdi + 0x3418 ] mov rbx , rsi mov r12 , rdx test eax , eax jne 0x208 test rbx , rbx je 0x2fe mov eax , 0xabacadab cmp qword ptr [ rbx + 0x90 ] , rax jne 0x2df cmp r12 , 0x40 mov eax , 0x40 cmovbe rax , r12 cmp dword ptr [ rbx + 0x10 ] , 0x1 mov qword ptr [ rbx ] , rax je 0x1e8 cmp qword ptr [ rbx + 0x50 ] , 0x0 je 0x198 mov rdi , rbx call 0xfffffffffffff7e0 mov rax , qword ptr [ rbx + 0x30 ] mov rsi , qword ptr [ rbp + 0x20 ] lea rcx , [ rax + 0x20 ] mov rax , qword ptr [ rbx ] add rax , 0x7 imul rcx , rax shr rcx , 0x3 cmp qword ptr [ rbp + 0x28 ] , rsi cmovae rsi , qword ptr [ rbp + 0x28 ] mov r12 , rsi imul r12 , rcx test rsi , rsi je 0xd0 xor edx , edx mov rax , r12 div rsi cmp rax , rcx je 0xd0 pop rbx xor eax , eax pop rbp pop r12 pop r13 pop r14 ret nop word ptr [ rax + rax ] mov eax , 0xabacadab cmp qword ptr [ rbx + 0x90 ] , rax jne 0x31d mov edi , 0x7 call 0xffffffffffe9bd60 mov esi , 0x8 mov qword ptr [ rbx + 0x48 ] , rax mov rdi , rax call 0xffffffffffe9ab30 test rax , rax mov qword ptr [ rbx + 0x50 ] , rax je 0xbf mov r14 , qword ptr [ rbx + 0x48 ] xor esi , esi mov qword ptr [ rbx + 0x58 ] , r12 mov rdi , rax lea r13 , [ r12 + 0x1 ] xor ebp , ebp lea rdx , [ r14 * 0x8 ] call 0xffffffffffe99940 test r14 , r14 mov rcx , rax jg 0x161 jmp 0x258 nop dword ptr [ rax ] call 0xffffffffffe9c710 xor esi , esi mov rdx , r13 add rbp , 0x1 mov rdi , rax call 0xffffffffffe99940 mov byte ptr [ rax + r12 ] , 0xab cmp rbp , qword ptr [ rbx + 0x48 ] jge 0x258 mov rcx , qword ptr [ rbx + 0x50 ] lea r14 , [ rcx + rbp * 0x8 ] mov rdi , r13 mov esi , 0x1 call 0xffffffffffe9b5d0 mov qword ptr [ r14 ] , rax mov rax , qword ptr [ rbx + 0x50 ] mov rdi , qword ptr [ rax + rbp * 0x8 ] test rdi , rdi jne 0x138 mov rdi , rbx call 0xfffffffffffff7e0 pop rbx xor eax , eax pop rbp pop r12 pop r13 pop r14 ret nop dword ptr [ rax ] mov rdx , qword ptr [ rbx + 0x30 ] add rax , 0x7 mov rsi , qword ptr [ rbp + 0x28 ] lea rcx , [ rdx + 0x20 ] imul rax , rcx shr rax , 0x3 cmp qword ptr [ rbp + 0x20 ] , rsi cmovae rsi , qword ptr [ rbp + 0x20 ] mov rcx , rax mov r12 , rsi imul r12 , rax test rsi , rsi je 0xe2 xor edx , edx mov rax , r12 div rsi cmp rax , rcx jne 0xbf jmp 0xe2 nop word ptr [ rax + rax ] cmp r12 , 0x20 ja 0x240 cmp r12 , 0x18 jbe 0x270 mov qword ptr [ rbx ] , 0x20 mov eax , 0x20 jmp 0x6f nop dword ptr [ rax ] lea r9 , [ rdi + 0x3f8 ] mov ecx , 0x2a3 xor eax , eax lea r8 , [ rip + 0x1e3240 ] mov edi , 0x8000 lea rdx , [ rip + 0x1f1f57 ] lea rsi , [ rip + 0x1f1bf8 ] call 0xffffffffffe9ba20 jmp 0x3a nop word ptr [ rax + rax ] mov qword ptr [ rbx ] , 0x40 mov eax , 0x40 jmp 0x6f nop dword ptr [ rax ] pop rbx mov eax , 0x1 pop rbp pop r12 pop r13 pop r14 ret nop word ptr cs : [ rax + rax ] cmp r12 , 0x10 jbe 0x290 mov qword ptr [ rbx ] , 0x18 mov eax , 0x18 jmp 0x6f nop word ptr [ rax + rax ] mov qword ptr [ rbx ] , 0x10 mov eax , 0x10 jmp 0x6f lea rcx , [ rip + 0x1f1ee8 ] mov edx , 0x2a0 lea rsi , [ rip + 0x1f1b74 ] lea rdi , [ rip + 0x1e3946 ] call 0xffffffffffe99f50 lea rcx , [ rip + 0x1f1ec9 ] mov edx , 0x2a1 lea rsi , [ rip + 0x1f1b55 ] lea rdi , [ rip + 0x1bc0ee ] call 0xffffffffffe99f50 lea rcx , [ rip + 0x1f1eaa ] mov edx , 0x2a5 lea rsi , [ rip + 0x1f1b36 ] lea rdi , [ rip + 0x1f1bc7 ] call 0xffffffffffe99f50 lea rcx , [ rip + 0x1f1e8b ] mov edx , 0x2a4 lea rsi , [ rip + 0x1f1b17 ] lea rdi , [ rip + 0x1f1b80 ] call 0xffffffffffe99f50 lea rcx , [ rip + 0x1f1e3c ] mov edx , 0xa3 lea rsi , [ rip + 0x1f1af8 ] lea rdi , [ rip + 0x1f1b89 ] call 0xffffffffffe99f50 nop dword ptr [ rax ]
Code2: lui gp , 0x34 addiu gp , gp , 0xefc addu gp , gp , t9 addiu sp , sp , - 0x30 sw ra , 0x2c ( sp ) sw fp , 0x28 ( sp ) move fp , sp sw gp , 0x18 ( sp ) sw a0 , 0x30 ( fp ) sw a1 , 0x34 ( fp ) sw a2 , 0x38 ( fp ) lw v0 , 0x30 ( fp ) bnez v0 , 0x64 nop lw v0 , - 0x7d80 ( gp ) addiu a3 , v0 , 0x958 addiu a2 , zero , 0x2a0 lw v0 , - 0x7d80 ( gp ) addiu a1 , v0 , 0x5c0 lw v0 , - 0x7d80 ( gp ) addiu a0 , v0 , 0x750 lw v0 , - 0x724c ( gp ) move t9 , v0 jalr t9 nop lw v0 , 0x30 ( fp ) lw v1 , 0x336c ( v0 ) lui v0 , 0xabac ori v0 , v0 , 0xadab beq v1 , v0 , 0xa8 nop lw v0 , - 0x7d80 ( gp ) addiu a3 , v0 , 0x958 addiu a2 , zero , 0x2a1 lw v0 , - 0x7d80 ( gp ) addiu a1 , v0 , 0x5c0 lw v0 , - 0x7d80 ( gp ) addiu a0 , v0 , 0x768 lw v0 , - 0x724c ( gp ) move t9 , v0 jalr t9 nop lw v0 , 0x30 ( fp ) lw v0 , 0x3350 ( v0 ) beqz v0 , 0xfc nop lw v0 , 0x30 ( fp ) addiu v0 , v0 , 0x340 sw v0 , 0x14 ( sp ) lw v0 , - 0x7d80 ( gp ) addiu v0 , v0 , 0x790 sw v0 , 0x10 ( sp ) addiu a3 , zero , 0x2a3 lw v0 , - 0x7d80 ( gp ) addiu a2 , v0 , 0x968 lw v0 , - 0x7d80 ( gp ) addiu a1 , v0 , 0x5c0 ori a0 , zero , 0x8000 lw v0 , - 0x7664 ( gp ) move t9 , v0 jalr t9 nop lw gp , 0x18 ( fp ) lw v0 , 0x34 ( fp ) bnez v0 , 0x134 nop lw v0 , - 0x7d80 ( gp ) addiu a3 , v0 , 0x958 addiu a2 , zero , 0x2a4 lw v0 , - 0x7d80 ( gp ) addiu a1 , v0 , 0x5c0 lw v0 , - 0x7d80 ( gp ) addiu a0 , v0 , 0x5d8 lw v0 , - 0x724c ( gp ) move t9 , v0 jalr t9 nop lw v0 , 0x34 ( fp ) lw v1 , 0x64 ( v0 ) lui v0 , 0xabac ori v0 , v0 , 0xadab beq v1 , v0 , 0x178 nop lw v0 , - 0x7d80 ( gp ) addiu a3 , v0 , 0x958 addiu a2 , zero , 0x2a5 lw v0 , - 0x7d80 ( gp ) addiu a1 , v0 , 0x5c0 lw v0 , - 0x7d80 ( gp ) addiu a0 , v0 , 0x600 lw v0 , - 0x724c ( gp ) move t9 , v0 jalr t9 nop lw a0 , 0x38 ( fp ) lw v1 , 0x38 ( fp ) addiu v0 , zero , 0x40 sltiu a0 , a0 , 0x41 movz v1 , v0 , a0 lw v0 , 0x34 ( fp ) sw v1 , ( v0 ) lw v0 , 0x34 ( fp ) lw v1 , 0x8 ( v0 ) addiu v0 , zero , 0x1 bne v1 , v0 , 0x22c nop lw v0 , 0x34 ( fp ) lw v0 , ( v0 ) sltiu v0 , v0 , 0x21 bnez v0 , 0x1d0 nop lw v0 , 0x34 ( fp ) addiu v1 , zero , 0x40 sw v1 , ( v0 ) b 0x22c nop lw v0 , 0x34 ( fp ) lw v0 , ( v0 ) sltiu v0 , v0 , 0x19 bnez v0 , 0x1f8 nop lw v0 , 0x34 ( fp ) addiu v1 , zero , 0x20 sw v1 , ( v0 ) b 0x22c nop lw v0 , 0x34 ( fp ) lw v0 , ( v0 ) sltiu v0 , v0 , 0x11 bnez v0 , 0x220 nop lw v0 , 0x34 ( fp ) addiu v1 , zero , 0x18 sw v1 , ( v0 ) b 0x22c nop lw v0 , 0x34 ( fp ) addiu v1 , zero , 0x10 sw v1 , ( v0 ) lw v0 , 0x34 ( fp ) lw v0 , 0x3c ( v0 ) beqz v0 , 0x258 nop lw a0 , 0x34 ( fp ) lw v0 , - 0x7d54 ( gp ) addiu v0 , v0 , 0x6718 move t9 , v0 bal - 0xe9c nop lw gp , 0x18 ( fp ) lw v0 , 0x34 ( fp ) lw v0 , 0x28 ( v0 ) addiu v1 , v0 , 0x20 lw v0 , 0x34 ( fp ) lw v0 , ( v0 ) addiu v0 , v0 , 0x7 mul v0 , v1 , v0 srl v0 , v0 , 0x3 sw v0 , 0x20 ( fp ) lw v0 , 0x30 ( fp ) lw v1 , 0x1c ( v0 ) lw v0 , 0x30 ( fp ) lw v0 , 0x18 ( v0 ) sltu a0 , v1 , v0 movz v0 , v1 , a0 lw v1 , 0x20 ( fp ) mul v0 , v1 , v0 sw v0 , 0x24 ( fp ) lw v0 , 0x30 ( fp ) lw v1 , 0x1c ( v0 ) lw v0 , 0x30 ( fp ) lw v0 , 0x18 ( v0 ) sltu a0 , v1 , v0 movz v0 , v1 , a0 beqz v0 , 0x304 nop lw v0 , 0x30 ( fp ) lw v1 , 0x1c ( v0 ) lw v0 , 0x30 ( fp ) lw v0 , 0x18 ( v0 ) sltu a0 , v1 , v0 movz v0 , v1 , a0 lw v1 , 0x24 ( fp ) teq v0 , zero , 0x7 divu zero , v1 , v0 mfhi v0 mflo v1 lw v0 , 0x20 ( fp ) beq v0 , v1 , 0x304 nop move v0 , zero b 0x324 nop lw a1 , 0x24 ( fp ) lw a0 , 0x34 ( fp ) lw v0 , - 0x7d54 ( gp ) addiu v0 , v0 , 0x6344 move t9 , v0 bal - 0x1270 nop lw gp , 0x18 ( fp ) move sp , fp lw ra , 0x2c ( sp ) lw fp , 0x28 ( sp ) addiu sp , sp , 0x30 jr ra nop
Similarity: -1
Label: 1
Similarity Score: -0.95
Explanation: The two assembly codes show significant differences due to their different architectures (x86-64 vs MIPS), instruction sets, and register usage. While both contain the constant 0xabacadab and some structural similarities (conditional checks, function calls), the overall flow, memory operations, and instruction patterns are fundamentally different. The x86-64 code uses Intel syntax with registers like rdi/rsi, while the MIPS code uses $gp/$v0 registers with load/store operations. Key differences include stack handling (push/pop vs sw/lw), branching mechanisms, and absence of equivalent instructions. The minimal similarity (-0.95) reflects only shared constants and high-level control structures, but the implementations are architecturally incompatible.
------------------------------------------------------------

------------------------------------------------------------
Code1: push ebp mov ebp , esp push esi sub esp , 0x54 mov eax , dword ptr [ ebp + 0x14 ] mov cl , byte ptr [ ebp + 0x10 ] mov edx , dword ptr [ ebp + 0xc ] mov esi , dword ptr [ ebp + 0x8 ] and cl , 0x1 mov byte ptr [ ebp - 0x5 ] , cl mov dword ptr [ ebp - 0xc ] , 0x0 mov dword ptr [ ebp - 0x1c ] , eax mov dword ptr [ ebp - 0x20 ] , edx mov dword ptr [ ebp - 0x24 ] , esi mov eax , dword ptr [ ebp + 0x8 ] mov dword ptr [ esp ] , eax mov dword ptr [ esp + 0x4 ] , 0x2c call 0xffffc0a0 mov dword ptr [ ebp - 0x10 ] , eax mov eax , dword ptr [ ebp + 0xc ] mov dword ptr [ ebp - 0x14 ] , eax mov eax , dword ptr [ ebp + 0x8 ] mov ecx , dword ptr [ ebp - 0x14 ] mov dword ptr [ esp ] , eax mov dword ptr [ esp + 0x4 ] , ecx mov dword ptr [ esp + 0x8 ] , 0x2c call 0x6b0 xor ecx , ecx mov dl , cl test al , 0x1 mov byte ptr [ ebp - 0x25 ] , dl jne 0x73 jmp 0x80 mov eax , dword ptr [ ebp - 0x14 ] cmp dword ptr [ eax + 0xc ] , 0x0 setne cl mov byte ptr [ ebp - 0x25 ] , cl mov al , byte ptr [ ebp - 0x25 ] mov cl , al xor cl , 0xff and cl , 0x1 mov dl , 0x1 mov ah , dl xor ah , 0x1 and al , ah xor dl , 0x1 and dl , 0xff and ah , 0x1 or cl , al or dl , ah xor cl , dl test cl , 0x1 jne 0xb1 jmp 0x16e mov eax , dword ptr [ ebp - 0x14 ] cmp byte ptr [ eax ] , 0x0 jne 0x15b cmp dword ptr [ ebp - 0x10 ] , 0x0 je 0xd7 mov eax , dword ptr [ ebp - 0x10 ] mov ecx , dword ptr [ ebp + 0x8 ] sub eax , ecx mov dword ptr [ ebp - 0x2c ] , eax jmp 0xe6 mov eax , dword ptr [ ebp + 0x8 ] mov ecx , esp mov dword ptr [ ecx ] , eax call 0xffffc0b0 mov dword ptr [ ebp - 0x2c ] , eax mov eax , dword ptr [ ebp - 0x2c ] mov dword ptr [ ebp - 0x18 ] , eax mov eax , dword ptr [ ebp + 0x14 ] mov dword ptr [ esp ] , eax call 0xffffc070 xor ecx , ecx mov edx , dword ptr [ ebp + 0x8 ] mov esi , dword ptr [ ebp - 0x18 ] mov dword ptr [ esp ] , 0x0 mov dword ptr [ esp + 0x4 ] , 0x8 mov dword ptr [ esp + 0x8 ] , edx mov dword ptr [ esp + 0xc ] , esi mov dword ptr [ ebp - 0x30 ] , eax mov dword ptr [ ebp - 0x34 ] , ecx call 0x67b0 xor ecx , ecx mov dword ptr [ esp ] , 0x0 mov dword ptr [ esp + 0x4 ] , 0x0 lea edx , [ 0x8057ff5 ] mov dword ptr [ esp + 0x8 ] , edx mov edx , dword ptr [ ebp - 0x30 ] mov dword ptr [ esp + 0xc ] , edx mov dword ptr [ esp + 0x10 ] , eax mov dword ptr [ ebp - 0x38 ] , ecx call 0xffffe9b0 mov dword ptr [ esp ] , 0x1 call 0xffffc400 jmp 0x160 mov eax , dword ptr [ ebp - 0x14 ] add eax , 0x10 mov dword ptr [ ebp - 0x14 ] , eax jmp 0x45 test byte ptr [ ebp - 0x5 ] , 0x1 je 0x186 mov eax , dword ptr [ ebp - 0x14 ] mov eax , dword ptr [ eax + 0xc ] mov dword ptr [ ebp - 0xc ] , eax jmp 0x19a mov eax , dword ptr [ ebp - 0x14 ] mov eax , dword ptr [ eax + 0xc ] mov ecx , dword ptr [ ebp - 0xc ] mov edx , ecx and edx , eax xor ecx , eax or edx , ecx mov dword ptr [ ebp - 0xc ] , edx cmp dword ptr [ ebp - 0x10 ] , 0x0 jne 0x1a9 jmp 0x1b7 mov eax , dword ptr [ ebp - 0x10 ] add eax , 0x1 mov dword ptr [ ebp + 0x8 ] , eax jmp 0x29 mov eax , dword ptr [ ebp - 0xc ] add esp , 0x54 pop esi pop ebp ret
Code2: addiu sp , sp , - 0x40 sw ra , 0x3c ( sp ) sw s5 , 0x38 ( sp ) sw s4 , 0x34 ( sp ) sw s3 , 0x30 ( sp ) sw s2 , 0x2c ( sp ) sw s1 , 0x28 ( sp ) sw s0 , 0x24 ( sp ) lui gp , 0x43 addiu gp , gp , - 0x4f10 sw gp , 0x18 ( sp ) move s0 , a0 move s5 , a1 move s3 , a2 move s4 , a3 move s2 , zero b 0x14c addiu s1 , zero , 0x2c beqz v0 , 0xc4 move a0 , s0 subu s1 , v0 , s0 addiu a2 , zero , 0x5 move a1 , s4 move a0 , zero lw t9 , - 0x7df0 ( gp ) jalr t9 nop lw gp , 0x18 ( sp ) move s2 , v0 move a3 , s1 move a2 , s0 addiu a1 , zero , 0x8 move a0 , zero lw t9 , - 0x7fac ( gp ) bal 0x8000 nop lw gp , 0x18 ( sp ) sw v0 , 0x10 ( sp ) move a3 , s2 lui a2 , 0x41 addiu a2 , a2 , 0x12ec move a1 , zero move a0 , zero jal 0x4024a4 nop lw gp , 0x18 ( sp ) addiu a0 , zero , 0x1 jal 0x401b30 nop lw t9 , - 0x7e48 ( gp ) jalr t9 nop lw gp , 0x18 ( sp ) b 0x54 move s1 , v0 lb v1 , ( v1 ) beqz v1 , 0xf0 nop bne v1 , s1 , 0xfc nop lw v1 , 0xc ( a3 ) bnez v1 , 0x134 nop lb v1 , ( a3 ) beqz v1 , 0x48 addiu a3 , a3 , 0x10 move a0 , a3 move v1 , s0 lb a1 , ( a0 ) beqz a1 , 0xdc nop addiu v1 , v1 , 0x1 lb a2 , - 0x1 ( v1 ) beq a2 , a1 , 0x110 addiu a0 , a0 , 0x1 b 0x100 lb v1 , ( a3 ) bnez s3 , 0x140 nop or v1 , v1 , s2 beqz v0 , 0x16c addiu s0 , v0 , 0x1 move s2 , v1 move a1 , s1 move a0 , s0 lw t9 , - 0x7e44 ( gp ) jalr t9 nop lw gp , 0x18 ( sp ) b 0x108 move a3 , s5 move v0 , v1 lw ra , 0x3c ( sp ) lw s5 , 0x38 ( sp ) lw s4 , 0x34 ( sp ) lw s3 , 0x30 ( sp ) lw s2 , 0x2c ( sp ) lw s1 , 0x28 ( sp ) lw s0 , 0x24 ( sp ) jr ra addiu sp , sp , 0x40
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two code snippets are fundamentally dissimilar due to multiple factors:
1. Architecture differences: Code1 uses x86 assembly (Intel syntax) with registers like EBP, ESP, EAX, while Code2 uses MIPS32 assembly with registers like SP, RA, S0-S5.
2. Structural divergence: Code1 has complex flag-based conditional jumps (test/jne/jmp chains) and byte-level manipulations, whereas Code2 relies on MIPS branch instructions (beqz/bne) and distinct calling conventions via T9 registers.
3. Functional mismatch: Code1 performs stack operations with byte-level masking (and cl, 0x1) and direct function calls, while Code2 uses MIPS-specific global pointer (gp) access and lui/addiu address loading.
4. No overlapping constants/patterns: Critical values (like 0x2c, 0x54 in Code1 vs 0x40, 0x5 in Code2) and control flow structures show no meaningful alignment to suggest equivalent functionality.
------------------------------------------------------------

------------------------------------------------------------
Code1: push ebp mov ebp , esp sub esp , 0x18 cmp dword ptr [ 0x80a5e5c ] , 0x0 jne 0x10f mov al , byte ptr [ 0x80a4704 ] xor al , 0x63 mov byte ptr [ 0x80a4708 ] , al mov al , byte ptr [ 0x80a4705 ] xor al , 0x56 mov byte ptr [ 0x80a4709 ] , al mov al , byte ptr [ 0x80a4706 ] xor al , 0x81 mov byte ptr [ 0x80a470a ] , al mov al , byte ptr [ 0x80a4707 ] xor al , 0x48 mov byte ptr [ 0x80a470b ] , al mov al , byte ptr [ 0x80a4710 ] xor al , 0x5d mov byte ptr [ 0x80a4730 ] , al mov al , byte ptr [ 0x80a4711 ] xor al , 0xa4 mov byte ptr [ 0x80a4731 ] , al mov al , byte ptr [ 0x80a4712 ] xor al , 0x3c mov byte ptr [ 0x80a4732 ] , al mov al , byte ptr [ 0x80a4713 ] xor al , 0xa3 mov byte ptr [ 0x80a4733 ] , al mov al , byte ptr [ 0x80a4714 ] xor al , 0x74 mov byte ptr [ 0x80a4734 ] , al mov al , byte ptr [ 0x80a4715 ] xor al , 0xb1 mov byte ptr [ 0x80a4735 ] , al mov al , byte ptr [ 0x80a4716 ] xor al , 0x7 mov byte ptr [ 0x80a4736 ] , al mov al , byte ptr [ 0x80a4717 ] xor al , 0xa3 mov byte ptr [ 0x80a4737 ] , al mov al , byte ptr [ 0x80a4718 ] xor al , 0x2d mov byte ptr [ 0x80a4738 ] , al mov al , byte ptr [ 0x80a4719 ] xor al , 0x7d mov byte ptr [ 0x80a4739 ] , al mov al , byte ptr [ 0x80a471a ] xor al , 0xb5 mov byte ptr [ 0x80a473a ] , al mov al , byte ptr [ 0x80a471b ] xor al , 0x8a mov byte ptr [ 0x80a473b ] , al mov al , byte ptr [ 0x80a471c ] xor al , 0xd2 mov byte ptr [ 0x80a473c ] , al mov al , byte ptr [ 0x80a471d ] xor al , 0x1c mov byte ptr [ 0x80a473d ] , al mov al , byte ptr [ 0x80a471e ] xor al , 0x5 mov byte ptr [ 0x80a473e ] , al mov al , byte ptr [ 0x80a471f ] xor al , 0xf2 mov byte ptr [ 0x80a473f ] , al mov al , byte ptr [ 0x80a4720 ] xor al , 0x32 mov byte ptr [ 0x80a4740 ] , al lea eax , [ 0x80a4730 ] mov dword ptr [ 0x80a5e5c ] , 0x1 mov ecx , dword ptr [ 0x80a4768 ] mov dword ptr [ esp ] , eax mov dword ptr [ ebp - 0x4 ] , ecx call 0xfffb32f0 lea ecx , [ 0x80a4708 ] mov edx , dword ptr [ ebp - 0x4 ] mov dword ptr [ esp ] , edx mov dword ptr [ esp + 0x4 ] , ecx mov dword ptr [ esp + 0x8 ] , eax call 0xfffb3390 mov ecx , dword ptr [ 0x80a38e0 ] mov dword ptr [ esp ] , ecx mov dword ptr [ ebp - 0x8 ] , eax call 0xfffb32e0 nop nop nop
Code2: lui gp , 0x44 addiu sp , sp , - 0x20 addiu gp , gp , - 0xe20 lui a1 , 0x42 addiu a2 , zero , 0x5 sw ra , 0x1c ( sp ) sw s0 , 0x18 ( sp ) addiu a1 , a1 , 0x5da0 sw gp , 0x10 ( sp ) move a0 , zero lw v0 , - 0x7c48 ( gp ) lw t9 , - 0x7c98 ( gp ) jalr t9 lw s0 , ( v0 ) lui a2 , 0x42 lw gp , 0x10 ( sp ) addiu a1 , zero , 0x1 addiu a2 , a2 , 0x5a58 move a0 , s0 lw t9 , - 0x7dbc ( gp ) jalr t9 move a3 , v0 lw gp , 0x10 ( sp ) lw v0 , - 0x7f3c ( gp ) lw t9 , - 0x7d14 ( gp ) lw a0 , ( v0 ) jalr t9 nop
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two code snippets are from entirely different architectures (x86 vs MIPS) with fundamentally distinct instruction sets and paradigms. Code1 uses x86-specific registers (ebp, esp, eax, ecx) and operations (mov, cmp, jne, lea), while Code2 uses MIPS-specific instructions (lui, addiu, sw) and registers (gp, sp, ra, t9). There's no overlap in functionality—Code1 performs byte-level XOR operations and memory manipulation, whereas Code2 handles function calls and stack management. The architectural divergence and lack of shared operations result in zero similarity.
------------------------------------------------------------

------------------------------------------------------------
Code1: push ebp push edi push esi push ebx call 0xfffe78a0 add ebx , 0xad4b sub esp , 0x18 mov edi , dword ptr [ esp + 0x34 ] mov esi , dword ptr [ esp + 0x2c ] mov eax , edi mov dword ptr [ esi ] , 0x0 mov dword ptr [ esi + 0x4 ] , 0x0 and eax , 0x1 mov dword ptr [ esi + 0x8 ] , 0x0 push 0x100 cmp eax , 0x1 sbb ebp , ebp and ebp , 0xfd4fca call 0xfffe6740 add ebp , 0x3b2fc add esp , 0x10 test eax , eax mov dword ptr [ esi + 0x10 ] , eax je 0x110 mov edx , edi shl edx , 0x15 and edx , 0x400000 or ebp , edx test edi , 0x4 jne 0xd8 and byte ptr [ esi + 0x1c ] , 0x7f movzx eax , byte ptr [ esi + 0x1c ] shr edi , 0x3 sub esp , 0xc and edi , 0x1 mov dword ptr [ esi + 0x14 ] , 0x0 shl edi , 0x4 and eax , 0xffffffef or eax , edi mov byte ptr [ esi + 0x1c ] , al push dword ptr [ esp + 0x30 ] call 0xfffe6800 mov edx , dword ptr [ esp + 0x34 ] mov ecx , eax mov eax , esi mov dword ptr [ esp ] , ebp call 0xffffe830 add esp , 0x10 cmp eax , 0x10 mov edi , eax je 0xf0 test eax , eax jne 0xf5 sub esp , 0xc push esi call 0xfffff960 add esp , 0x10 add esp , 0xc mov eax , edi pop ebx pop esi pop edi pop ebp ret lea esi , [ esi ] mov edx , ebp or byte ptr [ esi + 0x1c ] , 0x80 and edx , 0xffffffbf or dh , 0x1 mov ebp , edx jmp 0x75 nop lea esi , [ esi ] mov edi , 0x8 sub esp , 0xc push dword ptr [ esi + 0x10 ] call 0xfffe6510 mov dword ptr [ esi + 0x10 ] , 0x0 add esp , 0x10 jmp 0xc7 lea esi , [ esi ] add esp , 0xc mov edi , 0xc pop ebx mov eax , edi pop esi pop edi pop ebp ret nop
Code2: push ebp mov ebp , esp push edi push esi sub esp , 0x70 mov eax , dword ptr [ ebp + 0x10 ] mov ecx , dword ptr [ ebp + 0xc ] mov edx , dword ptr [ ebp + 0x8 ] mov esi , dword ptr [ ebp + 0x10 ] and esi , 0x1 cmp esi , 0x0 mov esi , 0x3b2fc mov edi , 0x10102c6 cmovne edi , esi mov dword ptr [ ebp - 0x18 ] , edi mov esi , dword ptr [ ebp + 0x8 ] mov dword ptr [ esi ] , 0x0 mov esi , dword ptr [ ebp + 0x8 ] mov dword ptr [ esi + 0x4 ] , 0x0 mov esi , dword ptr [ ebp + 0x8 ] mov dword ptr [ esi + 0x8 ] , 0x0 mov dword ptr [ esp ] , 0x100 mov dword ptr [ ebp - 0x20 ] , eax mov dword ptr [ ebp - 0x24 ] , ecx mov dword ptr [ ebp - 0x28 ] , edx call 0xfffeb200 mov ecx , dword ptr [ ebp + 0x8 ] mov dword ptr [ ecx + 0x10 ] , eax mov eax , dword ptr [ ebp + 0x8 ] mov eax , dword ptr [ eax + 0x10 ] mov dword ptr [ ebp - 0xc ] , eax mov dword ptr [ ebp - 0x1c ] , 0x4812e0f0 mov eax , dword ptr [ ebp - 0x1c ] mov ecx , eax sub ecx , 0xb81429a0 mov dword ptr [ ebp - 0x2c ] , eax mov dword ptr [ ebp - 0x30 ] , ecx je 0x2e6 jmp 0x8e mov eax , dword ptr [ ebp - 0x2c ] sub eax , 0xbcb9ff28 mov dword ptr [ ebp - 0x34 ] , eax je 0x231 jmp 0xa4 mov eax , dword ptr [ ebp - 0x2c ] sub eax , 0xc50a5dfa mov dword ptr [ ebp - 0x38 ] , eax je 0x219 jmp 0xba mov eax , dword ptr [ ebp - 0x2c ] sub eax , 0xdadc2053 mov dword ptr [ ebp - 0x3c ] , eax je 0x1a0 jmp 0xd0 mov eax , dword ptr [ ebp - 0x2c ] sub eax , 0xdf67ad94 mov dword ptr [ ebp - 0x40 ] , eax je 0x300 jmp 0xe6 mov eax , dword ptr [ ebp - 0x2c ] sub eax , 0xf89737fe mov dword ptr [ ebp - 0x44 ] , eax je 0x1ea jmp 0xfc mov eax , dword ptr [ ebp - 0x2c ] sub eax , 0x2d7a7a47 mov dword ptr [ ebp - 0x48 ] , eax je 0x2cd jmp 0x112 mov eax , dword ptr [ ebp - 0x2c ] sub eax , 0x4812e0f0 mov dword ptr [ ebp - 0x4c ] , eax je 0x185 jmp 0x128 mov eax , dword ptr [ ebp - 0x2c ] sub eax , 0x4aff19e3 mov dword ptr [ ebp - 0x50 ] , eax je 0x2ba jmp 0x13e mov eax , dword ptr [ ebp - 0x2c ] sub eax , 0x4d74e8a4 mov dword ptr [ ebp - 0x54 ] , eax je 0x336 jmp 0x154 mov eax , dword ptr [ ebp - 0x2c ] sub eax , 0x5bca9cab mov dword ptr [ ebp - 0x58 ] , eax je 0x1b3 jmp 0x16a mov eax , dword ptr [ ebp - 0x2c ] sub eax , 0x70970f5b mov dword ptr [ ebp - 0x5c ] , eax je 0x324 jmp 0x180 jmp 0x340 mov eax , dword ptr [ ebp - 0xc ] cmp eax , 0x0 mov eax , 0xdadc2053 mov ecx , 0x5bca9cab cmove ecx , eax mov dword ptr [ ebp - 0x1c ] , ecx jmp 0x340 mov dword ptr [ ebp - 0x10 ] , 0xc mov dword ptr [ ebp - 0x1c ] , 0x4d74e8a4 jmp 0x340 xor eax , eax mov ecx , dword ptr [ ebp + 0x10 ] and ecx , 0x2 cmp ecx , 0x0 mov ecx , 0x400000 cmovne eax , ecx or eax , dword ptr [ ebp - 0x18 ] mov dword ptr [ ebp - 0x18 ] , eax mov eax , dword ptr [ ebp + 0x10 ] and eax , 0x4 cmp eax , 0x0 mov eax , 0xf89737fe mov ecx , 0xc50a5dfa cmovne ecx , eax mov dword ptr [ ebp - 0x1c ] , ecx jmp 0x340 mov eax , dword ptr [ ebp - 0x18 ] and eax , 0xffffffbf mov dword ptr [ ebp - 0x18 ] , eax mov eax , dword ptr [ ebp - 0x18 ] or eax , 0x100 mov dword ptr [ ebp - 0x18 ] , eax mov eax , dword ptr [ ebp + 0x8 ] mov cl , byte ptr [ eax + 0x1c ] and cl , 0x7f or cl , 0x80 mov byte ptr [ eax + 0x1c ] , cl mov dword ptr [ ebp - 0x1c ] , 0xbcb9ff28 jmp 0x340 mov eax , dword ptr [ ebp + 0x8 ] mov cl , byte ptr [ eax + 0x1c ] and cl , 0x7f mov byte ptr [ eax + 0x1c ] , cl mov dword ptr [ ebp - 0x1c ] , 0xbcb9ff28 jmp 0x340 mov eax , dword ptr [ ebp + 0x10 ] and eax , 0x8 cmp eax , 0x0 setne cl xor cl , 0xff xor cl , 0xff and cl , 0x1 movzx eax , cl mov edx , dword ptr [ ebp + 0x8 ] mov cl , al mov ch , byte ptr [ edx + 0x1c ] and cl , 0x1 shl cl , 0x4 and ch , 0xef or ch , cl mov byte ptr [ edx + 0x1c ] , ch mov eax , dword ptr [ ebp + 0x8 ] mov dword ptr [ eax + 0x14 ] , 0x0 mov eax , dword ptr [ ebp + 0x8 ] mov edx , dword ptr [ ebp + 0xc ] mov esi , dword ptr [ ebp + 0xc ] mov edi , esp mov dword ptr [ edi ] , esi mov dword ptr [ ebp - 0x60 ] , eax mov dword ptr [ ebp - 0x64 ] , edx call 0xfffeb2c0 mov edx , dword ptr [ ebp - 0x18 ] mov esi , dword ptr [ ebp - 0x60 ] mov dword ptr [ esp ] , esi mov esi , dword ptr [ ebp - 0x64 ] mov dword ptr [ esp + 0x4 ] , esi mov dword ptr [ esp + 0x8 ] , eax mov dword ptr [ esp + 0xc ] , edx call 0xffffdeb0 mov dword ptr [ ebp - 0x14 ] , eax cmp dword ptr [ ebp - 0x14 ] , 0x10 mov eax , 0x4aff19e3 mov edx , 0x2d7a7a47 cmove edx , eax mov dword ptr [ ebp - 0x1c ] , edx jmp 0x340 mov dword ptr [ ebp - 0x14 ] , 0x8 mov dword ptr [ ebp - 0x1c ] , 0x2d7a7a47 jmp 0x340 cmp dword ptr [ ebp - 0x14 ] , 0x0 mov eax , 0xb81429a0 mov ecx , 0xdf67ad94 cmove ecx , eax mov dword ptr [ ebp - 0x1c ] , ecx jmp 0x340 mov eax , dword ptr [ ebp + 0x8 ] mov dword ptr [ esp ] , eax call 0xffffe7d0 mov dword ptr [ ebp - 0x1c ] , 0x70970f5b mov dword ptr [ ebp - 0x68 ] , eax jmp 0x340 mov eax , dword ptr [ ebp + 0x8 ] mov eax , dword ptr [ eax + 0x10 ] mov dword ptr [ esp ] , eax call 0xfffeafe0 mov eax , dword ptr [ ebp + 0x8 ] mov dword ptr [ eax + 0x10 ] , 0x0 mov dword ptr [ ebp - 0x1c ] , 0x70970f5b jmp 0x340 mov eax , dword ptr [ ebp - 0x14 ] mov dword ptr [ ebp - 0x10 ] , eax mov dword ptr [ ebp - 0x1c ] , 0x4d74e8a4 jmp 0x340 mov eax , dword ptr [ ebp - 0x10 ] add esp , 0x70 pop esi pop edi pop ebp ret jmp 0x72 nop word ptr cs : [ eax + eax ] nop
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly codes show significant structural and functional differences. Code1 follows a linear control flow with straightforward stack operations and direct register manipulations, while Code2 implements a complex state-machine pattern using extensive conditional jumps and memory-based comparisons (resembling a jump table). Key divergences include:
- Stack management: Code2 uses EBP-based addressing for parameters/local variables, unlike Code1's ESP-relative accesses
- Control flow: Code2 contains 14+ conditional blocks with unique constants (e.g., 0x4812e0f0,
------------------------------------------------------------

------------------------------------------------------------
Code1: lw v0 , 0xb0 ( a0 ) addiu a2 , zero , 0x3 beq v0 , a2 , 0x7c lw v1 , 0xb0 ( a1 ) addiu t0 , zero , 0x9 beq v0 , t0 , 0x80 addiu v0 , zero , 0x3 lw v0 , 0xb4 ( a0 ) beq v1 , a2 , 0x11c andi a3 , v0 , 0xf000 beq v1 , t0 , 0x10c addiu v1 , zero , 0x4000 lw v0 , 0xb4 ( a1 ) andi v0 , v0 , 0xf000 beq v0 , v1 , 0x130 nop beq a3 , v1 , 0x114 addiu v0 , zero , - 0x1 lw v1 , 0x48 ( a0 ) lw v0 , 0x48 ( a1 ) lw a3 , 0x4c ( a0 ) slt a2 , v1 , v0 bnez a2 , 0xa0 lw t0 , 0x4c ( a1 ) beq v0 , v1 , 0x140 sltu a2 , a3 , t0 slt a2 , v0 , v1 beqz a2 , 0xa8 nop jr ra addiu v0 , zero , 0x1 addiu v0 , zero , 0x3 beq v1 , v0 , 0x48 addiu v0 , zero , 0x9 beq v1 , v0 , 0x48 addiu v1 , zero , 0x4000 lw v0 , 0xb4 ( a1 ) andi v0 , v0 , 0xf000 beq v0 , v1 , 0x48 nop jr ra addiu v0 , zero , - 0x1 bne v1 , v0 , 0xb8 sltu a3 , t0 , a3 bnez a3 , 0x74 nop lui gp , 0x45 addiu sp , sp , - 0x28 addiu gp , gp , - 0x5e20 sw s1 , 0x20 ( sp ) sw s0 , 0x1c ( sp ) sw ra , 0x24 ( sp ) sw gp , 0x10 ( sp ) lw t9 , - 0x7d4c ( gp ) lw s1 , ( a1 ) jalr t9 lw s0 , ( a0 ) lw gp , 0x10 ( sp ) move a0 , s1 lw ra , 0x24 ( sp ) move a1 , s0 lw s1 , 0x20 ( sp ) lw s0 , 0x1c ( sp ) lw t9 , - 0x7cf8 ( gp ) sw zero , ( v0 ) jr t9 addiu sp , sp , 0x28 beq a3 , v1 , 0x48 addiu v0 , zero , 0x1 jr ra nop addiu v0 , zero , 0x4000 beq a3 , v0 , 0x48 addiu v0 , zero , 0x1 b 0x114 nop beq a3 , v0 , 0x48 addiu v0 , zero , 0x1 b 0x114 nop beqz a2 , 0x68 nop jr ra addiu v0 , zero , - 0x1
Code2: push ebp mov ebp , esp sub esp , 0x28 mov eax , dword ptr [ ebp + 0xc ] mov ecx , dword ptr [ ebp + 0x8 ] mov dword ptr [ ebp - 0xc ] , eax mov dword ptr [ ebp - 0x10 ] , ecx mov eax , dword ptr [ ebp + 0x8 ] mov dword ptr [ esp ] , eax call 0xfb0 and al , 0x1 mov byte ptr [ ebp - 0x5 ] , al mov ecx , dword ptr [ ebp + 0xc ] mov dword ptr [ esp ] , ecx call 0xfb0 and al , 0x1 mov byte ptr [ ebp - 0x6 ] , al test byte ptr [ ebp - 0x5 ] , 0x1 je 0x52 test byte ptr [ ebp - 0x6 ] , 0x1 jne 0x52 mov dword ptr [ ebp - 0x4 ] , 0xffffffff jmp 0x96 test byte ptr [ ebp - 0x5 ] , 0x1 jne 0x72 test byte ptr [ ebp - 0x6 ] , 0x1 je 0x72 mov dword ptr [ ebp - 0x4 ] , 0x1 jmp 0x96 jmp 0x77 mov eax , dword ptr [ ebp + 0xc ] mov ecx , dword ptr [ ebp + 0x8 ] mov dword ptr [ esp ] , eax mov dword ptr [ esp + 0x4 ] , ecx lea eax , [ 0x8052630 ] mov dword ptr [ esp + 0x8 ] , eax call 0x1100 mov dword ptr [ ebp - 0x4 ] , eax mov eax , dword ptr [ ebp - 0x4 ] add esp , 0x28 pop ebp ret nop
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly code snippets are fundamentally dissimilar due to key differences:
1. Architecture: Code1 uses MIPS instructions (lw, addiu, beq, jr) and registers (v0, a0, a1), while Code2 uses x86 instructions (mov, call, test) and registers (ebp, esp, eax).
2. Control Flow: Code1 relies heavily on branch comparisons (beq/bnez) with immediate values, whereas Code2 uses function calls (call) and conditional jumps (je/jne).
3. Stack Management: Code2 explicitly manages stack frames (push ebp, sub esp), while Code1 uses simpler register-based operations without explicit stack setup.
4. Purpose: Code1 appears to perform low-level register comparisons and arithmetic checks, while Code2 involves function calls and byte-level tests.
The architectural differences and lack of overlapping logic patterns indicate these codes implement unrelated functionality.
------------------------------------------------------------

------------------------------------------------------------
Code1: sub esp , 0xc call 0xfff76736 add edx , 0x1d8f31 mov eax , dword ptr [ esp + 0x10 ] test eax , eax je 0x34 mov edx , dword ptr [ edx + 0xdd7c ] test edx , edx js 0x24 cmp edx , dword ptr [ eax ] jne 0x34 sub esp , 0x8 push dword ptr [ eax ] push dword ptr [ eax + 0x8 ] call 0xffffff44 add esp , 0x10 add esp , 0xc ret
Code2: str lr , [ sp , - 0x4 ] ! sub sp , sp , 0x14 str r0 , [ sp , 0x4 ] ldr r3 , [ sp , 0x4 ] str r3 , [ sp , 0xc ] ldr r0 , [ sp , 0xc ] bl 0xffffff90 mov r0 , r0 add sp , sp , 0x14 pop { pc }
Similarity: -1
Label: 1
Similarity Score: -0.75
Explanation: The two code snippets are not similar due to fundamental differences in architecture, structure, and operations. Code1 uses x86 architecture with stack manipulation via ESP, register operations (EAX, EDX), conditional jumps (JE, JNE), and two function calls. Code2 uses ARM architecture with distinct stack handling via SP/LR registers, load/store operations (LDR/STR), and a single branch call (BL). No overlapping functional logic or equivalent control flow exists. The minimal similarity (-0.75) comes only from basic stack management and function calls, heavily outweighed by architectural and structural disparities.
------------------------------------------------------------

------------------------------------------------------------
Code1: push r14 push rbx push rax mov r8 , rdx mov eax , dword ptr [ rip ] test eax , eax jne 0x2a5 mov al , byte ptr [ rip ] xor al , 0x9c mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x6a mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x1 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xe mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x14 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xe1 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xed mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xbd mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x94 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x61 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x10 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xdd mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x1b mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x52 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x95 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xe3 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xa8 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x4d mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x8f mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x70 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xdb mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xbe mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xd4 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x64 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xd mov byte ptr [ rip ] , al movaps xmm0 , xmmword ptr [ rip ] xorps xmm0 , xmmword ptr [ rip ] movaps xmmword ptr [ rip ] , xmm0 movaps xmm0 , xmmword ptr [ rip ] xorps xmm0 , xmmword ptr [ rip ] movaps xmmword ptr [ rip ] , xmm0 movaps xmm0 , xmmword ptr [ rip ] xorps xmm0 , xmmword ptr [ rip ] movaps xmmword ptr [ rip ] , xmm0 movaps xmm0 , xmmword ptr [ rip ] xorps xmm0 , xmmword ptr [ rip ] movaps xmmword ptr [ rip ] , xmm0 mov al , byte ptr [ rip ] xor al , 0x73 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x7f mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x79 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x71 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] not al mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x61 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xf mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x4e mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x2a mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xd8 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xd0 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x1c mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x1f mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xbe mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xca mov byte ptr [ rip ] , al mov dword ptr [ rip ] , 0x1 test rdi , rdi je 0x490 test r8 , r8 je 0x4a4 test rcx , rcx je 0x4b8 mov eax , 0x7 cmp rsi , 0x3 jb 0x488 cmp qword ptr [ rcx ] , 0x1 ja 0x2f3 mov qword ptr [ rcx ] , 0x2 mov eax , 0x6 add rsp , 0x8 pop rbx pop r14 ret mov dl , byte ptr [ rdi ] and dl , 0x1f cmp dl , 0x6 jne 0x488 movzx r9d , byte ptr [ rdi + 0x1 ] test r9b , r9b js 0x3bd mov ebx , 0x2 test r9 , r9 je 0x488 lea rdx , [ r9 + rbx ] cmp rdx , rsi ja 0x488 add rdi , rbx xor r10d , r10d movabs r11 , 0xcccccccccccccccd xor esi , esi xor edx , edx jmp 0x370 mov rax , rsi mul r11 shr rdx , 0x5 mov qword ptr [ r8 ] , rdx shl rdx , 0x3 lea rax , [ rdx + rdx * 0x4 ] sub rsi , rax mov qword ptr [ r8 + 0x8 ] , rsi mov edx , 0x2 jmp 0x39a nop word ptr cs : [ rax + rax ] nop dword ptr [ rax ] mov rax , rsi shl rax , 0x7 movzx ebx , byte ptr [ rdi + r10 ] mov esi , ebx and esi , 0x7f or rsi , rax test bl , bl js 0x39c cmp rdx , qword ptr [ rcx ] jae 0x396 test rdx , rdx je 0x340 mov qword ptr [ r8 + rdx * 0x8 ] , rsi add rdx , 0x1 xor esi , esi add r10 , 0x1 cmp r9 , r10 jne 0x370 xor esi , esi cmp rdx , qword ptr [ rcx ] mov eax , 0x6 cmovbe eax , esi mov qword ptr [ rcx ] , rdx add rsp , 0x8 pop rbx pop r14 ret cmp r9b , 0x80 je 0x488 cmp r9b , 0x82 ja 0x488 and r9d , 0x7f test r9b , r9b je 0x488 lea rdx , [ r9 - 0x1 ] mov r10d , r9d and r10d , 0x3 cmp rdx , 0x3 jae 0x3fe mov r11d , 0x2 xor edx , edx test r10 , r10 jne 0x45a jmp 0x475 mov r14 , r10 sub r14 , r9 mov r11d , 0x2 xor edx , edx nop dword ptr [ rax ] shl rdx , 0x8 movzx ebx , byte ptr [ rdi + r11 ] or rbx , rdx shl rbx , 0x8 movzx edx , byte ptr [ rdi + r11 + 0x1 ] or rdx , rbx shl rdx , 0x8 movzx ebx , byte ptr [ rdi + r11 + 0x2 ] or rbx , rdx shl rbx , 0x8 movzx edx , byte ptr [ rdi + r11 + 0x3 ] or rdx , rbx lea rbx , [ r14 + r11 ] add rbx , 0x4 lea r11 , [ r11 + 0x4 ] cmp rbx , 0x2 jne 0x410 test r10 , r10 je 0x475 add r11 , rdi xor r14d , r14d shl rdx , 0x8 movzx ebx , byte ptr [ r11 + r14 ] or rdx , rbx add r14 , 0x1 cmp r10 , r14 jne 0x460 add r9 , 0x2 mov rbx , r9 mov r9 , rdx test r9 , r9 jne 0x31d add rsp , 0x8 pop rbx pop r14 ret mov edi , 0x0 mov esi , 0x0 mov edx , 0x1f call 0x4a4 mov edi , 0x0 mov esi , 0x0 mov edx , 0x20 call 0x4b8 mov edi , 0x0 mov esi , 0x0 mov edx , 0x21 call 0x4cc
Code2: lui gp , 0x0 addiu sp , sp , - 0x20 addiu gp , gp , 0x0 sw ra , 0x1c ( sp ) beqz a0 , 0x5d4 sw gp , 0x10 ( sp ) beqz a2 , 0x5bc lw t9 , ( gp ) beqz a3 , 0x5a0 sltiu v0 , a1 , 0x3 bnez v0 , 0x2e0 nop lw t1 , ( a3 ) sltiu v1 , t1 , 0x2 bnez v1 , 0x42c addiu t2 , zero , 0x6 lbu t0 , ( a0 ) andi t3 , t0 , 0x1f bne t3 , t2 , 0x2e0 nop lbu v0 , 0x1 ( a0 ) seb t4 , v0 bltz t4 , 0x2f0 addiu t9 , zero , 0x2 beqz v0 , 0x2e0 addu ra , t9 , v0 sltu a1 , a1 , ra bnez a1 , 0x2e0 addu a1 , a0 , t9 addu t8 , a0 , ra lui t4 , 0xcccc subu t2 , t8 , a1 move a0 , zero andi t6 , t2 , 0x3 move v1 , zero beqz t6 , 0x190 ori t5 , t4 , 0xcccd addiu t0 , zero , 0x1 beq t6 , t0 , 0x140 nop addiu t7 , zero , 0x2 beq t6 , t7 , 0xf8 nop lbu a0 , ( a1 ) seb v0 , a0 bltz v0 , 0xf4 andi a0 , a0 , 0x7f beqz t1 , 0x564 addiu v1 , zero , 0x1 multu a0 , t5 addiu v1 , zero , 0x2 mfhi t1 srl t3 , t1 , 0x5 sll t9 , t3 , 0x2 sw t3 , ( a2 ) addu ra , t9 , t3 sll t2 , ra , 0x3 subu t6 , a0 , t2 move a0 , zero sw t6 , 0x4 ( a2 ) lw t1 , ( a3 ) addiu a1 , a1 , 0x1 lbu t4 , ( a1 ) sll t7 , a0 , 0x7 seb t0 , t4 andi a0 , t4 , 0x7f bltz t0 , 0x13c or a0 , a0 , t7 sltu v0 , v1 , t1 beqz v0 , 0x528 nop beqz v1 , 0x570 multu a0 , t5 sll t1 , v1 , 0x2 addiu v1 , v1 , 0x1 addu t3 , a2 , t1 sw a0 , ( t3 ) move a0 , zero lw t1 , ( a3 ) addiu a1 , a1 , 0x1 lbu t0 , ( a1 ) sll a0 , a0 , 0x7 andi v0 , t0 , 0x7f seb t3 , t0 bltz t3 , 0x184 or a0 , v0 , a0 sltu t9 , v1 , t1 beqz t9 , 0x474 nop beqz v1 , 0x534 multu a0 , t5 sll t1 , v1 , 0x2 addiu v1 , v1 , 0x1 addu ra , a2 , t1 sw a0 , ( ra ) move a0 , zero lw t1 , ( a3 ) addiu a1 , a1 , 0x1 beq t8 , a1 , 0x2c8 lw ra , 0x1c ( sp ) lbu t3 , ( a1 ) sll t9 , a0 , 0x7 seb ra , t3 andi a0 , t3 , 0x7f bltz ra , 0x1ec or t4 , a0 , t9 sltu t2 , v1 , t1 beqz t2 , 0x450 nop bnez v1 , 0x480 sll t1 , v1 , 0x2 multu t4 , t5 addiu v1 , zero , 0x2 mfhi t7 srl v0 , t7 , 0x5 sll t0 , v0 , 0x2 sw v0 , ( a2 ) addu t3 , t0 , v0 sll t9 , t3 , 0x3 subu a0 , t4 , t9 move t4 , zero sw a0 , 0x4 ( a2 ) lw t1 , ( a3 ) lbu ra , 0x1 ( a1 ) sll t6 , t4 , 0x7 addiu a1 , a1 , 0x1 andi t4 , ra , 0x7f seb t2 , ra bltz t2 , 0x234 or a0 , t4 , t6 sltu t7 , v1 , t1 beqz t7 , 0x45c nop beqz v1 , 0x4f8 multu a0 , t5 sll t1 , v1 , 0x2 addiu v1 , v1 , 0x1 addu v0 , a2 , t1 sw a0 , ( v0 ) move a0 , zero lw t1 , ( a3 ) lbu t2 , 0x1 ( a1 ) sll t7 , a0 , 0x7 andi v0 , t2 , 0x7f seb t0 , t2 bltz t0 , 0x278 or a0 , v0 , t7 sltu t3 , v1 , t1 beqz t3 , 0x468 nop beqz v1 , 0x498 multu a0 , t5 sll t1 , v1 , 0x2 addiu v1 , v1 , 0x1 addu t9 , a2 , t1 sw a0 , ( t9 ) move a0 , zero lw t1 , ( a3 ) lbu t0 , 0x2 ( a1 ) sll t3 , a0 , 0x7 andi t9 , t0 , 0x7f seb ra , t0 bltz ra , 0x2bc or a0 , t9 , t3 sltu t6 , v1 , t1 beqz t6 , 0x444 nop beqz v1 , 0x4c8 multu a0 , t5 sll t1 , v1 , 0x2 addiu v1 , v1 , 0x1 addu t4 , a2 , t1 sw a0 , ( t4 ) move a0 , zero lw t1 , ( a3 ) addiu a1 , a1 , 0x3 bne t8 , a1 , 0x190 lw ra , 0x1c ( sp ) addiu v0 , zero , 0x6 sltu a2 , t1 , v1 sw v1 , ( a3 ) movz v0 , zero , a2 jr ra addiu sp , sp , 0x20 lw ra , 0x1c ( sp ) addiu v0 , zero , 0x7 jr ra addiu sp , sp , 0x20 addiu t5 , v0 , 0x7f andi t6 , t5 , 0xff sltiu t7 , t6 , 0x2 beqz t7 , 0x2e0 andi t9 , v0 , 0x7f beqz t9 , 0x2e0 andi t8 , t9 , 0x7 move t2 , a0 move v0 , zero beqz t8 , 0x3bc addu ra , a0 , t9 addiu v1 , zero , 0x1 beq t8 , v1 , 0x3a8 addiu t0 , zero , 0x2 beq t8 , t0 , 0x398 addiu t3 , zero , 0x3 beq t8 , t3 , 0x388 addiu t4 , zero , 0x4 beq t8 , t4 , 0x378 addiu t5 , zero , 0x5 beq t8 , t5 , 0x368 addiu t6 , zero , 0x6 beq t8 , t6 , 0x358 nop lbu v0 , 0x2 ( a0 ) addiu t2 , a0 , 0x1 lbu t7 , 0x2 ( t2 ) sll v0 , v0 , 0x8 addiu t2 , t2 , 0x1 or v0 , t7 , v0 lbu t8 , 0x2 ( t2 ) sll v1 , v0 , 0x8 addiu t2 , t2 , 0x1 or v0 , t8 , v1 lbu t0 , 0x2 ( t2 ) sll t3 , v0 , 0x8 addiu t2 , t2 , 0x1 or v0 , t0 , t3 lbu t4 , 0x2 ( t2 ) sll t5 , v0 , 0x8 addiu t2 , t2 , 0x1 or v0 , t4 , t5 lbu t6 , 0x2 ( t2 ) sll t7 , v0 , 0x8 addiu t2 , t2 , 0x1 or v0 , t6 , t7 lbu t8 , 0x2 ( t2 ) sll v0 , v0 , 0x8 addiu t2 , t2 , 0x1 beq ra , t2 , 0x424 or v0 , t8 , v0 lbu v1 , 0x2 ( t2 ) sll t0 , v0 , 0x8 lbu t5 , 0x3 ( t2 ) addiu t2 , t2 , 0x8 or t3 , v1 , t0 sll t8 , t3 , 0x8 lbu t7 , - 0x4 ( t2 ) or v1 , t5 , t8 lbu t6 , - 0x3 ( t2 ) sll t5 , v1 , 0x8 lbu t4 , - 0x2 ( t2 ) lbu t0 , - 0x1 ( t2 ) or t7 , t7 , t5 lbu v0 , ( t2 ) sll t3 , t7 , 0x8 lbu t8 , 0x1 ( t2 ) or t6 , t6 , t3 sll v1 , t6 , 0x8 or t4 , t4 , v1 sll t5 , t4 , 0x8 or t0 , t0 , t5 sll t7 , t0 , 0x8 or v0 , v0 , t7 sll t3 , v0 , 0x8 bne ra , t2 , 0x3bc or v0 , t8 , t3 b 0x60 addiu t9 , t9 , 0x2 lw ra , 0x1c ( sp ) addiu t8 , zero , 0x2 addiu v0 , zero , 0x6 sw t8 , ( a3 ) jr ra addiu sp , sp , 0x20 addiu v1 , v1 , 0x1 b 0x2bc move a0 , zero addiu v1 , v1 , 0x1 b 0x1ec move t4 , zero addiu v1 , v1 , 0x1 b 0x234 move a0 , zero addiu v1 , v1 , 0x1 b 0x278 move a0 , zero addiu v1 , v1 , 0x1 b 0x184 move a0 , zero addiu v1 , v1 , 0x1 addu t6 , a2 , t1 sw t4 , ( t6 ) move t4 , zero b 0x1ec lw t1 , ( a3 ) addiu v1 , zero , 0x2 mfhi ra srl t6 , ra , 0x5 sll t4 , t6 , 0x2 sw t6 , ( a2 ) addu t2 , t4 , t6 sll t7 , t2 , 0x3 subu v0 , a0 , t7 move a0 , zero sw v0 , 0x4 ( a2 ) b 0x278 lw t1 , ( a3 ) addiu v1 , zero , 0x2 mfhi t2 srl t7 , t2 , 0x5 sll v0 , t7 , 0x2 sw t7 , ( a2 ) addu t0 , v0 , t7 sll t3 , t0 , 0x3 subu t9 , a0 , t3 move a0 , zero sw t9 , 0x4 ( a2 ) b 0x2bc lw t1 , ( a3 ) addiu v1 , zero , 0x2 mfhi t0 srl t3 , t0 , 0x5 sll t9 , t3 , 0x2 sw t3 , ( a2 ) addu ra , t9 , t3 sll t6 , ra , 0x3 subu t4 , a0 , t6 move a0 , zero sw t4 , 0x4 ( a2 ) b 0x234 lw t1 , ( a3 ) addiu v1 , v1 , 0x1 b 0x13c move a0 , zero addiu v1 , zero , 0x2 mfhi t2 srl t6 , t2 , 0x5 sll t4 , t6 , 0x2 sw t6 , ( a2 ) addu t7 , t4 , t6 sll t0 , t7 , 0x3 subu v0 , a0 , t0 move a0 , zero sw v0 , 0x4 ( a2 ) b 0x184 lw t1 , ( a3 ) move a0 , zero b 0xf8 addiu a1 , a1 , 0x1 addiu v1 , zero , 0x2 mfhi t9 srl ra , t9 , 0x5 sll t2 , ra , 0x2 sw ra , ( a2 ) addu t6 , t2 , ra sll t4 , t6 , 0x3 subu t7 , a0 , t4 move a0 , zero sw t7 , 0x4 ( a2 ) b 0x13c lw t1 , ( a3 ) lui a3 , 0x0 lw t9 , ( gp ) lui t5 , 0x0 addiu a2 , zero , 0x21 addiu a1 , a3 , 0x0 jalr t9 addiu a0 , t5 , 0x0 lui ra , 0x0 lui t6 , 0x0 addiu a2 , zero , 0x20 addiu a1 , ra , 0x0 jalr t9 addiu a0 , t6 , 0x0 lui t4 , 0x0 lw t9 , ( gp ) lui t2 , 0x0 addiu a2 , zero , 0x1f addiu a1 , t4 , 0x0 jalr t9 addiu a0 , t2 , 0x0
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly codes are for entirely different architectures (x86-64 vs MIPS) and show no functional or structural similarity. The first code uses x86-specific registers (rax, rbx, rdx) and instructions (movaps, xorps), while the second uses MIPS conventions (a0, a1, v0, t-registers). The operations differ fundamentally: the x86 code focuses on byte-level XOR operations and XMM register manipulation, while the MIPS code centers on conditional branching and arithmetic operations like sll and multu. Control flow patterns (jumps vs branches), memory access methods, and instruction sets are incompatible. No shared algorithms or logical sequences are identifiable, confirming complete dissimilarity.
------------------------------------------------------------

------------------------------------------------------------
Code1: push ebp mov ebp , esp push esi sub esp , 0x14 mov eax , dword ptr [ ebp + 0x8 ] cmp dword ptr [ 0x80caa88 ] , 0x0 mov dword ptr [ ebp - 0x8 ] , eax jne 0x43a mov al , byte ptr [ 0x80c2cfe ] xor al , 0x73 mov byte ptr [ 0x80c2d05 ] , al mov al , byte ptr [ 0x80c2cff ] xor al , 0x25 mov byte ptr [ 0x80c2d06 ] , al mov al , byte ptr [ 0x80c2d00 ] xor al , 0xe5 mov byte ptr [ 0x80c2d07 ] , al mov al , byte ptr [ 0x80c2d01 ] xor al , 0x6 mov byte ptr [ 0x80c2d08 ] , al mov al , byte ptr [ 0x80c2d02 ] xor al , 0x62 mov byte ptr [ 0x80c2d09 ] , al mov al , byte ptr [ 0x80c2d03 ] xor al , 0x63 mov byte ptr [ 0x80c2d0a ] , al mov al , byte ptr [ 0x80c2d04 ] xor al , 0xb8 mov byte ptr [ 0x80c2d0b ] , al mov al , byte ptr [ 0x80c2d10 ] xor al , 0xca mov byte ptr [ 0x80c2d30 ] , al mov al , byte ptr [ 0x80c2d11 ] xor al , 0x5a mov byte ptr [ 0x80c2d31 ] , al mov al , byte ptr [ 0x80c2d12 ] xor al , 0x27 mov byte ptr [ 0x80c2d32 ] , al mov al , byte ptr [ 0x80c2d13 ] xor al , 0xb9 mov byte ptr [ 0x80c2d33 ] , al mov al , byte ptr [ 0x80c2d14 ] xor al , 0x2c mov byte ptr [ 0x80c2d34 ] , al mov al , byte ptr [ 0x80c2d15 ] xor al , 0x76 mov byte ptr [ 0x80c2d35 ] , al mov al , byte ptr [ 0x80c2d16 ] xor al , 0x55 mov byte ptr [ 0x80c2d36 ] , al mov al , byte ptr [ 0x80c2d17 ] xor al , 0x2a mov byte ptr [ 0x80c2d37 ] , al mov al , byte ptr [ 0x80c2d18 ] xor al , 0xe6 mov byte ptr [ 0x80c2d38 ] , al mov al , byte ptr [ 0x80c2d19 ] xor al , 0xd4 mov byte ptr [ 0x80c2d39 ] , al mov al , byte ptr [ 0x80c2d1a ] xor al , 0xbb mov byte ptr [ 0x80c2d3a ] , al mov al , byte ptr [ 0x80c2d1b ] xor al , 0x5e mov byte ptr [ 0x80c2d3b ] , al mov al , byte ptr [ 0x80c2d1c ] xor al , 0xfd mov byte ptr [ 0x80c2d3c ] , al mov al , byte ptr [ 0x80c2d1d ] xor al , 0x28 mov byte ptr [ 0x80c2d3d ] , al mov al , byte ptr [ 0x80c2d1e ] xor al , 0x6 mov byte ptr [ 0x80c2d3e ] , al mov al , byte ptr [ 0x80c2d1f ] xor al , 0x65 mov byte ptr [ 0x80c2d3f ] , al mov al , byte ptr [ 0x80c2d20 ] xor al , 0xd3 mov byte ptr [ 0x80c2d40 ] , al mov al , byte ptr [ 0x80c2d21 ] xor al , 0xf2 mov byte ptr [ 0x80c2d41 ] , al mov al , byte ptr [ 0x80c2d22 ] xor al , 0xfb mov byte ptr [ 0x80c2d42 ] , al mov al , byte ptr [ 0x80c2d23 ] xor al , 0x2e mov byte ptr [ 0x80c2d43 ] , al mov al , byte ptr [ 0x80c2d24 ] xor al , 0x52 mov byte ptr [ 0x80c2d44 ] , al mov al , byte ptr [ 0x80c2d25 ] xor al , 0x9f mov byte ptr [ 0x80c2d45 ] , al mov al , byte ptr [ 0x80c2d26 ] xor al , 0x48 mov byte ptr [ 0x80c2d46 ] , al mov al , byte ptr [ 0x80c2d27 ] xor al , 0x4c mov byte ptr [ 0x80c2d47 ] , al mov al , byte ptr [ 0x80c2d28 ] xor al , 0x8e mov byte ptr [ 0x80c2d48 ] , al mov al , byte ptr [ 0x80c2d29 ] xor al , 0x67 mov byte ptr [ 0x80c2d49 ] , al mov al , byte ptr [ 0x80c2d2a ] xor al , 0x41 mov byte ptr [ 0x80c2d4a ] , al mov al , byte ptr [ 0x80c2d50 ] xor al , 0x3b mov byte ptr [ 0x80c2d90 ] , al mov al , byte ptr [ 0x80c2d51 ] xor al , 0xac mov byte ptr [ 0x80c2d91 ] , al mov al , byte ptr [ 0x80c2d52 ] xor al , 0xcd mov byte ptr [ 0x80c2d92 ] , al mov al , byte ptr [ 0x80c2d53 ] xor al , 0x1b mov byte ptr [ 0x80c2d93 ] , al mov al , byte ptr [ 0x80c2d54 ] xor al , 0xce mov byte ptr [ 0x80c2d94 ] , al mov al , byte ptr [ 0x80c2d55 ] xor al , 0xa6 mov byte ptr [ 0x80c2d95 ] , al mov al , byte ptr [ 0x80c2d56 ] xor al , 0x71 mov byte ptr [ 0x80c2d96 ] , al mov al , byte ptr [ 0x80c2d57 ] xor al , 0xbc mov byte ptr [ 0x80c2d97 ] , al mov al , byte ptr [ 0x80c2d58 ] xor al , 0x11 mov byte ptr [ 0x80c2d98 ] , al mov al , byte ptr [ 0x80c2d59 ] xor al , 0x1e mov byte ptr [ 0x80c2d99 ] , al mov al , byte ptr [ 0x80c2d5a ] xor al , 0xda mov byte ptr [ 0x80c2d9a ] , al mov al , byte ptr [ 0x80c2d5b ] xor al , 0x6e mov byte ptr [ 0x80c2d9b ] , al mov al , byte ptr [ 0x80c2d5c ] xor al , 0xa4 mov byte ptr [ 0x80c2d9c ] , al mov al , byte ptr [ 0x80c2d5d ] xor al , 0x2f mov byte ptr [ 0x80c2d9d ] , al mov al , byte ptr [ 0x80c2d5e ] xor al , 0xe7 mov byte ptr [ 0x80c2d9e ] , al mov al , byte ptr [ 0x80c2d5f ] xor al , 0x4b mov byte ptr [ 0x80c2d9f ] , al mov al , byte ptr [ 0x80c2d60 ] xor al , 0x72 mov byte ptr [ 0x80c2da0 ] , al mov al , byte ptr [ 0x80c2d61 ] xor al , 0x88 mov byte ptr [ 0x80c2da1 ] , al mov al , byte ptr [ 0x80c2d62 ] xor al , 0xf6 mov byte ptr [ 0x80c2da2 ] , al mov al , byte ptr [ 0x80c2d63 ] xor al , 0xac mov byte ptr [ 0x80c2da3 ] , al mov al , byte ptr [ 0x80c2d64 ] xor al , 0xbc mov byte ptr [ 0x80c2da4 ] , al mov al , byte ptr [ 0x80c2d65 ] xor al , 0x87 mov byte ptr [ 0x80c2da5 ] , al mov al , byte ptr [ 0x80c2d66 ] xor al , 0x87 mov byte ptr [ 0x80c2da6 ] , al mov al , byte ptr [ 0x80c2d67 ] xor al , 0x16 mov byte ptr [ 0x80c2da7 ] , al mov al , byte ptr [ 0x80c2d68 ] xor al , 0xd1 mov byte ptr [ 0x80c2da8 ] , al mov al , byte ptr [ 0x80c2d69 ] xor al , 0x28 mov byte ptr [ 0x80c2da9 ] , al mov al , byte ptr [ 0x80c2d6a ] xor al , 0xc7 mov byte ptr [ 0x80c2daa ] , al mov al , byte ptr [ 0x80c2d6b ] xor al , 0xba mov byte ptr [ 0x80c2dab ] , al mov al , byte ptr [ 0x80c2d6c ] xor al , 0x6 mov byte ptr [ 0x80c2dac ] , al mov al , byte ptr [ 0x80c2d6d ] xor al , 0xee mov byte ptr [ 0x80c2dad ] , al mov al , byte ptr [ 0x80c2d6e ] xor al , 0xf4 mov byte ptr [ 0x80c2dae ] , al mov al , byte ptr [ 0x80c2d6f ] xor al , 0x1e mov byte ptr [ 0x80c2daf ] , al mov al , byte ptr [ 0x80c2d70 ] xor al , 0xcd mov byte ptr [ 0x80c2db0 ] , al mov al , byte ptr [ 0x80c2d71 ] xor al , 0xb5 mov byte ptr [ 0x80c2db1 ] , al mov al , byte ptr [ 0x80c2d72 ] xor al , 0x5d mov byte ptr [ 0x80c2db2 ] , al mov al , byte ptr [ 0x80c2d73 ] xor al , 0xf6 mov byte ptr [ 0x80c2db3 ] , al mov al , byte ptr [ 0x80c2d74 ] xor al , 0x85 mov byte ptr [ 0x80c2db4 ] , al mov al , byte ptr [ 0x80c2d75 ] xor al , 0xee mov byte ptr [ 0x80c2db5 ] , al mov al , byte ptr [ 0x80c2d76 ] xor al , 0xe3 mov byte ptr [ 0x80c2db6 ] , al mov al , byte ptr [ 0x80c2d77 ] xor al , 0x2b mov byte ptr [ 0x80c2db7 ] , al mov al , byte ptr [ 0x80c2d78 ] xor al , 0x10 mov byte ptr [ 0x80c2db8 ] , al mov al , byte ptr [ 0x80c2d79 ] xor al , 0xb6 mov byte ptr [ 0x80c2db9 ] , al mov al , byte ptr [ 0x80c2d7a ] xor al , 0x10 mov byte ptr [ 0x80c2dba ] , al mov al , byte ptr [ 0x80c2d7b ] xor al , 0x7d mov byte ptr [ 0x80c2dbb ] , al mov al , byte ptr [ 0x80c2d7c ] xor al , 0xff mov byte ptr [ 0x80c2dbc ] , al mov al , byte ptr [ 0x80c2d7d ] xor al , 0x70 mov byte ptr [ 0x80c2dbd ] , al mov al , byte ptr [ 0x80c2d7e ] xor al , 0x2d mov byte ptr [ 0x80c2dbe ] , al mov al , byte ptr [ 0x80c2d7f ] xor al , 0xde mov byte ptr [ 0x80c2dbf ] , al mov al , byte ptr [ 0x80c2d80 ] xor al , 0x13 mov byte ptr [ 0x80c2dc0 ] , al mov al , byte ptr [ 0x80c2d81 ] xor al , 0x87 mov byte ptr [ 0x80c2dc1 ] , al mov al , byte ptr [ 0x80c2d82 ] xor al , 0x2 mov byte ptr [ 0x80c2dc2 ] , al mov al , byte ptr [ 0x80c2d83 ] xor al , 0xdb mov byte ptr [ 0x80c2dc3 ] , al mov al , byte ptr [ 0x80c2d84 ] xor al , 0x7b mov byte ptr [ 0x80c2dc4 ] , al mov al , byte ptr [ 0x80c2d85 ] xor al , 0x4e mov byte ptr [ 0x80c2dc5 ] , al xor eax , eax mov dword ptr [ 0x80caa88 ] , 0x1 mov ecx , esp add ecx , - 0x10 mov esp , ecx mov edx , esp add edx , - 0x10 mov esp , edx mov esi , dword ptr [ ebp - 0x8 ] mov dword ptr [ ecx ] , esi cmp eax , dword ptr [ ecx ] mov dword ptr [ ebp - 0xc ] , ecx mov dword ptr [ ebp - 0x10 ] , edx jne 0x46c jmp 0x54b test byte ptr [ 0x80cbfb4 ] , 0x1 je 0x47e jmp 0x4ae lea eax , [ 0x80c2d90 ] lea ecx , [ 0x80c2d05 ] lea edx , [ 0x80c2d30 ] sub esp , 0x10 mov dword ptr [ esp ] , edx mov dword ptr [ esp + 0x4 ] , ecx mov dword ptr [ esp + 0x8 ] , 0x17b mov dword ptr [ esp + 0xc ] , eax call 0xfffe36e0 add esp , 0x10 mov eax , dword ptr [ ebp - 0xc ] mov ecx , dword ptr [ eax ] mov ecx , dword ptr [ ecx + 0x9c ] sub esp , 0x10 mov dword ptr [ esp ] , ecx call 0x0 add esp , 0x10 mov eax , dword ptr [ ebp - 0xc ] mov ecx , dword ptr [ eax ] lea edx , [ 0x8050b90 ] cmp dword ptr [ ecx ] , edx je 0x4ed mov eax , dword ptr [ ebp - 0xc ] mov ecx , dword ptr [ eax ] lea edx , [ 0x8053330 ] cmp dword ptr [ ecx ] , edx jne 0x532 mov eax , dword ptr [ ebp - 0xc ] mov ecx , dword ptr [ eax ] test byte ptr [ ecx + 0x28 ] , 0x1 je 0x52d mov eax , dword ptr [ ebp - 0xc ] mov ecx , dword ptr [ eax ] add ecx , 0x28 mov edx , dword ptr [ ebp - 0x10 ] mov dword ptr [ edx ] , ecx mov ecx , dword ptr [ edx ] cmp dword ptr [ ecx + 0x4c ] , 0x0 je 0x528 mov eax , dword ptr [ ebp - 0x10 ] mov ecx , dword ptr [ eax ] sub esp , 0x10 mov dword ptr [ esp ] , ecx call 0x5680 add esp , 0x10 jmp 0x52d jmp 0x532 mov eax , dword ptr [ ebp - 0xc ] mov ecx , dword ptr [ eax ] mov ecx , dword ptr [ ecx + 0xa0 ] sub esp , 0x10 mov dword ptr [ esp ] , ecx call 0x0 add esp , 0x10 lea esp , [ ebp - 0x4 ] pop esi pop ebp ret nop word ptr cs : [ eax + eax ] nop dword ptr [ eax + eax ]
Code2: lui gp , 0x47 addiu sp , sp , - 0x50 addiu gp , gp , 0x43a0 sw ra , 0x4c ( sp ) sw fp , 0x48 ( sp ) sw s7 , 0x44 ( sp ) sw s6 , 0x40 ( sp ) sw s5 , 0x3c ( sp ) sw s4 , 0x38 ( sp ) sw s3 , 0x34 ( sp ) sw s2 , 0x30 ( sp ) sw s1 , 0x2c ( sp ) sw s0 , 0x28 ( sp ) sw gp , 0x10 ( sp ) beqz a0 , 0x494 sw a0 , 0x50 ( sp ) lw s2 , - 0x7fd0 ( gp ) lbu v0 , 0x20 ( s2 ) beqz v0 , 0x4c4 lw s0 , - 0x7f58 ( gp ) lw v0 , 0x9c ( a0 ) beqz v0 , 0x5fc sw v0 , 0x20 ( sp ) lw v0 , 0x9c ( v0 ) beqz v0 , 0x5a4 sw v0 , 0x24 ( sp ) lw v0 , 0x9c ( v0 ) beqz v0 , 0x54c sw v0 , 0x18 ( sp ) lw v0 , 0x9c ( v0 ) beqz v0 , 0x43c sw v0 , 0x1c ( sp ) lw s7 , 0x9c ( v0 ) beqz s7 , 0x37c lw v0 , 0x1c ( sp ) lw s6 , 0x9c ( s7 ) beqz s6 , 0x2c8 lui v0 , 0x41 lw s1 , 0x9c ( s6 ) beqz s1 , 0x214 lui v0 , 0x41 lw fp , 0x9c ( s1 ) beqz fp , 0x160 lui v0 , 0x41 lui s4 , 0x41 lw s5 , - 0x7f54 ( gp ) lw s3 , - 0x7f50 ( gp ) b 0xe4 addiu s4 , s4 , - 0x1f0 beq v0 , s3 , 0xf8 nop lw fp , 0xa0 ( fp ) beqz fp , 0x160 lui v0 , 0x41 lbu v0 , 0x20 ( s2 ) beqz v0 , 0x4c8 lui a3 , 0x45 jal 0x4103b4 lw a0 , 0x9c ( fp ) lw v0 , ( fp ) bne v0 , s0 , 0xc4 lw gp , 0x10 ( sp ) lbu v0 , 0x28 ( fp ) beqz v0 , 0xcc nop lw v0 , 0x74 ( fp ) beqz v0 , 0xcc lw t9 , - 0x7f4c ( gp ) addiu a2 , fp , 0x28 lw a0 , 0x90 ( fp ) bal 0xfeec move a1 , s4 lw a0 , 0x90 ( fp ) lw v0 , ( s5 ) beq a0 , v0 , 0xcc lw gp , 0x10 ( sp ) lw t9 , - 0x7f48 ( gp ) bal 0x1f994 nop lw gp , 0x10 ( sp ) lw t9 , - 0x7a58 ( gp ) jalr t9 lw a0 , 0x90 ( fp ) lw gp , 0x10 ( sp ) sw zero , 0x90 ( fp ) lw fp , 0xa0 ( fp ) bnez fp , 0xd8 lui v0 , 0x41 lw s5 , - 0x7f54 ( gp ) addiu s3 , v0 , - 0x1f0 lw v0 , ( s1 ) beq v0 , s0 , 0x1ac lw s4 , - 0x7f50 ( gp ) beq v0 , s4 , 0x1ac nop lw s1 , 0xa0 ( s1 ) beqz s1 , 0x214 lui v0 , 0x41 lbu v0 , 0x20 ( s2 ) beqz v0 , 0x4c8 lui a3 , 0x45 lw fp , 0x9c ( s1 ) bnez fp , 0xb0 nop lw v0 , ( s1 ) bne v0 , s0 , 0x174 nop lbu v0 , 0x28 ( s1 ) beqz v0 , 0x17c nop lw v0 , 0x74 ( s1 ) beqz v0 , 0x17c lw t9 , - 0x7f4c ( gp ) addiu a2 , s1 , 0x28 lw a0 , 0x90 ( s1 ) bal 0xfeec move a1 , s3 lw a0 , 0x90 ( s1 ) lw v0 , ( s5 ) beq a0 , v0 , 0x17c lw gp , 0x10 ( sp ) lw t9 , - 0x7f48 ( gp ) bal 0x1f994 nop lw gp , 0x10 ( sp ) lw t9 , - 0x7a58 ( gp ) jalr t9 lw a0 , 0x90 ( s1 ) lw gp , 0x10 ( sp ) sw zero , 0x90 ( s1 ) lw s1 , 0xa0 ( s1 ) bnez s1 , 0x188 lui v0 , 0x41 lw s5 , - 0x7f54 ( gp ) addiu s3 , v0 , - 0x1f0 lw v0 , ( s6 ) beq v0 , s0 , 0x260 lw s4 , - 0x7f50 ( gp ) beq v0 , s4 , 0x260 nop lw s6 , 0xa0 ( s6 ) beqz s6 , 0x2c8 lui v0 , 0x41 lbu v0 , 0x20 ( s2 ) beqz v0 , 0x4c8 lui a3 , 0x45 lw s1 , 0x9c ( s6 ) bnez s1 , 0xa4 nop lw v0 , ( s6 ) bne v0 , s0 , 0x228 nop lbu v0 , 0x28 ( s6 ) beqz v0 , 0x230 nop lw v0 , 0x74 ( s6 ) beqz v0 , 0x230 lw t9 , - 0x7f4c ( gp ) addiu a2 , s6 , 0x28 lw a0 , 0x90 ( s6 ) bal 0xfeec move a1 , s3 lw a0 , 0x90 ( s6 ) lw v0 , ( s5 ) beq a0 , v0 , 0x230 lw gp , 0x10 ( sp ) lw t9 , - 0x7f48 ( gp ) bal 0x1f994 nop lw gp , 0x10 ( sp ) lw t9 , - 0x7a58 ( gp ) jalr t9 lw a0 , 0x90 ( s6 ) lw gp , 0x10 ( sp ) sw zero , 0x90 ( s6 ) lw s6 , 0xa0 ( s6 ) bnez s6 , 0x23c lui v0 , 0x41 lw s4 , - 0x7f54 ( gp ) addiu s1 , v0 , - 0x1f0 lw v0 , ( s7 ) beq v0 , s0 , 0x314 lw s3 , - 0x7f50 ( gp ) beq v0 , s3 , 0x314 nop lw s7 , 0xa0 ( s7 ) beqz s7 , 0x37c lw v0 , 0x1c ( sp ) lbu v0 , 0x20 ( s2 ) beqz v0 , 0x4c8 lui a3 , 0x45 lw s6 , 0x9c ( s7 ) bnez s6 , 0x98 nop lw v0 , ( s7 ) bne v0 , s0 , 0x2dc nop lbu v0 , 0x28 ( s7 ) beqz v0 , 0x2e4 nop lw v0 , 0x74 ( s7 ) beqz v0 , 0x2e4 lw t9 , - 0x7f4c ( gp ) addiu a2 , s7 , 0x28 lw a0 , 0x90 ( s7 ) bal 0xfeec move a1 , s1 lw a0 , 0x90 ( s7 ) lw v0 , ( s4 ) beq a0 , v0 , 0x2e4 lw gp , 0x10 ( sp ) lw t9 , - 0x7f48 ( gp ) bal 0x1f994 nop lw gp , 0x10 ( sp ) lw t9 , - 0x7a58 ( gp ) jalr t9 lw a0 , 0x90 ( s7 ) lw gp , 0x10 ( sp ) sw zero , 0x90 ( s7 ) lw s7 , 0xa0 ( s7 ) bnez s7 , 0x2f0 lw v0 , 0x1c ( sp ) lui s4 , 0x41 lw s1 , - 0x7f54 ( gp ) lw s3 , - 0x7f50 ( gp ) lw v0 , ( v0 ) beq v0 , s0 , 0x3d0 addiu s4 , s4 , - 0x1f0 beq v0 , s3 , 0x3d4 lw v1 , 0x1c ( sp ) lw v0 , 0x1c ( sp ) lw v0 , 0xa0 ( v0 ) beqz v0 , 0x43c sw v0 , 0x1c ( sp ) lbu v0 , 0x20 ( s2 ) beqz v0 , 0x4c4 lw v0 , 0x1c ( sp ) lw s7 , 0x9c ( v0 ) bnez s7 , 0x8c nop lw v0 , ( v0 ) bne v0 , s0 , 0x394 nop lw v1 , 0x1c ( sp ) lbu v0 , 0x28 ( v1 ) beqz v0 , 0x3a0 lw v0 , 0x1c ( sp ) lw v0 , 0x74 ( v1 ) beqz v0 , 0x3a0 lw v0 , 0x1c ( sp ) lw t9 , - 0x7f4c ( gp ) move s5 , v1 lw a0 , 0x90 ( v1 ) addiu a2 , v1 , 0x28 bal 0xfeec move a1 , s4 lw a0 , 0x90 ( s5 ) lw v0 , ( s1 ) beq a0 , v0 , 0x39c lw gp , 0x10 ( sp ) lw t9 , - 0x7f48 ( gp ) bal 0x1f994 nop lw gp , 0x10 ( sp ) lw t9 , - 0x7a58 ( gp ) jalr t9 lw a0 , 0x90 ( s5 ) lw gp , 0x10 ( sp ) b 0x39c sw zero , 0x90 ( s5 ) lui s4 , 0x41 lw s3 , - 0x7f54 ( gp ) lw s1 , - 0x7f50 ( gp ) addiu s4 , s4 , - 0x1f0 lw v0 , 0x18 ( sp ) lw v0 , ( v0 ) beq v0 , s0 , 0x4e8 lw v1 , 0x18 ( sp ) beq v0 , s1 , 0x4e8 nop lw v0 , 0x18 ( sp ) lw v0 , 0xa0 ( v0 ) beqz v0 , 0x54c sw v0 , 0x18 ( sp ) lbu v0 , 0x20 ( s2 ) beqz v0 , 0x4c4 lw v0 , 0x18 ( sp ) lw v0 , 0x9c ( v0 ) bnez v0 , 0x80 sw v0 , 0x1c ( sp ) b 0x450 lw v0 , 0x18 ( sp ) lw ra , 0x4c ( sp ) lw fp , 0x48 ( sp ) lw s7 , 0x44 ( sp ) lw s6 , 0x40 ( sp ) lw s5 , 0x3c ( sp ) lw s4 , 0x38 ( sp ) lw s3 , 0x34 ( sp ) lw s2 , 0x30 ( sp ) lw s1 , 0x2c ( sp ) lw s0 , 0x28 ( sp ) jr ra addiu sp , sp , 0x50 lui a3 , 0x45 lw t9 , - 0x7c70 ( gp ) lui a1 , 0x45 lui a0 , 0x45 addiu a3 , a3 , 0x5bf4 addiu a2 , zero , 0x17b addiu a1 , a1 , 0x55f4 jalr t9 addiu a0 , a0 , 0x5618 lbu v0 , 0x28 ( v1 ) beqz v0 , 0x468 lw v0 , 0x18 ( sp ) lw v0 , 0x74 ( v1 ) beqz v0 , 0x464 addiu a2 , v1 , 0x28 lw t9 , - 0x7f4c ( gp ) move s5 , v1 lw a0 , 0x90 ( v1 ) bal 0xfeec move a1 , s4 lw a0 , 0x90 ( s5 ) lw v0 , ( s3 ) beq a0 , v0 , 0x464 lw gp , 0x10 ( sp ) lw t9 , - 0x7f48 ( gp ) bal 0x1f994 nop lw gp , 0x10 ( sp ) lw t9 , - 0x7a58 ( gp ) jalr t9 lw a0 , 0x90 ( s5 ) lw gp , 0x10 ( sp ) b 0x464 sw zero , 0x90 ( s5 ) lui s1 , 0x41 lw s4 , - 0x7f54 ( gp ) lw s3 , - 0x7f50 ( gp ) addiu s1 , s1 , - 0x1f0 lw v0 , 0x24 ( sp ) lw v0 , ( v0 ) beq v0 , s0 , 0x72c lw v1 , 0x24 ( sp ) beq v0 , s3 , 0x72c nop lw v0 , 0x24 ( sp ) lw v0 , 0xa0 ( v0 ) beqz v0 , 0x5a4 sw v0 , 0x24 ( sp ) lbu v0 , 0x20 ( s2 ) beqz v0 , 0x4c4 lw v0 , 0x24 ( sp ) lw v0 , 0x9c ( v0 ) bnez v0 , 0x74 sw v0 , 0x18 ( sp ) b 0x560 lw v0 , 0x24 ( sp ) lui s1 , 0x41 lw s4 , - 0x7f54 ( gp ) lw s3 , - 0x7f50 ( gp ) addiu s1 , s1 , - 0x1f0 lw v0 , 0x20 ( sp ) lw v0 , ( v0 ) beq v0 , s0 , 0x6c8 lw v1 , 0x20 ( sp ) beq v0 , s3 , 0x6c8 nop lw v0 , 0x20 ( sp ) lw v0 , 0xa0 ( v0 ) beqz v0 , 0x5fc sw v0 , 0x20 ( sp ) lbu v0 , 0x20 ( s2 ) beqz v0 , 0x4c4 lw v0 , 0x20 ( sp ) lw v0 , 0x9c ( v0 ) bnez v0 , 0x68 sw v0 , 0x24 ( sp ) b 0x5b8 lw v0 , 0x20 ( sp ) lui s1 , 0x41 lw s4 , - 0x7f54 ( gp ) lw s3 , - 0x7f50 ( gp ) addiu s1 , s1 , - 0x1f0 lw v0 , 0x50 ( sp ) lw v0 , ( v0 ) beq v0 , s0 , 0x654 nop beq v0 , s3 , 0x658 lw v0 , 0x50 ( sp ) lw v0 , 0x50 ( sp ) lw v0 , 0xa0 ( v0 ) beqz v0 , 0x494 sw v0 , 0x50 ( sp ) lbu v0 , 0x20 ( s2 ) beqz v0 , 0x4c4 lw v0 , 0x50 ( sp ) lw v0 , 0x9c ( v0 ) bnez v0 , 0x5c sw v0 , 0x20 ( sp ) b 0x610 lw v0 , 0x50 ( sp ) lw v0 , 0x50 ( sp ) lbu v0 , 0x28 ( v0 ) beqz v0 , 0x628 lw v0 , 0x50 ( sp ) lw v1 , 0x50 ( sp ) lw v0 , 0x74 ( v0 ) beqz v0 , 0x624 addiu a2 , v1 , 0x28 lw t9 , - 0x7f4c ( gp ) move a1 , s1 bal 0xfeec lw a0 , 0x90 ( v1 ) lw v0 , 0x50 ( sp ) lw a0 , 0x90 ( v0 ) lw v0 , ( s4 ) beq a0 , v0 , 0x624 lw gp , 0x10 ( sp ) lw t9 , - 0x7f48 ( gp ) bal 0x1f994 nop lw gp , 0x10 ( sp ) lw v0 , 0x50 ( sp ) lw t9 , - 0x7a58 ( gp ) jalr t9 lw a0 , 0x90 ( v0 ) lw v0 , 0x50 ( sp ) lw gp , 0x10 ( sp ) b 0x624 sw zero , 0x90 ( v0 ) lbu v0 , 0x28 ( v1 ) beqz v0 , 0x5d0 lw v0 , 0x20 ( sp ) lw v0 , 0x74 ( v1 ) beqz v0 , 0x5cc addiu a2 , v1 , 0x28 lw t9 , - 0x7f4c ( gp ) move s5 , v1 lw a0 , 0x90 ( v1 ) bal 0xfeec move a1 , s1 lw a0 , 0x90 ( s5 ) lw v0 , ( s4 ) beq a0 , v0 , 0x5cc lw gp , 0x10 ( sp ) lw t9 , - 0x7f48 ( gp ) bal 0x1f994 nop lw gp , 0x10 ( sp ) lw t9 , - 0x7a58 ( gp ) jalr t9 lw a0 , 0x90 ( s5 ) lw gp , 0x10 ( sp ) b 0x5cc sw zero , 0x90 ( s5 ) lbu v0 , 0x28 ( v1 ) beqz v0 , 0x578 lw v0 , 0x24 ( sp ) lw v0 , 0x74 ( v1 ) beqz v0 , 0x574 addiu a2 , v1 , 0x28 lw t9 , - 0x7f4c ( gp ) move s5 , v1 lw a0 , 0x90 ( v1 ) bal 0xfeec move a1 , s1 lw a0 , 0x90 ( s5 ) lw v0 , ( s4 ) beq a0 , v0 , 0x574 lw gp , 0x10 ( sp ) lw t9 , - 0x7f48 ( gp ) bal 0x1f994 nop lw gp , 0x10 ( sp ) lw t9 , - 0x7a58 ( gp ) jalr t9 lw a0 , 0x90 ( s5 ) lw gp , 0x10 ( sp ) b 0x574 sw zero , 0x90 ( s5 )
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly codes are fundamentally dissimilar due to differences in architecture (x86 vs MIPS), structure, and operations. The first code performs sequential byte-level XOR operations on fixed memory addresses, characteristic of low-level data manipulation. The second code uses MIPS-specific instructions (lui, addiu, sw, etc.), features extensive conditional branching with register-based operations, and includes multiple function calls (jalr, bal). There are no overlapping instruction patterns, memory access methods, or control flow structures between the codes. The architectural mismatch alone makes meaningful similarity impossible.
------------------------------------------------------------

------------------------------------------------------------
Code1: push rbp mov rbp , rsp sub rsp , 0x30 mov qword ptr [ rbp - 0x8 ] , rdi mov qword ptr [ rbp - 0x10 ] , rsi mov qword ptr [ rbp - 0x18 ] , rdx mov rdx , qword ptr [ rbp - 0x18 ] mov rdx , qword ptr [ rdx + 0x40 ] mov qword ptr [ rbp - 0x20 ] , rdx mov rdi , qword ptr [ rbp - 0x8 ] mov rsi , qword ptr [ rbp - 0x20 ] call 0xffffffffffffd720 xor edi , edi mov rsi , qword ptr [ rbp - 0x20 ] mov dword ptr [ rbp - 0x24 ] , eax call 0xffffffffffffd660 mov cl , 0x1 and cl , 0x1 movzx edi , cl mov dword ptr [ rbp - 0x28 ] , eax mov eax , edi add rsp , 0x30 pop rbp ret nop
Code2: push esi push ebx call 0xffffe9f0 add ebx , 0x4cb79 sub esp , 0xc mov eax , dword ptr [ esp + 0x20 ] mov esi , dword ptr [ eax + 0x2c ] push esi push dword ptr [ esp + 0x1c ] call 0xffffe5a0 pop eax pop edx push esi push 0x0 call 0xffffe050 add esp , 0x14 mov eax , 0x1 pop ebx pop esi ret lea esi , [ esi ] lea edi , [ edi ]
Similarity: -1
Label: 1
Similarity Score: 0.1
Explanation: The codes show minor structural similarities (both make two function calls and return 1), but fundamental differences exist. Code1 uses 64-bit registers (RBP, RSP, RDI) with a stack frame setup, while Code2 uses 32-bit registers (ESI, EBX) with direct stack manipulation. The calling conventions differ significantly: Code1 passes arguments
------------------------------------------------------------

------------------------------------------------------------
Code1: push { r4 , r5 , r6 , r7 , r8 , lr } ldr r5 , [ r1 ] mov r6 , r0 mov r1 , 0x2e mov r0 , r5 bl 0xffffbc78 ldr r6 , [ r6 ] mov r4 , r0 mov r1 , 0x2e mov r0 , r6 bl 0xffffbc78 ldr r3 , [ pc , 0x44 ] cmp r0 , 0x0 moveq r7 , r3 movne r7 , r0 cmp r4 , 0x0 moveq r4 , r3 bl 0xffffbb94 mov r2 , 0x0 mov r3 , r0 mov r1 , r7 mov r0 , r4 str r2 , [ r3 ] bl 0xffffbaa4 cmp r0 , 0x0 popne { r4 , r5 , r6 , r7 , r8 , pc } mov r1 , r6 mov r0 , r5 pop { r4 , r5 , r6 , r7 , r8 , lr } b 0xffffbaa4 andeq r7 , r3 , r8 , rrx
Code2: push ebp mov ebp , esp push esi sub esp , 0x14 mov eax , dword ptr [ ebp + 0xc ] mov ecx , dword ptr [ ebp + 0x8 ] mov edx , dword ptr [ ebp + 0xc ] mov esi , dword ptr [ ebp + 0x8 ] mov dword ptr [ esp ] , edx mov dword ptr [ esp + 0x4 ] , esi lea edx , [ 0x805a790 ] mov dword ptr [ esp + 0x8 ] , edx mov dword ptr [ ebp - 0x8 ] , eax mov dword ptr [ ebp - 0xc ] , ecx call 0x2eb0 add esp , 0x14 pop esi pop ebp ret nop word ptr cs : [ eax + eax ] nop
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly codes are fundamentally dissimilar due to differences in architecture (ARM vs x86), register usage, stack handling, and control flow. Code1 uses ARM-specific instructions (e.g., `bl`, `ldr` with PC-relative addressing, conditional execution like `moveq`/`movne`), while Code2 uses x86 conventions (e.g., `ebp`/`esp` stack frames, `dword ptr` memory operands). Code1 contains multiple function calls and conditional branches, whereas Code2 has a single function call and no conditionals. The operations, constants, and overall structure show no logical equivalence, indicating completely unrelated functionality.
------------------------------------------------------------

------------------------------------------------------------
Code1: lui gp , 0x42 addiu gp , gp , 0x40d0 lw t9 , - 0x7fbc ( gp ) b 0x1d10 addiu a0 , a0 , 0x4
Code2: push ebp mov ebp , esp sub esp , 0x8 mov eax , dword ptr [ ebp + 0x8 ] mov ecx , dword ptr [ ebp + 0x8 ] add ecx , 0x4 mov dword ptr [ esp ] , ecx mov dword ptr [ ebp - 0x4 ] , eax call 0x32a0 add esp , 0x8 pop ebp ret nop
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The first code is MIPS assembly and the second is x86 assembly. The architectures are different, and the operations (e.g., loading addresses and branching vs. stack frame setup and function calls) are not similar.
------------------------------------------------------------

------------------------------------------------------------
Code1: push rbp mov rbp , rsp sub rsp , 0x10 mov qword ptr [ rbp - 0x8 ] , rdi mov rdi , qword ptr [ rbp - 0x8 ] add rdi , 0x4 call 0x3eb0 add rsp , 0x10 pop rbp ret nop
Code2: push { fp , lr } add fp , sp , 0x4 sub sp , sp , 0x8 str r0 , [ fp , - 0x8 ] ldr r3 , [ fp , - 0x8 ] add r3 , r3 , 0x24 mov r0 , r3 bl 0xfffff230 mov r0 , r0 sub sp , fp , 0x4 pop { fp , pc }
Similarity: 1
Label: -1
Similarity Score: 0.8
Explanation: Both functions exhibit nearly identical structural patterns despite being for different architectures (x86 vs ARM). They save the first argument to the stack, modify it via an immediate addition (4 in code1, 0x24 in code2), call another function with the modified value, then clean up the stack and return. Key differences include the specific immediate values, function call offsets (0x3eb0 vs 0xfffff230), and stack allocation sizes (0x10 vs 0x8), but the core logic and control flow are fundamentally the same.
------------------------------------------------------------

------------------------------------------------------------
Code1: lui gp , 0x48 addiu sp , sp , - 0x28 addiu gp , gp , - 0x1a80 sw ra , 0x24 ( sp ) sw s1 , 0x20 ( sp ) sw s0 , 0x1c ( sp ) beqz a0 , 0x5f4 sw gp , 0x10 ( sp ) lw s1 , 0xa0 ( a0 ) bnez s1 , 0xac move s0 , a0 lw s1 , 0x9c ( s0 ) bnez s1 , 0x128 nop lw v0 , 0x8 ( s0 ) addiu v1 , zero , 0x5 beq v0 , v1 , 0x5ac addiu v1 , zero , 0x4 beq v0 , v1 , 0x588 addiu v1 , zero , 0x1 beq v0 , v1 , 0x2bc nop beqz v0 , 0x21c addiu v1 , zero , 0x2 bne v0 , v1 , 0x1a4 addiu v1 , zero , 0x3 lw v1 , ( s0 ) lw v0 , - 0x7f64 ( gp ) bne v1 , v0 , 0x4f4 lui a3 , 0x46 lw v0 , 0x9c ( s0 ) bnez v0 , 0x648 lw ra , 0x24 ( sp ) lw v0 , 0xa0 ( s0 ) lw s1 , 0x20 ( sp ) lwc1 f2 , 0x1c ( v0 ) lui v0 , 0x46 lwc1 f0 , - 0x20b0 ( v0 ) sub.s f0 , f0 , f2 swc1 f0 , 0x1c ( s0 ) lw s0 , 0x1c ( sp ) jr ra addiu sp , sp , 0x28 lw a0 , 0xa0 ( s1 ) bnez a0 , 0x308 nop lw a0 , 0x9c ( s1 ) bnez a0 , 0x2f8 nop lw v0 , 0x8 ( s1 ) addiu v1 , zero , 0x5 beq v0 , v1 , 0x5ac addiu v1 , zero , 0x4 beq v0 , v1 , 0x588 addiu v1 , zero , 0x1 beq v0 , v1 , 0x408 nop beqz v0 , 0x24c addiu v1 , zero , 0x2 bne v0 , v1 , 0x338 addiu v1 , zero , 0x3 lw v1 , ( s1 ) lw v0 , - 0x7f64 ( gp ) bne v1 , v0 , 0x4f4 lui a3 , 0x46 lw v0 , 0x9c ( s1 ) bnez v0 , 0x648 lui v0 , 0x46 lw v1 , 0xa0 ( s1 ) lwc1 f0 , - 0x20b0 ( v0 ) lwc1 f2 , 0x1c ( v1 ) sub.s f0 , f0 , f2 b 0x2c swc1 f0 , 0x1c ( s1 ) lw a0 , 0xa0 ( s1 ) bnez a0 , 0x318 nop lw a0 , 0x9c ( s1 ) bnez a0 , 0x328 nop lw v0 , 0x8 ( s1 ) addiu v1 , zero , 0x5 beq v0 , v1 , 0x5ac addiu v1 , zero , 0x4 beq v0 , v1 , 0x588 addiu v1 , zero , 0x1 beq v0 , v1 , 0x428 nop beqz v0 , 0x270 addiu v1 , zero , 0x2 bne v0 , v1 , 0x3a0 addiu v1 , zero , 0x3 lw v1 , ( s1 ) lw v0 , - 0x7f64 ( gp ) bne v1 , v0 , 0x4f4 lui a3 , 0x46 lw v0 , 0x9c ( s1 ) bnez v0 , 0x648 lui v0 , 0x46 lw v1 , 0xa0 ( s1 ) lwc1 f0 , - 0x20b0 ( v0 ) lwc1 f2 , 0x1c ( v1 ) sub.s f0 , f0 , f2 b 0x38 swc1 f0 , 0x1c ( s1 ) bne v0 , v1 , 0x5d0 lw v1 , - 0x7f60 ( gp ) lw v0 , ( s0 ) beq v0 , v1 , 0x290 lw v1 , - 0x7f5c ( gp ) beq v0 , v1 , 0x514 lw v1 , - 0x7f58 ( gp ) bne v0 , v1 , 0x658 lui a3 , 0x46 lw v0 , 0xa0 ( s0 ) beqz v0 , 0x524 nop lwc1 f2 , 0x1c ( v0 ) lui v0 , 0x46 lw v1 , 0x9c ( s0 ) beqz v1 , 0x1ec lwc1 f0 , - 0x20b0 ( v0 ) lwc1 f0 , 0x1c ( v1 ) add.s f0 , f0 , f2 lwc1 f2 , - 0x20b0 ( v0 )
Code2: push ebp mov ebp , esp sub esp , 0x58 mov eax , dword ptr [ ebp + 0x8 ] xor ecx , ecx cmp ecx , dword ptr [ ebp + 0x8 ] mov dword ptr [ ebp - 0x2c ] , eax je 0x1c jmp 0x46 lea eax , [ 0x80bd3ae ] mov dword ptr [ esp ] , eax lea eax , [ 0x80bd3b8 ] mov dword ptr [ esp + 0x4 ] , eax mov dword ptr [ esp + 0x8 ] , 0x476 lea eax , [ 0x80bd3bf ] mov dword ptr [ esp + 0xc ] , eax call 0xffffab50 mov eax , dword ptr [ ebp + 0x8 ] cmp dword ptr [ eax + 0xa0 ] , 0x0 je 0x74 mov eax , dword ptr [ ebp + 0x8 ] mov eax , dword ptr [ eax + 0xa0 ] mov dword ptr [ esp ] , eax call 0x0 fstp dword ptr [ ebp - 0xc ] movss xmm0 , dword ptr [ ebp - 0xc ] movss dword ptr [ ebp - 0x30 ] , xmm0 mov eax , dword ptr [ ebp + 0x8 ] cmp dword ptr [ eax + 0x9c ] , 0x0 je 0xa2 mov eax , dword ptr [ ebp + 0x8 ] mov eax , dword ptr [ eax + 0x9c ] mov dword ptr [ esp ] , eax call 0x0 fstp dword ptr [ ebp - 0x10 ] movss xmm0 , dword ptr [ ebp - 0x10 ] movss dword ptr [ ebp - 0x34 ] , xmm0 mov eax , dword ptr [ ebp + 0x8 ] cmp dword ptr [ eax + 0x8 ] , 0x5 je 0xb4 jmp 0xde lea eax , [ 0x80bd3f1 ] mov dword ptr [ esp ] , eax lea eax , [ 0x80bd3b8 ] mov dword ptr [ esp + 0x4 ] , eax mov dword ptr [ esp + 0x8 ] , 0x47d lea eax , [ 0x80bd3bf ] mov dword ptr [ esp + 0xc ] , eax call 0xffffab50 mov eax , dword ptr [ ebp + 0x8 ] cmp dword ptr [ eax + 0x8 ] , 0x4 je 0xf0 jmp 0x11a lea eax , [ 0x80bd40a ] mov dword ptr [ esp ] , eax lea eax , [ 0x80bd3b8 ] mov dword ptr [ esp + 0x4 ] , eax mov dword ptr [ esp + 0x8 ] , 0x47e lea eax , [ 0x80bd3bf ] mov dword ptr [ esp + 0xc ] , eax call 0xffffab50 mov eax , dword ptr [ ebp + 0x8 ] mov eax , dword ptr [ eax + 0x8 ] mov ecx , eax sub ecx , 0x5 mov dword ptr [ ebp - 0x38 ] , eax mov dword ptr [ ebp - 0x3c ] , ecx ja 0x47d mov eax , dword ptr [ ebp - 0x38 ] mov ecx , dword ptr [ eax * 0x4 + 0x80bd360 ] jmp ecx xor eax , eax mov ecx , dword ptr [ ebp + 0x8 ] cmp eax , dword ptr [ ecx + 0xa0 ] jne 0x153 jmp 0x17d lea eax , [ 0x80bd422 ] mov dword ptr [ esp ] , eax lea eax , [ 0x80bd3b8 ] mov dword ptr [ esp + 0x4 ] , eax mov dword ptr [ esp + 0x8 ] , 0x483 lea eax , [ 0x80bd3bf ] mov dword ptr [ esp + 0xc ] , eax call 0xffffab50 xor eax , eax mov ecx , dword ptr [ ebp + 0x8 ] cmp eax , dword ptr [ ecx + 0x9c ] jne 0x193 jmp 0x1bd lea eax , [ 0x80bd438 ] mov dword ptr [ esp ] , eax lea eax , [ 0x80bd3b8 ] mov dword ptr [ esp + 0x4 ] , eax mov dword ptr [ esp + 0x8 ] , 0x484 lea eax , [ 0x80bd3bf ] mov dword ptr [ esp + 0xc ] , eax call 0xffffab50 mov eax , dword ptr [ ebp + 0x8 ] movss xmm0 , dword ptr [ eax + 0x1c ] movss dword ptr [ ebp - 0x4 ] , xmm0 jmp 0x4a7 xor eax , eax mov ecx , dword ptr [ ebp + 0x8 ] cmp eax , dword ptr [ ecx + 0xa0 ] jne 0x1e5 jmp 0x20f lea eax , [ 0x80bd422 ] mov dword ptr [ esp ] , eax lea eax , [ 0x80bd3b8 ] mov dword ptr [ esp + 0x4 ] , eax mov dword ptr [ esp + 0x8 ] , 0x488 lea eax , [ 0x80bd3bf ] mov dword ptr [ esp + 0xc ] , eax call 0xffffab50 xor eax , eax mov ecx , dword ptr [ ebp + 0x8 ] cmp eax , dword ptr [ ecx + 0x9c ] jne 0x225 jmp 0x24f lea eax , [ 0x80bd438 ] mov dword ptr [ esp ] , eax lea eax , [ 0x80bd3b8 ] mov dword ptr [ esp + 0x4 ] , eax mov dword ptr [ esp + 0x8 ] , 0x489 lea eax , [ 0x80bd3bf ] mov dword ptr [ esp + 0xc ] , eax call 0xffffab50 mov eax , dword ptr [ ebp + 0x8 ] movss xmm0 , dword ptr [ eax + 0x1c ] movss dword ptr [ ebp - 0x4 ] , xmm0 jmp 0x4a7 mov eax , dword ptr [ ebp + 0x8 ] lea ecx , [ 0x804cac0 ] cmp dword ptr [ eax ] , ecx jne 0x277 jmp 0x2a1 lea eax , [ 0x80bd44d ] mov dword ptr [ esp ] , eax lea eax , [ 0x80bd3b8 ] mov dword ptr [ esp + 0x4 ] , eax mov dword ptr [ esp + 0x8 ] , 0x48e lea eax , [ 0x80bd3bf ] mov dword ptr [ esp + 0xc ] , eax call 0xffffab50 xor eax , eax mov ecx , dword ptr [ ebp + 0x8 ] cmp eax , dword ptr [ ecx + 0x9c ] jne 0x2b7 jmp 0x2e1 lea eax , [ 0x80bd438 ] mov dword ptr [ esp ] , eax lea eax , [ 0x80bd3b8 ] mov dword ptr [ esp + 0x4 ] , eax mov dword ptr [ esp + 0x8 ] , 0x48f lea eax , [ 0x80bd3bf ] mov dword ptr [ esp + 0xc ] , eax call 0xffffab50 movsd xmm0 , qword ptr [ 0x80bd358 ] mov eax , dword ptr [ ebp + 0x8 ] mov eax , dword ptr [ eax + 0xa0 ] movss xmm1 , dword ptr [ eax + 0x1c ] cvtss2sd xmm1 , xmm1 subsd xmm0 , xmm1 cvtsd2ss xmm0 , xmm0 mov eax , dword ptr [ ebp + 0x8 ] movss dword ptr [ eax + 0x1c ] , xmm0 mov eax , dword ptr [ ebp + 0x8 ] movss xmm0 , dword ptr [ eax + 0x1c ] movss dword ptr [ ebp - 0x4 ] , xmm0 jmp 0x4a7 mov eax , dword ptr [ ebp + 0x8 ] lea ecx , [ 0x804b970 ] cmp dword ptr [ eax ] , ecx jne 0x378 mov eax , dword ptr [ ebp + 0x8 ] mov eax , dword ptr [ eax + 0xa0 ] mov dword ptr [ esp ] , eax call 0x4c0 fstp dword ptr [ ebp - 0x20 ] movss xmm0 , dword ptr [ ebp - 0x20 ] mov eax , dword ptr [ ebp + 0x8 ] mov eax , dword ptr [ eax + 0x9c ] mov dword ptr [ esp ] , eax movss dword ptr [ ebp - 0x40 ] , xmm0 call 0x4c0 fstp dword ptr [ ebp - 0x1c ] movss xmm0 , dword ptr [ ebp - 0x1c ] movss xmm1 , dword ptr [ ebp - 0x40 ] mulss xmm1 , xmm0 movss dword ptr [ ebp - 0x8 ] , xmm1 jmp 0x42a mov eax , dword ptr [ ebp + 0x8 ] lea ecx , [ 0x804bc50 ] cmp dword ptr [ eax ] , ecx jne 0x39b movss xmm0 , dword ptr [ 0x80bd354 ] movss dword ptr [ ebp - 0x8 ] , xmm0 jmp 0x425 mov eax , dword ptr [ ebp + 0x8 ] lea ecx , [ 0x804cfb0 ] cmp dword ptr [ eax ] , ecx jne 0x3f6 mov eax , dword ptr [ ebp + 0x8 ] mov eax , dword ptr [ eax + 0xa0 ] mov dword ptr [ esp ] , eax call 0x4c0 fstp dword ptr [ ebp - 0x18 ] movss xmm0 , dword ptr [ ebp - 0x18 ] mov eax , dword ptr [ ebp + 0x8 ] mov eax , dword ptr [ eax + 0x9c ] mov dword ptr [ esp ] , eax movss dword ptr [ ebp - 0x44 ] , xmm0 call 0x4c0 fstp dword ptr [ ebp - 0x14 ] movss xmm0 , dword ptr [ ebp - 0x14 ] movss xmm1 , dword ptr [ ebp - 0x44 ] addss xmm1 , xmm0 movss dword ptr [ ebp - 0x8 ] , xmm1 jmp 0x420 lea eax , [ 0x80bcd96 ] mov dword ptr [ esp ] , eax lea eax , [ 0x80bd3b8 ] mov dword ptr [ esp + 0x4 ] , eax mov dword ptr [ esp + 0x8 ] , 0x4a6 lea eax , [ 0x80bd3bf ] mov dword ptr [ esp + 0xc ] , eax call 0xffffab50 jmp 0x425 jmp 0x42a movss xmm0 , dword ptr [ ebp - 0x8 ] movss dword ptr [ esp ] , xmm0 call 0x510 fstp dword ptr [ ebp - 0x24 ] movss xmm0 , dword ptr [ ebp - 0x24 ] mov eax , dword ptr [ ebp + 0x8 ] movss dword ptr [ eax + 0x1c ] , xmm0 mov eax , dword ptr [ ebp + 0x8 ] movss xmm0 , dword ptr [ eax + 0x1c ] movss dword ptr [ ebp - 0x4 ] , xmm0 jmp 0x4a7 movss xmm0 , dword ptr [ 0x80bd354 ] mov eax , dword ptr [ ebp + 0x8 ] movss dword ptr [ eax + 0x1c ] , xmm0 mov eax , dword ptr [ ebp + 0x8 ] movss xmm0 , dword ptr [ eax + 0x1c ] movss dword ptr [ ebp - 0x4 ] , xmm0 jmp 0x4a7 lea eax , [ 0x80bcd96 ] mov dword ptr [ esp ] , eax lea eax , [ 0x80bd3b8 ] mov dword ptr [ esp + 0x4 ] , eax mov dword ptr [ esp + 0x8 ] , 0x4b2 lea eax , [ 0x80bd3bf ] mov dword ptr [ esp + 0xc ] , eax call 0xffffab50 movss xmm0 , dword ptr [ ebp - 0x4 ] movss dword ptr [ ebp - 0x28 ] , xmm0 fld dword ptr [ ebp - 0x28 ] add esp , 0x58 pop ebp ret nop dword ptr [ eax ]
Similarity: -1
Label: 1
Similarity Score: 0.2
Explanation: The two assembly codes show significant architectural and structural differences. Code 1 uses MIPS instructions (lui, addiu, sw, lwc1, etc.) with registers like gp, sp, a0, s0, and s1, while Code 2 uses x86 instructions (push, mov, lea, cmp, etc.) with registers like ebp, esp, eax, and ecx. The control flow differs substantially: Code 1 relies heavily on branch instructions (beqz, bnez, beq) without explicit calls, whereas Code 2 contains multiple function calls (call 0xffffab50) and complex jump logic. Memory access patterns
------------------------------------------------------------

------------------------------------------------------------
Code1: push ebp mov ebp , esp push ebx push edi push esi sub esp , 0x2c mov eax , dword ptr [ ebp + 0x10 ] mov ecx , dword ptr [ ebp + 0xc ] mov edx , dword ptr [ ebp + 0x8 ] mov esi , dword ptr [ ebp + 0x8 ] mov edi , dword ptr [ ebp + 0xc ] mov ebx , dword ptr [ ebp + 0x10 ] mov dword ptr [ esp ] , esi mov dword ptr [ esp + 0x4 ] , edi mov dword ptr [ esp + 0x8 ] , ebx mov dword ptr [ ebp - 0x18 ] , eax mov dword ptr [ ebp - 0x1c ] , ecx mov dword ptr [ ebp - 0x20 ] , edx call 0x6b450 xor ecx , ecx mov dword ptr [ ebp - 0x14 ] , eax cmp ecx , dword ptr [ ebp - 0x14 ] jne 0x4e mov dword ptr [ ebp - 0x10 ] , 0x0 jmp 0x71 mov eax , dword ptr [ ebp + 0x8 ] mov ecx , dword ptr [ ebp + 0xc ] mov edx , dword ptr [ ebp + 0x10 ] mov esi , dword ptr [ ebp - 0x14 ] mov dword ptr [ esp ] , eax mov dword ptr [ esp + 0x4 ] , ecx mov dword ptr [ esp + 0x8 ] , edx mov dword ptr [ esp + 0xc ] , esi call 0x560 mov dword ptr [ ebp - 0x10 ] , eax mov eax , dword ptr [ ebp - 0x10 ] add esp , 0x2c pop esi pop edi pop ebx pop ebp ret nop dword ptr [ eax ]
Code2: push rbp mov rbp , rsp sub rsp , 0x40 mov dword ptr [ rbp - 0xc ] , edi mov qword ptr [ rbp - 0x18 ] , rsi mov qword ptr [ rbp - 0x20 ] , rdx mov edi , dword ptr [ rbp - 0xc ] mov rsi , qword ptr [ rbp - 0x18 ] mov rdx , qword ptr [ rbp - 0x20 ] call 0xd4dc0 mov dword ptr [ rbp - 0x24 ] , eax mov eax , dword ptr [ rbp - 0x24 ] mov dword ptr [ rbp - 0x4 ] , eax mov dword ptr [ rbp - 0x28 ] , 0xd8a71d73 mov eax , dword ptr [ rbp - 0x28 ] mov ecx , eax sub ecx , 0xae1c64b5 mov dword ptr [ rbp - 0x2c ] , eax mov dword ptr [ rbp - 0x30 ] , ecx je 0xc5 jmp 0x4f mov eax , dword ptr [ rbp - 0x2c ] sub eax , 0xb8580a76 mov dword ptr [ rbp - 0x34 ] , eax je 0xb2 jmp 0x65 mov eax , dword ptr [ rbp - 0x2c ] sub eax , 0xd8a71d73 mov dword ptr [ rbp - 0x38 ] , eax je 0x96 jmp 0x7b mov eax , dword ptr [ rbp - 0x2c ] sub eax , 0x10d32b69 mov dword ptr [ rbp - 0x3c ] , eax je 0xe7 jmp 0x91 jmp 0xf0 xor eax , eax mov ecx , dword ptr [ rbp - 0x4 ] cmp eax , ecx mov eax , 0xb8580a76 mov ecx , 0xae1c64b5 cmove ecx , eax mov dword ptr [ rbp - 0x28 ] , ecx jmp 0xf0 mov dword ptr [ rbp - 0x8 ] , 0x0 mov dword ptr [ rbp - 0x28 ] , 0x10d32b69 jmp 0xf0 mov edi , dword ptr [ rbp - 0xc ] mov rsi , qword ptr [ rbp - 0x18 ] mov rdx , qword ptr [ rbp - 0x20 ] mov ecx , dword ptr [ rbp - 0x24 ] call 0xa00 mov dword ptr [ rbp - 0x8 ] , eax mov dword ptr [ rbp - 0x28 ] , 0x10d32b69 jmp 0xf0 mov eax , dword ptr [ rbp - 0x8 ] add rsp , 0x40 pop rbp ret jmp 0x33 nop word ptr cs : [ rax + rax ] nop
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two code snippets are for different architectures (32-bit vs 64-bit) and exhibit significantly different control flow, stack management, and instruction sequences. Code1 has a simpler structure with one conditional jump and two function calls, while Code2 features complex branching with multiple conditional jumps and a jump table pattern. The register usage, stack operations, and overall logic are dissimilar, indicating they are not the same function or algorithm.
------------------------------------------------------------

------------------------------------------------------------
Code1: push ebp mov ebp , esp push esi sub esp , 0x14 mov eax , dword ptr [ ebp + 0xc ] mov ecx , dword ptr [ ebp + 0x8 ] mov dword ptr [ ebp - 0xc ] , eax mov dword ptr [ ebp - 0x10 ] , ecx mov eax , esp add eax , - 0x10 mov esp , eax mov ecx , dword ptr [ ebp - 0x10 ] mov dword ptr [ ebp - 0x8 ] , ecx mov edx , dword ptr [ ebp - 0xc ] mov dword ptr [ eax ] , edx mov eax , dword ptr [ eax ] mov esi , dword ptr [ ebp - 0x8 ] mov dword ptr [ ebp - 0x14 ] , eax mov dword ptr [ ebp - 0x18 ] , esi mov eax , dword ptr [ ebp - 0x18 ] sub esp , 0x10 mov ecx , dword ptr [ ebp - 0x14 ] mov dword ptr [ esp ] , ecx mov dword ptr [ esp + 0x4 ] , eax lea eax , [ 0x80494e0 ] mov dword ptr [ esp + 0x8 ] , eax call 0x810 lea esp , [ ebp - 0x4 ] pop esi pop ebp ret nop word ptr cs : [ eax + eax ] nop
Code2: move v1 , a1 lw v0 , 0x50 ( a0 ) lw a1 , 0x50 ( a1 ) slt a2 , v0 , a1 bnez a2 , 0x54 nop slt v0 , a1 , v0 bnez v0 , 0x4c addiu v0 , zero , 0x1 lw v0 , 0x54 ( a0 ) lw a1 , 0x54 ( v1 ) subu v0 , v0 , a1 bnez v0 , 0x4c lui gp , 0x45 lw a1 , ( a0 ) addiu gp , gp , - 0x5e20 lw t9 , - 0x7c38 ( gp ) jr t9 lw a0 , ( v1 ) jr ra nop jr ra addiu v0 , zero , - 0x1
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly code snippets show fundamental differences in architecture, structure, and functionality. Code1 uses x86 instructions (ebp/esp registers, call) with stack frame management and a direct function call. Code2 uses MIPS instructions (v0/a0 registers, lw/jr) with comparison operations and indirect jumps. There are no overlapping algorithms, register usage patterns, or control flow structures. The architectural mismatch (x86 vs MIPS) and absence of equivalent operations confirm they implement unrelated logic.
------------------------------------------------------------

------------------------------------------------------------
Code1: push edi push esi push ebx sub esp , 0x20 call 0xffff2597 add ebx , 0x3da2c mov eax , dword ptr gs : [ 0x14 ] mov dword ptr [ esp + 0x1c ] , eax xor eax , eax mov esi , dword ptr [ ebx + 0x1004 ] mov edi , dword ptr [ ebx + 0x1008 ] call 0xfffffb7b cmp eax , 0x7fffffff setne dl movzx edx , dl add eax , edx mov dword ptr [ esp + 0xc ] , edi mov dword ptr [ esp + 0x10 ] , esi mov dword ptr [ esp + 0x14 ] , 0x0 mov dword ptr [ esp + 0x18 ] , 0xffffffff sub esp , 0xc lea edx , [ esp + 0x18 ] push edx lea ecx , [ ebx - 0x3dc45 ] mov edx , eax mov eax , 0x0 call 0xfffffcc9 mov esi , dword ptr [ esp + 0x28 ] add esp , 0x10 test esi , esi jns 0x8c mov eax , dword ptr [ esp + 0x1c ] xor eax , dword ptr gs : [ 0x14 ] jne 0xcc add esp , 0x20 pop ebx pop esi pop edi ret sub esp , 0x4 push 0x5 lea eax , [ ebx - 0x16708 ] push eax push 0x0 call 0xffff1e77 push esi push eax push 0x0 push 0x0 call 0xffff2087 add esp , 0x20 lea eax , [ ebx - 0x16670 ] push eax push 0x18c lea eax , [ ebx - 0x1671c ] push eax lea eax , [ ebx - 0x16713 ] push eax call 0xffff24f7 call 0x23437
Code2: push rbp mov rbp , rsp sub rsp , 0x10 mov dword ptr [ rbp - 0x4 ] , 0x1 mov rdi , qword ptr [ 0x6a2908 ] mov rsi , qword ptr [ 0x6a2910 ] call 0xa0 mov dword ptr [ rbp - 0x8 ] , eax cmp dword ptr [ rbp - 0x8 ] , 0x0 jl 0x60 mov dword ptr [ rbp - 0x4 ] , 0x0 movabs rdi , 0x480886 call 0x470 xor ecx , ecx mov edx , dword ptr [ rbp - 0x8 ] mov edi , ecx mov esi , ecx mov dword ptr [ rbp - 0xc ] , edx mov rdx , rax mov ecx , dword ptr [ rbp - 0xc ] mov al , 0x0 call 0xfffffffffffe6c80 cmp dword ptr [ rbp - 0x4 ] , 0x0 je 0x6f jmp 0x97 movabs rdi , 0x48091e movabs rsi , 0x480927 mov edx , 0x18c movabs rcx , 0x480930 call 0xfffffffffffe68f0 add rsp , 0x10 pop rbp ret nop dword ptr [ rax ]
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly codes show fundamental differences in architecture, structure, and operations:
1. **Architecture**: Code1 uses 32-bit registers (eax/ebx/esp) and memory addressing (dword ptr), while Code2 uses 64-bit registers (rbp/rsp/rdi) and quad-word pointers (qword ptr).
2. **Stack Management**: Code1 manually adjusts ESP with pushes/pops and `sub esp, 0x20`, while Code2 uses RBP-based frame pointers and `sub rsp, 0x10`.
3. **Key Operations**: 
   - Code1 contains position-independent code patterns (`add ebx, 0x3da2c`), GS segment security checks, and complex multi-register setups.
   - Code2 uses modern x64 calling conventions (RDI/RSI for arguments) and `movabs` for 64-bit immediates.
4. **Control Flow**: Code1 has conditional jumps (`jns/jne`) for error handling, while Code2 uses simpler flag checks (`jl/je`).
5. **Function Calls**: Code1 makes direct calls to fixed offsets (e.g., `call 0xfffffb7b`), while Code2 uses near-absolute addressing (`call 0xfffffffffffe6c80`).

The absence of overlapping architectural patterns, register usage, or algorithmic logic indicates no meaningful similarity.
------------------------------------------------------------

------------------------------------------------------------
Code1: push r13 push r12 push rbp push rbx mov rbp , rsi sub rsp , 0x8 test rdi , rdi je 0x80 mov r13 , rdx mov rbx , rdi call 0xffffffffffffff10 test rax , rax mov r12 , rax je 0x6e mov rsi , r13 mov rdi , rbp call 0xfffffffffffd1ec0 test rax , rax je 0x60 mov rsi , r13 mov rdi , rbx call 0xfffffffffffffdd0 test al , al je 0x60 cmp r12 , 0x1 jne 0x95 add rsp , 0x8 mov rax , r13 pop rbx pop rbp pop r12 pop r13 ret nop dword ptr [ rax + rax ] cmp r12 , 0x1 je 0x6e mov rdi , r12 call 0xfffffffffffffce0 add rsp , 0x8 xor eax , eax pop rbx pop rbp pop r12 pop r13 ret nop dword ptr [ rax + rax ] add rsp , 0x8 mov rdi , rbp mov rsi , rdx pop rbx pop rbp pop r12 pop r13 jmp 0xfffffffffffd2130 mov rdi , r12 call 0xfffffffffffffce0 test al , al jne 0x4a jmp 0x6e nop dword ptr [ rax ] nop word ptr cs : [ rax + rax ]
Code2: push ebp mov ebp , esp push ebx push edi push esi sub esp , 0x5c mov eax , dword ptr [ ebp + 0x10 ] mov ecx , dword ptr [ ebp + 0xc ] mov edx , dword ptr [ ebp + 0x8 ] mov dword ptr [ ebp - 0x1c ] , eax mov dword ptr [ ebp - 0x20 ] , ecx mov dword ptr [ ebp - 0x24 ] , edx mov eax , esp add eax , - 0x10 mov esp , eax mov ecx , esp add ecx , - 0x10 mov esp , ecx mov edx , esp add edx , - 0x10 mov esp , edx mov esi , dword ptr [ ebp - 0x24 ] mov dword ptr [ ebp - 0x14 ] , esi mov edi , dword ptr [ ebp - 0x20 ] mov dword ptr [ ebp - 0x18 ] , edi mov ebx , dword ptr [ ebp - 0x1c ] mov dword ptr [ eax ] , ebx mov dword ptr [ ebp - 0x28 ] , eax mov dword ptr [ ebp - 0x2c ] , ecx mov dword ptr [ ebp - 0x30 ] , edx cmp dword ptr [ ebp - 0x14 ] , 0x0 jne 0x88 mov eax , dword ptr [ ebp - 0x18 ] mov ecx , dword ptr [ ebp - 0x28 ] mov edx , dword ptr [ ecx ] mov dword ptr [ ebp - 0x34 ] , eax mov dword ptr [ ebp - 0x38 ] , edx sub esp , 0x10 mov eax , dword ptr [ ebp - 0x34 ] mov dword ptr [ esp ] , eax mov ecx , dword ptr [ ebp - 0x38 ] mov dword ptr [ esp + 0x4 ] , ecx call 0xfff3be80 add esp , 0x10 mov dword ptr [ ebp - 0x3c ] , eax mov eax , dword ptr [ ebp - 0x3c ] mov dword ptr [ ebp - 0x10 ] , eax jmp 0x175 mov eax , dword ptr [ ebp - 0x14 ] mov dword ptr [ ebp - 0x40 ] , eax sub esp , 0x10 mov eax , dword ptr [ ebp - 0x40 ] mov dword ptr [ esp ] , eax call 0x190 add esp , 0x10 mov ecx , dword ptr [ ebp - 0x2c ] mov dword ptr [ ecx ] , eax mov eax , dword ptr [ ebp - 0x2c ] cmp dword ptr [ eax ] , 0x0 je 0x169 mov eax , dword ptr [ ebp - 0x18 ] mov dword ptr [ ebp - 0x44 ] , eax mov eax , dword ptr [ ebp - 0x28 ] mov ecx , dword ptr [ eax ] mov dword ptr [ ebp - 0x48 ] , ecx sub esp , 0x10 mov eax , dword ptr [ ebp - 0x44 ] mov dword ptr [ esp ] , eax mov ecx , dword ptr [ ebp - 0x48 ] mov dword ptr [ esp + 0x4 ] , ecx call 0xfff3b9c0 add esp , 0x10 xor ecx , ecx mov dl , cl cmp eax , 0x0 mov byte ptr [ ebp - 0x49 ] , dl je 0x10f mov eax , dword ptr [ ebp - 0x14 ] mov dword ptr [ ebp - 0x50 ] , eax mov eax , dword ptr [ ebp - 0x28 ] mov ecx , dword ptr [ eax ] mov dword ptr [ ebp - 0x54 ] , ecx sub esp , 0x10 mov eax , dword ptr [ ebp - 0x50 ] mov dword ptr [ esp ] , eax mov ecx , dword ptr [ ebp - 0x54 ] mov dword ptr [ esp + 0x4 ] , ecx call 0x2f0 add esp , 0x10 mov byte ptr [ ebp - 0x49 ] , al mov al , byte ptr [ ebp - 0x49 ] and al , 0x1 mov ecx , dword ptr [ ebp - 0x30 ] mov byte ptr [ ecx ] , al mov edx , dword ptr [ ebp - 0x2c ] mov esi , dword ptr [ edx ] sub esp , 0x10 mov dword ptr [ esp ] , esi call 0x610 add esp , 0x10 test al , 0x1 jne 0x139 jmp 0x164 mov eax , dword ptr [ ebp - 0x30 ] mov cl , byte ptr [ eax ] mov byte ptr [ ebp - 0x55 ] , cl mov al , byte ptr [ ebp - 0x55 ] test al , 0x1 jne 0x151 jmp 0x164 mov eax , dword ptr [ ebp - 0x28 ] mov ecx , dword ptr [ eax ] mov dword ptr [ ebp - 0x5c ] , ecx mov eax , dword ptr [ ebp - 0x5c ] mov dword ptr [ ebp - 0x10 ] , eax jmp 0x175 jmp 0x169 mov dword ptr [ ebp - 0x10 ] , 0x0 jmp 0x175 mov eax , dword ptr [ ebp - 0x10 ] mov dword ptr [ ebp - 0x60 ] , eax mov eax , dword ptr [ ebp - 0x60 ] lea esp , [ ebp - 0xc ] pop esi pop edi pop ebx pop ebp ret nop word ptr cs : [ eax + eax ]
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two code snippets are for different architectures (x86-64 vs x86) and exhibit significant differences in register usage, stack management, and function call patterns. While both have function prologue and epilogue, the control flow and operations are substantially different. The lack of matching instruction patterns and architectural differences indicate they are not similar.
------------------------------------------------------------

------------------------------------------------------------
Code1: push rax call 0xfffffffffffffff0 pop rcx ret nop dword ptr [ rax + rax ]
Code2: sub esp , 0xc mov eax , dword ptr [ esp + 0x14 ] mov ecx , dword ptr [ esp + 0x10 ] mov dword ptr [ esp ] , ecx mov dword ptr [ esp + 0x4 ] , eax call 0xffffffe0 add esp , 0xc ret nop dword ptr [ eax + eax ]
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two code snippets are entirely different in structure and purpose. Code1 is a short sequence using 64-bit registers (rax, rcx) with push, call, pop, and ret. Code2 is a longer sequence using 32-bit registers (eax, ecx, esp) that adjusts the stack, moves data, and calls a function. The only similarity is the trailing 'ret' and a multi-byte nop instruction, which is common compiler padding and not functionally significant. The core operations and register usage show no meaningful similarity.
------------------------------------------------------------

------------------------------------------------------------
Code1: lui gp , 0x53 addiu sp , sp , - 0x28 addiu gp , gp , 0x2030 sw ra , 0x24 ( sp ) sw s2 , 0x20 ( sp ) sw s1 , 0x1c ( sp ) sw s0 , 0x18 ( sp ) beqz a0 , 0xc4 sw gp , 0x10 ( sp ) lw v1 , 0x20 ( a0 ) beqz v1 , 0xc4 move a3 , a0 lw v1 , 0x24 ( a0 ) beqz v1 , 0xc4 nop jal 0x4c6938 move s1 , a2 lw gp , 0x10 ( sp ) bnez v0 , 0xc4 move s2 , v0 lw v1 , 0x1c ( a3 ) lw v0 , 0x6c ( v1 ) lw a2 , 0x74 ( v1 ) lw a0 , 0x2c ( v1 ) addu v0 , v0 , a2 sltu s0 , v0 , a0 movn a0 , v0 , s0 beqz a1 , 0x7c move s0 , a0 bnez a0 , 0xa4 subu v0 , v0 , a0 beqz s1 , 0x8c lw ra , 0x24 ( sp ) sw s0 , ( s1 ) lw ra , 0x24 ( sp ) move v0 , s2 lw s2 , 0x20 ( sp ) lw s1 , 0x1c ( sp ) lw s0 , 0x18 ( sp ) jr ra addiu sp , sp , 0x28 lw v1 , 0x38 ( v1 ) lw t9 , - 0x77fc ( gp ) move a2 , a0 move a0 , a1 jalr t9 addu a1 , v1 , v0 b 0x7c nop b 0x88 addiu s2 , zero , - 0x2
Code2: push rbp mov rbp , rsp sub rsp , 0x40 mov qword ptr [ rbp - 0x10 ] , rdi mov qword ptr [ rbp - 0x18 ] , rsi mov qword ptr [ rbp - 0x20 ] , rdx mov rdi , qword ptr [ rbp - 0x10 ] call 0xfffffffffffff8a0 test eax , eax setne cl movzx eax , cl mov edx , eax mov rdx , qword ptr [ rdx * 0x8 + 0x853998 ] jmp rdx mov dword ptr [ rbp - 0x4 ] , 0xfffffffe mov rax , qword ptr [ rip + 0x307769 ] jmp rax mov rax , qword ptr [ rbp - 0x10 ] mov rax , qword ptr [ rax + 0x38 ] mov qword ptr [ rbp - 0x28 ] , rax mov rax , qword ptr [ rbp - 0x28 ] mov ecx , dword ptr [ rax + 0xac ] mov edx , dword ptr [ rax + 0xb4 ] add ecx , edx mov dword ptr [ rbp - 0x2c ] , ecx mov ecx , dword ptr [ rbp - 0x2c ] mov rax , qword ptr [ rbp - 0x28 ] mov edx , dword ptr [ rax + 0x50 ] sub ecx , edx seta sil movzx edx , sil mov eax , edx mov rax , qword ptr [ rax * 0x8 + 0x8539a8 ] mov dword ptr [ rbp - 0x30 ] , ecx jmp rax mov rax , qword ptr [ rbp - 0x28 ] mov ecx , dword ptr [ rax + 0x50 ] mov dword ptr [ rbp - 0x2c ] , ecx mov rax , qword ptr [ rip + 0x3076e2 ] jmp rax mov rax , qword ptr [ rbp - 0x18 ] test rax , rax setne cl movzx edx , cl mov eax , edx mov rax , qword ptr [ rax * 0x8 + 0x8539b8 ] jmp rax mov eax , dword ptr [ rbp - 0x2c ] test eax , eax setne cl movzx eax , cl mov edx , eax mov rdx , qword ptr [ rdx * 0x8 + 0x8539c8 ] jmp rdx mov rdi , qword ptr [ rbp - 0x18 ] mov rax , qword ptr [ rbp - 0x28 ] mov rcx , qword ptr [ rax + 0x60 ] mov edx , dword ptr [ rax + 0xac ] mov esi , edx add rcx , rsi mov edx , dword ptr [ rax + 0xb4 ] mov eax , edx add rcx , rax mov edx , dword ptr [ rbp - 0x2c ] mov eax , edx sub rcx , rax mov rsi , rcx mov rdx , rax call 0xffffffffffeb77d0 mov rcx , qword ptr [ rip + 0x30768c ] mov qword ptr [ rbp - 0x38 ] , rax jmp rcx mov rax , qword ptr [ rbp - 0x20 ] test rax , rax setne cl movzx edx , cl mov eax , edx mov rax , qword ptr [ rax * 0x8 + 0x8539d8 ] jmp rax mov eax , dword ptr [ rbp - 0x2c ] mov rcx , qword ptr [ rbp - 0x20 ] mov dword ptr [ rcx ] , eax mov rcx , qword ptr [ rip + 0x30766d ] jmp rcx mov dword ptr [ rbp - 0x4 ] , 0x0 mov rax , qword ptr [ rip + 0x307665 ] jmp rax mov eax , dword ptr [ rbp - 0x4 ] add rsp , 0x40 pop rbp ret nop
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two code snippets are from different processor architectures (MIPS vs x86_64) and exhibit fundamental differences in instruction sets, register usage, and calling conventions. The MIPS code uses a fixed stack frame with explicit register saves/restores and direct branch instructions, while the x86_64 code uses a jump table for control flow and memory-based operations with RIP-relative addressing. There are no matching sequences of operations or structural similarities beyond basic arithmetic and memory access patterns common to all assembly code.
------------------------------------------------------------

------------------------------------------------------------
Code1: push ebp mov ebp , esp sub esp , 0x28 mov eax , dword ptr [ ebp + 0x10 ] mov ecx , dword ptr [ ebp + 0xc ] mov edx , dword ptr [ ebp + 0x8 ] mov dword ptr [ ebp - 0x4 ] , eax mov dword ptr [ ebp - 0x8 ] , ecx mov dword ptr [ ebp - 0xc ] , edx xor eax , eax mov ecx , dword ptr [ ebp + 0x8 ] mov dword ptr [ esp ] , ecx mov dword ptr [ esp + 0x4 ] , 0x0 mov dword ptr [ ebp - 0x10 ] , eax call 0x3540 mov byte ptr [ ebp - 0x11 ] , al mov al , byte ptr [ ebp - 0x11 ] and al , 0x1 movzx eax , al add esp , 0x28 pop ebp ret
Code2: addiu sp , sp , - 0x20 sw ra , 0x1c ( sp ) move a1 , zero jal 0x414fc4 nop lw ra , 0x1c ( sp ) jr ra addiu sp , sp , 0x20
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The codes are for different architectures (x86 vs MIPS) and serve different purposes. Code1 sets up a stack frame, loads multiple arguments, calls a function (0x3540), processes the return value with bitwise operations, and cleans the stack. Code2 simply saves a return address, sets a register to zero, calls a function (0x414fc4), and restores the stack. There's no overlap in register usage, stack management, or logical operations. The architectural differences and functional disparities make them fundamentally dissimilar.
------------------------------------------------------------

------------------------------------------------------------
Code1: push ebp mov ebp , esp push ebx push edi push esi sub esp , 0x1c mov eax , dword ptr [ ebp + 0xc ] mov ecx , dword ptr [ ebp + 0x8 ] cmp dword ptr [ 0x806db34 ] , 0x0 mov dword ptr [ ebp - 0x10 ] , eax mov dword ptr [ ebp - 0x14 ] , ecx jne 0xa6 mov al , byte ptr [ 0x8069e37 ] xor al , 0xab mov byte ptr [ 0x8069e42 ] , al mov al , byte ptr [ 0x8069e38 ] xor al , 0xdf mov byte ptr [ 0x8069e43 ] , al mov al , byte ptr [ 0x8069e39 ] xor al , 0x80 mov byte ptr [ 0x8069e44 ] , al mov al , byte ptr [ 0x8069e3a ] xor al , 0x3a mov byte ptr [ 0x8069e45 ] , al mov al , byte ptr [ 0x8069e3b ] xor al , 0x6d mov byte ptr [ 0x8069e46 ] , al mov al , byte ptr [ 0x8069e3c ] xor al , 0x6f mov byte ptr [ 0x8069e47 ] , al mov al , byte ptr [ 0x8069e3d ] xor al , 0x34 mov byte ptr [ 0x8069e48 ] , al mov al , byte ptr [ 0x8069e3e ] xor al , 0x14 mov byte ptr [ 0x8069e49 ] , al mov al , byte ptr [ 0x8069e3f ] xor al , 0x3f mov byte ptr [ 0x8069e4a ] , al mov al , byte ptr [ 0x8069e40 ] xor al , 0x5d mov byte ptr [ 0x8069e4b ] , al mov al , byte ptr [ 0x8069e41 ] xor al , 0x88 mov byte ptr [ 0x8069e4c ] , al xor eax , eax mov dword ptr [ 0x806db34 ] , 0x1 mov ecx , esp add ecx , - 0x10 mov esp , ecx mov edx , esp add edx , - 0x10 mov esp , edx mov esi , esp add esi , - 0x10 mov esp , esi mov edi , dword ptr [ ebp - 0x14 ] mov dword ptr [ ecx ] , edi mov ebx , dword ptr [ ebp - 0x10 ] mov dword ptr [ edx ] , ebx mov ecx , dword ptr [ ecx ] mov edx , dword ptr [ edx ] sub esp , 0x10 mov dword ptr [ esp ] , 0x0 mov dword ptr [ esp + 0x4 ] , ecx mov dword ptr [ esp + 0x8 ] , edx mov dword ptr [ ebp - 0x18 ] , eax mov dword ptr [ ebp - 0x1c ] , esi call 0xb970 add esp , 0x10 mov ecx , dword ptr [ ebp - 0x1c ] mov dword ptr [ ecx ] , eax cmp dword ptr [ ecx ] , - 0x1 jne 0x138 call 0xffff3ca0 lea ecx , [ 0x8069e42 ] mov eax , dword ptr [ eax ] sub esp , 0x10 mov dword ptr [ esp ] , ecx mov dword ptr [ ebp - 0x20 ] , eax call 0xffff3c20 mov dword ptr [ esp ] , 0x1 mov ecx , dword ptr [ ebp - 0x20 ] mov dword ptr [ esp + 0x4 ] , ecx mov dword ptr [ esp + 0x8 ] , eax call 0xffff3bd0 add esp , 0x10 mov eax , dword ptr [ ebp - 0x1c ] mov eax , dword ptr [ eax ] lea esp , [ ebp - 0xc ] pop esi pop edi pop ebx pop ebp ret nop word ptr cs : [ eax + eax ] nop
Code2: lui gp , 0x42 addiu sp , sp , - 0x20 addiu gp , gp , 0x40d0 move a2 , a1 move a1 , a0 sw ra , 0x1c ( sp ) sw gp , 0x10 ( sp ) lw t9 , - 0x7fcc ( gp ) bal 0x38fc move a0 , zero addiu v1 , zero , - 0x1 beq v0 , v1 , 0x3c lw ra , 0x1c ( sp ) jr ra addiu sp , sp , 0x20 jal 0x403008 nop
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly codes show fundamental differences in architecture, structure, and operations. Code1 uses x86-specific registers (ebp, esp, eax, etc.) and includes a sequence of XOR operations on fixed memory addresses (0x8069e37-0x8069e41), which is absent in Code2. Code2 uses MIPS-specific conventions (gp, sp, ra, bal) and focuses on argument handling and function calls without any low-level bit manipulation. The stack management, calling conventions, and instruction sets are entirely incompatible between architectures. No overlapping logic or patterns suggest functional similarity.
------------------------------------------------------------

------------------------------------------------------------
Code1: addiu sp , sp , - 0x38 sw ra , 0x34 ( sp ) sw s5 , 0x30 ( sp ) sw s4 , 0x2c ( sp ) sw s3 , 0x28 ( sp ) sw s2 , 0x24 ( sp ) sw s1 , 0x20 ( sp ) sw s0 , 0x1c ( sp ) lui gp , 0x4d addiu gp , gp , - 0x5f20 sw gp , 0x10 ( sp ) move s0 , a0 move s5 , a1 move s4 , a2 move s2 , a3 lw s1 , 0x48 ( sp ) lw s3 , 0x4c ( sp ) addiu a1 , zero , 0xd move a0 , a3 lw t9 , - 0x7f84 ( gp ) bal - 0x16268 nop lw gp , 0x10 ( sp ) bnez v0 , 0xfc addiu a1 , zero , 0xb beqz s3 , 0xbc addiu v0 , zero , 0x1 beq s1 , v0 , 0x1d8 addiu v0 , zero , 0x2 beq s1 , v0 , 0x1e4 lui a2 , 0x4a lui a2 , 0x4a addiu a2 , a2 , 0x4520 lw a3 , 0x50 ( sp ) move a1 , s0 lui a0 , 0x4a addiu a0 , a0 , - 0x408 lw t9 , - 0x7f8c ( gp ) jalr t9 nop lw gp , 0x10 ( sp ) move a1 , v0 move a0 , s3 lw t9 , - 0x7e08 ( gp ) bal - 0xe3a8 nop lw gp , 0x10 ( sp ) move a2 , s1 move a1 , s4 move a0 , s0 lw t9 , - 0x7d34 ( gp ) jalr t9 nop lw gp , 0x10 ( sp ) lw ra , 0x34 ( sp ) lw s5 , 0x30 ( sp ) lw s4 , 0x2c ( sp ) lw s3 , 0x28 ( sp ) lw s2 , 0x24 ( sp ) lw s1 , 0x20 ( sp ) lw s0 , 0x1c ( sp ) jr ra addiu sp , sp , 0x38 move a0 , s2 lw t9 , - 0x7f84 ( gp ) bal - 0x16268 nop lw gp , 0x10 ( sp ) beqz v0 , 0x15c move a3 , s2 addiu a1 , zero , 0xb move a0 , s2 lw t9 , - 0x7f84 ( gp ) bal - 0x16268 nop lw gp , 0x10 ( sp ) addiu v1 , zero , 0x2 bne v0 , v1 , 0x64 addiu a1 , zero , 0xd move a0 , s2 lw t9 , - 0x7f84 ( gp ) bal - 0x16268 nop lw gp , 0x10 ( sp ) addiu v1 , zero , 0x1 beq v0 , v1 , 0x64 move a3 , s2 move a2 , s5 move a1 , s0 move a0 , zero jal 0x420a18 nop lw gp , 0x10 ( sp ) beqz v0 , 0x64 nop beqz s3 , 0x1a4 lw a3 , 0x50 ( sp ) move a2 , s0 lui a1 , 0x4a addiu a1 , a1 , - 0x438 move a0 , s3 lw t9 , - 0x7d90 ( gp ) bal - 0xe304 nop lw gp , 0x10 ( sp ) move a0 , s0 lw t9 , - 0x7fd0 ( gp ) jalr t9 nop lw gp , 0x10 ( sp ) sw v0 , ( s4 ) move a0 , s0 lw t9 , - 0x7d30 ( gp ) jalr t9 nop lw gp , 0x10 ( sp ) b 0xdc lw ra , 0x34 ( sp ) lui a2 , 0x4a b 0x84 addiu a2 , a2 , - 0x448 b 0x84 addiu a2 , a2 , - 0x440
Code2: push { r4 , r5 , r6 , r7 , r8 , sb , sl , lr } mov r1 , 0xd mov r4 , r0 add r5 , sp , 0x20 mov r0 , r3 ldm r5 , { r5 , r7 , sb } mov r6 , r3 mov r8 , r2 bl 0xffff1384 cmp r0 , 0x0 bne 0x84 cmp r7 , 0x0 beq 0x68 cmp r5 , 0x1 beq 0x7c ldr r3 , [ pc , 0xcc ] cmp r5 , 0x2 ldr r2 , [ pc , 0xc8 ] movne r2 , r3 mov r1 , r4 mov r3 , sb ldr r0 , [ pc , 0xbc ] bl 0x55c84 mov r1 , r0 mov r0 , r7 bl 0xffff6164 mov r2 , r5 mov r1 , r8 mov r0 , r4 pop { r4 , r5 , r6 , r7 , r8 , sb , sl , lr } b 0x4ffe4 ldr r2 , [ pc , 0x98 ] b 0x4c mov r1 , 0xb mov r0 , r6 bl 0xffff1384 cmp r0 , 0x0 bne 0xe4 mov r2 , r6 mov r1 , r4 mov r0 , 0x0 bl 0xffffeb7c cmp r0 , 0x0 beq 0x2c cmp r7 , 0x0 beq 0xcc mov r3 , sb mov r0 , r7 mov r2 , r4 ldr r1 , [ pc , 0x54 ] bl 0xffff61b0 mov r0 , r4 bl 0x55ae0 str r0 , [ r8 ] mov r0 , r4 pop { r4 , r5 , r6 , r7 , r8 , sb , sl , lr } b 0x50118 mov r1 , 0xb mov r0 , r6 bl 0xffff1384 cmp r0 , 0x2 bne 0x2c mov r1 , 0xd mov r0 , r6 bl 0xffff1384 cmp r0 , 0x1 bne 0x98 b 0x2c ldrdeq r6 , r7 , [ r8 ] , -r0 andeq r1 , r8 , r4 , ror r4 andeq r1 , r8 , ip , lsr 0x9 andeq r1 , r8 , ip , ror 0x8 andeq r1 , r8 , ip , ror r4
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The provided assembly codes are for entirely different architectures (MIPS vs ARM) and the instructions do not correspond. The only similarities are the presence of function prologue and epilogue, which are too generic to indicate functional similarity.
------------------------------------------------------------

------------------------------------------------------------
Code1: str lr , [ sp , - 0x4 ] ! sub sp , sp , 0x1c str r0 , [ sp , 0xc ] str r1 , [ sp , 0x8 ] str r2 , [ sp , 0x4 ] ldr r1 , [ sp , 0x4 ] ldr r0 , [ sp , 0x8 ] bl 0xfffffe7c str r0 , [ sp , 0x14 ] ldr r3 , [ sp , 0x14 ] cmp r3 , 0x0 beq 0x3c ldr r3 , [ sp , 0x4 ] cmp r3 , 0x0 beq 0x44 ldr r3 , [ sp , 0x14 ] b 0x78 ldr r3 , [ sp , 0x8 ] ldr r3 , [ r3 , 0x28 ] and r3 , r3 , 0x2 cmp r3 , 0x0 beq 0x74 ldr r3 , [ sp , 0x8 ] ldr r3 , [ r3 , 0x2c ] and r3 , r3 , 0x20 cmp r3 , 0x0 bne 0x74 mov r3 , 0x0 b 0x78 ldr r3 , [ sp , 0x14 ] mov r0 , r3 add sp , sp , 0x1c pop { pc }
Code2: mov rcx , qword ptr [ rsi + 0x48 ] test cl , 0x4 je 0x11 xor eax , eax test byte ptr [ rsi + 0x58 ] , 0x4 je 0x8c test edx , edx je 0x5f test cl , 0x2 je 0x22 xor eax , eax test byte ptr [ rsi + 0x50 ] , 0x4 je 0x8c test cl , 0x1 jne 0x8d mov eax , ecx and eax , 0x60 xor edi , edi cmp rax , 0x60 sete dil mov edx , 0x4 sub edx , edi cmp rax , 0x60 je 0x95 mov eax , ecx and eax , 0x2 test rax , rax jne 0x95 xor eax , eax test cl , 0x8 je 0x8c mov rcx , qword ptr [ rsi + 0x60 ] test cl , 0x7 jne 0xa2 jmp 0x8c mov edx , 0x1 test cl , 0x8 je 0x7f mov rdi , qword ptr [ rsi + 0x60 ] test dil , 0x20 jne 0x7f shr edi , 0x6 xor eax , eax and edi , 0x2 mov edx , edi je 0x8c test cl , 0x2 je 0xae xor eax , eax test byte ptr [ rsi + 0x50 ] , 0x20 jne 0xae ret shr ecx , 0x4 and ecx , 0x1 mov edx , ecx test edx , edx je 0xae cmp edx , 0x5 jne 0xae mov rcx , qword ptr [ rsi + 0x60 ] mov edx , 0x5 xor eax , eax test cl , 0x2 je 0x8c mov eax , edx ret nop word ptr cs : [ rax + rax ] nop dword ptr [ rax + rax ]
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two code snippets are fundamentally dissimilar due to multiple factors:
1. Architecture difference: Code1 uses ARM assembly (e.g., ldr/str/bl instructions, r0-r3/sp registers), while Code2 uses x86_64 assembly (e.g., mov/test/je instructions, rcx/rsi/rax registers).
2. Structural mismatch: Code1 features sequential stack operations and conditional branching (cmp/beq) with fixed offsets, whereas Code2 relies heavily on bitwise tests (test/and) and jump tables.
3. Functional divergence: Code1 appears to manage stack frames and subroutine calls (bl instruction), while Code2 focuses on register-based bitmask testing without stack management.
4. No overlapping patterns: There are no equivalent instruction sequences, register usage patterns, or control flow structures between the two codes. The operations (e.g., stack manipulation vs. flag testing) serve entirely different purposes.
------------------------------------------------------------

------------------------------------------------------------
Code1: lui gp , 0x65 addiu sp , sp , - 0x20 addiu gp , gp , 0x3de0 sw s0 , 0x18 ( sp ) move s0 , a1 sw ra , 0x1c ( sp ) sw gp , 0x10 ( sp ) lw t9 , - 0x5f88 ( gp ) bal 0x2390 move a1 , zero move a1 , s0 lw gp , 0x10 ( sp ) move a0 , v0 lw ra , 0x1c ( sp ) lw s0 , 0x18 ( sp ) j 0x5372b0 addiu sp , sp , 0x20
Code2: push rbp mov rbp , rsp sub rsp , 0x30 xor eax , eax mov r8d , eax mov qword ptr [ rbp - 0x8 ] , rdi mov qword ptr [ rbp - 0x10 ] , rsi mov qword ptr [ rbp - 0x18 ] , rdx mov qword ptr [ rbp - 0x20 ] , rcx mov rdi , qword ptr [ rbp - 0x8 ] mov rdx , qword ptr [ rbp - 0x18 ] mov rcx , qword ptr [ rbp - 0x20 ] mov rsi , r8 call 0x2e80 mov qword ptr [ rbp - 0x28 ] , rax mov rdi , qword ptr [ rbp - 0x28 ] mov rsi , qword ptr [ rbp - 0x10 ] call 0xffffffffffffff70 add rsp , 0x30 pop rbp ret nop dword ptr [ rax + rax ]
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two code snippets are entirely dissimilar due to fundamental architectural differences. The first uses MIPS instructions (e.g., `lui`, `addiu`, `sw`) and MIPS-specific registers (`gp`, `sp`, `s0`), while the second uses x86_64 instructions (e.g., `push`, `mov`, `call`) and x86_64 registers (`rbp`, `rsp`, `rdi`). The calling conventions, stack management, and instruction semantics are completely incompatible between the architectures. There is no functional or structural overlap beyond generic low-level patterns like stack frame setup, which is insufficient to establish similarity.
------------------------------------------------------------

------------------------------------------------------------
Code1: push ebp push edi push esi push ebx sub esp , 0x2c call 0xffff90a7 add ebx , 0x6103b mov dword ptr [ esp + 0x4 ] , eax mov dword ptr [ esp ] , edx mov ebp , ecx mov esi , dword ptr [ esp + 0x40 ] mov edi , dword ptr [ esp + 0x48 ] mov eax , dword ptr gs : [ 0x14 ] mov dword ptr [ esp + 0x1c ] , eax xor eax , eax mov eax , esi sub eax , dword ptr [ esp + 0x44 ] cmp eax , 0x4 ja 0x9c lea edi , [ esi * 0x4 + 0x2 ] mov edx , edi mov eax , dword ptr [ esp ] call 0xfffffe84 sub esp , 0x4 lea eax , [ edi - 0x2 ] push eax push dword ptr [ esp + 0x8 ] push ebp call 0xffff8ec7 mov edx , esi mov eax , ebp call 0xfffffeaa add esp , 0xc push ebp mov eax , dword ptr [ esp + 0xc ] push eax push eax call 0xffff8137 sub esi , 0x1 sub edi , 0x4 add esp , 0x10 cmp dword ptr [ esp + 0x44 ] , esi jb 0x41 mov eax , dword ptr [ esp + 0x1c ] xor eax , dword ptr gs : [ 0x14 ] jne 0x15f add esp , 0x2c pop ebx pop esi pop edi pop ebp ret mov eax , esi add eax , dword ptr [ esp + 0x44 ] shr eax , 0x1 mov dword ptr [ esp + 0xc ] , eax add eax , 0x1 sub esp , 0x4 push edi mov dword ptr [ esp + 0x10 ] , eax push eax push esi mov edx , dword ptr [ esp + 0x10 ] mov eax , dword ptr [ esp + 0x14 ] call 0x0 mov eax , dword ptr [ esp + 0x18 ] lea esi , [ eax * 0x4 ] lea edx , [ esi + 0x2 ] mov eax , dword ptr [ esp + 0x10 ] call 0xfffffe84 add esp , 0xc push esi push dword ptr [ esp + 0x8 ] push ebp call 0xffff8ec7 mov edx , dword ptr [ esp + 0x18 ] mov eax , ebp call 0xfffffeaa add esp , 0x10 test edi , edi je 0x14c mov dword ptr [ esp + 0x10 ] , 0x0 sub esp , 0x8 push ebp push edi call 0xffff80b7 add esp , 0x10 sub esp , 0x4 push 0x0 push dword ptr [ esp + 0x4c ] push dword ptr [ esp + 0x18 ] mov ecx , ebp mov edx , dword ptr [ esp + 0x10 ] mov eax , edi call 0x0 add esp , 0xc push edi mov eax , dword ptr [ esp + 0xc ] push eax push eax call 0xffff8137 add esp , 0x4 lea eax , [ esp + 0x1c ] push eax call 0xffff8787 add esp , 0x10 jmp 0x83 sub esp , 0x8 push ebp lea edi , [ esp + 0x1c ] push edi call 0xffff7c47 add esp , 0x10 jmp 0x10e call 0x42997
Code2: lui gp , 0x8 addiu gp , gp , 0x4d04 addu gp , gp , t9 addiu sp , sp , - 0x58 sw s3 , 0x3c ( sp ) sw s2 , 0x38 ( sp ) lw s3 , - 0x7adc ( gp ) lw s2 , 0x68 ( sp ) sw gp , 0x18 ( sp ) sw s7 , 0x4c ( sp ) sw s6 , 0x48 ( sp ) subu v0 , a3 , s2 sw s5 , 0x44 ( sp ) move s6 , a1 sw s4 , 0x40 ( sp ) sltiu v0 , v0 , 0x5 sw s0 , 0x30 ( sp ) move s4 , a3 sw ra , 0x54 ( sp ) move s0 , a0 sw fp , 0x50 ( sp ) move s5 , a2 sw s1 , 0x34 ( sp ) lw v1 , ( s3 ) lw s7 , 0x6c ( sp ) sw v1 , 0x2c ( sp ) beqz v0 , 0x194 lui s1 , 0x3fff sll s7 , a3 , 0x2 addiu s7 , s7 , 0x2 ori s1 , s1 , 0xffff lw a3 , 0x8 ( s6 ) addiu a2 , s7 , - 0x2 lw v0 , ( a3 ) addu v0 , s7 , v0 sltu v1 , v0 , s7 beqz v1 , 0xb0 sw v0 , ( a3 ) move v1 , a3 addiu v1 , v1 , 0x4 lw v0 , ( v1 ) addiu v0 , v0 , 0x1 beqz v0 , 0x9c sw v0 , ( v1 ) lw v1 , 0x4 ( s6 ) move a1 , s6 lw t9 , - 0x7f40 ( gp ) move a0 , s5 sll v0 , v1 , 0x2 addu a3 , a3 , v0 lw v0 , ( a3 ) sltu v0 , zero , v0 addu v0 , v0 , v1 jalr t9 sw v0 , 0x4 ( s6 ) lw a3 , 0x8 ( s5 ) lw gp , 0x18 ( sp ) lw v0 , ( a3 ) subu v1 , v0 , s4 sltu v0 , v0 , s4 beqz v0 , 0x110 sw v1 , ( a3 ) move v0 , a3 addiu v0 , v0 , 0x4 lw v1 , ( v0 ) addiu a0 , v1 , - 0x1 beqz v1 , 0xfc sw a0 , ( v0 ) lw v0 , 0x4 ( s5 ) addiu s4 , s4 , - 0x1 lw t9 , - 0x7b88 ( gp ) move a2 , s5 move a1 , s0 addu v1 , v0 , s1 move a0 , s0 sll v1 , v1 , 0x2 addiu s7 , s7 , - 0x4 addu a3 , a3 , v1 lw v1 , ( a3 ) sltiu v1 , v1 , 0x1 subu v0 , v0 , v1 jalr t9 sw v0 , 0x4 ( s5 ) sltu v0 , s2 , s4 bnez v0 , 0x7c lw gp , 0x18 ( sp ) lw v1 , 0x2c ( sp ) lw v0 , ( s3 ) bne v1 , v0 , 0x2f8 lw ra , 0x54 ( sp ) lw fp , 0x50 ( sp ) lw s7 , 0x4c ( sp ) lw s6 , 0x48 ( sp ) lw s5 , 0x44 ( sp ) lw s4 , 0x40 ( sp ) lw s3 , 0x3c ( sp ) lw s2 , 0x38 ( sp ) lw s1 , 0x34 ( sp ) lw s0 , 0x30 ( sp ) jr ra addiu sp , sp , 0x58 addu s1 , a3 , s2 lw s4 , - 0x7fd0 ( gp ) sw s7 , 0x14 ( sp ) srl s1 , s1 , 0x1 addiu s4 , s4 , 0x133c addiu fp , s1 , 0x1 move t9 , s4 bal 0x0 sw fp , 0x10 ( sp ) sll a2 , fp , 0x2 lw a3 , 0x8 ( s6 ) addiu v0 , a2 , 0x2 lw gp , 0x18 ( sp ) lw v1 , ( a3 ) addu v1 , v0 , v1 sltu v0 , v1 , v0 beqz v0 , 0x1f4 sw v1 , ( a3 ) move v1 , a3 addiu v1 , v1 , 0x4 lw v0 , ( v1 ) addiu v0 , v0 , 0x1 beqz v0 , 0x1e0 sw v0 , ( v1 ) lw v1 , 0x4 ( s6 ) move a0 , s5 lw t9 , - 0x7f40 ( gp ) move a1 , s6 sll v0 , v1 , 0x2 addu a3 , a3 , v0 lw v0 , ( a3 ) sltu v0 , zero , v0 addu v0 , v0 , v1 jalr t9 sw v0 , 0x4 ( s6 ) lw a0 , 0x8 ( s5 ) lw gp , 0x18 ( sp ) lw v0 , ( a0 ) subu v1 , v0 , fp sltu fp , v0 , fp beqz fp , 0x254 sw v1 , ( a0 ) move v0 , a0 addiu v0 , v0 , 0x4 lw v1 , ( v0 ) addiu a1 , v1 , - 0x1 beqz v1 , 0x240 sw a1 , ( v0 ) lw v0 , 0x4 ( s5 ) sll v1 , v0 , 0x2 addu a0 , a0 , v1 lw v1 , - 0x4 ( a0 ) sltiu v1 , v1 , 0x1 subu v0 , v0 , v1 beqz s7 , 0x2dc sw v0 , 0x4 ( s5 ) lw t9 , - 0x7b68 ( gp ) addiu fp , sp , 0x20 sw zero , 0x20 ( sp ) move a1 , s5 jalr t9 move a0 , s7 move a3 , s1 sw s2 , 0x10 ( sp ) move a2 , s5 sw zero , 0x14 ( sp ) move a1 , s6 move t9 , s4 bal 0x0 move a0 , s7 move a0 , s0 lw gp , 0x18 ( sp ) move a2 , s7 lw t9 , - 0x7b88 ( gp ) jalr t9 move a1 , s0 lw gp , 0x18 ( sp ) lw t9 , - 0x7d40 ( gp ) jalr t9 move a0 , fp b 0x158 lw gp , 0x18 ( sp ) addiu fp , sp , 0x20 lw t9 , - 0x7a30 ( gp ) move a1 , s5 jalr t9 move a0 , fp b 0x28c move s7 , fp lw t9 , - 0x7b4c ( gp ) jalr t9 nop
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly codes show fundamental differences:  
1. Architecture - Code1 uses x86 syntax (ebp/eax/esp), while Code2 uses MIPS syntax (gp/sp/t9)  
2. Structure - Code1 has push/pop/call sequences typical of x86, while Code2 uses MIPS-specific ops (lui/addiu/sw)  
3. Control flow - Jumps/conditions differ (Code1 uses ja/jb/jne, Code2 uses beqz/bnez)  
4. Register usage - No overlap in register names or manipulation patterns  
5. Stack handling - Code1 adjusts esp directly, Code2 uses MIPS stack ops (addiu/sw)  
No significant algorithmic or structural similarities found.
------------------------------------------------------------

------------------------------------------------------------
Code1: cmp r0 , 0x0 push { r4 , r5 , r6 , r7 , r8 , lr } moveq r5 , r0 beq 0x4c ldr r5 , [ r0 ] mov r4 , r1 cmp r5 , 0x0 bne 0x54 cmp r1 , 0x0 moveq r5 , 0x1 beq 0x4c mov r6 , 0x1 mov r5 , r6 ldr r3 , [ r1 ] mov r2 , 0x0 strb r2 , [ r3 ] ldr r3 , [ r4 ] add r6 , r3 , r6 str r6 , [ r4 ] mov r0 , r5 pop { r4 , r5 , r6 , r7 , r8 , pc } ldr r3 , [ r0 , 0x4 ] ldr r1 , [ r0 , 0x8 ] ands ip , r3 , 0x100 moveq r3 , 0x1 movne r3 , 0x0 ldrb r2 , [ r1 ] cmp r2 , 0x7f movle r3 , 0x0 andgt r3 , r3 , 0x1 cmp r3 , 0x0 beq 0x130 cmp r4 , 0x0 add r5 , r5 , 0x1 beq 0x4c mov r2 , 0x0 ldr r3 , [ r4 ] strb r2 , [ r3 ] ldr lr , [ r0 ] add r3 , r3 , 0x1 cmp lr , 0x0 mov r6 , r5 movne r2 , lr ldrne r1 , [ r0 , 0x8 ] beq 0x38 cmp ip , 0x0 beq 0x14c sub r2 , r2 , 0x1 ldrb r7 , [ r1 , r2 ] add r0 , r3 , r2 cmp r7 , 0x0 add r1 , r1 , r2 bne 0x198 mov r8 , r7 mov r3 , r0 sub ip , r1 , 0x1 strb r8 , [ r3 ] , - 0x1 mov r1 , ip ldrb r7 , [ ip ] , - 0x1 add r2 , r3 , lr cmp r7 , 0x0 sub r2 , r2 , r0 beq 0xe0 rsb r0 , r7 , 0x0 cmp r2 , 0x1 strb r0 , [ r3 ] sub r3 , r3 , 0x1 sub r0 , r1 , 0x1 ble 0x40 sub r1 , r1 , r2 ldrb r2 , [ r0 ] , - 0x1 mvn r2 , r2 cmp r0 , r1 strb r2 , [ r3 ] , - 0x1 bne 0x118 b 0x40 cmp ip , 0x0 bne 0x158 cmp r4 , 0x0 beq 0x4c mov r6 , r5 mov r2 , r5 ldr r3 , [ r4 ] mov r0 , r3 bl 0xfff0ad50 b 0x40 cmp r2 , 0x80 bgt 0x180 beq 0x1a4 cmp r4 , 0x0 beq 0x4c ldr r3 , [ r4 ] mov r6 , r5 mov r2 , r5 mov lr , r5 b 0xbc cmp r4 , 0x0 add r5 , r5 , 0x1 beq 0x4c ldr r3 , [ r4 ] mov r2 , 0xff b 0x94 mov r3 , r0 mov r2 , lr b 0xfc cmp r5 , 0x1 ble 0x1dc ldrb r3 , [ r1 , 0x1 ] cmp r3 , 0x0 bne 0x180 add lr , r1 , r5 sub lr , lr , 0x1 add r3 , r1 , 0x1 b 0x1d4 ldrb r2 , [ r3 , 0x1 ] ! cmp r2 , 0x0 bne 0x180 cmp lr , r3 bne 0x1c8 cmp r4 , 0x0 beq 0x4c ldr r3 , [ r4 ] mov r6 , r5 mov r2 , r5 mov lr , r5 b 0xb4
Code2: push rbp push r15 push r14 push rbx push rax test rdi , rdi je 0x7a mov r14 , rsi mov ebp , dword ptr [ rdi + 0x4 ] movsxd rcx , dword ptr [ rdi ] test rcx , rcx je 0x82 mov rax , qword ptr [ rdi + 0x8 ] mov bl , byte ptr [ rax ] test ebp , 0x100 sete dl test bl , bl sets sil test ebp , 0x100 jne 0x96 and dl , sil xor ebx , ebx movzx esi , dl lea r15d , [ rsi + rcx ] test r14 , r14 je 0x16b mov rax , qword ptr [ r14 ] test esi , esi je 0x5b mov byte ptr [ rax ] , bl add rax , 0x1 mov ecx , dword ptr [ rdi ] test ecx , ecx je 0xb4 mov rsi , qword ptr [ rdi + 0x8 ] test ebp , 0x100 jne 0xbc mov edx , ecx mov rdi , rax call 0xfffffffffff1cf90 jmp 0x165 xor r15d , r15d jmp 0x16b xor esi , esi mov r15d , 0x1 xor ebx , ebx test r14 , r14 jne 0x4c jmp 0x16b cmp bl , 0x80 jbe 0x179 mov esi , 0x1 mov bl , 0xff lea r15d , [ rsi + rcx ] test r14 , r14 jne 0x4c jmp 0x16b mov byte ptr [ rax ] , 0x0 jmp 0x165 movsxd rdi , ecx lea rdx , [ rsi + rdi ] add rax , rdi add rax , - 0x1 mov bl , byte ptr [ rsi + rdi - 0x1 ] add ecx , - 0x1 test bl , bl jne 0xf6 nop word ptr cs : [ rax + rax ] nop mov byte ptr [ rax ] , 0x0 add rax , - 0x1 movzx ebx , byte ptr [ rdx - 0x2 ] add rdx , - 0x1 add ecx , - 0x1 test bl , bl je 0xe0 neg bl mov byte ptr [ rax ] , bl test ecx , ecx jle 0x165 lea rsi , [ rdx - 0x2 ] lea r9d , [ rcx - 0x1 ] lea rbx , [ r9 + 0x1 ] cmp rbx , 0x10 jb 0x13c mov rdi , r9 not rdi add rdi , rax lea rbp , [ rdx - 0x1 ] cmp rdi , rbp jae 0x1d7 mov rdi , 0xfffffffffffffffe sub rdi , r9 add rdi , rdx cmp rdi , rax jae 0x1d7 mov rdi , rax mov eax , ecx xor ecx , ecx nop word ptr cs : [ rax + rax ] nop dword ptr [ rax ] movzx edx , byte ptr [ rsi + rcx ] not dl mov byte ptr [ rdi + rcx - 0x1 ] , dl add rcx , - 0x1 lea edx , [ rax + rcx ] test edx , edx jg 0x150 movsxd rax , r15d add qword ptr [ r14 ] , rax mov eax , r15d add rsp , 0x8 pop rbx pop r14 pop r15 pop rbp ret xor esi , esi cmp bl , 0x80 jne 0x1c6 mov ebx , 0x0 cmp ecx , 0x2 jl 0xa6 mov esi , 0x1 nop word ptr cs : [ rax + rax ] nop dword ptr [ rax ] cmp byte ptr [ rax + rsi ] , 0x0 jne 0x9f add rsi , 0x1 cmp rsi , rcx jl 0x1a0 xor esi , esi xor ebx , ebx lea r15d , [ rsi + rcx ] test r14 , r14 jne 0x4c jmp 0x16b xor ebx , ebx lea r15d , [ rsi + rcx ] test r14 , r14 jne 0x4c jmp 0x16b mov r8d , ecx and r8d , 0xf sub rbx , r8 sub ecx , ebx sub rsi , rbx mov rdi , rax sub rdi , rbx neg r9 lea rbx , [ r8 + r9 ] add rbx , - 0x1 xor ebp , ebp movdqa xmm0 , xmmword ptr [ rip + 0xe0f8f ] nop word ptr cs : [ rax + rax ] nop dword ptr [ rax + rax ] movq xmm1 , qword ptr [ rdx + rbp - 0x9 ] punpcklbw xmm1 , xmm0 movq xmm2 , qword ptr [ rdx + rbp - 0x11 ] punpcklbw xmm2 , xmm0 pandn xmm1 , xmm0 pandn xmm2 , xmm0 packuswb xmm2 , xmm1 movdqu xmmword ptr [ rax + rbp - 0x10 ] , xmm2 add rbp , - 0x10 cmp rbx , rbp jne 0x210 test r8d , r8d jne 0x13f jmp 0x165 nop dword ptr [ rax ]
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly codes show fundamental architectural differences. Code1 uses ARM-specific registers (r0-r8, lr, pc) and instructions (push/pop with register lists, conditional execution like moveq/beq). Code2 uses x86_64 conventions (rdi, rsi, rbp, xmm registers) and AT&T syntax (dword ptr, qword ptr). Key structural differences include:  
- Code1 has multi-register push/pop operations while Code2 uses individual pushes  
- Code1 uses status flags for conditional branching (beq/bne), while Code2 uses compare-and-jump (je/jne)  
- Code2 uses SSE instructions (movdqa, pandn) absent in Code1  
- Memory operations differ significantly (ldr/str vs mov/movzx)  
The control flow patterns and register usage show no algorithmic alignment, confirming dissimilar implementations.
------------------------------------------------------------

------------------------------------------------------------
Code1: push ebp mov ebp , esp push edi push esi sub esp , 0x10 mov eax , dword ptr [ ebp + 0x8 ] cmp dword ptr [ 0x8126c88 ] , 0x0 mov dword ptr [ ebp - 0xc ] , eax jne 0x30f mov al , byte ptr [ 0x81245a7 ] xor al , 0xb mov byte ptr [ 0x81245b4 ] , al mov al , byte ptr [ 0x81245a8 ] xor al , 0xfc mov byte ptr [ 0x81245b5 ] , al mov al , byte ptr [ 0x81245a9 ] xor al , 0x14 mov byte ptr [ 0x81245b6 ] , al mov al , byte ptr [ 0x81245aa ] xor al , 0xcc mov byte ptr [ 0x81245b7 ] , al mov al , byte ptr [ 0x81245ab ] xor al , 0x25 mov byte ptr [ 0x81245b8 ] , al mov al , byte ptr [ 0x81245ac ] xor al , 0x78 mov byte ptr [ 0x81245b9 ] , al mov al , byte ptr [ 0x81245ad ] xor al , 0x31 mov byte ptr [ 0x81245ba ] , al mov al , byte ptr [ 0x81245ae ] xor al , 0x3e mov byte ptr [ 0x81245bb ] , al mov al , byte ptr [ 0x81245af ] xor al , 0x4f mov byte ptr [ 0x81245bc ] , al mov al , byte ptr [ 0x81245b0 ] xor al , 0xfb mov byte ptr [ 0x81245bd ] , al mov al , byte ptr [ 0x81245b1 ] xor al , 0xa5 mov byte ptr [ 0x81245be ] , al mov al , byte ptr [ 0x81245b2 ] xor al , 0x94 mov byte ptr [ 0x81245bf ] , al mov al , byte ptr [ 0x81245b3 ] xor al , 0xb2 mov byte ptr [ 0x81245c0 ] , al mov al , byte ptr [ 0x81245c1 ] xor al , 0x59 mov byte ptr [ 0x81245ce ] , al mov al , byte ptr [ 0x81245c2 ] xor al , 0xe4 mov byte ptr [ 0x81245cf ] , al mov al , byte ptr [ 0x81245c3 ] xor al , 0x5f mov byte ptr [ 0x81245d0 ] , al mov al , byte ptr [ 0x81245c4 ] xor al , 0x3 mov byte ptr [ 0x81245d1 ] , al mov al , byte ptr [ 0x81245c5 ] xor al , 0xa5 mov byte ptr [ 0x81245d2 ] , al mov al , byte ptr [ 0x81245c6 ] xor al , 0x1f mov byte ptr [ 0x81245d3 ] , al mov al , byte ptr [ 0x81245c7 ] xor al , 0x1b mov byte ptr [ 0x81245d4 ] , al mov al , byte ptr [ 0x81245c8 ] xor al , 0xa4 mov byte ptr [ 0x81245d5 ] , al mov al , byte ptr [ 0x81245c9 ] xor al , 0xc8 mov byte ptr [ 0x81245d6 ] , al mov al , byte ptr [ 0x81245ca ] xor al , 0xd2 mov byte ptr [ 0x81245d7 ] , al mov al , byte ptr [ 0x81245cb ] xor al , 0x62 mov byte ptr [ 0x81245d8 ] , al mov al , byte ptr [ 0x81245cc ] xor al , 0xd mov byte ptr [ 0x81245d9 ] , al mov al , byte ptr [ 0x81245cd ] xor al , 0x9c mov byte ptr [ 0x81245da ] , al mov al , byte ptr [ 0x81245e0 ] xor al , 0xc9 mov byte ptr [ 0x8124610 ] , al mov al , byte ptr [ 0x81245e1 ] xor al , 0xe4 mov byte ptr [ 0x8124611 ] , al mov al , byte ptr [ 0x81245e2 ] xor al , 0x9b mov byte ptr [ 0x8124612 ] , al mov al , byte ptr [ 0x81245e3 ] xor al , 0x43 mov byte ptr [ 0x8124613 ] , al mov al , byte ptr [ 0x81245e4 ] xor al , 0x3a mov byte ptr [ 0x8124614 ] , al mov al , byte ptr [ 0x81245e5 ] xor al , 0x9f mov byte ptr [ 0x8124615 ] , al mov al , byte ptr [ 0x81245e6 ] xor al , 0x14 mov byte ptr [ 0x8124616 ] , al mov al , byte ptr [ 0x81245e7 ] xor al , 0xab mov byte ptr [ 0x8124617 ] , al mov al , byte ptr [ 0x81245e8 ] xor al , 0xb2 mov byte ptr [ 0x8124618 ] , al mov al , byte ptr [ 0x81245e9 ] xor al , 0x8e mov byte ptr [ 0x8124619 ] , al mov al , byte ptr [ 0x81245ea ] xor al , 0x52 mov byte ptr [ 0x812461a ] , al mov al , byte ptr [ 0x81245eb ] xor al , 0xd mov byte ptr [ 0x812461b ] , al mov al , byte ptr [ 0x81245ec ] xor al , 0x98 mov byte ptr [ 0x812461c ] , al mov al , byte ptr [ 0x81245ed ] xor al , 0x2a mov byte ptr [ 0x812461d ] , al mov al , byte ptr [ 0x81245ee ] xor al , 0xcb mov byte ptr [ 0x812461e ] , al mov al , byte ptr [ 0x81245ef ] xor al , 0x8f mov byte ptr [ 0x812461f ] , al mov al , byte ptr [ 0x81245f0 ] xor al , 0x80 mov byte ptr [ 0x8124620 ] , al mov al , byte ptr [ 0x81245f1 ] xor al , 0x3e mov byte ptr [ 0x8124621 ] , al mov al , byte ptr [ 0x81245f2 ] xor al , 0xfd mov byte ptr [ 0x8124622 ] , al mov al , byte ptr [ 0x81245f3 ] xor al , 0xc7 mov byte ptr [ 0x8124623 ] , al mov al , byte ptr [ 0x81245f4 ] xor al , 0xf5 mov byte ptr [ 0x8124624 ] , al mov al , byte ptr [ 0x81245f5 ] xor al , 0x27 mov byte ptr [ 0x8124625 ] , al mov al , byte ptr [ 0x81245f6 ] xor al , 0x9d mov byte ptr [ 0x8124626 ] , al mov al , byte ptr [ 0x81245f7 ] xor al , 0x20 mov byte ptr [ 0x8124627 ] , al mov al , byte ptr [ 0x81245f8 ] xor al , 0xc0 mov byte ptr [ 0x8124628 ] , al mov al , byte ptr [ 0x81245f9 ] xor al , 0xe4 mov byte ptr [ 0x8124629 ] , al mov al , byte ptr [ 0x81245fa ] xor al , 0x55 mov byte ptr [ 0x812462a ] , al mov al , byte ptr [ 0x81245fb ] xor al , 0x51 mov byte ptr [ 0x812462b ] , al mov al , byte ptr [ 0x81245fc ] xor al , 0x86 mov byte ptr [ 0x812462c ] , al mov al , byte ptr [ 0x81245fd ] xor al , 0xe1 mov byte ptr [ 0x812462d ] , al mov al , byte ptr [ 0x81245fe ] xor al , 0xd0 mov byte ptr [ 0x812462e ] , al mov al , byte ptr [ 0x81245ff ] xor al , 0xee mov byte ptr [ 0x812462f ] , al mov al , byte ptr [ 0x8124600 ] xor al , 0x53 mov byte ptr [ 0x8124630 ] , al mov al , byte ptr [ 0x8124601 ] xor al , 0x14 mov byte ptr [ 0x8124631 ] , al mov al , byte ptr [ 0x8124602 ] xor al , 0x63 mov byte ptr [ 0x8124632 ] , al mov al , byte ptr [ 0x8124603 ] xor al , 0x46 mov byte ptr [ 0x8124633 ] , al mov al , byte ptr [ 0x8124604 ] xor al , 0xc mov byte ptr [ 0x8124634 ] , al xor eax , eax mov dword ptr [ 0x8126c88 ] , 0x1 mov ecx , esp add ecx , - 0x10 mov esp , ecx mov edx , esp add edx , - 0x10 mov esp , edx mov esi , dword ptr [ ebp - 0xc ] mov dword ptr [ ecx ] , esi mov edi , dword ptr [ ecx ] cmp eax , dword ptr [ edi ] mov dword ptr [ ebp - 0x10 ] , ecx mov dword ptr [ ebp - 0x14 ] , edx jg 0x3a4 mov eax , dword ptr [ ebp - 0x10 ] mov ecx , dword ptr [ eax ] mov ecx , dword ptr [ ecx ] sub esp , 0x10 mov dword ptr [ esp ] , ecx call 0xfff62330 add esp , 0x10 cmp eax , 0x0 setne dl and dl , 0x1 mov eax , dword ptr [ ebp - 0x14 ] mov byte ptr [ eax ] , dl test byte ptr [ eax ] , 0x1 jne 0x36f jmp 0x39f lea eax , [ 0x8124610 ] lea ecx , [ 0x81245b4 ] lea edx , [ 0x81245ce ] sub esp , 0x10 mov dword ptr [ esp ] , edx mov dword ptr [ esp + 0x4 ] , ecx mov dword ptr [ esp + 0x8 ] , 0x40 mov dword ptr [ esp + 0xc ] , eax call 0xfff62380 add esp , 0x10 jmp 0x3a4 lea esp , [ ebp - 0x8 ] pop esi pop edi pop ebp ret nop nop nop
Code2: mov edi , dword ptr [ rdi ] test edi , edi js 0x20 sub rsp , 0x8 call 0xfffffffffffe3d70 test eax , eax jne 0x22 add rsp , 0x8 ret nop dword ptr [ rax + rax ] repz ret lea rcx , [ rip + 0x1aaa7 ] lea rsi , [ rip + 0x1aa43 ] lea rdi , [ rip + 0x1aa49 ] mov edx , 0x40 call 0xfffffffffffe3cf0 nop dword ptr [ rax + rax ] nop word ptr cs : [ rax + rax ]
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two code snippets show significant differences in structure, functionality, and architecture. The first code uses 32-bit registers (ebp, esp, eax) and performs a long sequence of XOR operations on memory locations, suggesting decryption or data transformation logic. It includes stack manipulation and conditional branching. The second code uses 64-bit registers (rdi, rsp, rcx) and focuses on conditional function calls without any data manipulation operations. There are no overlapping instruction patterns, memory operations, or control flow structures. The architectural difference (32-bit vs 64-bit) and fundamental purpose (data transformation vs function orchestration) confirm they are unrelated.
------------------------------------------------------------

------------------------------------------------------------
Code1: push rbp push r14 push rbx mov r14d , 0x1 test rsi , rsi je 0x84 mov rbp , rdx mov rbx , rdi call 0x44380 test eax , eax jle 0x51 mov rdi , rbx mov rsi , rbp call 0x448d0 test eax , eax jle 0x62 mov rdi , rbx call 0x3a8a0 test eax , eax jne 0x84 mov rdi , qword ptr [ rip + 0x3fc520 ] xor r14d , r14d mov esi , 0x58a709 xor eax , eax call 0x91d70 jmp 0x84 mov rdi , qword ptr [ rip + 0x3fc508 ] xor r14d , r14d mov esi , 0x58a740 jmp 0x71 mov rdi , qword ptr [ rip + 0x3fc4f7 ] xor r14d , r14d mov esi , 0x58a75b xor eax , eax call 0x91d70 mov rdi , qword ptr [ rip + 0x3fc4e1 ] call 0x9b910 mov eax , r14d pop rbx pop r14 pop rbp ret nop dword ptr [ rax ]
Code2: push ebx sub esp , 0x8 call 0xfffc2a22 add ebx , 0x2a24f5 cmp dword ptr [ esp + 0x14 ] , 0x0 jne 0x20 mov eax , 0x1 jmp 0xf7 sub esp , 0x8 push dword ptr [ esp + 0x1c ] push dword ptr [ esp + 0x1c ] call 0x5991e add esp , 0x10 test eax , eax jg 0x70 lea eax , [ ebx + 0xcb2c ] mov eax , dword ptr [ eax ] sub esp , 0x8 lea edx , [ ebx - 0xfed15 ] push edx push eax call 0xbc539 add esp , 0x10 lea eax , [ ebx + 0xcb2c ] mov eax , dword ptr [ eax ] sub esp , 0xc push eax call 0xc4534 add esp , 0x10 mov eax , 0x0 jmp 0xf7 sub esp , 0x8 push dword ptr [ esp + 0x20 ] push dword ptr [ esp + 0x1c ] call 0x5a1b7 add esp , 0x10 test eax , eax jg 0xbd lea eax , [ ebx + 0xcb2c ] mov eax , dword ptr [ eax ] sub esp , 0x8 lea edx , [ ebx - 0xfecfa ] push edx push eax call 0xbc539 add esp , 0x10 lea eax , [ ebx + 0xcb2c ] mov eax , dword ptr [ eax ] sub esp , 0xc push eax call 0xc4534 add esp , 0x10 mov eax , 0x0 jmp 0xf7 sub esp , 0xc push dword ptr [ esp + 0x1c ] call 0x4c34d add esp , 0x10 test eax , eax jne 0xf2 lea eax , [ ebx + 0xcb2c ] mov eax , dword ptr [ eax ] sub esp , 0x8 lea edx , [ ebx - 0xfed4c ] push edx push eax call 0xbc539 add esp , 0x10 mov eax , 0x0 jmp 0xf7 mov eax , 0x1 add esp , 0x8 pop ebx ret
Similarity: -1
Label: 1
Similarity Score: 0.15
Explanation: The two assembly codes show some structural similarities in control flow patterns (conditional jumps and function calls) and both return a status value (0/1). However, they differ significantly in architecture (64-bit vs 32-bit registers), calling conventions, stack management, and instruction sequences. The register usage (R14/RBX vs EBX), function addresses, and error handling implementations are distinct. While both follow a test-and-branch pattern, the low-level implementation details and architectural differences outweigh these similarities.
------------------------------------------------------------

------------------------------------------------------------
Code1: push r15 push r14 mov r14 , rcx push r13 push r12 mov r13 , r8 push rbp push rbx mov r12 , rsi mov rbp , rdx sub rsp , 0x18 test rdx , rdx mov qword ptr [ rsp ] , rdi je 0x128 test rsi , rsi je 0x128 mov rsi , rdx mov rdi , r12 call 0xfffffffffffcaca0 test eax , eax sete al movzx eax , al mov dword ptr [ rsp + 0xc ] , eax lea r15 , [ rip + 0x1b1bfd ] mov ecx , 0x5 mov rsi , r12 mov rdi , r15 repe cmpsb byte ptr [ rsi ] , byte ptr [ rdi ] seta al sbb al , 0x0 test al , al je 0x168 lea rdi , [ rip + 0x1b1be2 ] mov ecx , 0x4 mov rsi , r12 repe cmpsb byte ptr [ rsi ] , byte ptr [ rdi ] seta bl sbb bl , 0x0 movsx ebx , bl test ebx , ebx je 0x1d0 mov edx , dword ptr [ rsp + 0xc ] mov rdi , qword ptr [ rsp ] mov rsi , r12 call 0xfffffffffffff620 xor ebx , ebx test rax , rax mov qword ptr [ r14 ] , rax je 0x112 test rbp , rbp je 0x150 mov eax , dword ptr [ rsp + 0xc ] test eax , eax je 0x149 mov edx , 0x2 mov ecx , 0x5 mov rsi , rbp mov rdi , r15 repe cmpsb byte ptr [ rsi ] , byte ptr [ rdi ] seta al sbb al , 0x0 test al , al je 0x180 lea rdi , [ rip + 0x1b1b72 ] mov ecx , 0x4 mov rsi , rbp repe cmpsb byte ptr [ rsi ] , byte ptr [ rdi ] seta bl sbb bl , 0x0 movsx ebx , bl test ebx , ebx je 0x1a8 mov rdi , qword ptr [ rsp ] mov rsi , rbp call 0xfffffffffffff620 xor ebx , ebx test rax , rax mov qword ptr [ r13 ] , rax setne bl add rsp , 0x18 mov eax , ebx pop rbx pop rbp pop r12 pop r13 pop r14 pop r15 ret nop dword ptr [ rax + rax ] test r12 , r12 jne 0x1f0 test r14 , r14 je 0x190 test rbp , rbp mov qword ptr [ r14 ] , 0x0 lea r15 , [ rip + 0x1b1b04 ] je 0x150 xor edx , edx jmp 0xbe test r13 , r13 mov ebx , 0x1 je 0x112 mov qword ptr [ r13 ] , 0x0 jmp 0x112 nop dword ptr [ rax ] lea rdi , [ r12 + 0x5 ] call 0xb2a30 jmp 0x9a nop word ptr [ rax + rax ] lea rdi , [ rbp + 0x5 ] call 0xb2a30 jmp 0x106 nop test rbp , rbp je 0x150 lea r15 , [ rip + 0x1b1aaf ] xor edx , edx jmp 0xbe nop dword ptr [ rax + rax ] add rbp , 0x4 mov rdi , rbp call 0xfffffffffffca560 test rax , rax je 0x1fd mov rdi , rax call 0xb2a30 jmp 0x106 nop word ptr cs : [ rax + rax ] add r12 , 0x4 mov rdi , r12 call 0xfffffffffffca560 test rax , rax je 0x21d mov rdi , rax call 0xb2a30 jmp 0x9a nop mov dword ptr [ rsp + 0xc ] , 0x0 jmp 0x47 mov rdi , qword ptr [ rsp ] lea rsi , [ rip + 0x1b2058 ] mov rdx , rbp call 0xbabc0 mov qword ptr [ r13 ] , 0x0 jmp 0x112 mov rdi , qword ptr [ rsp ] lea rsi , [ rip + 0x1b2038 ] mov rdx , r12 call 0xbabc0 mov qword ptr [ r14 ] , 0x0 jmp 0x112 nop dword ptr [ rax ]
Code2: push { r4 , r5 , r6 , r7 , r8 , sb , sl , lr } mov r8 , r0 mov r7 , r3 ldr sb , [ sp , 0x20 ] mov r6 , r2 mov r5 , r1 cmp r1 , 0x0 cmpne r2 , 0x0 moveq r4 , 0x0 beq 0x3c mov r1 , r2 mov r0 , r5 bl 0xfffd1f3c clz r4 , r0 lsr r4 , r4 , 0x5 cmp r5 , 0x0 beq 0x68 mov r2 , r4 mov r1 , r5 mov r0 , r8 bl 0xfffff150 str r0 , [ r7 ] cmp r0 , 0x0 bne 0x74 mov r0 , 0x0 pop { r4 , r5 , r6 , r7 , r8 , sb , sl , pc } cmp r7 , 0x0 movne r3 , 0x0 strne r3 , [ r7 ] cmp r6 , 0x0 beq 0xa4 cmp r4 , 0x0 moveq r2 , r4 movne r2 , 0x2 mov r1 , r6 mov r0 , r8 bl 0xfffff150 str r0 , [ sb ] adds r0 , r0 , 0x0 movne r0 , 0x1 pop { r4 , r5 , r6 , r7 , r8 , sb , sl , pc } cmp sb , 0x0 beq 0xbc mov r3 , 0x0 str r3 , [ sb ] mov r0 , 0x1 pop { r4 , r5 , r6 , r7 , r8 , sb , sl , pc } mov r0 , 0x1 pop { r4 , r5 , r6 , r7 , r8 , sb , sl , pc }
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly codes show fundamental differences in architecture, structure, and logic. Code1 is x86-64 assembly with complex string comparisons (repe cmpsb), multi-register operations, and stack-heavy procedures. Code2 is ARM assembly featuring unified push/pop operations, conditional execution (cmpne/moveq), and different calling conventions. There's no alignment in control flow patterns, register usage, or algorithmic approach. The architectural differences (x86 vs ARM) alone make direct similarity impossible, and no significant overlapping logic or instruction patterns exist between the codes.
------------------------------------------------------------

------------------------------------------------------------
Code1: push r15 push r14 push r13 push r12 push rbp push rbx sub rsp , 0xf8 mov rax , qword ptr fs : [ 0x28 ] mov qword ptr [ rsp + 0xe8 ] , rax xor eax , eax mov qword ptr [ rsp + 0x10 ] , 0x0 mov qword ptr [ rsp + 0x18 ] , 0x0 mov qword ptr [ rsp + 0x20 ] , 0x0 mov qword ptr [ rsp + 0x28 ] , 0x0 test rdi , rdi je 0x51d mov rbp , rdi mov rcx , qword ptr [ rdi ] test rcx , rcx je 0x525 lea rax , [ rsp + 0x30 ] lea rdx , [ rsp + 0xe0 ] mov qword ptr [ rax + 0x8 ] , 0x0 mov qword ptr [ rax ] , 0x0 add rax , 0x10 cmp rdx , rax jne 0x6d mov rdi , qword ptr [ rcx + 0x110 ] test rdi , rdi je 0x137 mov rdx , rcx jmp 0xa0 mov rdx , rdi mov rdi , rax mov esi , dword ptr [ rdx + 0x14 ] mov rax , qword ptr [ rdi + 0x110 ] test rax , rax jne 0x9a add rdx , 0x110 cmp dword ptr [ rdi + 0x10 ] , 0x3 jne 0x147 test byte ptr [ rip + 0x23e080 ] , 0x9 je 0x108 mov rcx , qword ptr [ rip + 0x23d657 ] mov edx , 0x16 mov esi , 0x1 lea rdi , [ rip + 0x2bec8 ] call 0xffffffffffffbd07 mov edx , 0x0 mov rsi , qword ptr [ rbp ] mov rdi , qword ptr [ rip + 0x23d631 ] call 0xfffffffffffffa22 mov rcx , qword ptr [ rbp ] test rcx , rcx je 0x4d3 mov r13d , 0x0 cmp dword ptr [ rcx + 0x10 ] , 0x3 je 0x15a mov r14d , 0x0 lea rax , [ rsp + 0x10 ] mov qword ptr [ rsp ] , rax lea rax , [ rsp + 0x20 ] mov qword ptr [ rsp + 0x8 ] , rax lea r15 , [ rsp + 0x30 ] jmp 0x439 mov rdx , rbp mov rdi , rcx mov esi , 0x3 jmp 0xb6 call 0xfffffffffffff35c test byte ptr [ rip + 0x23dff4 ] , 0x9 je 0xfb jmp 0xc9 mov r13d , dword ptr [ rcx + 0x14 ] jmp 0x114 cmp dword ptr [ rbx + 0x14 ] , r13d je 0x450 mov rdx , rbp mov esi , r13d mov rdi , rbx call 0xfffffffffffff35c mov rbx , rax jmp 0x450 cmp r13d , 0x1 je 0x425 cmp byte ptr [ r12 + 0x18 ] , 0x0 jne 0x4af mov rax , qword ptr [ r12 ] cmp rax , qword ptr [ rip + 0x23cace ] sete dl cmp rax , qword ptr [ rip + 0x23cb14 ] sete cl or edx , ecx cmp rax , qword ptr [ rip + 0x23caa8 ] sete cl or dl , cl jne 0x1c7 cmp rax , qword ptr [ rip + 0x23ca5a ] jne 0x206 test byte ptr [ rip + 0x23df79 ] , 0x8 jne 0x2d4 mov rax , qword ptr [ rbx + 0x110 ] mov qword ptr [ rbp ] , rax mov rax , qword ptr [ rsp + 0x20 ] mov qword ptr [ rbx + 0x110 ] , rax mov qword ptr [ rsp + 0x20 ] , rbx cmp qword ptr [ rsp + 0x28 ] , 0x0 jne 0x439 mov qword ptr [ rsp + 0x28 ] , rbx jmp 0x439 movzx edx , word ptr [ rip + 0x23df62 ] cmp rax , qword ptr [ rip + 0x23cabb ] sete cl cmp rax , qword ptr [ rip + 0x23ca69 ] sete sil or ecx , esi test dx , dx sete sil or ecx , esi cmp rax , qword ptr [ rip + 0x23ca6b ] sete sil or cl , sil jne 0x246 cmp rax , qword ptr [ rip + 0x23c9c3 ] jne 0x2c3 cmp rax , qword ptr [ rip + 0x23ca62 ] je 0x32d cmp dx , 0x1 jbe 0x26a mov eax , dword ptr [ r12 + 0x20 ] sub eax , 0x1 cmp eax , 0x1 jbe 0x35f cmp dx , 0x2 jbe 0x432 test byte ptr [ rip + 0x23decc ] , 0x8 jne 0x370 mov rax , qword ptr [ rbx + 0x118 ] mov edx , dword ptr [ rax + 0x20 ] mov eax , edx shl rax , 0x4 lea rcx , [ r15 + rax ] mov rsi , qword ptr [ rbx + 0x110 ] mov qword ptr [ rbp ] , rsi mov rsi , qword ptr [ rcx ] mov qword ptr [ rbx + 0x110 ] , rsi mov qword ptr [ rcx ] , rbx cmp qword ptr [ rsp + rax + 0x38 ] , 0x0 jne 0x439 mov qword ptr [ rsp + rax + 0x38 ] , rbx jmp 0x439 cmp dword ptr [ r12 + 0x20 ] , 0x0 jne 0x246 jmp 0x1c7 movzx ecx , word ptr [ rip + 0x23de94 ] lea rdx , [ rip + 0x2c325 ] mov esi , 0x1 mov rdi , qword ptr [ rip + 0x23d439 ] mov eax , 0x0 call 0xffffffffffffbd17 mov rsi , qword ptr [ rbx + 0x118 ] mov rdi , qword ptr [ rip + 0x23d421 ] call 0xfffffffffffff4b5 mov rcx , qword ptr [ rip + 0x23d415 ] mov edx , 0x10 mov esi , 0x1 lea rdi , [ rip + 0x2bc9d ] call 0xffffffffffffbd07 jmp 0x1d4 mov rax , qword ptr [ rbx + 0x110 ] mov qword ptr [ rbp ] , rax mov rax , qword ptr [ rsp + 0x10 ] mov qword ptr [ rbx + 0x110 ] , rax mov qword ptr [ rsp + 0x10 ] , rbx cmp qword ptr [ rsp + 0x18 ] , 0x0 jne 0x439 mov qword ptr [ rsp + 0x18 ] , rbx jmp 0x439 cmp byte ptr [ r12 + 0x1a ] , 0x0 je 0x274 jmp 0x26a movzx ecx , dx lea rdx , [ rip + 0x2bc57 ] mov esi , 0x1 mov rdi , qword ptr [ rip + 0x23d3a1 ] mov eax , 0x0 call 0xffffffffffffbd17 mov rsi , qword ptr [ rbx + 0x118 ] mov rdi , qword ptr [ rip + 0x23d389 ] call 0xfffffffffffff4b5 mov rax , qword ptr [ rbx + 0x118 ] mov ecx , dword ptr [ rax + 0x20 ] cmp ecx , dword ptr [ rip + 0x23cd34 ] je 0x3da lea rdx , [ rip + 0x23cd3b ] mov eax , 0x1 cmp ecx , dword ptr [ rdx ] je 0x3df add eax , 0x1 add rdx , 0x10 cmp eax , 0xb jne 0x3c1 lea rcx , [ rip + 0x2bb2e ] jmp 0x3f1 mov eax , 0x0 mov eax , eax shl rax , 0x4 lea rdx , [ rip + 0x23ccfb ] mov rcx , qword ptr [ rdx + rax + 0x8 ] lea rdx , [ rip + 0x2bbf7 ] mov esi , 0x1 mov rdi , qword ptr [ rip + 0x23d323 ] mov eax , 0x0 call 0xffffffffffffbd17 jmp 0x281 lea rdi , [ r12 + 0x118 ] call 0x0 mov byte ptr [ r12 + 0x18 ] , al mov rax , qword ptr [ rbx + 0x118 ] cmp byte ptr [ rax + 0x18 ] , 0x0 jne 0x4af lea rbp , [ rbx + 0x110 ] mov rbx , qword ptr [ rbp ] test rbx , rbx je 0x4d9 cmp dword ptr [ rbx + 0x10 ] , 0x3 je 0x160 mov r12 , qword ptr [ rbx + 0x118 ] mov eax , dword ptr [ r12 + 0x10 ] cmp eax , 0x2 je 0x413 cmp eax , 0x2 jb 0x180 cmp eax , 0x3 jne 0x482 lea rdi , [ rbx + 0x118 ] call 0x0 mov byte ptr [ r12 + 0x18 ] , al jmp 0x425 mov edx , 0x5 lea rsi , [ rip + 0x2bfe9 ] mov edi , 0x0 call 0xffffffffffffb6f7 mov rdx , rax mov esi , 0x0 mov edi , 0x1 mov eax , 0x0 call 0xffffffffffffbbd7 mov r8 , rbp mov rcx , qword ptr [ rsp ] mov rdx , qword ptr [ rsp + 0x8 ] mov esi , 0xb mov rdi , r15 call 0xffffffffffffff8f mov r14d , 0x1 jmp 0x432 mov r14d , 0x0 lea rcx , [ rsp + 0x10 ] lea rdx , [ rsp + 0x20 ] lea rdi , [ rsp + 0x30 ] mov r8 , rbp mov esi , 0xb call 0xffffffffffffff8f mov eax , r14d mov rsi , qword ptr [ rsp + 0xe8 ] xor rsi , qword ptr fs : [ 0x28 ] jne 0x52d add rsp , 0xf8 pop rbx pop rbp pop r12 pop r13 pop r14 pop r15 ret mov r14d , 0x0 jmp 0x4f5 mov r14d , 0x0 jmp 0x4f5 call 0xffffffffffffb747
Code2: push ebp mov ebp , esp push esi sub esp , 0xf4 mov eax , dword ptr [ ebp + 0x8 ] xor ecx , ecx lea edx , [ ebp - 0x10 ] mov dword ptr [ esp ] , edx mov dword ptr [ esp + 0x4 ] , 0x0 mov dword ptr [ esp + 0x8 ] , 0x8 mov dword ptr [ ebp - 0x9c ] , eax mov dword ptr [ ebp - 0xa0 ] , ecx call 0xffff7420 lea eax , [ ebp - 0x18 ] mov dword ptr [ esp ] , eax mov dword ptr [ esp + 0x4 ] , 0x0 mov dword ptr [ esp + 0x8 ] , 0x8 call 0xffff7420 mov byte ptr [ ebp - 0x89 ] , 0x0 cmp dword ptr [ ebp + 0x8 ] , 0x0 je 0x6e mov eax , dword ptr [ ebp + 0x8 ] cmp dword ptr [ eax ] , 0x0 jne 0x77 mov byte ptr [ ebp - 0x5 ] , 0x0 jmp 0x5f3 mov dword ptr [ ebp - 0x74 ] , 0x0 cmp dword ptr [ ebp - 0x74 ] , 0xb jge 0xa9 mov eax , dword ptr [ ebp - 0x74 ] shl eax , 0x3 lea ecx , [ ebp - 0x70 ] add ecx , eax mov dword ptr [ esp ] , ecx call 0x2c30 mov eax , dword ptr [ ebp - 0x74 ] add eax , 0x1 mov dword ptr [ ebp - 0x74 ] , eax jmp 0x7e mov eax , dword ptr [ ebp + 0x8 ] mov dword ptr [ ebp - 0x7c ] , eax mov dword ptr [ ebp - 0x90 ] , 0x3 mov eax , dword ptr [ ebp - 0x7c ] mov eax , dword ptr [ eax ] mov dword ptr [ ebp - 0x78 ] , eax mov eax , dword ptr [ ebp - 0x78 ] cmp dword ptr [ eax + 0x9c ] , 0x0 je 0xf9 mov eax , dword ptr [ ebp - 0x78 ] add eax , 0x9c mov dword ptr [ ebp - 0x7c ] , eax mov eax , dword ptr [ ebp - 0x78 ] mov eax , dword ptr [ eax + 0xc ] mov dword ptr [ ebp - 0x90 ] , eax mov eax , dword ptr [ ebp - 0x78 ] mov eax , dword ptr [ eax + 0x9c ] mov dword ptr [ ebp - 0x78 ] , eax jmp 0xc1 mov eax , dword ptr [ ebp - 0x78 ] cmp dword ptr [ eax + 0x8 ] , 0x3 je 0x128 mov eax , dword ptr [ ebp - 0x78 ] mov ecx , dword ptr [ ebp - 0x90 ] mov edx , dword ptr [ ebp - 0x7c ] mov dword ptr [ esp ] , eax mov dword ptr [ esp + 0x4 ] , ecx mov dword ptr [ esp + 0x8 ] , edx call 0x11c0 mov dword ptr [ ebp - 0xa4 ] , eax mov eax , dword ptr [ 0x80ed27c ] and eax , 0x9 cmp eax , 0x0 je 0x17d mov eax , dword ptr [ 0x80ec8d0 ] mov dword ptr [ esp ] , eax lea eax , [ 0x80d14ab ] mov dword ptr [ esp + 0x4 ] , eax call 0x2c70 xor ecx , ecx mov edx , dword ptr [ 0x80ec8d0 ] mov esi , dword ptr [ ebp + 0x8 ] mov esi , dword ptr [ esi ] mov dword ptr [ esp ] , edx mov dword ptr [ esp + 0x4 ] , esi mov dword ptr [ esp + 0x8 ] , 0x0 mov dword ptr [ ebp - 0xa8 ] , eax mov dword ptr [ ebp - 0xac ] , ecx call 0x2cc0 mov eax , dword ptr [ ebp + 0x8 ] mov dword ptr [ ebp - 0x7c ] , eax mov dword ptr [ ebp - 0x94 ] , 0x0 mov eax , dword ptr [ ebp - 0x7c ] cmp dword ptr [ eax ] , 0x0 je 0x1b6 mov eax , dword ptr [ ebp - 0x7c ] mov eax , dword ptr [ eax ] cmp dword ptr [ eax + 0x8 ] , 0x3 jne 0x1b6 mov eax , dword ptr [ ebp - 0x7c ] mov eax , dword ptr [ eax ] mov eax , dword ptr [ eax + 0xc ] mov dword ptr [ ebp - 0x94 ] , eax jmp 0x1bb mov eax , dword ptr [ ebp - 0x7c ] mov eax , dword ptr [ eax ] mov dword ptr [ ebp - 0x78 ] , eax cmp eax , 0x0 je 0x5b9 mov eax , dword ptr [ ebp - 0x78 ] cmp dword ptr [ eax + 0x8 ] , 0x3 jne 0x20f mov eax , dword ptr [ ebp - 0x78 ] mov eax , dword ptr [ eax + 0xc ] cmp eax , dword ptr [ ebp - 0x94 ] je 0x20a mov eax , dword ptr [ ebp - 0x78 ] mov ecx , dword ptr [ ebp - 0x94 ] mov edx , dword ptr [ ebp - 0x7c ] mov dword ptr [ esp ] , eax mov dword ptr [ esp + 0x4 ] , ecx mov dword ptr [ esp + 0x8 ] , edx call 0x11c0 mov dword ptr [ ebp - 0x78 ] , eax jmp 0x20f mov eax , dword ptr [ ebp - 0x78 ] mov eax , dword ptr [ eax + 0xa0 ] mov eax , dword ptr [ eax + 0x8 ] mov dword ptr [ ebp - 0x88 ] , eax mov eax , dword ptr [ ebp - 0x78 ] mov eax , dword ptr [ eax + 0xa0 ] mov eax , dword ptr [ eax ] mov dword ptr [ ebp - 0x84 ] , eax mov eax , dword ptr [ ebp - 0x88 ] mov ecx , eax sub ecx , 0x2 mov dword ptr [ ebp - 0xb0 ] , eax mov dword ptr [ ebp - 0xb4 ] , ecx jb 0x288 jmp 0x254 mov eax , dword ptr [ ebp - 0xb0 ] sub eax , 0x2 mov dword ptr [ ebp - 0xb8 ] , eax je 0x4df jmp 0x26e mov eax , dword ptr [ ebp - 0xb0 ] sub eax , 0x3 mov dword ptr [ ebp - 0xbc ] , eax je 0x508 jmp 0x52b cmp dword ptr [ ebp - 0x94 ] , 0x1 jne 0x29a jmp 0x559 mov eax , dword ptr [ ebp - 0x78 ] mov eax , dword ptr [ eax + 0xa0 ] test byte ptr [ eax + 0x10 ] , 0x1 jne 0x4da mov eax , dword ptr [ ebp - 0x78 ] mov eax , dword ptr [ eax + 0xa0 ] mov dword ptr [ esp ] , eax call 0x2d10 test al , 0x1 jne 0x2cb jmp 0x35a mov eax , dword ptr [ 0x80ed27c ] and eax , 0x8 cmp eax , 0x0 je 0x33c mov eax , dword ptr [ 0x80ec8d0 ] movzx ecx , word ptr [ 0x80ed294 ] mov dword ptr [ esp ] , eax lea eax , [ 0x80d14c2 ] mov dword ptr [ esp + 0x4 ] , eax mov dword ptr [ esp + 0x8 ] , ecx call 0xffff7400 mov ecx , dword ptr [ 0x80ec8d0 ] mov edx , dword ptr [ ebp - 0x78 ] mov edx , dword ptr [ edx + 0xa0 ] mov dword ptr [ esp ] , ecx mov dword ptr [ esp + 0x4 ] , edx mov dword ptr [ ebp - 0xc0 ] , eax call 0xffffe8c0 mov eax , dword ptr [ 0x80ec8d0 ] mov dword ptr [ esp ] , eax lea eax , [ 0x80d14e3 ] mov dword ptr [ esp + 0x4 ] , eax call 0xffff7400 mov dword ptr [ ebp - 0xc4 ] , eax mov eax , dword ptr [ ebp - 0x78 ] mov ecx , dword ptr [ ebp - 0x7c ] lea edx , [ ebp - 0x18 ] mov dword ptr [ esp ] , edx mov dword ptr [ esp + 0x4 ] , eax mov dword ptr [ esp + 0x8 ] , ecx call 0x1400 jmp 0x1bb lea eax , [ 0x804dc10 ] cmp dword ptr [ ebp - 0x84 ] , eax jne 0x38a mov eax , dword ptr [ ebp - 0x78 ] mov ecx , dword ptr [ ebp - 0x7c ] lea edx , [ ebp - 0x10 ] mov dword ptr [ esp ] , edx mov dword ptr [ esp + 0x4 ] , eax mov dword ptr [ esp + 0x8 ] , ecx call 0x1400 jmp 0x1bb movzx eax , word ptr [ 0x80ed294 ] cmp eax , 0x1 jle 0x3e3 mov eax , dword ptr [ ebp - 0x78 ] mov eax , dword ptr [ eax + 0xa0 ] mov ecx , 0x2 cmp ecx , dword ptr [ eax + 0x18 ] je 0x3c8 mov eax , dword ptr [ ebp - 0x78 ] mov eax , dword ptr [ eax + 0xa0 ] mov ecx , 0x1 cmp ecx , dword ptr [ eax + 0x18 ] jne 0x3e3 mov eax , dword ptr [ ebp - 0x78 ] mov eax , dword ptr [ eax + 0xa0 ] test byte ptr [ eax + 0x12 ] , 0x1 mov cl , 0x1 mov byte ptr [ ebp - 0xc5 ] , cl je 0x3f6 movzx eax , word ptr [ 0x80ed294 ] cmp eax , 0x2 setg cl mov byte ptr [ ebp - 0xc5 ] , cl mov al , byte ptr [ ebp - 0xc5 ] and al , 0x1 mov byte ptr [ ebp - 0x95 ] , al test byte ptr [ ebp - 0x95 ] , 0x1 je 0x4d5 mov eax , dword ptr [ 0x80ed27c ] and eax , 0x8 cmp eax , 0x0 je 0x4a6 mov eax , dword ptr [ 0x80ec8d0 ] movzx ecx , word ptr [ 0x80ed294 ] mov dword ptr [ esp ] , eax lea eax , [ 0x80d14f4 ] mov dword ptr [ esp + 0x4 ] , eax mov dword ptr [ esp + 0x8 ] , ecx call 0xffff7400 mov ecx , dword ptr [ 0x80ec8d0 ] mov edx , dword ptr [ ebp - 0x78 ] mov edx , dword ptr [ edx + 0xa0 ] mov dword ptr [ esp ] , ecx mov dword ptr [ esp + 0x4 ] , edx mov dword ptr [ ebp - 0xcc ] , eax call 0x2d50 mov eax , dword ptr [ 0x80ec8d0 ] mov ecx , dword ptr [ ebp - 0x78 ] mov ecx , dword ptr [ ecx + 0xa0 ] mov ecx , dword ptr [ ecx + 0x18 ] mov dword ptr [ esp ] , ecx mov dword ptr [ ebp - 0xd0 ] , eax call 0xc10 mov ecx , dword ptr [ ebp - 0xd0 ] mov dword ptr [ esp ] , ecx lea ecx , [ 0x80d1512 ] mov dword ptr [ esp + 0x4 ] , ecx mov dword ptr [ esp + 0x8 ] , eax call 0xffff7400 mov dword ptr [ ebp - 0xd4 ] , eax mov eax , dword ptr [ ebp - 0x78 ] mov eax , dword ptr [ eax + 0xa0 ] mov eax , dword ptr [ eax + 0x18 ] shl eax , 0x3 lea ecx , [ ebp - 0x70 ] add ecx , eax mov eax , dword ptr [ ebp - 0x78 ] mov edx , dword ptr [ ebp - 0x7c ] mov dword ptr [ esp ] , ecx mov dword ptr [ esp + 0x4 ] , eax mov dword ptr [ esp + 0x8 ] , edx call 0x1400 jmp 0x1bb jmp 0x4da jmp 0x559 mov eax , dword ptr [ ebp - 0x78 ] mov eax , dword ptr [ eax + 0xa0 ] add eax , 0xa0 mov dword ptr [ esp ] , eax call 0x2d90 mov ecx , dword ptr [ ebp - 0x78 ] mov ecx , dword ptr [ ecx + 0xa0 ] and al , 0x1 mov byte ptr [ ecx + 0x10 ] , al jmp 0x559 mov eax , dword ptr [ ebp - 0x78 ] add eax , 0xa0 mov dword ptr [ esp ] , eax call 0x0 mov ecx , dword ptr [ ebp - 0x78 ] mov ecx , dword ptr [ ecx + 0xa0 ] and al , 0x1 mov byte ptr [ ecx + 0x10 ] , al jmp 0x559 lea eax , [ 0x80d1374 ] mov dword ptr [ esp ] , eax call 0x2dd0 xor ecx , ecx mov dword ptr [ esp ] , 0x1 mov dword ptr [ esp + 0x4 ] , 0x0 mov dword ptr [ esp + 0x8 ] , eax mov dword ptr [ ebp - 0xd8 ] , ecx call 0xffff7290 mov eax , dword ptr [ ebp - 0x78 ] mov eax , dword ptr [ eax + 0xa0 ] mov cl , byte ptr [ eax + 0x10 ] and cl , 0x1 movzx eax , cl cmp eax , 0x1 jne 0x5a9 lea eax , [ ebp - 0x70 ] mov ecx , dword ptr [ ebp - 0x7c ] mov dword ptr [ ebp - 0x80 ] , ecx mov ecx , dword ptr [ ebp - 0x80 ] mov dword ptr [ esp ] , eax mov dword ptr [ esp + 0x4 ] , 0xb lea eax , [ ebp - 0x18 ] mov dword ptr [ esp + 0x8 ] , eax lea eax , [ ebp - 0x10 ] mov dword ptr [ esp + 0xc ] , eax mov dword ptr [ esp + 0x10 ] , ecx call 0x2e30 mov byte ptr [ ebp - 0x89 ] , 0x1 mov eax , dword ptr [ ebp - 0x78 ] add eax , 0x9c mov dword ptr [ ebp - 0x7c ] , eax jmp 0x1bb lea eax , [ ebp - 0x70 ] mov ecx , dword ptr [ ebp - 0x7c ] mov dword ptr [ ebp - 0x80 ] , ecx mov ecx , dword ptr [ ebp - 0x80 ] mov dword ptr [ esp ] , eax mov dword ptr [ esp + 0x4 ] , 0xb lea eax , [ ebp - 0x18 ] mov dword ptr [ esp + 0x8 ] , eax lea eax , [ ebp - 0x10 ] mov dword ptr [ esp + 0xc ] , eax mov dword ptr [ esp + 0x10 ] , ecx call 0x1470 mov dl , byte ptr [ ebp - 0x89 ] and dl , 0x1 mov byte ptr [ ebp - 0x5 ] , dl mov al , byte ptr [ ebp - 0x5 ] and al , 0x1 movzx eax , al add esp , 0xf4 pop esi pop ebp ret nop word ptr cs : [ eax + eax ] nop
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly codes show fundamental architectural differences: the first uses 64-bit registers (rax, rdi, rsp) and x86-64 instructions (qword ptr), while the second uses 32-bit registers (ebp, esp, eax) and x86 instructions (dword ptr). Their stack management differs significantly (rsp vs esp adjustments), memory access patterns are incompatible, and control flow structures show no meaningful alignment. The calling conventions (register-based vs stack-based parameter passing) and instruction sets are entirely distinct, indicating these are different implementations for different architectures with no functional similarity.
------------------------------------------------------------

------------------------------------------------------------
Code1: mov eax , dword ptr [ rip ] test eax , eax jne 0xe0 movaps xmm0 , xmmword ptr [ rip ] xorps xmm0 , xmmword ptr [ rip ] movaps xmmword ptr [ rip ] , xmm0 movaps xmm0 , xmmword ptr [ rip ] xorps xmm0 , xmmword ptr [ rip ] movaps xmmword ptr [ rip ] , xmm0 movaps xmm0 , xmmword ptr [ rip ] xorps xmm0 , xmmword ptr [ rip ] movaps xmmword ptr [ rip ] , xmm0 movaps xmm0 , xmmword ptr [ rip ] xorps xmm0 , xmmword ptr [ rip ] movaps xmmword ptr [ rip ] , xmm0 mov al , byte ptr [ rip ] xor al , 0x59 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x30 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x36 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xa1 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xa5 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xb5 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xcc mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xb4 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xa8 mov byte ptr [ rip ] , al push rbp mov rbp , rsp push r15 push r14 push r13 push r12 push rbx push rax mov dword ptr [ rip ] , 0x1 mov rax , rsp lea r13 , [ rax - 0xd0 ] mov rsp , r13 mov r15 , rsp add r15 , - 0x40 mov rsp , r15 mov r14 , rsp add r14 , - 0x1a0 mov rsp , r14 mov rcx , rsp lea r12 , [ rcx - 0x10 ] mov rsp , r12 mov rdx , rsp lea rbx , [ rdx - 0x40 ] mov rsp , rbx mov byte ptr [ rcx - 0x10 ] , 0xa3 movaps xmm0 , xmmword ptr [ rip ] movaps xmmword ptr [ rdx - 0x10 ] , xmm0 movaps xmm0 , xmmword ptr [ rip ] movaps xmmword ptr [ rdx - 0x20 ] , xmm0 movaps xmm0 , xmmword ptr [ rip ] movaps xmmword ptr [ rdx - 0x30 ] , xmm0 movaps xmm0 , xmmword ptr [ rip ] movaps xmmword ptr [ rdx - 0x40 ] , xmm0 movabs rcx , 0xa3a3a3a3a3a3a3a3 mov qword ptr [ rax - 0x10 ] , rcx movaps xmm0 , xmmword ptr [ rip ] movaps xmmword ptr [ rax - 0x20 ] , xmm0 movaps xmmword ptr [ rax - 0x30 ] , xmm0 movaps xmmword ptr [ rax - 0x40 ] , xmm0 movaps xmmword ptr [ rax - 0x50 ] , xmm0 movaps xmmword ptr [ rax - 0x60 ] , xmm0 movaps xmmword ptr [ rax - 0x70 ] , xmm0 movaps xmmword ptr [ rax - 0x80 ] , xmm0 movaps xmmword ptr [ rax - 0x90 ] , xmm0 movaps xmmword ptr [ rax - 0xa0 ] , xmm0 movaps xmmword ptr [ rax - 0xb0 ] , xmm0 movaps xmmword ptr [ rax - 0xc0 ] , xmm0 movaps xmmword ptr [ rax - 0xd0 ] , xmm0 mov rdi , r14 call 0x1bc mov edx , 0xc8 mov rdi , r14 mov rsi , r13 call 0x1cc mov rdi , r14 mov rsi , r15 call 0x1d7 mov esi , 0x40 mov ecx , 0x40 mov r8d , 0x0 mov rdi , r15 mov rdx , rbx xor r9d , r9d call 0x1f5 mov ecx , 0x5 test eax , eax jne 0x2ca mov rdi , r14 call 0x20a mov edx , 0x64 mov rdi , r14 mov rsi , r13 call 0x21a add r13 , 0x64 mov edx , 0x64 mov rdi , r14 mov rsi , r13 call 0x22e mov rdi , r14 mov rsi , r15 call 0x239 mov esi , 0x40 mov ecx , 0x40 mov r8d , 0x0 mov rdi , r15 mov rdx , rbx mov r9d , 0x1 call 0x25a mov ecx , 0x5 test eax , eax jne 0x2ca mov r13 , rbx mov rdi , r14 call 0x26e mov ebx , 0xffffff38 nop word ptr cs : [ rax + rax ] nop dword ptr [ rax ] mov edx , 0x1 mov rdi , r14 mov rsi , r12 call 0x290 inc ebx jne 0x280 mov rdi , r14 mov rsi , r15 call 0x29f mov esi , 0x40 mov ecx , 0x40 mov r8d , 0x0 mov rdi , r15 mov rdx , r13 mov r9d , 0x2 call 0x2c0 xor ecx , ecx test eax , eax setne cl lea ecx , [ rcx + rcx * 0x4 ] mov eax , ecx lea rsp , [ rbp - 0x28 ] pop rbx pop r12 pop r13 pop r14 pop r15 pop rbp ret nop dword ptr [ rax + rax ]
Code2: push ebp push edi mov ecx , 0x32 push esi push ebx call 0xa add ebx , 0x2 sub esp , 0x30c lea ebp , [ esp + 0x234 ] mov byte ptr [ esp + 0x13 ] , 0xa3 mov dword ptr [ esp + 0x1f4 ] , 0xd2fa6de7 mov eax , dword ptr gs : [ 0x14 ] mov dword ptr [ esp + 0x2fc ] , eax xor eax , eax mov edi , ebp mov eax , 0xa3a3a3a3 mov dword ptr [ esp + 0x1f8 ] , 0xb1a88420 rep stosd dword ptr es : [ edi ] , eax mov dword ptr [ esp + 0x1fc ] , 0x2fcf7f46 mov dword ptr [ esp + 0x200 ] , 0x1b3658fa sub esp , 0xc mov dword ptr [ esp + 0x210 ] , 0xed2876ec mov dword ptr [ esp + 0x214 ] , 0xc0fdf3f5 mov dword ptr [ esp + 0x218 ] , 0xc45d80e4 mov dword ptr [ esp + 0x21c ] , 0xa8ecae8c mov dword ptr [ esp + 0x220 ] , 0xc3137c1b mov dword ptr [ esp + 0x224 ] , 0xa352df0a mov dword ptr [ esp + 0x228 ] , 0x73849565 mov dword ptr [ esp + 0x22c ] , 0x6bf42d9a mov dword ptr [ esp + 0x230 ] , 0x1cc589e5 mov dword ptr [ esp + 0x234 ] , 0x41a8a4a1 mov dword ptr [ esp + 0x238 ] , 0x5a54f66d mov dword ptr [ esp + 0x23c ] , 0xbae81c lea esi , [ esp + 0x20 ] push esi call 0xf7 add esp , 0xc push 0xc8 push ebp push esi call 0x106 pop eax pop edx lea edi , [ esp + 0x1bc ] mov dword ptr [ esp + 0x10 ] , edi push edi push esi call 0x11a pop ecx pop eax lea edx , [ ebx ] push 0x0 mov dword ptr [ esp + 0x10 ] , edx push edx push 0x40 lea ecx , [ esp + 0x208 ] mov dword ptr [ esp + 0x20 ] , ecx push ecx push 0x40 push edi call 0x13f add esp , 0x20 test eax , eax jne 0x258 sub esp , 0xc push esi call 0x153 add esp , 0xc push 0x64 push ebp push esi call 0x15f add esp , 0xc push 0x64 lea ebp , [ esp + 0x2a0 ] push ebp push esi call 0x172 pop ecx pop edi mov edi , dword ptr [ esp + 0x10 ] push edi push esi call 0x17f pop ebp pop eax push 0x1 push dword ptr [ esp + 0x10 ] push 0x40 push dword ptr [ esp + 0x20 ] push 0x40 push edi call 0x195 add esp , 0x20 test eax , eax jne 0x258 sub esp , 0xc mov ebp , 0xc8 push esi call 0x1ae add esp , 0x10 lea edi , [ esp + 0x13 ] lea esi , [ esi ] sub esp , 0x4 push 0x1 push edi push esi call 0x1c8 add esp , 0xc push 0x1 push edi push esi call 0x1d4 add esp , 0xc push 0x1 push edi push esi call 0x1e0 add esp , 0xc push 0x1 push edi push esi call 0x1ec add esp , 0xc push 0x1 push edi push esi call 0x1f8 add esp , 0xc push 0x1 push edi push esi call 0x204 add esp , 0xc push 0x1 push edi push esi call 0x210 add esp , 0xc push 0x1 push edi push esi call 0x21c add esp , 0x10 sub ebp , 0x8 jne 0x1c0 sub esp , 0x8 mov ebp , dword ptr [ esp + 0x10 ] push ebp push esi call 0x232 pop eax pop edx push 0x2 push dword ptr [ esp + 0x10 ] push 0x40 push dword ptr [ esp + 0x20 ] push 0x40 push ebp call 0x248 add esp , 0x20 test eax , eax je 0x25d nop lea esi , [ esi ] mov eax , 0x5 mov edx , dword ptr [ esp + 0x2fc ] xor edx , dword ptr gs : [ 0x14 ] jne 0x278 add esp , 0x30c pop ebx pop esi pop edi pop ebp ret call 0x279 lea esi , [ esi ]
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly codes show significant differences in architecture, structure, and operations:
1. Architecture: Code1 uses 64-bit registers (rax, rsp, rbp) and SSE instructions (movaps, xorps), while Code2 uses 32-bit registers (eax, esp, ebp) with no SSE operations.
2. Core Operations: 
   - Code1 features a distinct sequence of byte-level XOR operations (e.g., `xor al, 0x59`) and complex stack manipulation with repeated `movaps` memory operations.
   - Code2 focuses on DWORD-sized memory writes and different function call patterns, including a loop structure not present in Code1.
3. Stack/Frame Management: Code1 uses multi-layer stack adjustment (r13/r15/r14) and preserves more registers (r15-r12), while Code2 uses simpler ESP-based adjustments.
4. Security Features: Code2 includes a stack canary check (`gs:[0x14]`), absent in Code1.
5. Memory Patterns: Code1 initializes memory with `xmmword` values and uses RIP-relative addressing, whereas Code2 uses absolute values and different addressing modes.

These fundamental differences in design, instructions, and behavior indicate no meaningful similarity between the codes.
------------------------------------------------------------

------------------------------------------------------------
Code1: push ebp mov ebp , esp sub esp , 0x28 mov dword ptr [ ebp - 0x4 ] , 0x1 mov eax , dword ptr [ 0x80ed090 ] mov ecx , dword ptr [ 0x80ed094 ] mov dword ptr [ esp ] , eax mov dword ptr [ esp + 0x4 ] , ecx call 0x520 mov dword ptr [ ebp - 0x8 ] , eax cmp dword ptr [ ebp - 0x8 ] , 0x0 jl 0x6a mov dword ptr [ ebp - 0x4 ] , 0x0 lea eax , [ 0x80d4c01 ] mov dword ptr [ esp ] , eax call 0xfffe1400 xor ecx , ecx mov edx , dword ptr [ ebp - 0x8 ] mov dword ptr [ esp ] , 0x0 mov dword ptr [ esp + 0x4 ] , 0x0 mov dword ptr [ esp + 0x8 ] , eax mov dword ptr [ esp + 0xc ] , edx mov dword ptr [ ebp - 0xc ] , ecx call 0xfffe1360 cmp dword ptr [ ebp - 0x4 ] , 0x0 je 0x79 jmp 0xa3 lea eax , [ 0x80d4c99 ] mov dword ptr [ esp ] , eax lea eax , [ 0x80d4ca2 ] mov dword ptr [ esp + 0x4 ] , eax mov dword ptr [ esp + 0x8 ] , 0x18c lea eax , [ 0x80d4cab ] mov dword ptr [ esp + 0xc ] , eax call 0x570 add esp , 0x28 pop ebp ret nop dword ptr [ eax + eax ]
Code2: push ebp push edi push esi push ebx call 0xfffe7f40 add ebx , 0x4af47 sub esp , 0x3c mov eax , dword ptr gs : [ 0x14 ] mov dword ptr [ esp + 0x2c ] , eax xor eax , eax mov edi , dword ptr [ ebx + 0x1004 ] mov ebp , dword ptr [ ebx + 0x1008 ] call 0xfffff8d0 test eax , eax mov esi , eax lea edx , [ esp + 0x1c ] js 0x90 xor eax , eax cmp esi , 0x7fffffff mov dword ptr [ esp + 0x1c ] , ebp setne al mov dword ptr [ esp + 0x20 ] , edi mov dword ptr [ esp + 0x24 ] , 0x0 add esi , eax mov dword ptr [ esp + 0x28 ] , 0xffffffff mov eax , esi call 0xfffffad0 mov esi , dword ptr [ esp + 0x28 ] test esi , esi jns 0xe1 mov eax , dword ptr [ esp + 0x2c ] xor eax , dword ptr gs : [ 0x14 ] jne 0x11f add esp , 0x3c pop ebx pop esi pop edi pop ebp ret lea esi , [ esi ] lea edi , [ edi ] mov dword ptr [ esp + 0xc ] , edx sub esp , 0xc push 0x4 call 0xfffe7380 pop edx pop ecx mov edx , dword ptr [ esp + 0x14 ] cmp eax , - 0x1 mov esi , eax mov eax , 0x14 cmove esi , eax push edx mov dword ptr [ esp + 0x18 ] , edx push 0x7 call 0xfffe7350 add esp , 0x10 test eax , eax mov edx , dword ptr [ esp + 0xc ] jne 0x39 mov eax , dword ptr [ esp + 0x1c ] mov ecx , dword ptr [ esp + 0x20 ] and ecx , eax cmp ecx , - 0x1 cmovne esi , eax jmp 0x39 push eax lea eax , [ ebx - 0x17e70 ] push 0x5 push eax push 0x0 call 0xfffe7330 push esi push eax push 0x0 push 0x0 call 0xfffe7540 lea eax , [ ebx - 0x17dd8 ] add esp , 0x20 push eax lea eax , [ ebx - 0x17e84 ] push 0x18c push eax lea eax , [ ebx - 0x17e7b ] push eax call 0xfffe79c0 call 0x2f260 nop nop nop nop nop nop
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two code snippets show fundamental structural differences:
1. Prologue/Epilogue: Code1 uses a standard stack frame (push ebp/mov ebp,esp/sub esp) with simple cleanup (add esp/pop ebp). Code2 has multi-register saves (push ebp/edi/esi/ebx), stack canary security (mov gs:[0x14]), and complex cleanup (add esp/multi-pop).
2. Function calls: Code1 calls fixed addresses (0x520, 0xfffe1400), while Code2 uses position-independent calls (0xfffff8d0, 0xfffe7380) via ebx-relative addressing.
3. Control flow: Code1 has simple conditional jumps (jl/je), while Code2 uses advanced flag manipulation (setne/cmove/cmovne).
4. Data handling: Code1 references absolute memory (0x80ed090), while Code2 uses ebx-relative offsets ([ebx+0x1004]).
The core logic, register usage, and instruction sequences show no meaningful overlap, indicating entirely different functionalities.
------------------------------------------------------------

------------------------------------------------------------
Code1: push { fp , lr } add fp , sp , 0x4 sub sp , sp , 0x8 str r0 , [ fp , - 0x8 ] ldr r3 , [ pc , 0xb8 ] add r3 , pc , r3 ldr r3 , [ r3 ] cmp r3 , 0x0 bne 0xa8 ldr r3 , [ pc , 0xa8 ] add r3 , pc , r3 ldr r3 , [ r3 ] cmp r3 , 0x0 bne 0x48 ldr r3 , [ pc , 0x98 ] add r3 , pc , r3 mov r0 , r3 bl 0xfff7dd4c ldr r3 , [ pc , 0x8c ] add r3 , pc , r3 ldr r3 , [ r3 ] mov r0 , r3 bl 0xfff7d7a0 ldr r3 , [ pc , 0x7c ] add r3 , pc , r3 ldr r3 , [ r3 ] cmp r3 , 0x0 bne 0x94 ldr r1 , [ fp , - 0x8 ] ldr r3 , [ pc , 0x68 ] add r3 , pc , r3 mov r0 , r3 bl 0xffffb9fc mov r2 , r0 ldr r3 , [ pc , 0x58 ] add r3 , pc , r3 str r2 , [ r3 ] ldr r3 , [ pc , 0x50 ] add r3 , pc , r3 ldr r3 , [ r3 ] mov r0 , r3 bl 0xfff7e154 ldr r3 , [ pc , 0x40 ] add r3 , pc , r3 ldr r3 , [ r3 ] cmp r3 , 0x0 movne r3 , 0x1 moveq r3 , 0x0 and r3 , r3 , 0xff mov r0 , r3 sub sp , fp , 0x4 pop { fp , pc } umaaleq sb , r2 , r0 , pc subeq sb , r2 , r0 , lsl 0x31 subeq sb , r2 , ip , ror 0x30 subeq sb , r2 , ip , asr pc subeq sb , r2 , r4 , asr 0x30 eorseq pc , r7 , r0 , asr 0x26 subeq sb , r2 , r8 , lsl pc subeq sb , r2 , r0 , lsl pc strdeq sb , sl , [ r2 ] , - 0xe8
Code2: push ebp mov ebp , esp push ebx sub esp , 0x4 call 0xfffa7b78 add ebx , 0x3394ac mov eax , dword ptr [ ebx + 0x53c0 ] test eax , eax jne 0x81 mov eax , dword ptr [ ebx + 0x53c4 ] test eax , eax jne 0x38 sub esp , 0xc lea eax , [ ebx + 0x53c4 ] push eax call 0xfffa5948 add esp , 0x10 mov eax , dword ptr [ ebx + 0x53c4 ] sub esp , 0xc push eax call 0xfffa5198 add esp , 0x10 mov eax , dword ptr [ ebx + 0x53c0 ] test eax , eax jne 0x6f sub esp , 0x8 push dword ptr [ ebp + 0x8 ] lea eax , [ ebx - 0xc0017 ] push eax call 0xffffcfab add esp , 0x10 mov dword ptr [ ebx + 0x53c0 ] , eax mov eax , dword ptr [ ebx + 0x53c4 ] sub esp , 0xc push eax call 0xfffa5e98 add esp , 0x10 mov eax , dword ptr [ ebx + 0x53c0 ] test eax , eax setne al movzx eax , al mov ebx , dword ptr [ ebp - 0x4 ] leave ret
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two code snippets are for different architectures (ARM and x86) and have no significant similarity in their instruction sequences, register usage, or control flow patterns beyond the common function prologue and epilogue. The number of function calls and branches also differ.
------------------------------------------------------------

------------------------------------------------------------
Code1: push rbp mov rbp , rsp sub rsp , 0x20 mov dword ptr [ rbp - 0x4 ] , edi mov qword ptr [ rbp - 0x10 ] , rsi mov qword ptr [ rbp - 0x18 ] , rdx mov edi , dword ptr [ rbp - 0x4 ] mov rsi , qword ptr [ rbp - 0x10 ] mov rdx , qword ptr [ rbp - 0x18 ] mov ecx , 0x100 call 0xcd0 add rsp , 0x20 pop rbp ret nop
Code2: lui gp , 0x44 addiu gp , gp , 0xf0 lw t9 , - 0x7bcc ( gp ) jr t9 addiu a3 , zero , 0x100
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two code snippets are fundamentally dissimilar due to architectural differences. The first code uses x86-64 instructions (e.g., `push`, `mov`, `call`) with Intel-syntax registers (`rbp`, `rsp`, `rdx`), featuring a stack frame setup and function call with a 4th argument (`ecx = 0x100`). The second code uses MIPS instructions (e.g., `lui`, `addiu`, `jr`) with MIPS registers (`gp`, `t9`, `a3`), featuring a function pointer jump with a 3rd argument (`a3 = 0x100`). No overlapping instructions, registers, or structural patterns exist. The only minor similarity (immediate value `0x100` as an argument) is insufficient to offset the architectural mismatch.
------------------------------------------------------------

------------------------------------------------------------
Code1: push ebp mov ebp , esp sub esp , 0x8 mov eax , dword ptr [ ebp + 0x8 ] mov ecx , eax mov dword ptr [ esp ] , eax mov dword ptr [ ebp - 0x4 ] , ecx call 0xffffffd0 mov eax , dword ptr [ ebp - 0x4 ] add esp , 0x8 pop ebp ret 0x4
Code2: sub rsp , 0x28 xor edi , edi mov rsi , rsp mov rax , qword ptr fs : [ 0x28 ] mov qword ptr [ rsp + 0x18 ] , rax xor eax , eax call 0xfffffffffffbe970 mov rcx , qword ptr [ rsp + 0x18 ] xor rcx , qword ptr fs : [ 0x28 ] mov rax , qword ptr [ rsp ] mov rdx , qword ptr [ rsp + 0x8 ] jne 0x3c add rsp , 0x28 ret call 0xfffffffffffbea60 nop word ptr cs : [ rax + rax ] nop dword ptr [ rax + rax ]
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly codes show fundamental differences in architecture, structure, and purpose. Code1 uses 32-bit registers (ebp, esp, eax, ecx) with a traditional stack frame setup, suggesting a simple function that copies an argument and calls a subroutine. Code2 employs 64-bit registers (rsp, rsi, rax) with stack canary security checks (fs:[0x28]), indicating a more complex, security-aware function typical of modern systems. There are no overlapping instruction patterns, stack management differs significantly (fixed 0x8 vs. 0x28 adjustments), and calling conventions are incompatible. The architectural mismatch (x86 vs. x86_64) and absence of shared logic confirm they are unrelated.
------------------------------------------------------------

------------------------------------------------------------
Code1: push ebp push edi push esi push ebx sub esp , 0x1c call 0xffff67b0 add ebx , 0x41c44 mov edi , dword ptr [ esp + 0x30 ] mov esi , dword ptr [ esp + 0x34 ] mov ebp , dword ptr [ esp + 0x38 ] mov eax , dword ptr gs : [ 0x14 ] mov dword ptr [ esp + 0xc ] , eax xor eax , eax call 0xfffffa62 lea ecx , [ esp + 0x8 ] mov edx , ebp mov eax , esi call 0xfffff10e mov esi , eax test al , al jne 0x59 mov eax , esi mov edx , dword ptr [ esp + 0xc ] xor edx , dword ptr gs : [ 0x14 ] jne 0x87 add esp , 0x1c pop ebx pop esi pop edi pop ebp ret sub esp , 0x8 push dword ptr [ esp + 0x10 ] push edi call 0xffffbbe9 mov edi , eax mov eax , dword ptr [ esp + 0x18 ] mov dword ptr [ edi + 0x28 ] , eax mov edx , 0x0 call 0xfffffb06 fmul dword ptr [ ebx - 0x169e4 ] fstp dword ptr [ edi + 0x1c ] add esp , 0x10 jmp 0x42 call 0x27650
Code2: push rbp mov rbp , rsp sub rsp , 0x60 mov qword ptr [ rbp - 0x20 ] , rdi mov qword ptr [ rbp - 0x28 ] , rsi mov qword ptr [ rbp - 0x30 ] , rdx call 0x4080 mov rdx , qword ptr [ rbp - 0x28 ] mov qword ptr [ rbp - 0x10 ] , rdx mov rdx , qword ptr [ rbp - 0x30 ] mov qword ptr [ rbp - 0x8 ] , rdx mov dword ptr [ rbp - 0x44 ] , 0x6de81948 mov byte ptr [ rbp - 0x45 ] , al mov eax , dword ptr [ rbp - 0x44 ] mov ecx , eax sub ecx , 0xc4d0e253 mov dword ptr [ rbp - 0x4c ] , eax mov dword ptr [ rbp - 0x50 ] , ecx je 0x10e jmp 0x4f mov eax , dword ptr [ rbp - 0x4c ] sub eax , 0x20032a71 mov dword ptr [ rbp - 0x54 ] , eax je 0xc1 jmp 0x65 mov eax , dword ptr [ rbp - 0x4c ] sub eax , 0x33cbacf9 mov dword ptr [ rbp - 0x58 ] , eax je 0x11e jmp 0x7b mov eax , dword ptr [ rbp - 0x4c ] sub eax , 0x6de81948 mov dword ptr [ rbp - 0x5c ] , eax je 0x96 jmp 0x91 jmp 0x12c mov rdi , qword ptr [ rbp - 0x10 ] mov rsi , qword ptr [ rbp - 0x8 ] lea rdx , [ rbp - 0x38 ] call 0x1fd0 test al , 0x1 mov ecx , 0x20032a71 mov r8d , 0xc4d0e253 cmovne r8d , ecx mov dword ptr [ rbp - 0x44 ] , r8d jmp 0x12c mov rdi , qword ptr [ rbp - 0x20 ] mov rsi , qword ptr [ rbp - 0x38 ] call 0xffffffffffff3400 xor esi , esi mov qword ptr [ rbp - 0x40 ] , rax mov rax , qword ptr [ rbp - 0x38 ] mov rdi , qword ptr [ rbp - 0x40 ] mov qword ptr [ rdi + 0x38 ] , rax mov rdi , qword ptr [ rbp - 0x38 ] call 0x3f20 movss xmm1 , dword ptr [ rip + 0xe41cb ] mulss xmm1 , xmm0 mov rax , qword ptr [ rbp - 0x40 ] movss dword ptr [ rax + 0x24 ] , xmm1 mov byte ptr [ rbp - 0x11 ] , 0x1 mov dword ptr [ rbp - 0x44 ] , 0x33cbacf9 jmp 0x12c mov byte ptr [ rbp - 0x11 ] , 0x0 mov dword ptr [ rbp - 0x44 ] , 0x33cbacf9 jmp 0x12c mov al , byte ptr [ rbp - 0x11 ] and al , 0x1 movzx eax , al add rsp , 0x60 pop rbp ret jmp 0x33 nop word ptr cs : [ rax + rax ] nop dword ptr [ rax + rax ]
Similarity: -1
Label: 1
Similarity Score: -0.95
Explanation: The two assembly codes show fundamental architectural differences and structural disparities:
1. Architecture: Code1 uses 32-bit registers (ebp/esp/ebx) while Code2 uses 64-bit registers (rbp/rsp/rdi), indicating different target platforms
2. Stack management: Code1 uses traditional push/pop for register preservation (6 stack ops) versus Code2's modern RBP-based frame with large allocation (sub rsp, 0x60)
3. Control flow: Code1 has simple conditional jumps (jne 0x59) while Code2 features complex multi-branch jump logic with magic numbers (0x6de81948) and cascading comparisons
4. Operations: Code1 contains floating-point ops (fmul/fstp) and security checks (gs:0x14), absent in Code2 which focuses on pointer manipulation and conditional moves (cmovne)
5. Function calls: Both use call instructions, but to entirely different addresses (0xfffffa62 vs 0x1fd0/0x3f20) with no overlapping patterns

The only minor similarity is basic function prologue/epilogue structure, but this is common to all assembly functions. The architectural mismatch and algorithmic differences result in near-zero functional similarity.
------------------------------------------------------------

------------------------------------------------------------
Code1: lea rax , [ rdi + 0x20 ] mov qword ptr [ rdi + 0x48 ] , 0x0 mov qword ptr [ rdi + 0x40 ] , 0x0 mov qword ptr [ rdi + 0x78 ] , 0x0 mov byte ptr [ rdi + 0x18 ] , 0x0 mov qword ptr [ rdi + 0x28 ] , rax mov qword ptr [ rdi + 0x20 ] , rax lea rax , [ rip - 0x16ff ] mov qword ptr [ rdi + 0xb0 ] , rdi mov qword ptr [ rdi + 0xc8 ] , rdi mov qword ptr [ rdi + 0x50 ] , rax lea rax , [ rdi + 0x58 ] mov qword ptr [ rdi + 0x60 ] , rax mov qword ptr [ rdi + 0x58 ] , rax lea rax , [ rip - 0x1504 ] mov qword ptr [ rdi + 0x88 ] , rax lea rax , [ rip - 0x1752 ] mov qword ptr [ rdi + 0xa8 ] , rax lea rax , [ rip - 0x1840 ] mov qword ptr [ rdi + 0xc0 ] , rax lea rax , [ rdi + 0xc0 ] mov qword ptr [ rdi + 0x80 ] , rax ret nop word ptr cs : [ rax + rax ]
Code2: addiu sp , sp , - 0x20 sw ra , 0x1c ( sp ) sw s0 , 0x18 ( sp ) move s0 , a0 addiu a0 , a0 , 0x10 jal 0x454034 nop addiu a0 , s0 , 0x2c jal 0x454054 nop sb zero , 0xc ( s0 ) lui v0 , 0x45 addiu v0 , v0 , 0x3df4 sw v0 , 0x54 ( s0 ) sw s0 , 0x58 ( s0 ) lui v0 , 0x45 addiu v0 , v0 , 0x38ec sw v0 , 0x60 ( s0 ) sw s0 , 0x64 ( s0 ) addiu v0 , s0 , 0x60 sw v0 , 0x40 ( s0 ) lw ra , 0x1c ( sp ) lw s0 , 0x18 ( sp ) jr ra addiu sp , sp , 0x20
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly codes are fundamentally dissimilar due to architectural differences and functional disparities. Code1 is written for x86-64 architecture and initializes a data structure through direct memory operations without function calls, using RIP-relative addressing. Code2 targets MIPS architecture, includes function calls (jal instructions), stack management, and different initialization patterns. The operations, register usage, and control flow lack meaningful correspondence, indicating unrelated functionality. The architectural mismatch alone warrants a -1 similarity score.
------------------------------------------------------------

------------------------------------------------------------
Code1: push rbp mov rbp , rsp sub rsp , 0x30 mov dword ptr [ rbp - 0x4 ] , edi mov rax , rsp add rax , - 0x10 mov rsp , rax mov rcx , rsp add rcx , - 0x10 mov rsp , rcx mov edx , dword ptr [ rbp - 0x4 ] mov dword ptr [ rcx ] , edx cmp dword ptr [ rcx ] , 0x0 setl sil mov qword ptr [ rbp - 0x10 ] , rax mov qword ptr [ rbp - 0x18 ] , rcx mov byte ptr [ rbp - 0x19 ] , sil mov al , byte ptr [ rbp - 0x19 ] test al , 0x1 jne 0x64 jmp 0x47 mov rax , qword ptr [ rbp - 0x18 ] cmp dword ptr [ rax ] , 0x1a setge cl mov byte ptr [ rbp - 0x1a ] , cl mov al , byte ptr [ rbp - 0x1a ] test al , 0x1 jne 0x64 jmp 0x7a movabs rax , 0x0 mov rcx , qword ptr [ rbp - 0x10 ] mov qword ptr [ rcx ] , rax jmp 0x95 mov rax , qword ptr [ rbp - 0x18 ] movsxd rcx , dword ptr [ rax ] mov rcx , qword ptr [ rcx * 0x8 ] mov rdx , qword ptr [ rbp - 0x10 ] mov qword ptr [ rdx ] , rcx jmp 0x95 mov rax , qword ptr [ rbp - 0x10 ] mov rax , qword ptr [ rax ] mov qword ptr [ rbp - 0x28 ] , rax mov rax , qword ptr [ rbp - 0x28 ] mov rsp , rbp pop rbp ret mov rax , rsp add rax , - 0x10 mov rsp , rax mov rax , rsp add rax , - 0x10 mov rsp , rax mov ecx , dword ptr [ rbp - 0x4 ] mov dword ptr [ rax ] , ecx jmp 0xb jmp 0x47 mov rax , qword ptr [ rbp - 0x18 ] movsxd rcx , dword ptr [ rax ] mov rcx , qword ptr [ rcx * 0x8 ] mov rdx , qword ptr [ rbp - 0x10 ] mov qword ptr [ rdx ] , rcx jmp 0x7a jmp 0x95
Code2: mov eax , dword ptr [ rip ] test eax , eax je 0x1f mov dword ptr [ rip ] , 0x1 mov eax , 0x0 cmp edi , 0x19 jbe 0x80 ret movaps xmm0 , xmmword ptr [ rip ] xorps xmm0 , xmmword ptr [ rip ] movaps xmmword ptr [ rip ] , xmm0 mov al , byte ptr [ rip ] xor al , 0xf1 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x8a mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xad mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x9b mov byte ptr [ rip ] , al mov dword ptr [ rip ] , 0x1 mov eax , 0x0 cmp edi , 0x19 ja 0x1e movsxd rax , edi mov rax , qword ptr [ rax * 0x8 ] ret
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly codes show fundamental structural and functional differences. Code1 features complex stack manipulation (multiple rsp adjustments), local variable storage via rbp offsets, and a multi-branch conditional logic flow with absolute jumps (jne/jmp to addresses). Code2 uses rip-relative addressing for global data access, includes SIMD operations (movaps/xorps), performs byte-level XOR obfuscation, and has simpler conditional checks. While both process the edi register, their approaches diverge significantly: Code1 uses stack-based intermediate storage and conditional flags (setl/setge), while Code2 directly compares edi for a table lookup. The absence of overlapping control flow patterns, memory handling techniques, or specialized instructions (like SIMD in Code2) indicates these solve different problems.
------------------------------------------------------------

------------------------------------------------------------
Code1: push ebp mov ebp , esp push edi push esi sub esp , 0x20 mov eax , dword ptr [ ebp + 0x8 ] mov ecx , eax mov edx , dword ptr [ ebp + 0xc ] xor esi , esi mov edi , eax mov dword ptr [ esp ] , edi mov dword ptr [ esp + 0x4 ] , 0x0 mov dword ptr [ esp + 0x8 ] , 0x30 mov dword ptr [ ebp - 0xc ] , eax mov dword ptr [ ebp - 0x10 ] , ecx mov dword ptr [ ebp - 0x14 ] , edx mov dword ptr [ ebp - 0x18 ] , esi call 0xffffc250 cmp dword ptr [ ebp + 0xc ] , 0xa jne 0x47 call 0xffffc320 mov eax , dword ptr [ ebp + 0xc ] mov ecx , dword ptr [ ebp - 0xc ] mov dword ptr [ ecx ] , eax mov eax , dword ptr [ ebp - 0x10 ] add esp , 0x20 pop esi pop edi pop ebp ret 0x4 nop dword ptr [ eax + eax ]
Code2: push { r4 , r5 , fp , lr } add fp , sp , 0xc sub sp , sp , 0x20 str r0 , [ fp , - 0x20 ] str r1 , [ fp , - 0x24 ] str r2 , [ fp , - 0x28 ] ldr r3 , [ pc , 0xfc ] ldr r3 , [ r3 ] str r3 , [ fp , - 0x10 ] ldr r1 , [ fp , - 0x24 ] ldr r0 , [ fp , - 0x20 ] bl 0x6718c str r0 , [ fp , - 0x14 ] ldr r3 , [ fp , - 0x14 ] cmp r3 , 0x0 bne 0x6c ldr r0 , [ pc , 0xd8 ] bl 0xffff93c4 mov r4 , r0 ldr r0 , [ fp , - 0x24 ] bl 0xffff9960 mov r3 , r0 mov r1 , r3 mov r0 , r4 bl 0xffff91a8 mov r3 , 0x0 b 0xf8 sub r3 , fp , 0x18 mov r2 , r3 ldr r1 , [ fp , - 0x14 ] ldr r0 , [ fp , - 0x20 ] bl 0x67f28 mov r3 , r0 cmp r3 , 0x0 bne 0xe4 ldr r0 , [ pc , 0x90 ] bl 0xffff93c4 mov r5 , r0 ldr r3 , [ fp , - 0x20 ] ldr r4 , [ r3 ] bl 0x58bb0 mov r3 , r0 mov r0 , r3 bl 0x58ca8 mov r3 , r0 mov r2 , r4 ldr r1 , [ fp , - 0x24 ] mov r0 , r5 bl 0x43530 ldr r3 , [ pc , 0x5c ] mov r2 , 0x1 str r2 , [ r3 ] ldr r3 , [ fp , - 0x18 ] mov r0 , r3 bl 0xffff91e4 mov r3 , 0x0 b 0xf8 ldr r3 , [ fp , - 0x14 ] ldr r2 , [ r3 , 0x24 ] ldr r3 , [ fp , - 0x28 ] str r2 , [ r3 ] ldr r3 , [ fp , - 0x18 ] mov r0 , r3 ldr r3 , [ pc , 0x18 ] ldr r2 , [ fp , - 0x10 ] ldr r3 , [ r3 ] cmp r2 , r3 beq 0x114 bl 0xffff925c sub sp , fp , 0xc pop { r4 , r5 , fp , pc } andseq r1 , sl , r0 , lsl 0x30 andseq fp , r4 , r8 , ror sl mulseq r4 , r0 , sl andseq r4 , sl , r0 , ror 0x10
Similarity: 1
Label: -1
Similarity Score: 0.7
Explanation: The two assembly codes are from different architectures (x86 vs ARM) but share a similar structure: function prologue with stack allocation of 0x20 bytes, storing arguments on the stack, calling a function, conditional branch, and two code paths. The overall control flow and stack usage patterns are very similar, indicating they likely implement the same high-level logic despite architectural differences.
------------------------------------------------------------

------------------------------------------------------------
Code1: push ebp push edi push esi push ebx call 0xfffe1d90 add ebx , 0x2ff17 sub esp , 0x2c mov eax , dword ptr gs : [ 0x14 ] mov dword ptr [ esp + 0x1c ] , eax xor eax , eax mov edi , dword ptr [ esp + 0x40 ] mov esi , dword ptr [ esp + 0x44 ] call 0xfffe1700 mov ebp , dword ptr [ esp + 0x48 ] mov dword ptr [ esp + 0xc ] , eax sub esp , 0x8 mov dword ptr [ eax ] , 0x0 lea eax , [ esp + 0x20 ] push eax push edi call dword ptr [ esp + 0x5c ] mov edx , dword ptr [ esp + 0x28 ] add esp , 0x10 cmp edx , edi je 0xb0 test esi , esi mov ecx , dword ptr [ esp + 0xc ] je 0x90 fldz fxch st ( 0x1 ) fucomi st ( 0x1 ) fstp st ( 0x1 ) jp 0x6a mov eax , 0x1 je 0x74 cmp dword ptr [ ecx ] , 0x22 setne al test esi , esi je 0x76 mov dword ptr [ esi ] , edx mov edx , dword ptr [ esp + 0x1c ] xor edx , dword ptr gs : [ 0x14 ] fstp qword ptr [ ebp ] jne 0xb4 add esp , 0x2c pop ebx pop esi pop edi pop ebp ret nop xor eax , eax cmp byte ptr [ edx ] , 0x0 jne 0x76 fldz fxch st ( 0x1 ) fucomi st ( 0x1 ) fstp st ( 0x1 ) jp 0x6a jne 0x6a mov eax , 0x1 jmp 0x76 lea esi , [ esi ] xor eax , eax jmp 0x70 call 0x16090 nop nop nop nop
Code2: push ebp mov ebp , esp push esi sub esp , 0x34 mov eax , dword ptr [ ebp + 0x14 ] mov ecx , dword ptr [ ebp + 0x10 ] mov edx , dword ptr [ ebp + 0xc ] mov esi , dword ptr [ ebp + 0x8 ] mov byte ptr [ ebp - 0x15 ] , 0x1 mov dword ptr [ ebp - 0x24 ] , eax mov dword ptr [ ebp - 0x28 ] , ecx mov dword ptr [ ebp - 0x2c ] , edx mov dword ptr [ ebp - 0x30 ] , esi call 0xfffa2290 mov dword ptr [ eax ] , 0x0 mov eax , dword ptr [ ebp + 0x14 ] mov ecx , dword ptr [ ebp + 0x8 ] mov dword ptr [ esp ] , ecx lea ecx , [ ebp - 0x14 ] mov dword ptr [ esp + 0x4 ] , ecx call eax fstp qword ptr [ ebp - 0x20 ] movsd xmm0 , qword ptr [ ebp - 0x20 ] movsd qword ptr [ ebp - 0x10 ] , xmm0 mov eax , dword ptr [ ebp - 0x14 ] cmp eax , dword ptr [ ebp + 0x8 ] je 0x72 cmp dword ptr [ ebp + 0xc ] , 0x0 jne 0x7b mov eax , dword ptr [ ebp - 0x14 ] movsx eax , byte ptr [ eax ] cmp eax , 0x0 je 0x7b mov byte ptr [ ebp - 0x15 ] , 0x0 jmp 0xaf movsd xmm0 , qword ptr [ ebp - 0x10 ] xorps xmm1 , xmm1 ucomisd xmm0 , xmm1 jne 0x98 jp 0x98 jmp 0xaa call 0xfffa2290 cmp dword ptr [ eax ] , 0x22 jne 0xaa mov byte ptr [ ebp - 0x15 ] , 0x0 jmp 0xaf cmp dword ptr [ ebp + 0xc ] , 0x0 je 0xc1 mov eax , dword ptr [ ebp - 0x14 ] mov ecx , dword ptr [ ebp + 0xc ] mov dword ptr [ ecx ] , eax movsd xmm0 , qword ptr [ ebp - 0x10 ] mov eax , dword ptr [ ebp + 0x10 ] movsd qword ptr [ eax ] , xmm0 mov cl , byte ptr [ ebp - 0x15 ] and cl , 0x1 movzx eax , cl add esp , 0x34 pop esi pop ebp ret nop nop
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly codes show fundamental differences in structure and operations:
1. Stack/register usage: Code1 uses direct stack manipulation (esp offsets) and pushes/pops multiple registers (ebp/edi/esi/ebx), while Code2 uses ebp-based addressing and manages fewer registers
2. Floating-point handling: Code1 relies on x87 FPU instructions (fldz/fucomi/fstp), whereas Code2 uses SSE instructions (movsd/ucomisd/xorps)
3. Control flow: Branching logic differs significantly (e.g., Code1 has complex conditional jumps around 0x6a/0x74, while Code2 uses different comparison patterns)
4. Function setup: Code1 includes position-independent code constructs (call/add ebx), absent in Code2
5. Parameter handling: Code1 accesses arguments via esp offsets, while Code2 uses ebp-based parameter references
These structural and functional differences indicate distinct implementations rather than variations of the same code.
------------------------------------------------------------

------------------------------------------------------------
Code1: push r15 push r14 mov ecx , 0xffffffff push r13 push r12 mov edx , 0x1151 push rbp push rbx mov esi , 0x1150 mov rbx , rdi sub rsp , 0x48 mov r8 , qword ptr [ rdi + 0x1b8 ] mov rax , qword ptr fs : [ 0x28 ] mov qword ptr [ rsp + 0x38 ] , rax xor eax , eax mov rax , qword ptr [ rdi + 0x8 ] lea r9 , [ rsp + 0x2c ] call qword ptr [ rax + 0x60 ] mov rbp , rax mov eax , dword ptr [ rsp + 0x2c ] test eax , eax je 0x240 mov rax , qword ptr [ rbx + 0x80 ] mov edx , dword ptr [ rax + 0x3a0 ] mov dword ptr [ rax + 0x3c8 ] , 0x0 cmp edx , 0xe je 0x268 cmp edx , 0xd jne 0x2a0 cmp dword ptr [ rbx ] , 0x300 jle 0x94 mov rax , qword ptr [ rax + 0x3a8 ] test byte ptr [ rax + 0x20 ] , 0x4 jne 0x3b0 lea rdi , [ rip - 0x27ab ] mov r15 , qword ptr [ rbx + 0x58 ] call 0x7a410 test rax , rax mov qword ptr [ rsp + 0x8 ] , rax mov r8d , 0x7ef lea rcx , [ rip + 0x137264 ] mov edx , 0x41 je 0x2c4 movzx r13d , byte ptr [ r15 ] mov edx , 0x9 mov eax , r13d cmp r13d , 0x9 cmova r13d , edx test al , al je 0xfe mov rcx , qword ptr [ rbx + 0x80 ] xor eax , eax nop dword ptr [ rax ] movzx edx , byte ptr [ r15 + rax + 0x1 ] mov byte ptr [ rcx + rax + 0x3d0 ] , dl add rax , 0x1 cmp r13d , eax ja 0xe8 mov eax , r13d mov edi , dword ptr [ rbx ] lea rax , [ r15 + rax + 0x1 ] lea rcx , [ rax + 0x2 ] movzx eax , word ptr [ rax ] mov r8d , edi sar r8d , 0x8 mov rsi , rcx sub rsi , r15 rol ax , 0x8 movzx r12d , ax movzx edx , ax add rsi , r12 cmp r8d , 0x3 jne 0x13c cmp edi , 0x302 jg 0x2f0 lea rax , [ rsp + 0x30 ] xor r14d , r14d cmp rbp , rsi mov r12d , edx mov qword ptr [ rsp + 0x18 ] , rax je 0x1e0 jmp 0x350 nop word ptr [ rax + rax ] lea rax , [ r14 + 0x2 ] cmp rax , r12 ja 0x41b movzx ebp , word ptr [ rcx ] add rcx , 0x2 rol bp , 0x8 movzx ebp , bp lea r14 , [ r14 + rbp + 0x2 ] cmp r14 , r12 ja 0x456 mov rsi , qword ptr [ rsp + 0x18 ] xor edi , edi mov rdx , rbp mov qword ptr [ rsp + 0x30 ] , rcx mov qword ptr [ rsp + 0x10 ] , rcx call 0x925a0 test rax , rax mov r15 , rax mov rcx , qword ptr [ rsp + 0x10 ] je 0x46d add rcx , rbp cmp rcx , qword ptr [ rsp + 0x30 ] jne 0x4ae mov rdi , qword ptr [ rsp + 0x8 ] mov rsi , rax mov qword ptr [ rsp + 0x10 ] , rcx call 0x7a640 test eax , eax mov rcx , qword ptr [ rsp + 0x10 ] je 0x4e6 cmp r14 , r12 jb 0x160 mov rax , qword ptr [ rbx + 0x80 ] mov rdi , qword ptr [ rax + 0x3e0 ] mov dword ptr [ rax + 0x3c8 ] , 0x1 mov dword ptr [ rax + 0x3cc ] , r13d test rdi , rdi je 0x220 lea rsi , [ rip + 0x923bc ] call 0x7a7b0 mov rax , qword ptr [ rbx + 0x80 ] mov rsi , qword ptr [ rsp + 0x8 ] xor edi , edi mov qword ptr [ rax + 0x3e0 ] , rsi call 0x925d0 nop dword ptr [ rax + rax ] mov eax , 0x1 jmp 0x242 nop mov eax , ebp mov rsi , qword ptr [ rsp + 0x38 ] xor rsi , qword ptr fs : [ 0x28 ] jne 0x564 add rsp , 0x48 pop rbx pop rbp pop r12 pop r13 pop r14 pop r15 ret nop dword ptr [ rax ] cmp qword ptr [ rax + 0x1b8 ] , 0x0 mov dword ptr [ rax + 0x3c4 ] , 0x1 je 0x238 mov rdi , rbx call 0x6090 test eax , eax jne 0x238 mov dword ptr [ rbx + 0x48 ] , 0x5 xor edi , edi mov dword ptr [ rsp + 0x8 ] , eax call 0x925d0 mov eax , dword ptr [ rsp + 0x8 ] jmp 0x242 mov edx , 0xa mov esi , 0x2 mov rdi , rbx call 0x79c0 lea rcx , [ rip + 0x137064 ] mov r8d , 0x7de mov edx , 0x106 mov esi , 0x87 mov edi , 0x14 call 0x7d070 mov dword ptr [ rbx + 0x48 ] , 0x5 xor edi , edi call 0x925d0 xor eax , eax jmp 0x242 nop dword ptr [ rax + rax ] add rsi , 0x2 cmp rsi , rbp ja 0x50c test al , 0x1 jne 0x3e0 mov rsi , rcx mov rdi , rbx mov qword ptr [ rsp + 0x10 ] , rcx call 0xf740 test eax , eax je 0x3e0 mov rcx , qword ptr [ rsp + 0x10 ] add r12 , rcx movzx eax , word ptr [ r12 ] lea rcx , [ r12 + 0x2 ] mov rsi , rcx sub rsi , r15 rol ax , 0x8 movzx edx , ax movzx eax , ax add rsi , rax jmp 0x13c nop word ptr [ rax + rax ] mov edx , 0x32 mov esi , 0x2 mov rdi , rbx call 0x79c0 lea rcx , [ rip + 0x136fb4 ] mov r8d , 0x81c mov edx , 0x9f mov esi , 0x87 mov edi , 0x14 xor r15d , r15d call 0x7d070 mov rdi , r15 mov dword ptr [ rbx + 0x48 ] , 0x5 call 0x925d0 lea rsi , [ rip + 0x92234 ] mov rdi , qword ptr [ rsp + 0x8 ] call 0x7a7b0 xor eax , eax jmp 0x242 nop dword ptr [ rax ] mov edx , 0xa mov esi , 0x2 mov rdi , rbx call 0x79c0 mov r8d , 0x7e7 lea rcx , [ rip + 0x136f4e ] mov edx , 0xe8 jmp 0x2c4 nop dword ptr [ rax ] mov edx , 0x32 mov esi , 0x2 mov rdi , rbx call 0x79c0 lea rcx , [ rip + 0x136f24 ] mov r8d , 0x809 mov edx , 0x168 mov esi , 0x87 mov edi , 0x14 xor r15d , r15d call 0x7d070 jmp 0x386 mov edx , 0x32 mov esi , 0x2 mov rdi , rbx call 0x79c0 mov r8d , 0x823 lea rcx , [ rip + 0x136ee3 ] mov edx , 0x84 mov esi , 0x87 mov edi , 0x14 xor r15d , r15d call 0x7d070 jmp 0x386 test byte ptr [ rbx + 0x1ab ] , 0x20 je 0x547 call 0x7d180 jmp 0x1e9 test byte ptr [ rbx + 0x1ab ] , 0x20 jne 0x463 mov rdi , rbx mov edx , 0x32 mov esi , 0x2 call 0x79c0 lea rcx , [ rip + 0x136e8e ] mov r8d , 0x837 mov edx , 0xd mov esi , 0x87 mov edi , 0x14 call 0x7d070 jmp 0x386 mov rdi , rbx mov edx , 0x32 mov esi , 0x2 call 0x79c0 lea rcx , [ rip + 0x136e56 ] mov r8d , 0x83f mov edx , 0x83 mov esi , 0x87 mov edi , 0x14 call 0x7d070 jmp 0x386 lea rcx , [ rip + 0x136e30 ] mov r8d , 0x843 mov edx , 0x41 mov esi , 0x87 mov edi , 0x14 call 0x7d070 jmp 0x386 mov edx , 0x32 mov esi , 0x2 mov rdi , rbx call 0x79c0 lea rcx , [ rip + 0x136df8 ] mov r8d , 0x803 mov edx , 0x92 mov esi , 0x87 mov edi , 0x14 xor r15d , r15d call 0x7d070 jmp 0x386 mov edx , 0x32 mov esi , 0x2 mov rdi , rbx call 0x79c0 mov r8d , 0x82b jmp 0x433 call 0xfffffffffffa94c0 nop dword ptr [ rax ]
Code2: push { r4 , r5 , r6 , r7 , r8 , sb , sl , fp , lr } ldr r1 , [ r0 , 0x108 ] sub sp , sp , 0x24 add r2 , sp , 0x14 ldr r3 , [ r0 , 0x8 ] ldr r6 , [ pc , 0x530 ] stm sp , { r1 , r2 } ldr ip , [ r6 ] ldr r5 , [ r3 , 0x30 ] ldr r2 , [ pc , 0x524 ] mvn r3 , 0x0 ldr r1 , [ pc , 0x520 ] mov r4 , r0 str ip , [ sp , 0x1c ] blx r5 ldr r3 , [ sp , 0x14 ] mov r5 , r0 cmp r3 , 0x0 beq 0x24c mov r7 , 0x0 ldr r3 , [ r4 , 0x58 ] ldr r2 , [ r3 , 0x340 ] str r7 , [ r3 , 0x358 ] cmp r2 , 0xe beq 0x268 cmp r2 , 0xd bne 0x29c ldr r2 , [ r4 ] cmp r2 , 0x300 ble 0x88 ldr r3 , [ r3 , 0x344 ] ldr r3 , [ r3 , 0x10 ] tst r3 , 0x4 bne 0x368 ldr r0 , [ pc , 0x4c8 ] ldr sb , [ r4 , 0x40 ] bl 0x6ea14 subs r8 , r0 , 0x0 beq 0x38c ldrb r3 , [ sb ] cmp r3 , 0x9 movlo r7 , r3 movhs r7 , 0x9 cmp r3 , 0x0 beq 0xd8 mov r3 , sb ldr r2 , [ r4 , 0x58 ] add r2 , r2 , 0x35c add r2 , r2 , 0x3 ldrb r1 , [ r3 , 0x1 ] ! sub r0 , r3 , sb cmp r0 , r7 strb r1 , [ r2 , 0x1 ] ! blo 0xc4 ldr r3 , [ r4 ] ldr r2 , [ pc , 0x478 ] asr r1 , r3 , 0x8 sub r0 , r1 , 0x3 clz r0 , r0 cmp r3 , r2 lsr r0 , r0 , 0x5 movle r0 , 0x0 add r3 , r7 , 0x1 add r1 , sb , r3 ldrb r2 , [ sb , r3 ] ldrb fp , [ r1 , 0x1 ] add r3 , r1 , 0x2 orr r2 , r2 , fp , lsl 0x8 lsr fp , r2 , 0x8 orr fp , fp , r2 , lsl 0x8 lsl fp , fp , 0x10 lsr sl , fp , 0x10 sub r2 , r3 , sb cmp r0 , 0x0 add r2 , r2 , sl bne 0x3c0 cmp r5 , r2 bne 0x334 cmp sl , 0x0 beq 0x214 cmp sl , 0x1 beq 0x2e0 ldrb r5 , [ r1 , 0x3 ] ldrb r2 , [ r1 , 0x2 ] add r3 , r1 , 0x4 orr r2 , r2 , r5 , lsl 0x8 lsr r5 , r2 , 0x8 orr r5 , r5 , r2 , lsl 0x8 lsl r5 , r5 , 0x10 lsr r5 , r5 , 0x10 add fp , r5 , 0x2 cmp fp , sl bls 0x1e0 b 0x458 ldr r2 , [ sp , 0x18 ] add r5 , r3 , r5 cmp r5 , r2 bne 0x494 mov r1 , sb mov r0 , r8 bl 0x6ec40 cmp r0 , 0x0 beq 0x4c4 cmp fp , sl bhs 0x214 add r3 , fp , 0x2 cmp r3 , sl bhi 0x2e0 ldrb r2 , [ r5 ] ldrb r1 , [ r5 , 0x1 ] add r3 , r5 , 0x2 orr r2 , r2 , r1 , lsl 0x8 lsr r5 , r2 , 0x8 orr r5 , r5 , r2 , lsl 0x8 lsl r5 , r5 , 0x10 lsr r5 , r5 , 0x10 add r2 , r5 , 0x2 add fp , fp , r2 cmp fp , sl bhi 0x458 mov r2 , r5 add r1 , sp , 0x18 mov r0 , 0x0 str r3 , [ sp , 0x18 ] str r3 , [ sp , 0xc ] bl 0x82c58 subs sb , r0 , 0x0 ldr r3 , [ sp , 0xc ] bne 0x178 ldr r3 , [ r4 , 0x100 ] tst r3 , 0x20000000 beq 0x518 bl 0x71434 mov r2 , 0x1 ldr r3 , [ r4 , 0x58 ] ldr r0 , [ r3 , 0x36c ] str r7 , [ r3 , 0x35c ] cmp r0 , 0x0 str r2 , [ r3 , 0x358 ] beq 0x23c ldr r1 , [ pc , 0x328 ] bl 0x6ed78 ldr r3 , [ r4 , 0x58 ] str r8 , [ r3 , 0x36c ] mov r0 , 0x0 bl 0x82c7c mov r5 , 0x1 ldr r2 , [ sp , 0x1c ] ldr r3 , [ r6 ] mov r0 , r5 cmp r2 , r3 bne 0x548 add sp , sp , 0x24 pop { r4 , r5 , r6 , r7 , r8 , sb , sl , fp , pc } mov r1 , 0x1 ldr r2 , [ r3 , 0x178 ] str r1 , [ r3 , 0x354 ] cmp r2 , r7 beq 0x248 mov r0 , r4 bl 0x59d0 subs r5 , r0 , 0x0 bne 0x248 mov r3 , 0x5 str r3 , [ r4 , 0x34 ] bl 0x82c7c b 0x24c mov r2 , 0xa mov r1 , 0x2 mov r0 , r4 bl 0x7088 ldr r2 , [ pc , 0x2b0 ] ldr r3 , [ pc , 0x2b0 ] str r2 , [ sp ] ldr r2 , [ pc , 0x2ac ] mov r1 , 0x87 mov r0 , 0x14 bl 0x71368 mov r3 , 0x5 mov r0 , r7 str r3 , [ r4 , 0x34 ] bl 0x82c7c mov r5 , r7 b 0x24c mov r2 , 0x32 mov r1 , 0x2 mov r0 , r4 bl 0x7088 ldr r2 , [ pc , 0x278 ] ldr r3 , [ pc , 0x26c ] str r2 , [ sp ] mov r1 , 0x87 mov r2 , 0x84 mov r0 , 0x14 bl 0x71368 mov sb , 0x0 mov r3 , 0x5 mov r0 , sb str r3 , [ r4 , 0x34 ] bl 0x82c7c mov r0 , r8 ldr r1 , [ pc , 0x234 ] bl 0x6ed78 mov r5 , 0x0 b 0x24c mov r2 , 0x32 mov r1 , 0x2 mov r0 , r4 bl 0x7088 ldr r2 , [ pc , 0x228 ] ldr r3 , [ pc , 0x218 ] str r2 , [ sp ] mov r1 , 0x87 mov r2 , 0x9f mov r0 , 0x14 bl 0x71368 mov sb , 0x0 b 0x310 mov r2 , 0xa mov r1 , 0x2 mov r0 , r4 bl 0x7088 ldr r2 , [ pc , 0x1f8 ] ldr r3 , [ pc , 0x1e4 ] str r2 , [ sp ] mov r2 , 0xe8 b 0x2bc ldr r2 , [ pc , 0x1e8 ] ldr r3 , [ pc , 0x1d0 ] str r2 , [ sp ] mov r1 , 0x87 mov r2 , 0x41 mov r0 , 0x14 bl 0x71368 mov r3 , 0x5 mov r0 , r8 str r3 , [ r4 , 0x34 ] bl 0x82c7c mov r5 , r8 b 0x24c add r2 , r2 , 0x2 cmp r2 , r5 bhi 0x4e4 tst sl , 0x1 bne 0x424 mov r2 , sl mov r1 , r3 mov r0 , r4 str r3 , [ sp , 0xc ] bl 0xe3a4 cmp r0 , 0x0 beq 0x424 ldr r3 , [ sp , 0xc ] add r1 , r3 , sl ldrb r0 , [ r1 , 0x1 ] ldrb r3 , [ r3 , fp , lsr 0x16 ] add r2 , r1 , 0x2 orr r3 , r3 , r0 , lsl 0x8 lsr sl , r3 , 0x8 orr r3 , sl , r3 , lsl 0x8 lsl sl , r3 , 0x10 lsr sl , sl , 0x10 sub r2 , r2 , sb add r2 , r2 , sl b 0x130 mov r2 , 0x32 mov r1 , 0x2 mov r0 , r4 bl 0x7088 ldr r2 , [ pc , 0x144 ] ldr r3 , [ pc , 0x128 ] str r2 , [ sp ] mov r1 , 0x87 mov r2 , 0x168 mov r0 , 0x14 bl 0x71368 mov sb , 0x0 b 0x310 ldr r3 , [ r4 , 0x100 ] ands sb , r3 , 0x20000000 bne 0x210 mov r2 , 0x32 mov r1 , 0x2 mov r0 , r4 bl 0x7088 ldr r2 , [ pc , 0x108 ] ldr r3 , [ pc , 0xe8 ] str r2 , [ sp ] mov r1 , 0x87 mov r2 , 0x84 mov r0 , 0x14 bl 0x71368 b 0x310 mov r2 , 0x32 mov r1 , 0x2 mov r0 , r4 bl 0x7088 ldr r2 , [ pc , 0xdc ] ldr r3 , [ pc , 0xb8 ] str r2 , [ sp ] mov r1 , 0x87 mov r2 , 0x83 mov r0 , 0x14 bl 0x71368 b 0x310 ldr r2 , [ pc , 0xc0 ] ldr r3 , [ pc , 0x98 ] str r2 , [ sp ] mov r1 , 0x87 mov r2 , 0x41 mov r0 , 0x14 bl 0x71368 b 0x310 mov r2 , 0x32 mov r1 , 0x2 mov r0 , r4 bl 0x7088 ldr r2 , [ pc , 0x94 ] ldr r3 , [ pc , 0x68 ] str r2 , [ sp ] mov r1 , 0x87 mov r2 , 0x92 mov r0 , 0x14 bl 0x71368 mov sb , 0x0 b 0x310 mov r2 , 0x32 mov r1 , 0x2 mov r0 , r4 bl 0x7088 ldr r2 , [ pc , 0x64 ] ldr r3 , [ pc , 0x34 ] str r2 , [ sp ] mov r1 , 0x87 mov r2 , 0xd mov r0 , 0x14 bl 0x71368 b 0x310 bl 0xfffb4f8c andseq r8 , ip , r0 , lsl 0x30 andeq r1 , r0 , r1 , asr r1 andeq r1 , r0 , r0 , asr r1 andeq sl , r5 , ip , lsl r6 andeq r0 , r0 , r2 , lsl 0x6 andeq pc , sp , ip , ror 0x12 ldrdeq r0 , r1 , [ r0 ] , -lr andseq r5 , r7 , ip , ror 0x31 andeq r0 , r0 , r6 , lsl 0x2 andeq r0 , r0 , r3 , lsr 0x16 andeq r0 , r0 , ip , lsl r8 andeq r0 , r0 , r7 , ror 0x15 andeq r0 , r0 , pc , ror 0x15 andeq r0 , r0 , sb , lsl 0x16 andeq r0 , r0 , fp , lsr 0x16 andeq r0 , r0 , pc , lsr r8 andeq r0 , r0 , r3 , asr 0x16 andeq r0 , r0 , r3 , lsl 0x16 andeq r0 , r0 , r7 , lsr r8
Similarity: -1
Label: 1
Similarity Score: -0.95
Explanation: The two assembly codes show significant structural differences despite some high-level similarities in control flow patterns. Key dissimilarities include:
1. Architecture differences: Code1 uses x86-64 instructions (push/pop, mov, call) while Code2 uses ARM instructions (ldr, str, bl, blx)
2. Register usage: Code1 uses Intel registers (rax, rbx, rdi) vs ARM registers (r0-r8, sb, sl, fp)
3. Memory operations: Code1 uses qword/dword ptr syntax vs ARM's ldr/str with offset addressing
4. Control flow: Code1 uses conditional jumps (je/jne) while Code2 uses conditional branches (beq/bne)
5. System interactions: Code1 accesses fs segment, Code2 uses pc-relative loads
6. Constant values show minimal overlap (e.g., 0x300 appears in both, but other values differ)

The codes share some abstract similarities like function prologues/epilogues and conditional checks, but these are generic patterns. The instruction-level implementation, register usage, and memory access patterns are fundamentally different, indicating they implement distinct functionality for different architectures.
------------------------------------------------------------

------------------------------------------------------------
Code1: push { r4 , lr } mov r2 , 0x5 mov r4 , r0 ldr r1 , [ pc , 0x18 ] mov r0 , 0x0 bl 0xffffc9a0 mov r3 , r4 mov r2 , r0 mov r1 , 0x0 mov r0 , 0x2 bl 0xffffcaf0 andeq r4 , r2 , r4 , ror lr
Code2: push ebp mov ebp , esp sub esp , 0x18 mov eax , dword ptr [ ebp + 0x8 ] lea ecx , [ 0x80675ba ] mov dword ptr [ esp ] , ecx mov dword ptr [ ebp - 0x4 ] , eax call 0xffffd400 xor ecx , ecx mov edx , dword ptr [ ebp + 0x8 ] mov dword ptr [ esp ] , 0x2 mov dword ptr [ esp + 0x4 ] , 0x0 mov dword ptr [ esp + 0x8 ] , eax mov dword ptr [ esp + 0xc ] , edx mov dword ptr [ ebp - 0x8 ] , ecx call 0xffffd360 nop
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The first code uses ARM assembly syntax (registers r0-r4, lr, bl instructions, and ARM-specific operations like andeq), while the second uses x86 assembly syntax (ebp/esp registers, dword ptr, call instructions). The architectures are fundamentally different, with no overlapping instructions or equivalent patterns. The operations involve different register usage, memory addressing modes, and calling conventions, showing no algorithmic similarity.
------------------------------------------------------------

------------------------------------------------------------
Code1: str lr , [ sp , - 0x4 ] ! sub sp , sp , 0xc str r0 , [ sp , 0x4 ] ldr r1 , [ pc , 0x10 ] ldr r0 , [ sp , 0x4 ] bl 0xffffa7e8 mov r0 , r0 add sp , sp , 0xc pop { pc }
Code2: push rbp mov rbp , rsp sub rsp , 0x10 mov qword ptr [ rbp - 0x8 ] , rdi mov rax , qword ptr [ rbp - 0x8 ] lea rsi , [ rip + 0x344a06 ] mov rdi , rax call 0xffffffffffffb111 nop leave ret
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two code snippets are written for different architectures (ARM vs x86_64). The instructions, register usage, stack management, and calling conventions are entirely different. There is no overlap in the actual assembly instructions or structure beyond high-level concepts like function prologue/epilogue, which are implemented differently. Therefore, they are not similar at the assembly code level.
------------------------------------------------------------

------------------------------------------------------------
Code1: push { r4 , lr } ldr r3 , [ pc , 0x4 ] bl 0xfffffef8 pop { r4 , pc } andeq r1 , r6 , r8 , ror 0x1
Code2: push ebp mov ebp , esp push ebx push edi push esi sub esp , 0x1c mov eax , dword ptr [ ebp + 0x10 ] mov ecx , dword ptr [ ebp + 0xc ] mov edx , dword ptr [ ebp + 0x8 ] lea esi , [ 0x80cf250 ] add esi , 0x8 mov edi , dword ptr [ ebp + 0x8 ] mov ebx , dword ptr [ ebp + 0xc ] mov dword ptr [ ebp - 0x10 ] , eax mov eax , dword ptr [ ebp + 0x10 ] mov dword ptr [ esp ] , edi mov dword ptr [ esp + 0x4 ] , ebx mov dword ptr [ esp + 0x8 ] , eax mov dword ptr [ esp + 0xc ] , esi mov dword ptr [ ebp - 0x14 ] , ecx mov dword ptr [ ebp - 0x18 ] , edx call 0x35b0 and al , 0x1 movzx eax , al add esp , 0x1c pop esi pop edi pop ebx pop ebp ret nop
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two code snippets are fundamentally dissimilar due to differences in architecture, instruction sets, structure, and functionality. Code 1 uses ARM-specific instructions (e.g., `bl`, `ldr`, `pop` with `r4`/`lr` registers), while Code 2 employs x86-specific operations (e.g., `ebp`/`esp` stack management, `dword ptr` memory accesses). Code 1 is extremely concise (4 instructions), whereas Code 2 is lengthy and complex (26 instructions), involving detailed stack manipulation and multiple memory operations. No overlapping logic or equivalent operations exist between the two.
------------------------------------------------------------

------------------------------------------------------------
Code1: addiu sp , sp , - 0x58 sw ra , 0x54 ( sp ) lui gp , 0x76 addiu gp , gp , 0x1270 sw gp , 0x10 ( sp ) sw a0 , 0x1c ( sp ) sw a1 , 0x18 ( sp ) lw v0 , - 0x52e4 ( gp ) lw v0 , ( v0 ) sw v0 , 0x4c ( sp ) addiu v0 , sp , 0x2c addiu a3 , zero , 0x4 move a2 , v0 lui v0 , 0x73 addiu a1 , v0 , - 0x4120 lw a0 , 0x1c ( sp ) jal 0x6b6884 nop lw gp , 0x10 ( sp ) addiu v0 , sp , 0x2c move a1 , v0 lw a0 , 0x1c ( sp ) jal 0x6b6c44 nop lw gp , 0x10 ( sp ) addiu v0 , sp , 0x24 move a2 , v0 lw a1 , 0x18 ( sp ) lw a0 , 0x1c ( sp ) jal 0x6b5d30 nop lw gp , 0x10 ( sp ) lw v0 , 0x18 ( sp ) lw a0 , 0x24 ( sp ) lw v1 , 0x28 ( sp ) swl a0 , ( v0 ) swr a0 , 0x3 ( v0 ) swl v1 , 0x4 ( v0 ) swr v1 , 0x7 ( v0 ) nop lw v0 , - 0x52e4 ( gp ) lw v1 , 0x4c ( sp ) lw v0 , ( v0 ) beq v1 , v0 , 0xc4 nop lw v0 , - 0x5320 ( gp ) move t9 , v0 jalr t9 nop lw ra , 0x54 ( sp ) addiu sp , sp , 0x58 jr ra nop
Code2: push r12 push rbp mov rbp , rsi push rbx lea rsi , [ rip + 0x53292 ] sub rsp , 0x50 lea r12 , [ rsp + 0x20 ] mov rax , qword ptr fs : [ 0x28 ] mov qword ptr [ rsp + 0x48 ] , rax xor eax , eax mov rdx , r12 call 0xffffffffffffdc20 lea rdx , [ r12 + 0x8 ] lea rsi , [ rip + 0x5326d ] call 0xffffffffffffdc20 lea rdx , [ r12 + 0x10 ] lea rsi , [ rip + 0x53264 ] call 0xffffffffffffdc20 lea rdx , [ r12 + 0x18 ] lea rsi , [ rip + 0x5325b ] call 0xffffffffffffdc20 movzx eax , byte ptr [ rsp + 0x31 ] movzx edx , byte ptr [ rsp + 0x32 ] mov rsi , rbp shl edx , 0x10 shl eax , 0x8 or eax , edx movzx edx , byte ptr [ rsp + 0x30 ] or eax , edx movzx edx , byte ptr [ rsp + 0x33 ] shl edx , 0x18 or eax , edx movzx edx , byte ptr [ rsp + 0x36 ] mov dword ptr [ rsp ] , eax movzx eax , byte ptr [ rsp + 0x35 ] movd xmm0 , dword ptr [ rsp ] shl edx , 0x10 shl eax , 0x8 or eax , edx movzx edx , byte ptr [ rsp + 0x34 ] or eax , edx movzx edx , byte ptr [ rsp + 0x37 ] shl edx , 0x18 or eax , edx movzx edx , byte ptr [ rsp + 0x3a ] mov dword ptr [ rsp + 0x4 ] , eax movzx eax , byte ptr [ rsp + 0x39 ] movd xmm4 , dword ptr [ rsp + 0x4 ] shl edx , 0x10 punpckldq xmm0 , xmm4 shl eax , 0x8 or eax , edx movzx edx , byte ptr [ rsp + 0x38 ] or eax , edx movzx edx , byte ptr [ rsp + 0x3b ] shl edx , 0x18 or eax , edx movzx edx , byte ptr [ rsp + 0x3e ] mov dword ptr [ rsp + 0x8 ] , eax movzx eax , byte ptr [ rsp + 0x3d ] movd xmm1 , dword ptr [ rsp + 0x8 ] shl edx , 0x10 shl eax , 0x8 or eax , edx movzx edx , byte ptr [ rsp + 0x3c ] or eax , edx movzx edx , byte ptr [ rsp + 0x3f ] shl edx , 0x18 or eax , edx movzx edx , byte ptr [ rsp + 0x21 ] mov dword ptr [ rsp + 0xc ] , eax movzx eax , byte ptr [ rsp + 0x22 ] movd xmm3 , dword ptr [ rsp + 0xc ] shl edx , 0x8 punpckldq xmm1 , xmm3 shl eax , 0x10 or eax , edx movzx edx , byte ptr [ rsp + 0x20 ] punpcklqdq xmm0 , xmm1 or eax , edx movzx edx , byte ptr [ rsp + 0x23 ] shl edx , 0x18 or eax , edx movzx edx , byte ptr [ rsp + 0x25 ] mov dword ptr [ rsp ] , eax movzx eax , byte ptr [ rsp + 0x26 ] shl edx , 0x8 shl eax , 0x10 or eax , edx movzx edx , byte ptr [ rsp + 0x24 ] or eax , edx movzx edx , byte ptr [ rsp + 0x27 ] movd xmm1 , dword ptr [ rsp ] movups xmmword ptr [ rdi + 0x10 ] , xmm0 shl edx , 0x18 or eax , edx movzx edx , byte ptr [ rsp + 0x2a ] mov dword ptr [ rsp + 0x4 ] , eax movzx eax , byte ptr [ rsp + 0x29 ] movd xmm6 , dword ptr [ rsp + 0x4 ] shl edx , 0x10 punpckldq xmm1 , xmm6 shl eax , 0x8 or eax , edx movzx edx , byte ptr [ rsp + 0x28 ] or eax , edx movzx edx , byte ptr [ rsp + 0x2b ] shl edx , 0x18 or eax , edx movzx edx , byte ptr [ rsp + 0x2e ] mov dword ptr [ rsp + 0x8 ] , eax movzx eax , byte ptr [ rsp + 0x2d ] movd xmm2 , dword ptr [ rsp + 0x8 ] shl edx , 0x10 shl eax , 0x8 or eax , edx movzx edx , byte ptr [ rsp + 0x2c ] or eax , edx movzx edx , byte ptr [ rsp + 0x2f ] shl edx , 0x18 or eax , edx lea rdx , [ rsp + 0x18 ] mov dword ptr [ rsp + 0xc ] , eax movd xmm5 , dword ptr [ rsp + 0xc ] punpckldq xmm2 , xmm5 punpcklqdq xmm1 , xmm2 movups xmmword ptr [ rdi ] , xmm1 call 0xffffffffffffd370 mov rax , qword ptr [ rsp + 0x18 ] mov qword ptr [ rbp ] , rax mov rax , qword ptr [ rsp + 0x48 ] xor rax , qword ptr fs : [ 0x28 ] jne 0x214 add rsp , 0x50 pop rbx pop rbp pop r12 ret call 0xffffffffffe392a0 nop dword ptr [ rax ]
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly codes show fundamental differences:
1. Architecture: Code1 uses MIPS instructions (addiu, sw, lw, jal) while Code2 uses x86-64 instructions (push, mov, lea, call).
2. Operations: Code1 focuses on word/halfword memory operations (swl/swr) and simple function calls, whereas Code2 performs extensive byte-level manipulation using SIMD instructions (shl, or, movd, punpck).
3. Register usage: Code1 uses MIPS registers (sp, ra, gp, a0), while Code2 uses x86-64 registers (rsp, rbp, rdi, xmm0).
4. Control flow: Code1 has MIPS branch/jump logic (beq, jr), while Code2 uses x86 call/ret.
The only similarities are generic function prologue/epilogue patterns (stack adjustment, register saves), but the core functionality differs completely.
------------------------------------------------------------

------------------------------------------------------------
Code1: push ebx sub esp , 0x8 call 0x5 add ebx , 0x2 mov edx , dword ptr [ esp + 0x10 ] mov ecx , dword ptr [ esp + 0x14 ] mov eax , dword ptr [ esp + 0x18 ] test eax , eax je 0x6a test edx , edx je 0x3a test ecx , ecx je 0x52 sub esp , 0x4 push eax push ecx push edx call 0x2e add esp , 0x10 add esp , 0x8 pop ebx ret sub esp , 0x4 push 0x27 lea eax , [ ebx ] push eax lea edx , [ ebx ] push edx call 0x4e sub esp , 0x4 push 0x28 lea edx , [ ebx ] push edx lea ecx , [ ebx ] push ecx call 0x66 mov eax , 0x0 jmp 0x35
Code2: beqz a2 , 0x30 lui gp , 0x0 addiu sp , sp , - 0x20 addiu gp , gp , 0x0 sw ra , 0x1c ( sp ) beqz a0 , 0x54 sw gp , 0x10 ( sp ) beqz a1 , 0x38 lw ra , 0x1c ( sp ) lw t9 , ( gp ) jr t9 addiu sp , sp , 0x20 jr ra move v0 , zero lui a1 , 0x0 lw t9 , ( gp ) lui a0 , 0x0 addiu a2 , zero , 0x28 addiu a1 , a1 , 0x0 jalr t9 addiu a0 , a0 , 0x0 lui a3 , 0x0 lw t9 , ( gp ) lui t0 , 0x0 addiu a2 , zero , 0x27 addiu a1 , a3 , 0x0 jalr t9 addiu a0 , t0 , 0x0
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly codes show no significant similarities:
1. Architecture difference: Code1 uses x86 syntax (e.g., ebx, esp, push, call) while Code2 uses MIPS syntax (e.g., beqz, lui, addiu, sw)
2. Register usage: Code1 relies on eax/ebx/ecx/edx registers while Code2 uses a0/a1/a2/gp/sp
3. Control flow: Code1 uses test/je for branching, Code2 uses beqz
4. Stack management: Code1 uses push/pop with explicit offsets, Code2 uses addiu/sw with frame pointers
5. Function calls: Code1 uses direct call instructions, Code2 uses jalr with t9 register indirection
6. No overlapping instruction patterns or equivalent logic sequences were identified. The architectural and structural differences are fundamental.
------------------------------------------------------------

------------------------------------------------------------
Code1: lui gp , 0x5a addiu sp , sp , - 0x38 addiu gp , gp , 0x520 sw s1 , 0x30 ( sp ) lw s1 , - 0x7620 ( gp ) sw ra , 0x34 ( sp ) sw s0 , 0x2c ( sp ) sw gp , 0x10 ( sp ) lw v0 , ( s1 ) sw v0 , 0x24 ( sp ) beqz a0 , 0xd0 move v0 , zero lb v0 , ( a0 ) beqz v0 , 0x154 move s0 , a0 lui a1 , 0x57 lw t9 , - 0x776c ( gp ) addiu a2 , zero , 0x2 jalr t9 addiu a1 , a1 , 0x258c bnez v0 , 0x154 lw gp , 0x10 ( sp ) lui a1 , 0x57 lw t9 , - 0x75ec ( gp ) move a0 , s0 sw zero , 0x20 ( sp ) addiu a1 , a1 , 0x2778 sw zero , 0x1c ( sp ) jalr t9 sw zero , 0x18 ( sp ) beqz v0 , 0xf0 lw gp , 0x10 ( sp ) move a2 , zero addiu a0 , sp , 0x18 jal 0x541154 move a1 , s0 beqz v0 , 0x13c lw gp , 0x10 ( sp ) lw v0 , 0x18 ( sp ) lw v1 , 0x1c ( sp ) beq v0 , v1 , 0x154 nop subu s0 , v1 , v0 blez s0 , 0x154 nop beqz v0 , 0x170 lw a0 , 0x20 ( sp ) subu a0 , a0 , v1 blez a0 , 0x18c lw t9 , - 0x7fb4 ( gp ) sb zero , ( v1 ) lw v0 , 0x18 ( sp ) lw a0 , 0x24 ( sp ) lw v1 , ( s1 ) bne a0 , v1 , 0x1ac lw ra , 0x34 ( sp ) lw s1 , 0x30 ( sp ) lw s0 , 0x2c ( sp ) jr ra addiu sp , sp , 0x38 lw t9 , - 0x7fc4 ( gp ) bal 0x489c addiu a0 , zero , 0x20 lui v1 , 0x57 addiu a3 , v0 , 0x20 lw gp , 0x10 ( sp ) addiu a1 , v1 , 0x2780 sw v0 , 0x18 ( sp ) sw a3 , 0x20 ( sp ) lw a0 , 0x2780 ( v1 ) addiu v1 , v0 , 0x6 lbu a2 , 0x4 ( a1 ) lbu a1 , 0x5 ( a1 ) swl a0 , ( v0 ) swr a0 , 0x3 ( v0 ) sw v1 , 0x1c ( sp ) sb a2 , 0x4 ( v0 ) b 0xa0 sb a1 , 0x5 ( v0 ) lw a0 , 0x18 ( sp ) beqz a0 , 0x15c lw t9 , - 0x7614 ( gp ) jalr t9 nop lw gp , 0x10 ( sp ) b 0xd0 move v0 , zero lw v0 , 0x1c ( sp ) beqz v0 , 0x154 nop blez v0 , 0xd0 move v0 , zero lw t9 , - 0x7fc4 ( gp ) bal 0x489c addiu a0 , zero , 0x20 lw gp , 0x10 ( sp ) move v1 , v0 b 0xc8 sw v0 , 0x18 ( sp ) addiu a1 , s0 , 0x1 move a0 , v0 bal 0x4954 sll a1 , a1 , 0x1 lw gp , 0x10 ( sp ) addu v1 , v0 , s0 b 0xc8 sw v0 , 0x18 ( sp ) lw t9 , - 0x7648 ( gp ) jalr t9 nop
Code2: push { fp , lr } add fp , sp , 0x4 sub sp , sp , 0x20 str r0 , [ fp , - 0x20 ] str r1 , [ fp , - 0x24 ] ldr r3 , [ pc , 0x11c ] ldr r3 , [ r3 ] str r3 , [ fp , - 0x8 ] mov r3 , 0x0 str r3 , [ fp , - 0x18 ] ldr r3 , [ fp , - 0x20 ] cmp r3 , 0x0 beq 0x44 ldr r3 , [ fp , - 0x20 ] ldrb r3 , [ r3 ] cmp r3 , 0x0 bne 0x4c mov r3 , 0x0 b 0x114 mov r2 , 0x2 ldr r1 , [ pc , 0xe4 ] ldr r0 , [ fp , - 0x20 ] bl 0xffeef8cc mov r3 , r0 cmp r3 , 0x0 beq 0x70 mov r3 , 0x0 b 0x114 sub r3 , fp , 0x14 mov r0 , r3 bl 0xffffcb58 ldr r1 , [ pc , 0xbc ] ldr r0 , [ fp , - 0x20 ] bl 0xffeef434 mov r3 , r0 cmp r3 , 0x0 bne 0xa8 sub r3 , fp , 0x14 ldr r1 , [ pc , 0xa4 ] mov r0 , r3 bl 0xffffcc50 b 0xd4 sub r3 , fp , 0x14 mov r2 , 0x0 ldr r1 , [ fp , - 0x20 ] mov r0 , r3 bl 0xfffff8b0 mov r3 , r0 cmp r3 , 0x0 bne 0xd4 sub r3 , fp , 0x14 mov r0 , r3 bl 0xffffcaf0 sub r3 , fp , 0x14 mov r0 , r3 bl 0xffffcba4 mov r3 , r0 cmp r3 , 0x0 ble 0x110 sub r3 , fp , 0x14 mov r1 , 0x1 mov r0 , r3 bl 0xffffc9b4 ldr r3 , [ fp , - 0x10 ] mov r2 , 0x0 strb r2 , [ r3 ] ldr r3 , [ fp , - 0x14 ] str r3 , [ fp , - 0x18 ] ldr r3 , [ fp , - 0x18 ] mov r0 , r3 ldr r3 , [ pc , 0x18 ] ldr r2 , [ fp , - 0x8 ] ldr r3 , [ r3 ] cmp r2 , r3 beq 0x130 bl 0xffeef518 sub sp , fp , 0x4 pop { fp , pc } andseq r3 , r6 , r0 , lsl 0x30 andseq r2 , r5 , ip , ror sl andseq r2 , r5 , r0 , ror 0x23 andseq r2 , r5 , r8 , ror 0x23
Similarity: -1
Label: 1
Similarity Score: 0.15
Explanation: The two assembly codes are from different architectures (MIPS vs ARM) and exhibit fundamental differences in instruction sets, register usage, and calling conventions. While both initialize stack frames and include conditional checks for null inputs, their control flow structures, function call patterns, and memory operations differ significantly. The MIPS code uses GP-relative addressing and explicit delay slots, while the ARM code employs PC-relative loads and conditional execution suffixes. Key operations like string handling use architecture-specific instructions (e.g., `lb`/`jalr` in MIPS vs `ldrb`/`bl` in ARM). The low structural alignment and architectural divergence outweigh the minor high-level similarities, resulting in a low similarity score and a "not similar" classification.
------------------------------------------------------------

------------------------------------------------------------
Code1: sub rsp , 0x18 mov rcx , rsi mov rdx , rdi xorps xmm0 , xmm0 movups xmmword ptr [ rsp + 0x8 ] , xmm0 mov dword ptr [ rsp ] , 0x0 mov edi , 0x4e6210 mov esi , 0x5c85a9 xor r8d , r8d xor r9d , r9d call 0xffffffffffffe0e0 add rsp , 0x18 ret nop word ptr cs : [ rax + rax ] nop dword ptr [ rax ]
Code2: push ebx call 0xffed6a80 add ebx , 0x1bf306 sub esp , 0x14 lea eax , [ ebx - 0xe19bd ] push 0x0 push 0x0 push 0x0 push 0x0 push 0x0 push dword ptr [ esp + 0x34 ] push dword ptr [ esp + 0x34 ] push eax push dword ptr [ ebx + 0x270 ] call 0xffffcce0 add esp , 0x38 pop ebx ret nop lea esi , [ esi ]
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly codes show fundamental differences in architecture, calling conventions, and implementation logic. Code1 uses 64-bit registers (rsp, rcx, rdi) and SSE instructions (xorps, movups), indicating x86-64 architecture with register-based calling conventions. Code2 uses 32-bit registers (ebx, esp, eax) and stack-based argument passing, typical of 32-bit x86. The stack management (sub/add vs push/pop), argument setup (registers vs multiple pushes), and absence of overlapping operations or patterns confirm they implement unrelated functionality. The architectural mismatch and lack of shared logic result in no meaningful similarity.
------------------------------------------------------------

------------------------------------------------------------
Code1: push ebp push edi push esi push ebx call 0xfffea2c0 add ebx , 0xc86af sub esp , 0x30 mov eax , dword ptr [ esp + 0x44 ] mov dword ptr [ esp + 0x1c ] , ebx mov esi , dword ptr [ eax ] mov eax , dword ptr [ esp + 0x48 ] cmp dword ptr [ eax ] , esi cmovae esi , dword ptr [ eax ] add esi , 0x1 lea edi , [ esi * 0x4 ] push edi push 0x8 push 0x1 call 0xffff6800 mov dword ptr [ esp + 0x2c ] , eax add esp , 0x10 test esi , esi je 0x187 mov edx , dword ptr [ esp + 0x1c ] sub esp , 0x8 lea eax , [ edx + 0x8 ] mov dword ptr [ edx ] , esi mov esi , edx mov dword ptr [ edx + 0x4 ] , eax push edi push eax mov ebx , dword ptr [ esp + 0x28 ] call 0x799c0 mov edx , dword ptr [ esi ] mov eax , dword ptr [ esi + 0x4 ] mov dword ptr [ esp + 0x20 ] , edx mov dword ptr [ esp + 0x24 ] , eax add esp , 0x10 test edx , edx je 0xd2 xor ebx , ebx xor ebp , ebp test eax , eax je 0xd2 mov dword ptr [ esp + 0xc ] , ebx lea esi , [ esi ] mov eax , dword ptr [ esp + 0x40 ] xor esi , esi xor edi , edi cmp ebp , dword ptr [ eax ] jae 0x9c mov eax , dword ptr [ eax + 0x4 ] xor edi , edi mov esi , dword ptr [ eax + ebp * 0x4 ] mov eax , dword ptr [ esp + 0x44 ] cmp ebp , dword ptr [ eax ] jae 0x160 mov eax , dword ptr [ eax + 0x4 ] xor ebx , ebx xor edx , edx mov ecx , dword ptr [ eax + ebp * 0x4 ] mov eax , dword ptr [ esp + 0xc ] add eax , esi adc edx , edi add eax , ecx mov ecx , dword ptr [ esp + 0x14 ] adc edx , ebx mov dword ptr [ esp + 0xc ] , edx mov dword ptr [ ecx + ebp * 0x4 ] , eax add ebp , 0x1 cmp dword ptr [ esp + 0x10 ] , ebp jne 0x88 mov eax , dword ptr [ esp + 0x48 ] sub esp , 0x4 mov esi , dword ptr [ eax ] lea edi , [ esi * 0x4 ] push edi push 0x8 push 0x1 mov ebx , dword ptr [ esp + 0x28 ] call 0xffff6800 add esp , 0x10 test esi , esi mov ebp , eax je 0x187 mov dword ptr [ eax ] , esi lea eax , [ eax + 0x8 ] sub esp , 0x8 mov dword ptr [ ebp + 0x4 ] , eax push edi push eax mov edi , dword ptr [ esp + 0x28 ] mov ebx , edi call 0x799c0 push ebp push 0x0 push dword ptr [ esp + 0x60 ] mov esi , dword ptr [ esp + 0x38 ] push esi call 0xffffdbc0 mov eax , dword ptr [ esi ] add esp , 0x18 mov dword ptr [ esp + 0x14 ] , eax shl eax , 0x2 push eax push dword ptr [ esi + 0x4 ] call 0x799c0 pop eax pop edx push 0x8 push esi call 0x799c0 mov dword ptr [ esp ] , esi call 0xffff68b0 add esp , 0x3c mov eax , ebp pop ebx pop esi pop edi pop ebp ret mov esi , esi lea edi , [ edi ] mov eax , dword ptr [ esp + 0xc ] mov ebx , dword ptr [ esp + 0x14 ] xor edx , edx add eax , esi adc edx , edi mov dword ptr [ ebx + ebp * 0x4 ] , eax add ebp , 0x1 cmp dword ptr [ esp + 0x10 ] , ebp mov dword ptr [ esp + 0xc ] , edx jne 0x88 jmp 0xd2 call 0xfffe830c lea esi , [ esi ]
Code2: push rbp mov rbp , rsp sub rsp , 0x30 mov qword ptr [ rbp - 0x8 ] , rdi mov qword ptr [ rbp - 0x10 ] , rsi mov qword ptr [ rbp - 0x18 ] , rdx mov rdi , qword ptr [ rbp - 0x8 ] mov rsi , qword ptr [ rbp - 0x10 ] call 0xffffffffffffd160 mov qword ptr [ rbp - 0x20 ] , rax mov rdi , qword ptr [ rbp - 0x20 ] mov rsi , qword ptr [ rbp - 0x18 ] call 0xffffffffffffe4d0 mov qword ptr [ rbp - 0x28 ] , rax mov rdi , qword ptr [ rbp - 0x20 ] call 0xffffffffffffa690 mov rax , qword ptr [ rbp - 0x28 ] add rsp , 0x30 pop rbp ret nop dword ptr [ rax ]
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two code snippets show fundamental differences in architecture, structure, and functionality:
1. Architecture: Code1 uses 32-bit registers (eax/ebx/esi) while Code2 uses 64-bit registers (rax/rdi/rbp)
2. Stack management: Code1 manually manages stack pointers with `add/sub esp`, while Code2 uses standard RBP frame pointers
3. Functionality: Code1 contains complex arithmetic operations, conditional jumps, and memory manipulation. Code2 has straightforward function calls with no branching
4. Calling conventions: Code1 passes arguments via stack pushes, while Code2 uses register-based calling (rdi/rsi)
5. Control flow: Code1 contains loops (cmp/jne) and conditional logic, while Code2 is linear with no branching
6. Memory operations: Code1 has extensive dword ptr memory accesses, while Code2 uses qword ptr exclusively

The architectural differences (32-bit vs 64-bit), absence of shared logic patterns, and fundamentally different approaches to memory/stack management indicate completely dissimilar implementations.
------------------------------------------------------------

------------------------------------------------------------
Code1: push ebp mov ebp , esp push ebx sub esp , 0x44 mov eax , dword ptr [ 0x8054c38 ] mov dword ptr [ eax + 0x14 ] , 0x0 mov eax , dword ptr [ 0x8054c38 ] mov eax , dword ptr [ eax + 0x4 ] mov dword ptr [ ebp - 0x1c ] , eax mov eax , dword ptr [ 0x8054c14 ] mov ecx , dword ptr [ 0x8054c38 ] mov dword ptr [ ecx + 0x4 ] , eax mov eax , dword ptr [ 0x8054c38 ] add eax , - 0x1c mov dword ptr [ ebp - 0x8 ] , eax mov eax , dword ptr [ 0x80532e0 ] jmp eax mov eax , dword ptr [ ebp - 0x8 ] sub eax , 0x8055fdc setae cl movzx edx , cl mov edx , dword ptr [ edx * 0x4 + 0x80536bc ] mov dword ptr [ ebp - 0x20 ] , eax jmp edx mov dword ptr [ ebp - 0x18 ] , 0x7fffffff mov eax , dword ptr [ ebp - 0x8 ] sub eax , 0x8055fdc sete cl movzx edx , cl mov edx , dword ptr [ edx * 0x4 + 0x80536c4 ] mov dword ptr [ ebp - 0x24 ] , eax jmp edx mov eax , dword ptr [ 0x8054c4c ] mov ecx , dword ptr [ 0x80532f0 ] mov dword ptr [ ebp - 0x28 ] , eax jmp ecx mov eax , dword ptr [ 0x8054c30 ] mov ecx , dword ptr [ 0x80532f0 ] mov dword ptr [ ebp - 0x28 ] , eax jmp ecx mov eax , dword ptr [ ebp - 0x28 ] mov dword ptr [ ebp - 0x10 ] , eax mov eax , dword ptr [ ebp - 0x8 ] mov dword ptr [ ebp - 0xc ] , eax mov eax , dword ptr [ ebp - 0xc ] mov eax , dword ptr [ eax + 0x4 ] mov ecx , dword ptr [ ebp - 0x10 ] add ecx , eax mov dword ptr [ ebp - 0x10 ] , ecx mov eax , dword ptr [ 0x80532f4 ] jmp eax mov eax , dword ptr [ ebp - 0xc ] add eax , 0x1c mov dword ptr [ ebp - 0xc ] , eax mov eax , dword ptr [ ebp - 0xc ] mov ecx , dword ptr [ ebp - 0x10 ] mov edx , esp mov dword ptr [ edx + 0x4 ] , ecx mov dword ptr [ edx ] , eax call 0xef0 mov ecx , dword ptr [ ebp - 0xc ] mov ecx , dword ptr [ ecx + 0x14 ] add eax , ecx mov dword ptr [ ebp - 0x14 ] , eax mov eax , dword ptr [ ebp - 0x8 ] sub eax , 0x8055fdc sete bl movzx ecx , bl mov ecx , dword ptr [ ecx * 0x4 + 0x80536cc ] mov dword ptr [ ebp - 0x2c ] , eax jmp ecx mov eax , dword ptr [ 0x8054c44 ] test eax , eax setg cl movzx eax , cl mov eax , dword ptr [ eax * 0x4 + 0x80536d4 ] jmp eax mov eax , dword ptr [ ebp - 0x10 ] mov ecx , dword ptr [ 0x8054c44 ] sub eax , ecx add eax , eax lea eax , [ eax + eax * 0x4 ] imul eax , eax sar eax , 0x1 mov ecx , dword ptr [ ebp - 0x14 ] add ecx , eax mov dword ptr [ ebp - 0x14 ] , ecx mov eax , dword ptr [ 0x8053300 ] jmp eax mov eax , dword ptr [ ebp - 0x14 ] mov ecx , dword ptr [ ebp - 0x18 ] sub eax , ecx setl dl movzx ecx , dl mov ecx , dword ptr [ ecx * 0x4 + 0x80536dc ] mov dword ptr [ ebp - 0x30 ] , eax jmp ecx mov eax , dword ptr [ ebp - 0x14 ] mov dword ptr [ ebp - 0x18 ] , eax mov eax , dword ptr [ ebp - 0xc ] mov ecx , dword ptr [ ebp - 0x8 ] mov dword ptr [ ecx + 0x18 ] , eax mov eax , dword ptr [ ebp - 0x10 ] mov ecx , dword ptr [ ebp - 0x8 ] mov dword ptr [ ecx + 0x10 ] , eax mov eax , dword ptr [ 0x8053308 ] jmp eax mov eax , dword ptr [ ebp - 0xc ] mov ecx , dword ptr [ 0x8054c38 ] sub eax , ecx sete dl movzx ecx , dl mov ecx , dword ptr [ ecx * 0x4 + 0x80536e4 ] mov dword ptr [ ebp - 0x34 ] , eax jmp ecx mov eax , dword ptr [ 0x8053318 ] jmp eax mov eax , dword ptr [ ebp - 0xc ] mov ecx , dword ptr [ eax - 0x14 ] mov eax , dword ptr [ eax + 0x4 ] add ecx , eax mov eax , dword ptr [ ebp - 0x10 ] add eax , ecx mov dword ptr [ ebp - 0x10 ] , eax mov eax , dword ptr [ 0x8053314 ] jmp eax mov eax , dword ptr [ ebp - 0x10 ] mov ecx , dword ptr [ 0x8054c14 ] sub eax , ecx setl dl movzx ecx , dl mov ecx , dword ptr [ ecx * 0x4 + 0x80536ec ] mov dword ptr [ ebp - 0x38 ] , eax jmp ecx mov eax , dword ptr [ ebp - 0x18 ] mov ecx , dword ptr [ ebp - 0x8 ] mov edx , esp mov dword ptr [ edx ] , ecx mov dword ptr [ ebp - 0x3c ] , eax call 0xfb0 mov ecx , dword ptr [ ebp - 0x3c ] add ecx , eax mov eax , dword ptr [ ebp - 0x8 ] mov dword ptr [ eax + 0x14 ] , ecx mov eax , dword ptr [ 0x805331c ] jmp eax mov eax , dword ptr [ ebp - 0x8 ] add eax , - 0x1c mov dword ptr [ ebp - 0x8 ] , eax mov eax , dword ptr [ 0x80532e0 ] jmp eax mov eax , dword ptr [ ebp - 0x1c ] mov ecx , dword ptr [ 0x8054c38 ] mov dword ptr [ ecx + 0x4 ] , eax add esp , 0x44 pop ebx pop ebp ret nop
Code2: push { r4 , r5 , r6 , r7 , r8 , sb , sl , fp , lr } sub sp , sp , 0x14 ldr r3 , [ pc , 0x1e4 ] ldr r5 , [ r3 , 0x24 ] mov r2 , 0x0 str r2 , [ r5 , 0x14 ] ldr r2 , [ r5 , 0x4 ] str r2 , [ sp , 0xc ] ldr sb , [ r3 , 0x28 ] str sb , [ r5 , 0x4 ] sub r4 , r5 , 0x1c ldr r3 , [ pc , 0x1c4 ] cmp r4 , r3 blo 0x1e4 ldr r3 , [ pc , 0x1b4 ] ldr r2 , [ r3 , 0x4 ] str r2 , [ sp , 0x4 ] ldr r2 , [ r3 , 0x8 ] str r2 , [ sp , 0x8 ] ldr sl , [ r3 , 0x2c ] ldr fp , [ r3 , 0x30 ] ldr r8 , [ pc , 0x19c ] b 0x174 ldr r1 , [ r2 , 0x14 ] add r3 , r3 , r1 cmp r4 , r8 beq 0xe8 cmp r3 , r6 strlt r2 , [ r4 , 0x18 ] strlt r0 , [ r4 , 0x10 ] movlt r6 , r3 cmp r5 , r2 beq 0x108 ldr r3 , [ r2 , - 0x14 ] ldr r1 , [ r2 , 0x4 ] add r3 , r3 , r1 add r0 , r0 , r3 cmp sb , r0 ble 0x108 add r2 , r2 , 0x1c cmp r5 , r2 moveq r3 , 0x0 beq 0x5c sub r3 , sl , r0 add r3 , r3 , r3 , lsl 0x2 lsl r3 , r3 , 0x1 mul r1 , r3 , r3 mov r3 , r1 ldr r1 , [ r2 , 0x18 ] cmp r5 , r1 beq 0x5c ldr r1 , [ r2 , 0x10 ] sub r1 , r0 , r1 add r1 , r1 , r1 , lsl 0x2 lsl r1 , r1 , 0x1 mul ip , r1 , r1 add r3 , r3 , ip , asr 0x1 b 0x5c cmp fp , 0x0 ble 0x6c sub r1 , r0 , fp add r1 , r1 , r1 , lsl 0x2 lsl r1 , r1 , 0x1 mul ip , r1 , r1 add r3 , r3 , ip , asr 0x1 b 0x6c cmp r4 , r8 ldrls r7 , [ pc , 0xe8 ] bls 0x134 ldrb r3 , [ r4 , - 0x10 ] tst r3 , 0x2 beq 0x19c and r3 , r3 , 0x8 cmp r3 , 0x0 ldr r3 , [ pc , 0xd0 ] movne r7 , 0x960 moveq r7 , r3 ldrb r3 , [ r4 , 0xc ] tst r3 , 0x1 subne r7 , r7 , 0x640 bne 0x160 tst r3 , 0x8 beq 0x160 ldr r3 , [ sp ] add r1 , r3 , 0x2 ldr r0 , [ pc , 0xa8 ] bl 0x5870 add r7 , r7 , r0 add r6 , r6 , r7 str r6 , [ r4 , 0x14 ] sub r4 , r4 , 0x1c cmp r4 , r8 blo 0x1e4 ldr r0 , [ sp , 0x4 ] ldr r3 , [ sp , 0x8 ] cmp r4 , r8 moveq r0 , r3 ldr r3 , [ r4 , 0x4 ] str r3 , [ sp ] add r0 , r3 , r0 mov r2 , r4 mvn r6 , 0x80000000 b 0x9c tst r3 , 0x4 ldrne r7 , [ pc , 0x60 ] bne 0x134 ldr r3 , [ pc , 0x5c ] cmp r4 , r3 ldrls r7 , [ pc , 0x44 ] bls 0x134 ldrb r3 , [ r4 , - 0x2c ] tst r3 , 0x8 ldreq r7 , [ pc , 0x34 ] beq 0x134 ldr r1 , [ r4 , - 0x18 ] add r1 , r1 , 0x2 ldr r0 , [ pc , 0x38 ] bl 0x5870 add r7 , r0 , 0x1300 add r7 , r7 , 0x24 b 0x134 ldr r3 , [ sp , 0xc ] str r3 , [ r5 , 0x4 ] add sp , sp , 0x14 pop { r4 , r5 , r6 , r7 , r8 , sb , sl , fp , pc } andeq r8 , r2 , r4 , ror 0x2 strheq r8 , [ r2 ] , -r8 andeq r1 , r0 , r4 , lsr 0x6 andeq sb , r5 , r4 , ror 0x2 andeq r5 , r0 , r4 , ror 0x15 andeq r0 , r0 , r4 , ror 0x25 ldrdeq r8 , sb , [ r2 ] , -r4 andeq sb , r0 , r0 , asr 0x24
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two code snippets are for different architectures (x86 vs ARM) and the operations and control flow do not match. The only similarities are the standard function prologue and epilogue, which are common to many functions and do not indicate the same logic. The body of the code shows significant differences in instructions, memory accesses, and branching patterns.
------------------------------------------------------------

------------------------------------------------------------
Code1: mov rcx , qword ptr [ rsi + 0x8 ] test rcx , rcx je 0x21 mov eax , dword ptr [ rdx + 0x38 ] cmp eax , 0x1 je 0x4c cmp eax , 0x1 jb 0x44 cmp eax , 0x2 je 0x54 mov eax , 0x0 ret sub rsp , 0x8 lea rcx , [ rip + 0x2ed21 ] mov edx , 0x239 lea rsi , [ rip + 0x2e7d0 ] lea rdi , [ rip + 0x2e7d0 ] call 0xffffffffffffe915 cmp rcx , qword ptr [ rdx + 0x40 ] seta al ret cmp rcx , qword ptr [ rdx + 0x40 ] setb al ret cmp qword ptr [ rdx + 0x40 ] , rcx sete al ret
Code2: push ebp mov ebp , esp push edi push esi sub esp , 0x40 mov eax , dword ptr [ ebp + 0x10 ] mov ecx , dword ptr [ ebp + 0xc ] mov edx , dword ptr [ ebp + 0x8 ] mov esi , dword ptr [ ebp + 0xc ] mov edi , dword ptr [ esi + 0x58 ] mov esi , dword ptr [ esi + 0x5c ] or edi , esi mov dword ptr [ ebp - 0x10 ] , eax mov dword ptr [ ebp - 0x14 ] , ecx mov dword ptr [ ebp - 0x18 ] , edx mov dword ptr [ ebp - 0x1c ] , edi je 0x38 jmp 0x33 jmp 0x62 lea eax , [ 0x8144fe2 ] mov dword ptr [ esp ] , eax lea eax , [ 0x8144f44 ] mov dword ptr [ esp + 0x4 ] , eax mov dword ptr [ esp + 0x8 ] , 0x239 lea eax , [ 0x8144ff8 ] mov dword ptr [ esp + 0xc ] , eax call 0xffffc0b0 mov eax , dword ptr [ ebp + 0x10 ] mov eax , dword ptr [ eax + 0x28 ] mov dword ptr [ ebp - 0x20 ] , eax mov eax , dword ptr [ ebp - 0x20 ] cmp eax , 0x1 jl 0x94 mov eax , dword ptr [ ebp - 0x20 ] cmp eax , 0x2 jl 0xd5 mov eax , dword ptr [ ebp - 0x20 ] cmp eax , 0x2 je 0x10a jmp 0x13e mov eax , dword ptr [ ebp - 0x20 ] cmp eax , 0x0 jne 0x13e mov eax , dword ptr [ ebp + 0xc ] mov ecx , dword ptr [ eax + 0x58 ] mov eax , dword ptr [ eax + 0x5c ] mov edx , dword ptr [ ebp + 0x10 ] mov esi , dword ptr [ edx + 0x30 ] mov edx , dword ptr [ edx + 0x34 ] sub esi , ecx sbb edx , eax mov dword ptr [ ebp - 0x24 ] , esi mov dword ptr [ ebp - 0x28 ] , edx jae 0xd0 jmp 0xc7 mov byte ptr [ ebp - 0x9 ] , 0x1 jmp 0x147 jmp 0x143 mov eax , dword ptr [ ebp + 0xc ] mov ecx , dword ptr [ eax + 0x58 ] mov eax , dword ptr [ eax + 0x5c ] mov edx , dword ptr [ ebp + 0x10 ] mov esi , dword ptr [ edx + 0x30 ] mov edx , dword ptr [ edx + 0x34 ] sub ecx , esi sbb eax , edx mov dword ptr [ ebp - 0x2c ] , ecx mov dword ptr [ ebp - 0x30 ] , eax jae 0x105 jmp 0xfc mov byte ptr [ ebp - 0x9 ] , 0x1 jmp 0x147 jmp 0x143 mov eax , dword ptr [ ebp + 0xc ] mov ecx , dword ptr [ eax + 0x58 ] mov eax , dword ptr [ eax + 0x5c ] mov edx , dword ptr [ ebp + 0x10 ] mov esi , dword ptr [ edx + 0x30 ] mov edx , dword ptr [ edx + 0x34 ] xor eax , edx xor ecx , esi or ecx , eax mov dword ptr [ ebp - 0x34 ] , ecx jne 0x139 jmp 0x130 mov byte ptr [ ebp - 0x9 ] , 0x1 jmp 0x147 jmp 0x143 jmp 0x143 mov byte ptr [ ebp - 0x9 ] , 0x0 mov al , byte ptr [ ebp - 0x9 ] and al , 0x1 movzx eax , al add esp , 0x40 pop esi pop edi pop ebp ret nop word ptr cs : [ eax + eax ]
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly code snippets show significant differences in architecture, structure, and functionality. Code1 uses 64-bit registers (rcx, rsi, rdx) and RIP-relative addressing, while Code2 employs 32-bit registers (ebp, esp, eax) and absolute addressing. Code1 lacks stack frame setup and has simpler control flow with direct comparisons and set* instructions, whereas Code2 uses stack frames, complex conditional jumps (jl/jne/jae), and multi-step boolean logic. The operations (e.g., Code1's single call vs Code2's arithmetic/logic chains) and memory access patterns are fundamentally different. These architectural and structural disparities indicate no functional similarity.
------------------------------------------------------------

------------------------------------------------------------
Code1: push rbx sub rsp , 0x20 mov rbx , rsi mov rax , qword ptr fs : [ 0x28 ] mov qword ptr [ rsp + 0x18 ] , rax xor eax , eax lea rdx , [ rsp + 0x8 ] mov ecx , 0x0 mov esi , 0xa call 0xfffffffffffefa68 test eax , eax jne 0x87 mov rdi , qword ptr [ rsp + 0x8 ] test rdi , rdi je 0x87 lea rsi , [ rsp + 0x10 ] mov edx , 0xa call 0xfffffffffffefd08 mov rdx , qword ptr [ rsp + 0x10 ] cmp byte ptr [ rdx ] , 0x0 jne 0x65 mov edx , 0xfffffffe cmp rax , rdx ja 0x65 mov dword ptr [ rbx + 0x328 ] , eax jmp 0x79 mov rdi , qword ptr [ rsp + 0x8 ] call 0xfffffffffffef9f8 test eax , eax je 0x9d mov dword ptr [ rbx + 0x328 ] , eax mov rdi , qword ptr [ rsp + 0x8 ] lea rax , [ rip + 0x249f43 ] call qword ptr [ rax ] mov rax , qword ptr [ rsp + 0x18 ] xor rax , qword ptr fs : [ 0x28 ] jne 0xc7 add rsp , 0x20 pop rbx ret call 0xfffffffffffef688 mov edi , dword ptr [ rax ] call 0xfffffffffffefd88 mov rcx , rax mov rdx , qword ptr [ rsp + 0x8 ] lea rsi , [ rip + 0x3735d ] mov rdi , qword ptr [ rbx ] mov eax , 0x0 call 0x2059d jmp 0x79 call 0xfffffffffffef7c8
Code2: lui gp , 0xb addiu gp , gp , - 0x1794 addu gp , gp , t9 addiu sp , sp , - 0x48 sw ra , 0x44 ( sp ) sw fp , 0x40 ( sp ) sw s1 , 0x3c ( sp ) sw s0 , 0x38 ( sp ) move fp , sp sw gp , 0x10 ( sp ) sw a0 , 0x1c ( fp ) sw a1 , 0x18 ( fp ) lw v0 , - 0x7830 ( gp ) lw v0 , ( v0 ) sw v0 , 0x34 ( fp ) addiu v0 , fp , 0x20 move a3 , zero move a2 , v0 addiu a1 , zero , 0xa lw a0 , 0x1c ( fp ) lw v0 , - 0x7900 ( gp ) move t9 , v0 jalr t9 nop lw gp , 0x10 ( fp ) sw v0 , 0x28 ( fp ) lw v0 , 0x28 ( fp ) bnez v0 , 0x1a8 nop lw v0 , 0x20 ( fp ) beqz v0 , 0x1a8 nop lw v0 , 0x20 ( fp ) addiu v1 , fp , 0x24 addiu a2 , zero , 0xa move a1 , v1 move a0 , v0 lw v0 , - 0x78f8 ( gp ) move t9 , v0 jalr t9 nop lw gp , 0x10 ( fp ) sw v0 , 0x2c ( fp ) lw v0 , 0x24 ( fp ) lb v0 , ( v0 ) bnez v0 , 0xe0 nop lw v1 , 0x2c ( fp ) addiu v0 , zero , - 0x1 beq v1 , v0 , 0xe0 nop lw v0 , 0x18 ( fp ) lw v1 , 0x2c ( fp ) sw v1 , 0x2f4 ( v0 ) b 0x188 nop sw zero , 0x30 ( fp ) lw v0 , 0x20 ( fp ) move a0 , v0 lw v0 , - 0x79fc ( gp ) move t9 , v0 jalr t9 nop lw gp , 0x10 ( fp ) sw v0 , 0x30 ( fp ) lw v0 , 0x30 ( fp ) bnez v0 , 0x17c nop lw v0 , 0x18 ( fp ) lw s0 , ( v0 ) lw s1 , 0x20 ( fp ) lw v0 , - 0x793c ( gp ) move t9 , v0 jalr t9 nop lw gp , 0x10 ( fp ) lw v0 , ( v0 ) move a0 , v0 lw v0 , - 0x78e4 ( gp ) move t9 , v0 jalr t9 nop lw gp , 0x10 ( fp ) move a3 , v0 move a2 , s1 lw v0 , - 0x7fd4 ( gp ) addiu a1 , v0 , 0x12b0 move a0 , s0 lw v0 , - 0x7f34 ( gp ) move t9 , v0 jalr t9 nop lw gp , 0x10 ( fp ) b 0x188 nop lw v0 , 0x18 ( fp ) lw v1 , 0x30 ( fp ) sw v1 , 0x2f4 ( v0 ) lw v0 , - 0x7fcc ( gp ) lw v0 , ( v0 ) lw v1 , 0x20 ( fp ) move a0 , v1 move t9 , v0 jalr t9 nop lw gp , 0x10 ( fp ) nop lw v0 , - 0x7830 ( gp ) lw v1 , 0x34 ( fp ) lw v0 , ( v0 ) beq v1 , v0 , 0x1d0 nop lw v0 , - 0x7868 ( gp ) move t9 , v0 jalr t9 nop move sp , fp lw ra , 0x44 ( sp ) lw fp , 0x40 ( sp ) lw s1 , 0x3c ( sp ) lw s0 , 0x38 ( sp ) addiu sp , sp , 0x48 jr ra nop
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly code snippets are fundamentally dissimilar due to key differences:
1. Architecture: Code1 uses x86_64 instructions (rax, rbx, rsp, call) while Code2 uses MIPS instructions (lui, addiu, sw, jalr).
2. Register usage: Code1 employs x86 registers (rsi, rdi, rdx) whereas Code2 uses MIPS registers (gp, t9, v0, v1).
3. Memory operations: Code1 uses qword ptr and byte ptr with x86 addressing modes, while Code2 uses MIPS-style offsets like 0x44(sp).
4. Control flow: Code1 uses x86 conditional jumps (jne/je) while Code2 uses MIPS branch instructions (bnez/beq).
5. Function calls: Code1 uses direct call instructions while Code2 uses MIPS t9 register indirection (jalr t9).
The architectural differences (x86 vs MIPS) and lack of overlapping instruction patterns indicate these code snippets implement entirely different logic for different processors.
------------------------------------------------------------

------------------------------------------------------------
Code1: push ebp push edi mov ebp , eax push esi push ebx xor esi , esi call 0xffff4a30 add ebx , 0x1e583 sub esp , 0x3c mov eax , dword ptr gs : [ 0x14 ] mov dword ptr [ esp + 0x2c ] , eax xor eax , eax test edx , edx je 0x7f mov edi , dword ptr [ ecx ] mov eax , dword ptr [ edx + edi * 0x4 ] test eax , eax je 0x7f add edi , 0x1 mov edx , dword ptr [ esp + 0x50 ] mov dword ptr [ ecx ] , edi lea edi , [ ebx + 0x12e0 ] mov dword ptr [ esp + 0x1c ] , edx lea edx , [ esp + 0x1c ] sub esp , 0xc mov ecx , dword ptr [ edi + 0x20 ] mov dword ptr [ esp + 0x18 ] , ecx mov ecx , dword ptr [ edi + 0x1c ] add ecx , 0x15180 mov dword ptr [ esp + 0x14 ] , ecx lea ecx , [ ebx - 0xd6a0 ] push ecx push 0x404e0000 push 0x0 push dword ptr [ esp + 0x24 ] push dword ptr [ esp + 0x24 ] call 0xffffc950 add esp , 0x20 test al , al jne 0xa0 mov ebx , dword ptr [ esp + 0x2c ] xor ebx , dword ptr gs : [ 0x14 ] mov eax , esi jne 0x142 add esp , 0x3c pop ebx pop esi pop edi pop ebp ret lea esi , [ esi ] sub esp , 0xc push ebp call 0xffffaab0 mov ecx , eax mov eax , dword ptr [ esp + 0x2c ] mov esi , dword ptr [ edi + 0x1c ] sub esi , dword ptr [ esp + 0x34 ] mov edx , 0xc22e4507 mov dword ptr [ ecx + 0x24 ] , eax mov eax , dword ptr [ esp + 0x30 ] mov dword ptr [ ecx + 0x28 ] , eax mov eax , dword ptr [ esp + 0x34 ] mov dword ptr [ ecx + 0x2c ] , eax mov eax , dword ptr [ esp + 0x38 ] mov dword ptr [ ecx + 0x30 ] , eax mov eax , esi imul edx add edx , esi sar esi , 0x1f sar edx , 0x10 sub edx , esi mov dword ptr [ esp + 0x18 ] , edx fild dword ptr [ esp + 0x18 ] add esp , 0x10 fld st ( 0x0 ) fld qword ptr [ ebx - 0xd218 ] fucompi st ( 0x1 ) fstp st ( 0x0 ) ja 0x120 fld1 fucompi st ( 0x1 ) ja 0x138 fld dword ptr [ ebx - 0xd224 ] fxch st ( 0x1 ) fucompi st ( 0x1 ) fstp st ( 0x0 ) ja 0x13a fld dword ptr [ ebx - 0xd228 ] jmp 0x128 lea esi , [ esi ] lea edi , [ edi ] fstp st ( 0x0 ) fld dword ptr [ ebx - 0xd250 ] fstp dword ptr [ ecx + 0x18 ] mov esi , 0x1 jmp 0x7f lea esi , [ esi ] fstp st ( 0x0 ) fld dword ptr [ ebx - 0xd22c ] jmp 0x128 call 0xe2b0 mov esi , esi lea edi , [ edi ]
Code2: push ebp push edi push esi push ebx sub esp , 0x94 call 0xffe13dae add ebx , 0x1b759f mov dword ptr [ esp + 0x14 ] , eax mov edi , edx mov dword ptr [ esp + 0x18 ] , ecx mov edx , dword ptr [ esp + 0xac ] mov dword ptr [ esp + 0x1c ] , edx mov ecx , dword ptr gs : [ 0x14 ] mov dword ptr [ esp + 0x84 ] , ecx xor ecx , ecx lea esi , [ esp + 0x38 ] push esi push eax call 0xffe1166e add esp , 0x4 lea eax , [ esp + 0x40 ] push eax push esi lea eax , [ esp + 0x50 ] push eax lea eax , [ esp + 0x50 ] push eax push edi call 0xffe12c1e mov eax , dword ptr [ esp + 0x50 ] add esp , 0x20 test al , 0x1 je 0x70 sub eax , 0x1 mov dword ptr [ esp + 0x30 ] , eax mov eax , dword ptr [ esp + 0x34 ] test al , 0x1 je 0x7f sub eax , 0x1 mov dword ptr [ esp + 0x34 ] , eax sub esp , 0xc push dword ptr [ esp + 0x20 ] push 0x3 push dword ptr [ esp + 0x48 ] push dword ptr [ esp + 0x48 ] push dword ptr [ esp + 0x28 ] call 0xffe1175e mov esi , eax add esp , 0x20 mov eax , 0x0 test esi , esi je 0x24b sub esp , 0x8 lea eax , [ esp + 0x58 ] push eax push edi call 0xffe11d6e fnstcw word ptr [ esp + 0x3e ] movzx edx , word ptr [ esp + 0x3e ] or dh , 0xc mov word ptr [ esp + 0x3c ] , dx fld qword ptr [ esp + 0x60 ] fldcw word ptr [ esp + 0x3c ] fistp qword ptr [ esp + 0x30 ] fldcw word ptr [ esp + 0x3e ] mov edx , dword ptr [ esp + 0x30 ] mov edi , edx mov dword ptr [ esp + 0x40 ] , edx add esp , 0x10 test al , 0x8 je 0x203 fld qword ptr [ esp + 0x58 ] fldcw word ptr [ esp + 0x2c ] fistp qword ptr [ esp + 0x20 ] fldcw word ptr [ esp + 0x2e ] mov eax , dword ptr [ esp + 0x20 ] mov dword ptr [ esp + 0x34 ] , eax mov eax , dword ptr [ esi + 0x18 ] cmp edi , eax jne 0x11b mov ecx , dword ptr [ esp + 0x34 ] cmp dword ptr [ esi + 0x1c ] , ecx je 0x20c lea ecx , [ edi + 0x1 ] sub ecx , eax shr ecx , 0x1 mov dword ptr [ esp + 0x40 ] , ecx mov eax , dword ptr [ esp + 0x34 ] add eax , 0x1 sub eax , dword ptr [ esi + 0x1c ] shr eax , 0x1 mov dword ptr [ esp + 0x44 ] , eax push dword ptr [ esp + 0x14 ] mov eax , dword ptr [ esp + 0x10 ] push dword ptr [ eax + 0x23c ] lea eax , [ esp + 0x48 ] push eax push esi call 0xffe12b0e mov ebp , eax add esp , 0x10 mov eax , 0x0 test ebp , ebp je 0x24b sub esp , 0xc push esi call 0xffe130ae add esp , 0x10 mov eax , dword ptr [ esp + 0x10 ] cmp dword ptr [ ebp + 0x18 ] , eax jne 0x182 mov eax , dword ptr [ esp + 0xa0 ] cmp dword ptr [ ebp + 0x1c ] , eax je 0x1b7 sub esp , 0xc push dword ptr [ esp + 0x20 ] push dword ptr [ ebp + 0x228 ] push dword ptr [ esp + 0xb4 ] push dword ptr [ esp + 0x28 ] push ebp call 0xffe1175e mov esi , eax add esp , 0x20 test eax , eax je 0x1b7 sub esp , 0xc push ebp call 0xffe130ae add esp , 0x10 mov ebp , esi sub esp , 0x4 mov esi , dword ptr [ esp + 0x18 ] push esi push 0x1c push ebp call 0xffe1283e mov dword ptr [ esp ] , esi push 0x3 mov eax , dword ptr [ ebp + 0x1c ] shr eax , 0x1 push eax mov eax , dword ptr [ ebp + 0x18 ] shr eax , 0x1 push eax push ebp call 0xffe1175e mov edx , eax mov dword ptr [ esp + 0x30 ] , eax add esp , 0x20 mov eax , 0x0 test edx , edx je 0x24b cmp dword ptr [ ebp + 0x1c ] , 0x0 jle 0x213 mov dword ptr [ esp + 0x18 ] , 0x0 jmp 0x4ae mov dword ptr [ esp + 0x34 ] , edx jmp 0x107 mov ebp , esi jmp 0x16d mov esi , 0x800 mov edi , dword ptr [ esp + 0xc ] sub esp , 0x8 push 0x0 push edi call 0xffe12e6e add esp , 0x10 sub esi , 0x1 jne 0x21c sub esp , 0xc push dword ptr [ esp + 0x1c ] call 0xffe130ae mov dword ptr [ esp ] , ebp call 0xffe130ae add esp , 0x10 mov eax , 0x1 mov edx , dword ptr [ esp + 0x7c ] xor edx , dword ptr gs : [ 0x14 ] jne 0x52a add esp , 0x8c pop ebx pop esi pop edi pop ebp ret fstp st ( 0x0 ) mov eax , 0x0 jmp 0x276 fstp st ( 0x0 ) jmp 0x276 fstp st ( 0x0 ) sub esp , 0x8 movzx eax , al push eax push dword ptr [ esp + 0x18 ] call 0xffe12e6e mov eax , dword ptr [ ebp + 0x298 ] lea esi , [ esi + eax * 0x8 ] add edi , 0x1 mov eax , dword ptr [ ebp + 0x18 ] add eax , eax add esp , 0x10 cmp eax , edi jle 0x4e5 mov eax , dword ptr [ ebp + 0x2a8 ] mov eax , dword ptr [ eax + 0x8 ] fld qword ptr [ esi + eax * 0x8 ] fucomi st ( 0x0 ) jp 0x267 mov eax , 0x0 fldz fucompi st ( 0x1 ) jae 0x270 fdiv dword ptr [ ebx - 0x13a3d4 ] mov eax , 0xffffffff fld dword ptr [ ebx - 0x13a3d0 ] fxch st ( 0x1 ) fucomi st ( 0x1 ) fstp st ( 0x1 ) jae 0x274 fadd dword ptr [ ebx - 0x14329c ] fnstcw word ptr [ esp + 0x2e ] movzx eax , word ptr [ esp + 0x2e ] or ah , 0xc mov word ptr [ esp + 0x2c ] , ax fldcw word ptr [ esp + 0x2c ] fistp word ptr [ esp + 0x2a ] fldcw word ptr [ esp + 0x2e ] movzx eax , word ptr [ esp + 0x2a ] jmp 0x276 fstp st ( 0x0 ) mov eax , 0x0 jmp 0x312 fstp st ( 0x0 ) jmp 0x312 fstp st ( 0x0 ) sub esp , 0x8 movzx eax , al push eax push dword ptr [ esp + 0x18 ] call 0xffe12e6e mov eax , dword ptr [ ebp + 0x298 ] lea esi , [ esi + eax * 0x8 ] add edi , 0x1 mov eax , dword ptr [ esp + 0x20 ] mov eax , dword ptr [ eax + 0x18 ] add esp , 0x10 cmp eax , edi jle 0x39d mov eax , dword ptr [ ebp + 0x2a8 ] mov eax , dword ptr [ eax + 0x14 ] fld qword ptr [ esi + eax * 0x8 ] fucomi st ( 0x0 ) jp 0x303 mov eax , 0x0 fldz fucompi st ( 0x1 ) jae 0x30c fdiv dword ptr [ ebx - 0x13a3d4 ] mov eax , 0xffffffff fld dword ptr [ ebx - 0x13a3d0 ] fxch st ( 0x1 ) fucomi st ( 0x1 ) fstp st ( 0x1 ) jae 0x310 fadd dword ptr [ ebx - 0x14329c ] fnstcw word ptr [ esp + 0x2e ] movzx eax , word ptr [ esp + 0x2e ] or ah , 0xc mov word ptr [ esp + 0x2c ] , ax fldcw word ptr [ esp + 0x2c ] fistp word ptr [ esp + 0x2a ] fldcw word ptr [ esp + 0x2e ] movzx eax , word ptr [ esp + 0x2a ] jmp 0x312 sub esp , 0x8 push dword ptr [ esp + 0x1c ] push 0x1 push eax push dword ptr [ esp + 0x30 ] push 0x0 mov edi , dword ptr [ esp + 0x2c ] push edi call 0xffe1119e mov esi , eax add esp , 0x20 test eax , eax je 0x213 cmp dword ptr [ edi + 0x18 ] , 0x0 jle 0x46d mov edi , 0x0 jmp 0x40c fstp st ( 0x0 ) mov eax , 0x0 jmp 0x3e4 fstp st ( 0x0 ) jmp 0x3e4 fstp st ( 0x0 ) sub esp , 0x8 movzx eax , al push eax push dword ptr [ esp + 0x18 ] call 0xffe12e6e mov eax , dword ptr [ ebp + 0x298 ] lea esi , [ esi + eax * 0x8 ] add edi , 0x1 add esp , 0x10 mov eax , dword ptr [ esp + 0x10 ] cmp dword ptr [ eax + 0x18 ] , edi jle 0x46d mov eax , dword ptr [ ebp + 0x2a8 ] mov eax , dword ptr [ eax + 0x20 ] fld qword ptr [ esi + eax * 0x8 ] fucomi st ( 0x0 ) jp 0x3d5 mov eax , 0x0 fldz fucompi st ( 0x1 ) jae 0x3de fdiv dword ptr [ ebx - 0x13a3d4 ] mov eax , 0xffffffff fld dword ptr [ ebx - 0x13a3d0 ] fxch st ( 0x1 ) fucomi st ( 0x1 ) fstp st ( 0x1 ) jae 0x3e2 fadd dword ptr [ ebx - 0x14329c ] fnstcw word ptr [ esp + 0x2e ] movzx eax , word ptr [ esp + 0x2e ] or ah , 0xc mov word ptr [ esp + 0x2c ] , ax fldcw word ptr [ esp + 0x2c ] fistp word ptr [ esp + 0x2a ] fldcw word ptr [ esp + 0x2e ] movzx eax , word ptr [ esp + 0x2a ] jmp 0x3e4 sub esp , 0x8 mov eax , dword ptr [ ebp + 0x1c ] mov edx , 0x0 push edx push eax mov edi , dword ptr [ esp + 0x28 ] mov eax , edi cdq push edx push edi lea eax , [ ebx - 0x116376 ] push eax push dword ptr [ esp + 0x28 ] call 0xffe13afe add esp , 0x20 test eax , eax je 0x213 add edi , 0x2 mov dword ptr [ esp + 0x18 ] , edi cmp dword ptr [ ebp + 0x1c ] , edi jle 0x213 sub esp , 0x8 push dword ptr [ esp + 0x1c ] push 0x2 push dword ptr [ ebp + 0x18 ] push dword ptr [ esp + 0x2c ] push 0x0 push ebp call 0xffe1119e mov esi , eax add esp , 0x20 test eax , eax je 0x213 mov eax , dword ptr [ ebp + 0x18 ] add eax , eax mov edi , 0x0 test eax , eax jg 0x2a2 mov eax , dword ptr [ esp + 0x18 ] sar eax , 0x1 mov dword ptr [ esp + 0x1c ] , eax sub esp , 0x8 push dword ptr [ esp + 0x1c ] push 0x1 mov edi , dword ptr [ esp + 0x20 ] push dword ptr [ edi + 0x18 ] push eax push 0x0 push edi call 0xffe1119e mov esi , eax add esp , 0x20 test eax , eax je 0x213 mov eax , dword ptr [ edi + 0x18 ] test eax , eax jle 0x39d mov edi , 0x0 jmp 0x33c call 0x73c9e
Similarity: 1
Label: -1
Similarity Score: 0.65
Explanation: The two assembly codes show
------------------------------------------------------------

------------------------------------------------------------
Code1: push ebp mov ebp , esp push edi push esi sub esp , 0x40 mov eax , dword ptr [ ebp + 0xc ] mov ecx , dword ptr [ ebp + 0x8 ] mov edx , dword ptr [ ebp + 0x8 ] mov esi , dword ptr [ ebp + 0xc ] mov dword ptr [ esp ] , edx mov dword ptr [ esp + 0x4 ] , esi mov dword ptr [ ebp - 0x1c ] , eax mov dword ptr [ ebp - 0x20 ] , ecx call 0x210 mov eax , dword ptr [ ebp + 0xc ] cmp dword ptr [ eax ] , 0x0 jbe 0x37 jmp 0x61 lea eax , [ 0x8148a95 ] mov dword ptr [ esp ] , eax lea eax , [ 0x8148aa9 ] mov dword ptr [ esp + 0x4 ] , eax mov dword ptr [ esp + 0x8 ] , 0x105 lea eax , [ 0x8148ab4 ] mov dword ptr [ esp + 0xc ] , eax call 0xfffdfd90 mov eax , dword ptr [ ebp + 0xc ] mov eax , dword ptr [ eax + 0x4 ] mov ecx , dword ptr [ ebp + 0xc ] mov ecx , dword ptr [ ecx ] sub ecx , 0x1 cmp dword ptr [ eax + ecx * 0x4 ] , 0x0 jne 0x7e jmp 0xa8 lea eax , [ 0x8148af8 ] mov dword ptr [ esp ] , eax lea eax , [ 0x8148aa9 ] mov dword ptr [ esp + 0x4 ] , eax mov dword ptr [ esp + 0x8 ] , 0x106 lea eax , [ 0x8148ab4 ] mov dword ptr [ esp + 0xc ] , eax call 0xfffdfd90 mov eax , dword ptr [ ebp + 0xc ] mov eax , dword ptr [ eax ] add eax , 0x1 shl eax , 0x2 mov dword ptr [ esp ] , eax call 0x83990 mov dword ptr [ ebp - 0xc ] , eax mov dword ptr [ ebp - 0x14 ] , 0x0 mov eax , dword ptr [ ebp + 0xc ] mov eax , dword ptr [ eax ] mov dword ptr [ ebp - 0x10 ] , eax mov eax , dword ptr [ ebp + 0x8 ] mov ecx , dword ptr [ ebp + 0xc ] mov edx , dword ptr [ ebp - 0xc ] mov esi , dword ptr [ ebp - 0x10 ] mov edi , dword ptr [ ebp - 0x14 ] mov dword ptr [ esp ] , eax mov dword ptr [ esp + 0x4 ] , ecx mov dword ptr [ esp + 0x8 ] , edx mov dword ptr [ esp + 0xc ] , esi mov dword ptr [ esp + 0x10 ] , edi call 0x270 mov dword ptr [ ebp - 0x18 ] , eax mov eax , dword ptr [ ebp + 0x8 ] mov eax , dword ptr [ eax + 0x20 ] mov ecx , dword ptr [ ebp + 0x8 ] mov edx , dword ptr [ ebp + 0xc ] mov edx , dword ptr [ edx + 0x18 ] mov esi , dword ptr [ ebp - 0x18 ] mov edi , dword ptr [ ebp - 0xc ] mov dword ptr [ esp ] , ecx mov dword ptr [ esp + 0x4 ] , edx mov dword ptr [ esp + 0x8 ] , esi mov dword ptr [ esp + 0xc ] , edi call eax cmp eax , 0x0 je 0x15e mov eax , dword ptr [ ebp + 0x8 ] mov ecx , dword ptr [ ebp + 0xc ] mov edx , dword ptr [ ebp - 0x10 ] mov dword ptr [ esp ] , eax mov dword ptr [ esp + 0x4 ] , ecx mov dword ptr [ esp + 0x8 ] , 0x1 mov dword ptr [ esp + 0xc ] , edx call 0x3a0 mov dword ptr [ ebp - 0x10 ] , eax mov eax , dword ptr [ ebp - 0x18 ] mov ecx , dword ptr [ ebp + 0x8 ] sub eax , dword ptr [ ecx + 0x1c ] add eax , dword ptr [ ebp - 0x14 ] mov dword ptr [ ebp - 0x14 ] , eax jmp 0x1cb mov eax , dword ptr [ ebp - 0x10 ] mov ecx , dword ptr [ ebp + 0x8 ] mov ecx , dword ptr [ ecx + 0x1c ] add ecx , 0x1 cmp eax , ecx ja 0x19d lea eax , [ 0x8148b23 ] mov dword ptr [ esp ] , eax call 0xfffdf960 xor ecx , ecx mov dword ptr [ esp ] , 0x1 mov dword ptr [ esp + 0x4 ] , 0x0 mov dword ptr [ esp + 0x8 ] , eax mov dword ptr [ ebp - 0x24 ] , ecx call 0xfffdf8c0 xor eax , eax mov ecx , dword ptr [ ebp + 0x8 ] mov edx , dword ptr [ ebp + 0xc ] mov esi , dword ptr [ ebp - 0x10 ] mov dword ptr [ esp ] , ecx mov dword ptr [ esp + 0x4 ] , edx mov dword ptr [ esp + 0x8 ] , 0x0 mov dword ptr [ esp + 0xc ] , esi mov dword ptr [ ebp - 0x28 ] , eax call 0x3a0 mov dword ptr [ ebp - 0x10 ] , eax jmp 0x1cb jmp 0x1d0 mov eax , dword ptr [ ebp - 0x14 ] add eax , 0x1 mov ecx , dword ptr [ ebp + 0xc ] mov ecx , dword ptr [ ecx ] mov edx , dword ptr [ ebp + 0x8 ] sub ecx , dword ptr [ edx + 0x1c ] cmp eax , ecx jb 0xcd mov eax , dword ptr [ ebp - 0xc ] mov dword ptr [ esp ] , eax call 0xfffdf590 mov eax , dword ptr [ ebp + 0x8 ] mov ecx , dword ptr [ ebp + 0xc ] mov dword ptr [ esp ] , eax mov dword ptr [ esp + 0x4 ] , ecx call 0x990 add esp , 0x40 pop esi pop edi pop ebp ret nop dword ptr [ eax ]
Code2: mov r3 , 0x0 push { r4 , r5 , r6 , r7 , r8 , sb , sl , fp , lr } mov r6 , r1 sub sp , sp , 0x14 str r3 , [ sp , 0x8 ] str r3 , [ sp , 0x4 ] str r3 , [ sp ] ldr r2 , [ pc , 0x278 ] mov r8 , r0 bl 0xfffffba4 ldr r3 , [ r6 ] cmp r3 , 0x0 beq 0x26c ldr r2 , [ r6 , 0x4 ] sub r3 , r3 , 0xc0000001 ldr sb , [ r2 , r3 , lsl 0x2 ] lsl r3 , r3 , 0x2 cmp sb , 0x0 bne 0x258 add r0 , r3 , 0x8 bl 0xf1a0 ldr r1 , [ r6 ] mov r7 , r0 mov sl , sb mov r5 , r1 ldr fp , [ r8 , 0x1c ] cmp fp , 0x0 moveq ip , sb beq 0x98 ldr r3 , [ r6 , 0x4 ] sub r2 , r7 , 0x4 sub r3 , r3 , 0x4 add ip , r3 , fp , lsl 0x2 ldr r0 , [ r3 , 0x4 ] ! cmp ip , r3 str r0 , [ r2 , 0x4 ] ! bne 0x84 add ip , sb , fp cmp r1 , ip cmphi r5 , fp mov r4 , fp bls 0xdc ldr r3 , [ r6 , 0x4 ] sub r0 , ip , 0xc0000001 sub r2 , fp , 0xc0000001 add r0 , r3 , r0 , lsl 0x2 add r2 , r7 , r2 , lsl 0x2 add r4 , r4 , 0x1 add r3 , r4 , ip sub r3 , r3 , fp cmp r1 , r3 cmphi r5 , r4 ldr r3 , [ r0 , 0x4 ] ! str r3 , [ r2 , 0x4 ] ! bhi 0xbc cmp fp , r4 bhi 0x244 ldr fp , [ r8 , 0x20 ] str sl , [ r7 , r4 , lsl 0x2 ] mov r3 , r7 mov r2 , r4 ldr r1 , [ r6 , 0x18 ] mov r0 , r8 blx fp subs fp , r0 , 0x0 bne 0x1c8 ldr r2 , [ r8 , 0x1c ] add ip , r2 , 0x1 cmp ip , r5 bhs 0x280 ldr r1 , [ r6 , 0x28 ] clz r3 , r1 lsr r3 , r3 , 0x5 cmp r5 , r1 orrlo r3 , r3 , 0x1 cmp r3 , 0x0 ldr r3 , [ r6 , 0x24 ] strne r5 , [ r6 , 0x28 ] ldrne fp , [ r8 , 0x1c ] moveq fp , r2 cmp r3 , 0x0 beq 0x1c0 ldr r1 , [ r6 , 0x28 ] cmp r3 , r1 bhs 0x1c0 sub r3 , r1 , r3 lsrs r3 , r3 , 0x1 subne r5 , r5 , r3 subeq r5 , r5 , 0x1 cmp r2 , 0x0 beq 0x178 cmp ip , r5 blo 0x180 mov r5 , ip cmp r5 , 0x0 moveq r5 , 0x1 ldr r1 , [ r6 ] add r3 , sb , 0x1 sub r2 , r1 , fp cmp r3 , r2 blo 0x68 mov r0 , r7 bl 0xffff2b14 mov r1 , 0x0 mvn r2 , 0x0 ldr r3 , [ r6 , 0x14 ] str fp , [ r6 ] str r1 , [ r6 , 0x1c ] str r2 , [ r6 , 0x20 ] str r3 , [ r6 , 0x10 ] add sp , sp , 0x14 pop { r4 , r5 , r6 , r7 , r8 , sb , sl , fp , pc } lsr r5 , r5 , 0x1 b 0x164 ldr r2 , [ r6 , 0x24 ] ldr r3 , [ r8 , 0x1c ] cmp r5 , r2 movhi r2 , r5 strhi r5 , [ r6 , 0x24 ] ldrhi fp , [ r8 , 0x1c ] movls fp , r3 cmp r2 , 0x0 beq 0x230 ldr r1 , [ r6 , 0x28 ] cmp r1 , r2 bls 0x230 sub r2 , r1 , r2 lsrs r2 , r2 , 0x1 addne r5 , r5 , r2 addeq r5 , r5 , 0x1 cmp r3 , 0x0 beq 0x21c add r3 , r3 , 0x1 cmp r5 , r3 movlo r5 , r3 cmp r5 , 0x0 moveq r5 , 0x1 add sb , sb , r4 sub sb , sb , fp b 0x180 cmn r5 , 0x1 addne r5 , r5 , 0x1 cmp r3 , 0x0 bne 0x210 b 0x224 ldr r3 , [ pc , 0x54 ] mov r2 , 0xf2 ldr r1 , [ pc , 0x50 ] ldr r0 , [ pc , 0x50 ] bl 0xffff312c ldr r3 , [ pc , 0x4c ] ldr r2 , [ pc , 0x4c ] ldr r1 , [ pc , 0x3c ] ldr r0 , [ pc , 0x48 ] bl 0xffff312c ldr r3 , [ pc , 0x38 ] ldr r2 , [ pc , 0x40 ] ldr r1 , [ pc , 0x28 ] ldr r0 , [ pc , 0x3c ] bl 0xffff312c mov r2 , 0x5 ldr r1 , [ pc , 0x34 ] bl 0xffff2bec mov r1 , fp mov r2 , r0 mov r0 , 0x1 bl 0xffff2d48 andeq ip , r4 , r0 , asr sl andeq ip , r4 , r8 , asr 0x19 andeq ip , r4 , r8 , lsr sl andeq ip , r4 , r4 , lsl 0x22 strheq ip , [ r4 ] , -ip andeq r0 , r0 , r6 , lsl 0x2 ldrdeq ip , sp , [ r4 ] , -r8 andeq r0 , r0 , r5 , lsl 0x2 andeq ip , r4 , r4 , asr 0x21 andeq ip , r4 , r4 , lsr 0x22
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two code snippets are from different architectures (x86 vs ARM). The instructions, registers, and calling conventions are fundamentally different. There is no clear structural similarity in the control flow or operations that would indicate they are the same function. The stack adjustments, function calls, and branching patterns do not align, and the overall logic appears distinct. Therefore, they are not similar.
------------------------------------------------------------

------------------------------------------------------------
Code1: beqz a1 , 0x8c addiu a2 , a0 , 0x1 move v1 , zero addiu a3 , zero , 0x5c addiu t0 , a1 , - 0x1 addiu t1 , zero , 0x6e addiu t3 , zero , 0xa addu v0 , a0 , v1 lb v0 , ( v0 ) beqz v0 , 0x5c nop bne v0 , a3 , 0x64 move t2 , a2 beq t0 , v1 , 0x5c addiu v1 , v1 , 0x1 addu v0 , a0 , v1 lb v0 , ( v0 ) beq v0 , a3 , 0x94 nop bne v0 , t1 , 0x5c nop b 0x68 sb t3 , - 0x1 ( a2 ) jr ra move v0 , zero sb v0 , - 0x1 ( a2 ) addiu v1 , v1 , 0x1 sltu v0 , v1 , a1 bnez v0 , 0x1c addiu a2 , a2 , 0x1 addu a1 , a0 , a1 sltu a1 , t2 , a1 beqz a1 , 0x8c nop sb zero , ( t2 ) jr ra move v0 , a0 b 0x68 sb a3 , - 0x1 ( a2 )
Code2: push ebp mov ebp , esp push ebx push edi push esi sub esp , 0x4c mov eax , dword ptr [ ebp + 0xc ] mov ecx , dword ptr [ ebp + 0x8 ] mov dword ptr [ ebp - 0x10 ] , eax mov dword ptr [ ebp - 0x14 ] , ecx mov eax , esp add eax , - 0x10 mov esp , eax mov ecx , esp add ecx , - 0x10 mov esp , ecx mov edx , esp add edx , - 0x10 mov esp , edx mov esi , esp add esi , - 0x10 mov esp , esi mov edi , esp add edi , - 0x10 mov esp , edi mov ebx , dword ptr [ ebp - 0x14 ] mov dword ptr [ ecx ] , ebx mov ebx , dword ptr [ ebp - 0x10 ] mov dword ptr [ edx ] , ebx mov ebx , dword ptr [ ecx ] mov dword ptr [ esi ] , ebx mov dword ptr [ edi ] , 0x0 mov dword ptr [ ebp - 0x18 ] , eax mov dword ptr [ ebp - 0x1c ] , ecx mov dword ptr [ ebp - 0x20 ] , edx mov dword ptr [ ebp - 0x24 ] , esi mov dword ptr [ ebp - 0x28 ] , edi jmp 0x60 mov eax , dword ptr [ ebp - 0x28 ] mov ecx , dword ptr [ eax ] mov edx , dword ptr [ ebp - 0x20 ] cmp ecx , dword ptr [ edx ] setb bl mov byte ptr [ ebp - 0x29 ] , bl mov al , byte ptr [ ebp - 0x29 ] test al , 0x1 jne 0x80 jmp 0x1a2 mov eax , dword ptr [ ebp - 0x1c ] mov ecx , dword ptr [ eax ] mov edx , dword ptr [ ebp - 0x28 ] mov esi , dword ptr [ edx ] movsx ecx , byte ptr [ ecx + esi ] test ecx , ecx mov dword ptr [ ebp - 0x30 ] , ecx je 0x160 jmp 0x9e mov eax , dword ptr [ ebp - 0x30 ] sub eax , 0x5c mov dword ptr [ ebp - 0x34 ] , eax jne 0x16e jmp 0xb2 mov eax , dword ptr [ ebp - 0x28 ] mov ecx , dword ptr [ eax ] mov edx , dword ptr [ ebp - 0x20 ] mov esi , dword ptr [ edx ] sub esi , 0x1 cmp ecx , esi sete bl mov byte ptr [ ebp - 0x35 ] , bl mov al , byte ptr [ ebp - 0x35 ] test al , 0x1 jne 0xd7 jmp 0xe5 mov eax , dword ptr [ ebp - 0x18 ] mov dword ptr [ eax ] , 0x0 jmp 0x1e0 mov eax , dword ptr [ ebp - 0x28 ] mov ecx , dword ptr [ eax ] add ecx , 0x1 mov dword ptr [ eax ] , ecx mov ecx , dword ptr [ ebp - 0x1c ] mov edx , dword ptr [ ecx ] mov esi , dword ptr [ eax ] movsx edx , byte ptr [ edx + esi ] mov dword ptr [ ebp - 0x3c ] , edx mov eax , dword ptr [ ebp - 0x3c ] sub eax , 0x5c mov dword ptr [ ebp - 0x40 ] , eax je 0x139 jmp 0x111 mov eax , dword ptr [ ebp - 0x3c ] sub eax , 0x6e mov dword ptr [ ebp - 0x44 ] , eax jne 0x14d jmp 0x125 mov eax , dword ptr [ ebp - 0x24 ] mov ecx , dword ptr [ eax ] mov edx , ecx add edx , 0x1 mov dword ptr [ eax ] , edx mov byte ptr [ ecx ] , 0xa jmp 0x15b mov eax , dword ptr [ ebp - 0x24 ] mov ecx , dword ptr [ eax ] mov edx , ecx add edx , 0x1 mov dword ptr [ eax ] , edx mov byte ptr [ ecx ] , 0x5c jmp 0x15b mov eax , dword ptr [ ebp - 0x18 ] mov dword ptr [ eax ] , 0x0 jmp 0x1e0 jmp 0x18e mov eax , dword ptr [ ebp - 0x18 ] mov dword ptr [ eax ] , 0x0 jmp 0x1e0 mov eax , dword ptr [ ebp - 0x1c ] mov ecx , dword ptr [ eax ] mov edx , dword ptr [ ebp - 0x28 ] mov esi , dword ptr [ edx ] mov bl , byte ptr [ ecx + esi ] mov ecx , dword ptr [ ebp - 0x24 ] mov esi , dword ptr [ ecx ] mov edi , esi add edi , 0x1 mov dword ptr [ ecx ] , edi mov byte ptr [ esi ] , bl jmp 0x18e jmp 0x193 mov eax , dword ptr [ ebp - 0x28 ] mov ecx , dword ptr [ eax ] add ecx , 0x1 mov dword ptr [ eax ] , ecx jmp 0x60 mov eax , dword ptr [ ebp - 0x24 ] mov ecx , dword ptr [ eax ] mov edx , dword ptr [ ebp - 0x1c ] mov esi , dword ptr [ edx ] mov edi , dword ptr [ ebp - 0x20 ] add esi , dword ptr [ edi ] cmp ecx , esi setb bl mov byte ptr [ ebp - 0x45 ] , bl mov al , byte ptr [ ebp - 0x45 ] test al , 0x1 jne 0x1c9 jmp 0x1d6 mov eax , dword ptr [ ebp - 0x24 ] mov ecx , dword ptr [ eax ] mov byte ptr [ ecx ] , 0x0 jmp 0x1d6 mov eax , dword ptr [ ebp - 0x1c ] mov ecx , dword ptr [ eax ] mov edx , dword ptr [ ebp - 0x18 ] mov dword ptr [ edx ] , ecx mov eax , dword ptr [ ebp - 0x18 ] mov eax , dword ptr [ eax ] mov dword ptr [ ebp - 0x4c ] , eax mov eax , dword ptr [ ebp - 0x4c ] lea esp , [ ebp - 0xc ] pop esi pop edi pop ebx pop ebp ret mov eax , esp add eax , - 0x10 mov esp , eax mov eax , esp add eax , - 0x10 mov esp , eax mov ecx , esp add ecx , - 0x10 mov esp , ecx mov edx , esp add edx , - 0x10 mov esp , edx mov esi , esp add esi , - 0x10 mov esp , esi mov edi , dword ptr [ ebp - 0x14 ] mov dword ptr [ eax ] , edi mov ebx , dword ptr [ ebp - 0x10 ] mov dword ptr [ ecx ] , ebx mov eax , dword ptr [ eax ] mov dword ptr [ edx ] , eax mov dword ptr [ esi ] , 0x0 jmp 0x15 jmp 0x60 jmp 0xb2 mov eax , dword ptr [ ebp - 0x18 ] mov dword ptr [ eax ] , 0x0 jmp 0xd7 mov eax , dword ptr [ ebp - 0x28 ] mov ecx , dword ptr [ eax ] add ecx , 0x1 mov dword ptr [ eax ] , ecx jmp 0xe5 mov eax , dword ptr [ ebp - 0x24 ] mov ecx , dword ptr [ eax ] mov edx , ecx add edx , 0x1 mov dword ptr [ eax ] , edx mov byte ptr [ ecx ] , 0x5c jmp 0x139 mov eax , dword ptr [ ebp - 0x18 ] mov dword ptr [ eax ] , 0x0 jmp 0x14d jmp 0x15b mov eax , dword ptr [ ebp - 0x1c ] mov ecx , dword ptr [ eax ] mov edx , dword ptr [ ebp - 0x28 ] mov esi , dword ptr [ edx ] mov bl , byte ptr [ ecx + esi ] mov ecx , dword ptr [ ebp - 0x24 ] mov esi , dword ptr [ ecx ] mov edi , esi add edi , 0x1 mov dword ptr [ ecx ] , edi mov byte ptr [ esi ] , bl jmp 0x16e jmp 0x18e jmp 0x1a2 mov eax , dword ptr [ ebp - 0x24 ] mov ecx , dword ptr [ eax ] mov byte ptr [ ecx ] , 0x0 jmp 0x1c9 jmp 0x1e0 nop nop nop nop
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly codes show no significant similarity due to fundamental differences:
1. **Architecture**: Code1 uses MIPS registers (a0, v0, t0, etc.) and instructions (beqz, lb, jr), while Code2 uses x86 registers (eax, ebp, esp) and operations (push, mov, cmp).
2. **Structure**: Code1 is compact with direct branching and memory operations. Code2 is verbose with stack-frame management (ebp/esp), complex memory addressing, and significantly more instructions.
3. **Functionality**: Both appear to process strings (Code1 checks for 0x5c/0x6e; Code2 compares 0x5c/0x6e), but Code2 includes extensive stack manipulation and local variables absent in Code1.
4. **Control Flow**: Code1 uses simple conditional jumps (beqz, bne). Code2 has multi-level conditionals with setb/test/jne and complex label jumps.
No overlapping logic or equivalent instruction sequences exist, indicating entirely different implementations.
------------------------------------------------------------

------------------------------------------------------------
Code1: push rbp push r15 push r14 push r13 push r12 push rbx sub rsp , 0x4a8 xor ebp , ebp test rdi , rdi je 0x18c mov r13 , rsi mov rbx , rdi lea rdx , [ rsp + 0x10 ] mov edi , 0x1 mov rsi , rbx call 0xffffffffffeff970 test eax , eax js 0x18c lea rdi , [ rsp + 0x10 ] xorps xmm0 , xmm0 mov esi , 0x90 call 0x6e0 test r13 , r13 je 0x18c mov esi , 0x5e5fc2 mov rdi , rbx call 0xffffffffffeffb10 test rax , rax je 0x18c mov r14 , rax test byte ptr [ rsp + 0x29 ] , 0x60 je 0x95 cmp r13 , - 0x1 mov eax , 0x800 cmove r13 , rax mov rdi , r14 xor esi , esi mov edx , 0x2 xor ecx , ecx call 0xffffffffffeffa70 cmp r13 , 0x400 mov eax , 0x400 mov ebp , 0x400 cmovl ebp , r13d test r13 , r13 setg r12b cmovle ebp , eax movsxd r15 , ebp lea rdi , [ rsp + 0xa0 ] mov esi , 0x1 mov rdx , r15 mov qword ptr [ rsp + 0x8 ] , r14 mov rcx , r14 call 0xffffffffffeff690 mov r14 , rax test r14d , r14d jle 0x164 mov dword ptr [ rsp + 0x4 ] , 0x0 lea rdi , [ rsp + 0xa0 ] xorps xmm0 , xmm0 cvtsi2sd xmm0 , r14d mov rbx , rdi mov esi , ebp call 0x6e0 mov eax , dword ptr [ rsp + 0x4 ] add eax , r14d test r12b , 0x1 mov dword ptr [ rsp + 0x4 ] , eax je 0x120 sub r13 , r15 mov rcx , qword ptr [ rsp + 0x8 ] jg 0x125 jmp 0x16c nop mov rcx , qword ptr [ rsp + 0x8 ] cmp r13 , 0x400 mov ebp , 0x400 cmovl ebp , r13d test r13 , r13 setg r12b mov eax , 0x400 cmovle ebp , eax movsxd r15 , ebp mov esi , 0x1 mov rdi , rbx mov rdx , r15 call 0xffffffffffeff690 mov rdi , rbx mov r14 , rax test r14d , r14d jg 0xf0 jmp 0x16c mov dword ptr [ rsp + 0x4 ] , 0x0 mov rdi , qword ptr [ rsp + 0x8 ] call 0xffffffffffeff6a0 lea rdi , [ rsp + 0xa0 ] mov esi , 0x400 call 0xfffffffffffa5ab0 mov ebp , dword ptr [ rsp + 0x4 ] mov eax , ebp add rsp , 0x4a8 pop rbx pop r12 pop r13 pop r14 pop r15 pop rbp ret
Code2: push { r4 , r5 , r6 , r7 , r8 , sb , sl , fp , lr } ldr r6 , [ pc , 0x138 ] sub sp , sp , 0x460 ldr r3 , [ r6 ] sub sp , sp , 0xc subs r5 , r0 , 0x0 str r3 , [ sp , 0x464 ] beq 0x58 mov r4 , r1 add r2 , sp , 0x8 mov r1 , r5 mov r0 , 0x3 bl 0xfff24bd8 cmp r0 , 0x0 blt 0x58 add r0 , sp , 0x8 mov r2 , 0x0 mov r3 , 0x0 mov r1 , 0x58 bl 0x55c cmp r4 , 0x0 bne 0x7c mov r5 , 0x0 ldr r2 , [ sp , 0x464 ] ldr r3 , [ r6 ] mov r0 , r5 cmp r2 , r3 bne 0x140 add sp , sp , 0x460 add sp , sp , 0xc pop { r4 , r5 , r6 , r7 , r8 , sb , sl , fp , pc } mov r0 , r5 ldr r1 , [ pc , 0xc0 ] bl 0xfff24a70 subs sb , r0 , 0x0 beq 0x58 ldr r3 , [ sp , 0x18 ] tst r3 , 0x6000 bne 0x124 mov r5 , 0x0 ldr sl , [ pc , 0xa4 ] b 0xd8 bl 0xc8ff4 mov r2 , r0 mov r3 , r1 add r0 , sp , 0x64 mov r1 , r7 bl 0x55c cmp r4 , 0x0 add r5 , r5 , fp ble 0xdc sub r4 , r4 , r7 cmp r4 , 0x0 ble 0x10c sub r8 , r4 , 0x1 cmp r8 , sl mov r3 , r4 movhi r3 , 0x400 movhi r7 , r3 movls r7 , r4 str sb , [ sp ] mov r2 , 0x1 mov r1 , 0x400 add r0 , sp , 0x64 bl 0xfff24e84 subs fp , r0 , 0x0 bgt 0xa8 mov r0 , sb bl 0xfff24e6c add r0 , sp , 0x64 mov r1 , 0x400 bl 0xfffa73fc b 0x5c mov r3 , 0x0 cmn r4 , 0x1 mov r1 , r3 mov r2 , 0x2 moveq r4 , 0x800 bl 0xfff24dd0 b 0x9c bl 0xfff24b54 eoreq sp , r1 , r0 , lsl 0x30 andseq r8 , fp , ip , lsl 0x27 strdeq r0 , r1 , [ r0 ] , -lr
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The codes are for different architectures (x86_64 vs ARM) and have no overlapping instructions or structural similarities. The first code uses x86-specific registers (rbp, r15, etc.) and calling conventions (call), while the second uses ARM-specific registers (r4-r8, sb, sl) and operations (ldr, bl). The control flow, stack management, and function calls are entirely architecture-specific with no equivalent patterns. The absence of any shared instructions or comparable logic confirms complete dissimilarity.
------------------------------------------------------------

------------------------------------------------------------
Code1: push ebp mov ebp , esp push ebx push edi push esi sub esp , 0xfc mov eax , dword ptr [ ebp + 0x14 ] mov ecx , dword ptr [ ebp + 0x10 ] mov edx , dword ptr [ ebp + 0xc ] mov esi , dword ptr [ ebp + 0x8 ] mov dword ptr [ ebp - 0x60 ] , eax mov dword ptr [ ebp - 0x64 ] , ecx mov dword ptr [ ebp - 0x68 ] , edx mov dword ptr [ ebp - 0x6c ] , esi mov eax , esp add eax , - 0x10 mov esp , eax mov ecx , esp add ecx , - 0x10 mov esp , ecx mov edx , esp add edx , - 0x10 mov esp , edx mov esi , esp add esi , - 0x10 mov esp , esi mov edi , dword ptr [ ebp - 0x6c ] mov dword ptr [ ebp - 0x10 ] , edi mov ebx , dword ptr [ ebp - 0x68 ] mov dword ptr [ ebp - 0x14 ] , ebx mov edi , dword ptr [ ebp - 0x64 ] mov dword ptr [ ebp - 0x18 ] , edi mov edi , dword ptr [ ebp - 0x60 ] mov dword ptr [ ebp - 0x1c ] , edi mov dword ptr [ ebp - 0x20 ] , 0x0 mov edi , dword ptr [ ebp - 0x10 ] sub esp , 0x10 mov ebx , esp mov dword ptr [ ebx ] , edi mov dword ptr [ ebp - 0x70 ] , eax mov dword ptr [ ebp - 0x74 ] , ecx mov dword ptr [ ebp - 0x78 ] , edx mov dword ptr [ ebp - 0x7c ] , esi call 0xfffeb3a0 add esp , 0x10 add eax , 0x2 sub esp , 0x10 mov dword ptr [ esp ] , eax call 0x79de0 add esp , 0x10 mov dword ptr [ ebp - 0x20 ] , eax mov eax , dword ptr [ ebp - 0x20 ] mov byte ptr [ eax ] , 0x5f mov eax , dword ptr [ ebp - 0x20 ] add eax , 0x1 mov ecx , dword ptr [ ebp - 0x10 ] mov edx , dword ptr [ ebp - 0x10 ] sub esp , 0x10 mov esi , esp mov dword ptr [ esi ] , edx mov dword ptr [ ebp - 0x80 ] , eax mov dword ptr [ ebp - 0x84 ] , ecx call 0xfffeb3a0 add esp , 0x10 add eax , 0x1 sub esp , 0x10 mov ecx , dword ptr [ ebp - 0x80 ] mov dword ptr [ esp ] , ecx mov ecx , dword ptr [ ebp - 0x84 ] mov dword ptr [ esp + 0x4 ] , ecx mov dword ptr [ esp + 0x8 ] , eax call 0xfffeaf80 add esp , 0x10 mov eax , dword ptr [ ebp - 0x14 ] lea ecx , [ ebp - 0x50 ] mov dword ptr [ ebp - 0x88 ] , ecx mov dword ptr [ ebp - 0x8c ] , eax sub esp , 0x10 mov eax , dword ptr [ ebp - 0x88 ] mov dword ptr [ esp ] , eax mov ecx , dword ptr [ ebp - 0x8c ] mov dword ptr [ esp + 0x4 ] , ecx mov dword ptr [ esp + 0x8 ] , 0x2c call 0xfffeaf80 add esp , 0x10 cmp dword ptr [ ebp - 0x50 ] , 0xb jl 0x153 lea eax , [ ebp - 0x50 ] mov ecx , dword ptr [ ebp - 0x50 ] mov dword ptr [ ebp - 0x90 ] , eax mov dword ptr [ ebp - 0x94 ] , ecx mov eax , dword ptr [ ebp - 0x94 ] sub eax , 0xb mov dword ptr [ ebp - 0x98 ] , eax mov eax , dword ptr [ ebp - 0x90 ] mov ecx , dword ptr [ ebp - 0x98 ] mov dword ptr [ eax ] , ecx jmp 0x17b lea eax , [ ebp - 0x50 ] mov ecx , dword ptr [ ebp - 0x50 ] mov dword ptr [ ebp - 0x9c ] , eax mov dword ptr [ ebp - 0xa0 ] , ecx mov eax , dword ptr [ ebp - 0xa0 ] add eax , 0xb mov ecx , dword ptr [ ebp - 0x9c ] mov dword ptr [ ecx ] , eax jmp 0x17b mov eax , dword ptr [ 0x8122c60 ] mov dword ptr [ ebp - 0xa4 ] , eax mov eax , dword ptr [ ebp - 0xa4 ] cmp eax , 0x0 sete cl mov byte ptr [ ebp - 0xa5 ] , cl mov al , byte ptr [ ebp - 0xa5 ] test al , 0x1 jne 0x1ab jmp 0x1d2 mov dword ptr [ 0x8122c64 ] , 0x1 mov eax , dword ptr [ 0x8122c64 ] sub esp , 0x10 mov dword ptr [ esp ] , eax call 0x79de0 add esp , 0x10 mov dword ptr [ 0x8122c60 ] , eax jmp 0x1d2 jmp 0x1d7 mov eax , dword ptr [ 0x8122c60 ] mov ecx , dword ptr [ 0x8122c64 ] mov edx , dword ptr [ ebp - 0x20 ] mov esi , dword ptr [ ebp - 0x14 ] mov dword ptr [ ebp - 0xac ] , eax mov dword ptr [ ebp - 0xb0 ] , ecx mov dword ptr [ ebp - 0xb4 ] , edx mov dword ptr [ ebp - 0xb8 ] , esi sub esp , 0x10 mov eax , dword ptr [ ebp - 0xac ] mov dword ptr [ esp ] , eax mov ecx , dword ptr [ ebp - 0xb0 ] mov dword ptr [ esp + 0x4 ] , ecx mov edx , dword ptr [ ebp - 0xb4 ] mov dword ptr [ esp + 0x8 ] , edx mov esi , dword ptr [ ebp - 0xb8 ] mov dword ptr [ esp + 0xc ] , esi call 0xfffeb330 add esp , 0x10 mov dword ptr [ ebp - 0x54 ] , eax mov eax , dword ptr [ ebp - 0x54 ] mov dword ptr [ ebp - 0xbc ] , eax mov eax , dword ptr [ ebp - 0xbc ] cmp eax , 0x0 je 0x50e mov eax , dword ptr [ ebp - 0x54 ] mov dword ptr [ ebp - 0xc0 ] , eax mov eax , dword ptr [ ebp - 0xc0 ] cmp eax , dword ptr [ 0x8122c64 ] setb cl mov byte ptr [ ebp - 0xc1 ] , cl mov al , byte ptr [ ebp - 0xc1 ] test al , 0x1 jne 0x27e jmp 0x50e mov dword ptr [ ebp - 0x5c ] , 0x0 mov eax , dword ptr [ ebp - 0x70 ] mov dword ptr [ eax ] , 0x0 mov eax , dword ptr [ ebp - 0x54 ] add eax , 0x1 add eax , dword ptr [ ebp - 0x1c ] mov ecx , dword ptr [ ebp - 0x74 ] mov dword ptr [ ecx ] , eax mov eax , dword ptr [ 0x8122c60 ] mov edx , dword ptr [ ecx ] sub esp , 0x10 mov dword ptr [ esp ] , eax mov dword ptr [ esp + 0x4 ] , edx call 0x79eb0 add esp , 0x10 mov dword ptr [ ebp - 0xc8 ] , eax mov eax , dword ptr [ ebp - 0xc8 ] mov dword ptr [ 0x8122c60 ] , eax mov ecx , dword ptr [ ebp - 0x74 ] mov edx , dword ptr [ ecx ] mov dword ptr [ 0x8122c64 ] , edx mov edx , dword ptr [ ecx ] sub esp , 0x10 mov dword ptr [ esp ] , edx call 0x79de0 add esp , 0x10 mov dword ptr [ ebp - 0x58 ] , eax mov eax , dword ptr [ ebp - 0x58 ] mov ecx , dword ptr [ 0x8122c64 ] mov edx , dword ptr [ ebp - 0x20 ] sub esp , 0x10 mov dword ptr [ esp ] , eax mov dword ptr [ esp + 0x4 ] , ecx mov dword ptr [ esp + 0x8 ] , edx lea eax , [ ebp - 0x50 ] mov dword ptr [ esp + 0xc ] , eax call 0xfffeb330 add esp , 0x10 mov ecx , dword ptr [ 0x8122c60 ] mov edx , dword ptr [ ebp - 0x58 ] sub esp , 0x10 mov dword ptr [ esp ] , ecx mov dword ptr [ esp + 0x4 ] , edx lea ecx , [ ebp - 0x5c ] mov dword ptr [ esp + 0x8 ] , ecx mov ecx , dword ptr [ ebp - 0x70 ] mov dword ptr [ esp + 0xc ] , ecx mov dword ptr [ ebp - 0xcc ] , eax call 0x550 add esp , 0x10 test al , 0x1 jne 0x349 jmp 0x4cb mov eax , dword ptr [ ebp - 0x70 ] mov ecx , dword ptr [ eax ] mov dword ptr [ ebp - 0xd0 ] , ecx mov eax , 0x2 mov ecx , dword ptr [ ebp - 0xd0 ] cmp eax , ecx sete dl mov byte ptr [ ebp - 0xd1 ] , dl mov al , byte ptr [ ebp - 0xd1 ] test al , 0x1 jne 0x37d jmp 0x4cb call 0xfffeb750 mov eax , dword ptr [ eax ] mov ecx , dword ptr [ 0x8122c60 ] mov edx , dword ptr [ ebp - 0x5c ] mov esi , dword ptr [ ebp - 0x70 ] add edx , dword ptr [ esi ] add ecx , edx mov dword ptr [ ebp - 0xd8 ] , eax mov dword ptr [ ebp - 0xdc ] , ecx mov eax , dword ptr [ ebp - 0xdc ] movzx ecx , byte ptr [ eax ] mov edx , dword ptr [ ebp - 0xd8 ] movzx ecx , word ptr [ edx + ecx * 0x2 ] and ecx , 0x800 mov dword ptr [ ebp - 0xe0 ] , ecx mov eax , dword ptr [ ebp - 0xe0 ] cmp eax , 0x0 jne 0x4cb mov eax , dword ptr [ ebp - 0x5c ] mov ecx , dword ptr [ ebp - 0x70 ] add eax , dword ptr [ ecx ] mov edx , dword ptr [ ebp - 0x78 ] mov dword ptr [ edx ] , eax mov eax , dword ptr [ ebp - 0x54 ] sub eax , dword ptr [ edx ] add eax , 0x1 mov dword ptr [ ebp - 0xe4 ] , eax mov eax , dword ptr [ ebp - 0x7c ] mov ecx , dword ptr [ ebp - 0xe4 ] mov dword ptr [ eax ] , ecx mov edx , dword ptr [ ebp - 0x78 ] mov esi , dword ptr [ edx ] add esi , dword ptr [ ebp - 0x1c ] mov dword ptr [ ebp - 0xe8 ] , esi mov eax , dword ptr [ ebp - 0xe8 ] mov ecx , dword ptr [ ebp - 0x7c ] add eax , dword ptr [ ecx ] mov edx , dword ptr [ ebp - 0x74 ] cmp eax , dword ptr [ edx ] jne 0x41d jmp 0x44d sub esp , 0x10 lea eax , [ 0x8119d89 ] mov dword ptr [ esp ] , eax lea eax , [ 0x8119a53 ] mov dword ptr [ esp + 0x4 ] , eax mov dword ptr [ esp + 0x8 ] , 0x224 lea eax , [ 0x8119dbc ] mov dword ptr [ esp + 0xc ] , eax call 0xfffeb740 add esp , 0x10 mov eax , dword ptr [ 0x8122c60 ] mov ecx , dword ptr [ ebp - 0x78 ] add eax , dword ptr [ ecx ] add eax , dword ptr [ ebp - 0x1c ] mov edx , dword ptr [ 0x8122c60 ] add edx , dword ptr [ ecx ] mov esi , dword ptr [ ebp - 0x7c ] mov edi , dword ptr [ esi ] sub esp , 0x10 mov ebx , esp mov dword ptr [ ebx + 0x8 ] , edi mov dword ptr [ ebx + 0x4 ] , edx mov dword ptr [ ebx ] , eax call 0xfffeaf30 add esp , 0x10 mov ecx , dword ptr [ 0x8122c60 ] mov edx , dword ptr [ ebp - 0x5c ] mov dword ptr [ ebp - 0xec ] , eax mov dword ptr [ ebp - 0xf0 ] , ecx mov dword ptr [ ebp - 0xf4 ] , edx mov eax , dword ptr [ ebp - 0xf0 ] mov ecx , dword ptr [ ebp - 0xf4 ] add eax , ecx mov edx , dword ptr [ ebp - 0x70 ] add eax , dword ptr [ edx ] mov esi , dword ptr [ ebp - 0x18 ] mov edi , dword ptr [ ebp - 0x1c ] sub esp , 0x10 mov dword ptr [ esp ] , eax mov dword ptr [ esp + 0x4 ] , esi mov dword ptr [ esp + 0x8 ] , edi call 0xfffeaf80 add esp , 0x10 jmp 0x4d0 jmp 0x4d0 mov eax , dword ptr [ ebp - 0x20 ] sub esp , 0x10 mov dword ptr [ esp ] , eax call 0xfffeaf40 add esp , 0x10 mov eax , dword ptr [ ebp - 0x58 ] mov dword ptr [ ebp - 0xf8 ] , eax sub esp , 0x10 mov eax , dword ptr [ ebp - 0xf8 ] mov dword ptr [ esp ] , eax call 0xfffeaf40 add esp , 0x10 mov eax , dword ptr [ 0x8122c60 ] add eax , 0x1 lea esp , [ ebp - 0xc ] pop esi pop edi pop ebx pop ebp ret mov eax , dword ptr [ 0x8122c60 ] sub esp , 0x10 mov dword ptr [ esp ] , eax lea eax , [ 0x8122c64 ] mov dword ptr [ esp + 0x4 ] , eax mov dword ptr [ esp + 0x8 ] , 0x1 call 0x79fb0 add esp , 0x10 mov dword ptr [ ebp - 0xfc ] , eax mov eax , dword ptr [ ebp - 0xfc ] mov dword ptr [ 0x8122c60 ] , eax jmp 0x549 jmp 0x1d7 nop
Code2: push ebp mov ebp , esp push ebx push edi push esi sub esp , 0x9c mov eax , dword ptr [ ebp + 0x14 ] mov ecx , dword ptr [ ebp + 0x10 ] mov edx , dword ptr [ ebp + 0xc ] mov esi , dword ptr [ ebp + 0x8 ] mov dword ptr [ ebp - 0x10 ] , 0x0 mov edi , dword ptr [ ebp + 0x8 ] mov ebx , esp mov dword ptr [ ebx ] , edi mov dword ptr [ ebp - 0x60 ] , eax mov dword ptr [ ebp - 0x64 ] , ecx mov dword ptr [ ebp - 0x68 ] , edx mov dword ptr [ ebp - 0x6c ] , esi call 0xffff0e40 add eax , 0x2 mov ecx , esp mov dword ptr [ ecx ] , eax call 0x46fd0 mov dword ptr [ ebp - 0x10 ] , eax mov eax , dword ptr [ ebp - 0x10 ] mov byte ptr [ eax ] , 0x5f mov eax , dword ptr [ ebp - 0x10 ] inc eax mov ecx , dword ptr [ ebp + 0x8 ] mov edx , esp mov dword ptr [ edx ] , ecx mov dword ptr [ ebp - 0x70 ] , eax mov dword ptr [ ebp - 0x74 ] , ecx call 0xffff0e40 inc eax mov ecx , esp mov dword ptr [ ecx + 0x8 ] , eax mov eax , dword ptr [ ebp - 0x74 ] mov dword ptr [ ecx + 0x4 ] , eax mov edx , dword ptr [ ebp - 0x70 ] mov dword ptr [ ecx ] , edx call 0xffff0a20 mov ecx , dword ptr [ ebp + 0xc ] mov edx , dword ptr [ ecx + 0x28 ] mov dword ptr [ ebp - 0x18 ] , edx movsd xmm0 , qword ptr [ ecx + 0x20 ] movsd qword ptr [ ebp - 0x20 ] , xmm0 movsd xmm0 , qword ptr [ ecx + 0x18 ] movsd qword ptr [ ebp - 0x28 ] , xmm0 movsd xmm0 , qword ptr [ ecx + 0x10 ] movsd qword ptr [ ebp - 0x30 ] , xmm0 movsd xmm0 , qword ptr [ ecx ] movsd xmm1 , qword ptr [ ecx + 0x8 ] movsd qword ptr [ ebp - 0x38 ] , xmm1 movsd qword ptr [ ebp - 0x40 ] , xmm0 mov ecx , dword ptr [ ebp - 0x40 ] sub ecx , 0xa setg dl movzx esi , dl mov esi , dword ptr [ esi * 0x4 + 0x80d8714 ] mov dword ptr [ ebp - 0x78 ] , eax mov dword ptr [ ebp - 0x7c ] , ecx jmp esi mov eax , dword ptr [ ebp - 0x40 ] add eax , - 0xb mov dword ptr [ ebp - 0x40 ] , eax mov eax , dword ptr [ 0x80d8330 ] jmp eax mov eax , dword ptr [ ebp - 0x40 ] add eax , 0xb mov dword ptr [ ebp - 0x40 ] , eax mov eax , dword ptr [ 0x80d8330 ] jmp eax mov eax , dword ptr [ 0x80f7ac0 ] test eax , eax sete cl movzx eax , cl mov eax , dword ptr [ eax * 0x4 + 0x80d871c ] jmp eax mov dword ptr [ 0x80f7ac4 ] , 0x1 mov eax , dword ptr [ 0x80f7ac4 ] mov ecx , esp mov dword ptr [ ecx ] , eax call 0x46fd0 mov dword ptr [ 0x80f7ac0 ] , eax mov eax , dword ptr [ 0x80d8338 ] jmp eax mov eax , dword ptr [ 0x80d833c ] jmp eax mov eax , dword ptr [ 0x80f7ac0 ] mov ecx , dword ptr [ 0x80f7ac4 ] mov edx , dword ptr [ ebp - 0x10 ] mov esi , dword ptr [ ebp + 0xc ] mov edi , esp mov dword ptr [ edi + 0xc ] , esi mov dword ptr [ edi + 0x8 ] , edx mov dword ptr [ edi + 0x4 ] , ecx mov dword ptr [ edi ] , eax call 0xffff0dd0 mov dword ptr [ ebp - 0x44 ] , eax mov eax , dword ptr [ ebp - 0x44 ] test eax , eax setne bl movzx eax , bl mov eax , dword ptr [ eax * 0x4 + 0x80d8724 ] jmp eax mov eax , dword ptr [ ebp - 0x44 ] mov ecx , dword ptr [ 0x80f7ac4 ] sub eax , ecx setb dl movzx ecx , dl mov ecx , dword ptr [ ecx * 0x4 + 0x80d872c ] mov dword ptr [ ebp - 0x80 ] , eax jmp ecx mov dword ptr [ ebp - 0x4c ] , 0x0 mov dword ptr [ ebp - 0x50 ] , 0x0 mov eax , dword ptr [ ebp - 0x44 ] mov ecx , dword ptr [ ebp + 0x14 ] lea eax , [ eax + ecx + 0x1 ] mov dword ptr [ ebp - 0x54 ] , eax mov eax , dword ptr [ 0x80f7ac0 ] mov ecx , dword ptr [ ebp - 0x54 ] mov edx , esp mov dword ptr [ edx + 0x4 ] , ecx mov dword ptr [ edx ] , eax call 0x470a0 mov dword ptr [ 0x80f7ac0 ] , eax mov eax , dword ptr [ ebp - 0x54 ] mov dword ptr [ 0x80f7ac4 ] , eax mov eax , dword ptr [ ebp - 0x54 ] mov ecx , esp mov dword ptr [ ecx ] , eax call 0x46fd0 mov dword ptr [ ebp - 0x48 ] , eax mov eax , dword ptr [ ebp - 0x48 ] mov ecx , dword ptr [ 0x80f7ac4 ] mov edx , dword ptr [ ebp - 0x10 ] mov esi , esp lea edi , [ ebp - 0x40 ] mov dword ptr [ esi + 0xc ] , edi mov dword ptr [ esi + 0x8 ] , edx mov dword ptr [ esi + 0x4 ] , ecx mov dword ptr [ esi ] , eax call 0xffff0dd0 mov ecx , dword ptr [ 0x80f7ac0 ] mov edx , dword ptr [ ebp - 0x48 ] mov esi , esp lea edi , [ ebp - 0x50 ] mov dword ptr [ esi + 0xc ] , edi lea edi , [ ebp - 0x4c ] mov dword ptr [ esi + 0x8 ] , edi mov dword ptr [ esi + 0x4 ] , edx mov dword ptr [ esi ] , ecx mov dword ptr [ ebp - 0x84 ] , eax call 0x3a0 movzx ecx , al mov ecx , dword ptr [ ecx * 0x4 + 0x80d8734 ] jmp ecx mov eax , dword ptr [ ebp - 0x50 ] sub eax , 0x2 sete cl movzx edx , cl mov edx , dword ptr [ edx * 0x4 + 0x80d873c ] mov dword ptr [ ebp - 0x88 ] , eax jmp edx call 0xffff11f0 mov eax , dword ptr [ eax ] mov ecx , dword ptr [ 0x80f7ac0 ] mov edx , dword ptr [ ebp - 0x4c ] mov esi , dword ptr [ ebp - 0x50 ] add edx , esi movzx ecx , byte ptr [ ecx + edx ] movzx eax , word ptr [ eax + ecx * 0x2 ] shr eax , 0x9 and eax , 0x4 mov eax , dword ptr [ eax + 0x80d8744 ] jmp eax mov eax , dword ptr [ ebp - 0x4c ] mov ecx , dword ptr [ ebp - 0x50 ] add eax , ecx mov dword ptr [ ebp - 0x58 ] , eax mov eax , dword ptr [ ebp - 0x44 ] mov ecx , dword ptr [ ebp - 0x58 ] sub eax , ecx inc eax mov dword ptr [ ebp - 0x5c ] , eax mov eax , dword ptr [ ebp - 0x58 ] mov ecx , dword ptr [ ebp + 0x14 ] add eax , ecx mov ecx , dword ptr [ ebp - 0x5c ] add eax , ecx mov ecx , dword ptr [ ebp - 0x54 ] sub eax , ecx sete dl movzx ecx , dl mov ecx , dword ptr [ ecx * 0x4 + 0x80d874c ] mov dword ptr [ ebp - 0x8c ] , eax jmp ecx mov eax , dword ptr [ 0x80d835c ] jmp eax lea eax , [ 0x80cd631 ] mov dword ptr [ esp ] , eax lea eax , [ 0x80cd2fb ] mov dword ptr [ esp + 0x4 ] , eax mov dword ptr [ esp + 0x8 ] , 0x224 lea eax , [ 0x80cd664 ] mov dword ptr [ esp + 0xc ] , eax call 0xffff11e0 mov eax , dword ptr [ 0x80f7ac0 ] mov ecx , dword ptr [ ebp - 0x58 ] add eax , ecx mov ecx , dword ptr [ ebp + 0x14 ] mov edx , eax add edx , ecx mov ecx , dword ptr [ ebp - 0x5c ] mov esi , esp mov dword ptr [ esi + 0x8 ] , ecx mov dword ptr [ esi + 0x4 ] , eax mov dword ptr [ esi ] , edx call 0xffff09d0 mov ecx , dword ptr [ 0x80f7ac0 ] mov edx , dword ptr [ ebp - 0x4c ] add ecx , edx mov edx , dword ptr [ ebp - 0x50 ] add ecx , edx mov edx , dword ptr [ ebp + 0x10 ] mov esi , dword ptr [ ebp + 0x14 ] mov edi , esp mov dword ptr [ edi + 0x8 ] , esi mov dword ptr [ edi + 0x4 ] , edx mov dword ptr [ edi ] , ecx mov dword ptr [ ebp - 0x90 ] , eax call 0xffff0a20 mov ecx , dword ptr [ 0x80d8364 ] mov dword ptr [ ebp - 0x94 ] , eax jmp ecx mov eax , dword ptr [ 0x80d8364 ] jmp eax mov eax , dword ptr [ ebp - 0x10 ] mov dword ptr [ esp ] , eax call 0xffff09e0 mov eax , dword ptr [ ebp - 0x48 ] mov dword ptr [ esp ] , eax call 0xffff09e0 mov eax , dword ptr [ 0x80f7ac0 ] add eax , 0x1 add esp , 0x9c pop esi pop edi pop ebx pop ebp ret mov eax , dword ptr [ 0x80f7ac0 ] mov ecx , esp mov dword ptr [ ecx ] , eax mov dword ptr [ ecx + 0x8 ] , 0x1 mov dword ptr [ ecx + 0x4 ] , 0x80f7ac4 call 0x47150 mov dword ptr [ 0x80f7ac0 ] , eax mov eax , dword ptr [ 0x80d836c ] jmp eax mov eax , dword ptr [ 0x80d833c ] jmp eax nop word ptr cs : [ eax + eax ] nop
Similarity: -1
Label: 1
Similarity Score: 0.15
Explanation: Both codes share a similar structure with function prologue (push ebp, mov ebp, esp) and epilogue (pop registers, ret), and both manipulate stack pointers and call functions. However, significant differences exist:
1. Code1 uses fixed memory offsets (e.g., 0x8122c60) while Code2 uses different addresses (e.g., 0x80f7ac0)
2. Code2 includes floating-point operations (movsd) and different control flow patterns
3. Function calls target entirely different addresses (e.g., 0xfffeb3a0 vs 0xffff0e40)
4. Code2 has complex jump tables and FPU usage absent in Code1
5. Stack adjustments differ (0xfc vs 0x9c)
The shared structural elements suggest a common calling convention, but operational differences indicate distinct functionality.
------------------------------------------------------------

------------------------------------------------------------
Code1: push rax mov rax , r9 mov r10d , r8d mov r9 , rcx mov ecx , edx sub rsp , 0x8 mov edx , 0x1 mov r8d , 0x0 push qword ptr [ rsp + 0x18 ] push rax push r10 call 0xfffffffffffffd80 add rsp , 0x20 pop rcx ret nop dword ptr [ rax ]
Code2: sub esp , 0xc call 0xffecedd1 add eax , 0x1ac7aa sub esp , 0xc push dword ptr [ esp + 0x34 ] push dword ptr [ esp + 0x34 ] push dword ptr [ esp + 0x34 ] push dword ptr [ esp + 0x34 ] push 0x0 push dword ptr [ esp + 0x38 ] push 0x1 push dword ptr [ esp + 0x3c ] push dword ptr [ esp + 0x3c ] call 0x3c add esp , 0x30 add esp , 0xc ret
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly codes show significant dissimilarities. Code1 uses 64-bit registers (rax, r9, rcx) and instructions tailored for x86-64 architecture, while Code2 employs 32-bit registers (esp, eax) and stack operations typical of x86. Their instruction sequences differ fundamentally: Code1 sets up registers before a call with specific push operations, whereas Code2 features an immediate call after stack adjustment and multiple memory pushes. The stack management (sub/add rsp vs. sub/add esp) and register usage patterns are incompatible. These architectural and structural differences indicate they perform unrelated tasks with no meaningful similarity.
------------------------------------------------------------

------------------------------------------------------------
Code1: push ebp mov ebp , esp push edi push esi sub esp , 0x30 mov eax , dword ptr [ ebp + 0x10 ] mov ecx , dword ptr [ ebp + 0xc ] mov edx , dword ptr [ ebp + 0x8 ] mov dword ptr [ ebp - 0xc ] , 0x0 mov esi , dword ptr [ ebp + 0x10 ] and esi , 0x40 cmp esi , 0x0 mov dword ptr [ ebp - 0x14 ] , eax mov dword ptr [ ebp - 0x18 ] , ecx mov dword ptr [ ebp - 0x1c ] , edx je 0x4d lea eax , [ ebp - 0x10 ] mov ecx , eax lea edx , [ ebp + 0x14 ] mov dword ptr [ ecx ] , edx mov ecx , dword ptr [ ebp - 0x10 ] mov edx , ecx add edx , 0x4 mov dword ptr [ ebp - 0x10 ] , edx mov ecx , dword ptr [ ecx ] mov dword ptr [ ebp - 0xc ] , ecx mov dword ptr [ ebp - 0x20 ] , eax mov eax , dword ptr [ ebp + 0x8 ] mov ecx , dword ptr [ ebp + 0xc ] mov edx , dword ptr [ ebp + 0x10 ] mov esi , dword ptr [ ebp - 0xc ] mov edi , esp mov dword ptr [ edi + 0xc ] , esi mov dword ptr [ edi + 0x8 ] , edx mov dword ptr [ edi + 0x4 ] , ecx mov dword ptr [ edi ] , eax call 0xffff4f00 mov ecx , esp mov dword ptr [ ecx ] , eax call 0x140 add esp , 0x30 pop esi pop edi pop ebp ret nop nop nop
Code2: lui gp , 0x43 addiu sp , sp , - 0x28 addiu gp , gp , - 0x2f30 andi v0 , a2 , 0x100 sw s0 , 0x20 ( sp ) sw a3 , 0x34 ( sp ) lw s0 , - 0x7de4 ( gp ) sw ra , 0x24 ( sp ) sw gp , 0x10 ( sp ) lw v1 , ( s0 ) sw v1 , 0x1c ( sp ) bnez v0 , 0x74 addiu v0 , sp , 0x34 move a3 , zero lw t9 , - 0x7e40 ( gp ) jalr t9 nop lw gp , 0x10 ( sp ) lw t9 , - 0x7ef8 ( gp ) bal 0x170 move a0 , v0 lw a0 , 0x1c ( sp ) lw v1 , ( s0 ) bne a0 , v1 , 0x7c lw gp , 0x10 ( sp ) lw ra , 0x24 ( sp ) lw s0 , 0x20 ( sp ) jr ra addiu sp , sp , 0x28 b 0x38 sw v0 , 0x18 ( sp ) lw t9 , - 0x7df4 ( gp ) jalr t9 nop
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two code snippets show no meaningful similarity due to fundamental differences:
1. Architecture: Code1 uses x86 instructions (ebp/esp registers, call/ret) while Code2 uses MIPS instructions (gp/sp registers, jalr/jr).
2. Structure: Code1 has a stack frame setup (push ebp, mov ebp,esp) and cleanup (pop/pop/ret) not present in Code2.
3. Operations: Code1 focuses on bitmask checks (and esi,0x40) and argument handling via stack, while Code2 uses different register conventions (a0-a3/v0-v1) and explicit load/store operations (lw/sw).
4. Control flow: Conditional jumps (je in Code1 vs bnez in Code2) and function calls (call vs jalr) are architecturally distinct.
The snippets represent entirely different low-level implementations with no overlapping logic or patterns.
------------------------------------------------------------

------------------------------------------------------------
Code1: push esi push ebx sub esp , 0x4 call 0xfff9b330 add ebx , 0x1ff902 mov esi , dword ptr [ esp + 0x10 ] mov eax , dword ptr [ esi + 0x15c ] test eax , eax je 0x2a sub esp , 0xc push eax call 0x20bf1 add esp , 0x10 sub esp , 0xc push esi call 0xffff654e add esp , 0x14 pop ebx pop esi ret
Code2: push rbp push rbx push rax mov rbx , rdi mov rax , qword ptr [ rdi + 0x248 ] mov qword ptr [ rsp ] , rax mov eax , 0xeec42415 mov ebp , 0x4ec1d426 jmp 0x30 cmp qword ptr [ rsp ] , 0x0 mov eax , 0x59e13be8 cmove eax , ebp nop word ptr [ rax + rax ] cmp eax , 0x59e13be8 je 0x47 cmp eax , 0x4ec1d426 je 0x57 cmp eax , 0xeec42415 jne 0x30 jmp 0x1d mov rdi , qword ptr [ rsp ] call 0x61230 mov eax , 0x4ec1d426 jmp 0x30 mov rdi , rbx add rsp , 0x8 pop rbx pop rbp jmp 0xfffffffffffe3f50 nop word ptr cs : [ rax + rax ] nop
Similarity: -1
Label: 1
Similarity Score: -0.95
Explanation: The two assembly code snippets are fundamentally dissimilar due to key differences:
1. Architecture: Code1 uses 32-bit registers (esi, ebx, eax) and stack operations (esp), while Code2 uses 64-bit registers (rbp, rbx, rax) and RDI-based parameter passing.
2. Structure: Code1 has a linear flow with one conditional jump (je) and two function calls. Code2 features complex control flow with multiple jumps (jmp/je/jne), comparisons (cmp), and conditional moves (cmove).
3. Operations: Code2 includes specialized operations like absolute jumps to fixed addresses (jmp 0xfffffffffffe3f50) and NOP padding, absent in Code1. Stack management also differs significantly (sub esp vs add rsp).
4. Purpose: Code1 appears to handle function arguments via stack and checks a memory offset, while Code2 implements a state-machine-like pattern using constant comparisons (0x59e13be8, etc.).

These architectural, structural, and operational disparities indicate the codes serve unrelated purposes with negligible similarity.
------------------------------------------------------------

------------------------------------------------------------
Code1: ldr r3 , [ r0 , - 0x4 ] cmp r3 , 0x0 beq 0x1c mov r2 , r1 mov r1 , r3 ldr r0 , [ r2 , 0x4 ] b 0xfffc0908 push { r4 , lr } ldr r3 , [ pc , 0xc ] ldr r2 , [ pc , 0xc ] ldr r1 , [ pc , 0xc ] ldr r0 , [ pc , 0xc ] bl 0xfffb40a4 andeq sl , r8 , ip , asr 0x10 andeq r0 , r0 , r5 , lsr 0x5 andeq sl , r8 , r0 , lsl 0x16 andeq sl , r8 , r8 , asr 0x16
Code2: lui gp , 0x4e lw v0 , - 0x4 ( a0 ) addiu sp , sp , - 0x20 addiu gp , gp , 0x30e0 sw ra , 0x1c ( sp ) beqz v0 , 0x34 sw gp , 0x10 ( sp ) lw a0 , 0x4 ( a1 ) move a1 , v0 lw ra , 0x1c ( sp ) lw t9 , - 0x7d9c ( gp ) jr t9 addiu sp , sp , 0x20 lui a3 , 0x4c lw t9 , - 0x75f8 ( gp ) lui a1 , 0x4c lui a0 , 0x4c addiu a3 , a3 , 0xf84 addiu a2 , zero , 0x2a5 addiu a1 , a1 , 0x40c jalr t9 addiu a0 , a0 , 0x48c
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly code snippets are fundamentally dissimilar due to differences in architecture (ARM vs MIPS), instruction sets, register usage patterns, and functional structure. Code1 uses ARM-specific instructions (e.g., ldr, cmp, beq, push) and registers (r0-r3, lr), featuring PC-relative loads and conditional execution. Code2 employs MIPS-specific operations (e.g., lui, lw, addiu, jr) and registers (v0, a0, a1, gp, sp), with distinct calling conventions and stack management. No significant structural or functional similarities exist in control flow, memory operations, or register handling. The architectural mismatch and lack of overlapping patterns result in minimal similarity.
------------------------------------------------------------

------------------------------------------------------------
Code1: push rbp mov rbp , rsp sub rsp , 0x10 mov qword ptr [ rbp - 0x10 ] , rdi mov qword ptr [ rbp - 0x18 ] , rsi mov rsi , qword ptr [ rbp - 0x10 ] mov rdi , qword ptr [ rbp - 0x18 ] mov rsi , qword ptr [ rsi + rdi * 0x8 ] mov qword ptr [ rbp - 0x8 ] , rsi mov dword ptr [ rbp - 0x34 ] , 0x25dc3929 mov eax , dword ptr [ rbp - 0x34 ] mov ecx , eax sub ecx , 0x92ddc3a9 mov dword ptr [ rbp - 0x38 ] , eax mov dword ptr [ rbp - 0x3c ] , ecx je 0x2dc jmp 0x43 mov eax , dword ptr [ rbp - 0x38 ] sub eax , 0x996fd2ae mov dword ptr [ rbp - 0x40 ] , eax je 0x353 jmp 0x59 mov eax , dword ptr [ rbp - 0x38 ] sub eax , 0xae0decf2 mov dword ptr [ rbp - 0x44 ] , eax je 0x226 jmp 0x6f mov eax , dword ptr [ rbp - 0x38 ] sub eax , 0xae8d27d8 mov dword ptr [ rbp - 0x48 ] , eax je 0x35f jmp 0x85 mov eax , dword ptr [ rbp - 0x38 ] sub eax , 0xd3b8c0a7 mov dword ptr [ rbp - 0x4c ] , eax je 0x2e8 jmp 0x9b mov eax , dword ptr [ rbp - 0x38 ] sub eax , 0xd66655b3 mov dword ptr [ rbp - 0x50 ] , eax je 0x347 jmp 0xb1 mov eax , dword ptr [ rbp - 0x38 ] sub eax , 0xe986b706 mov dword ptr [ rbp - 0x54 ] , eax je 0x3a3 jmp 0xc7 mov eax , dword ptr [ rbp - 0x38 ] sub eax , 0xefeab27f mov dword ptr [ rbp - 0x58 ] , eax je 0x397 jmp 0xdd mov eax , dword ptr [ rbp - 0x38 ] sub eax , 0x5323a70 mov dword ptr [ rbp - 0x5c ] , eax je 0x2c0 jmp 0xf3 mov eax , dword ptr [ rbp - 0x38 ] sub eax , 0x915c9e9 mov dword ptr [ rbp - 0x60 ] , eax je 0x33b jmp 0x109 mov eax , dword ptr [ rbp - 0x38 ] sub eax , 0x1401ce72 mov dword ptr [ rbp - 0x64 ] , eax je 0x276 jmp 0x11f mov eax , dword ptr [ rbp - 0x38 ] sub eax , 0x18cb399e mov dword ptr [ rbp - 0x68 ] , eax je 0x232 jmp 0x135 mov eax , dword ptr [ rbp - 0x38 ] sub eax , 0x2251f8c0 mov dword ptr [ rbp - 0x6c ] , eax je 0x2f4 jmp 0x14b mov eax , dword ptr [ rbp - 0x38 ] sub eax , 0x25dc3929 mov dword ptr [ rbp - 0x70 ] , eax je 0x209 jmp 0x161 mov eax , dword ptr [ rbp - 0x38 ] sub eax , 0x2f71b0ab mov dword ptr [ rbp - 0x74 ] , eax je 0x29a jmp 0x177 mov eax , dword ptr [ rbp - 0x38 ] sub eax , 0x3e5e06cb mov dword ptr [ rbp - 0x78 ] , eax je 0x254 jmp 0x18d mov eax , dword ptr [ rbp - 0x38 ] sub eax , 0x4b922b09 mov dword ptr [ rbp - 0x7c ] , eax je 0x282 jmp 0x1a3 mov eax , dword ptr [ rbp - 0x38 ] sub eax , 0x4d01fde5 mov dword ptr [ rbp - 0x80 ] , eax je 0x316 jmp 0x1b9 mov eax , dword ptr [ rbp - 0x38 ] sub eax , 0x688b4149 mov dword ptr [ rbp - 0x84 ] , eax je 0x2b4 jmp 0x1d2 mov eax , dword ptr [ rbp - 0x38 ] sub eax , 0x6bc4e0dd mov dword ptr [ rbp - 0x88 ] , eax je 0x37b jmp 0x1eb mov eax , dword ptr [ rbp - 0x38 ] sub eax , 0x70a1c1c4 mov dword ptr [ rbp - 0x8c ] , eax je 0x28e jmp 0x204 jmp 0x3a9 mov rax , qword ptr [ rbp - 0x8 ] cmp rax , 0x0 mov ecx , 0xae0decf2 mov edx , 0xe986b706 cmovne edx , ecx mov dword ptr [ rbp - 0x34 ] , edx jmp 0x3a9 mov dword ptr [ rbp - 0x34 ] , 0x18cb399e jmp 0x3a9 mov rax , qword ptr [ rbp - 0x10 ] sub qword ptr [ rax ] , 0x1 lea rax , [ rax + 0x8 ] jb 0x236 mov qword ptr [ rbp - 0x20 ] , rax mov dword ptr [ rbp - 0x34 ] , 0x3e5e06cb jmp 0x3a9 mov rax , qword ptr [ rbp - 0x10 ] mov rcx , qword ptr [ rbp - 0x18 ] cmp qword ptr [ rax + rcx * 0x8 ] , 0x0 mov edx , 0x1401ce72 mov esi , 0x6bc4e0dd cmove esi , edx mov dword ptr [ rbp - 0x34 ] , esi jmp 0x3a9 mov dword ptr [ rbp - 0x34 ] , 0x4b922b09 jmp 0x3a9 mov dword ptr [ rbp - 0x34 ] , 0x70a1c1c4 jmp 0x3a9 mov dword ptr [ rbp - 0x34 ] , 0x2f71b0ab jmp 0x3a9 cmp qword ptr [ rbp - 0x18 ] , 0x0 mov eax , 0x688b4149 mov ecx , 0x996fd2ae cmovne ecx , eax mov dword ptr [ rbp - 0x34 ] , ecx jmp 0x3a9 mov dword ptr [ rbp - 0x34 ] , 0x5323a70 jmp 0x3a9 mov rax , qword ptr [ rbp - 0x10 ] mov qword ptr [ rbp - 0x28 ] , rax mov rax , qword ptr [ rbp - 0x18 ] mov qword ptr [ rbp - 0x30 ] , rax mov dword ptr [ rbp - 0x34 ] , 0x92ddc3a9 jmp 0x3a9 mov dword ptr [ rbp - 0x34 ] , 0xd3b8c0a7 jmp 0x3a9 mov dword ptr [ rbp - 0x34 ] , 0x2251f8c0 jmp 0x3a9 mov rax , qword ptr [ rbp - 0x28 ] mov rcx , rax add rcx , 0x8 mov qword ptr [ rbp - 0x28 ] , rcx mov qword ptr [ rax ] , 0x0 mov dword ptr [ rbp - 0x34 ] , 0x4d01fde5 jmp 0x3a9 mov rax , qword ptr [ rbp - 0x30 ] add rax , - 0x1 mov qword ptr [ rbp - 0x30 ] , rax cmp rax , 0x0 mov ecx , 0x2251f8c0 mov edx , 0x915c9e9 cmovne edx , ecx mov dword ptr [ rbp - 0x34 ] , edx jmp 0x3a9 mov dword ptr [ rbp - 0x34 ] , 0xd66655b3 jmp 0x3a9 mov dword ptr [ rbp - 0x34 ] , 0x996fd2ae jmp 0x3a9 mov dword ptr [ rbp - 0x34 ] , 0xae8d27d8 jmp 0x3a9 mov rax , qword ptr [ rbp - 0x10 ] mov rcx , qword ptr [ rbp - 0x18 ] mov qword ptr [ rax + rcx * 0x8 ] , 0x1 mov dword ptr [ rbp - 0x34 ] , 0xefeab27f jmp 0x3a9 mov rax , qword ptr [ rbp - 0x10 ] mov rcx , qword ptr [ rbp - 0x18 ] mov qword ptr [ rax + rcx * 0x8 ] , 0x0 mov dword ptr [ rbp - 0x34 ] , 0xefeab27f jmp 0x3a9 mov dword ptr [ rbp - 0x34 ] , 0xe986b706 jmp 0x3a9 add rsp , 0x10 pop rbp ret jmp 0x27
Code2: push rbp mov rbp , rsp mov qword ptr [ rbp - 0x8 ] , rdi mov qword ptr [ rbp - 0x10 ] , rsi mov rsi , qword ptr [ rbp - 0x8 ] mov rdi , qword ptr [ rbp - 0x10 ] cmp qword ptr [ rsi + rdi * 0x8 ] , 0x0 je 0xeb jmp 0x24 mov rax , qword ptr [ rbp - 0x8 ] sub qword ptr [ rax ] , 0x1 lea rax , [ rax + 0x8 ] jb 0x28 mov qword ptr [ rbp - 0x18 ] , rax mov rax , qword ptr [ rbp - 0x8 ] mov rcx , qword ptr [ rbp - 0x10 ] cmp qword ptr [ rax + rcx * 0x8 ] , 0x0 jne 0xd6 jmp 0x52 jmp 0x57 jmp 0x5c cmp qword ptr [ rbp - 0x10 ] , 0x0 je 0xbc jmp 0x6c mov rax , qword ptr [ rbp - 0x8 ] mov qword ptr [ rbp - 0x20 ] , rax mov rax , qword ptr [ rbp - 0x10 ] mov qword ptr [ rbp - 0x28 ] , rax jmp 0x81 jmp 0x86 mov rax , qword ptr [ rbp - 0x20 ] mov rcx , rax add rcx , 0x8 mov qword ptr [ rbp - 0x20 ] , rcx mov qword ptr [ rax ] , 0x0 mov rax , qword ptr [ rbp - 0x28 ] add rax , - 0x1 mov qword ptr [ rbp - 0x28 ] , rax cmp rax , 0x0 jne 0x86 jmp 0xb7 jmp 0xbc jmp 0xc1 mov rax , qword ptr [ rbp - 0x8 ] mov rcx , qword ptr [ rbp - 0x10 ] mov qword ptr [ rax + rcx * 0x8 ] , 0x1 jmp 0xe6 mov rax , qword ptr [ rbp - 0x8 ] mov rcx , qword ptr [ rbp - 0x10 ] mov qword ptr [ rax + rcx * 0x8 ] , 0x0 jmp 0xeb pop rbp ret
Similarity: -1
Label: 1
Similarity Score: 0.35
Explanation: Both codes share core operations like stack frame setup, argument storage, and memory manipulation (array indexing with scaling). However, code1 implements a complex state machine using constant comparisons and conditional jumps (20+ cases), while code2 uses simpler direct conditionals and a compact loop structure. The state machine logic in code1 (with dword state variable at [rbp-0x34]) is absent in code2, and code2's loop (0x81-0x9b) has no equivalent in code1. Though memory write patterns (0/1 initialization) are similar, the fundamental control flow differs significantly—code1's jump table approach versus code2
------------------------------------------------------------

------------------------------------------------------------
Code1: str lr , [ sp , - 0x4 ] ! sub sp , sp , 0xc str r3 , [ sp ] mov r3 , r2 mov r2 , r1 mov r1 , r0 mov r0 , 0x3 bl 0xfffeeba0 add sp , sp , 0xc pop { pc }
Code2: push ebx call 0xfffe3710 add ebx , 0x333a sub esp , 0x14 push dword ptr [ esp + 0x28 ] push dword ptr [ esp + 0x28 ] push dword ptr [ esp + 0x28 ] push dword ptr [ esp + 0x28 ] push 0x3 call 0xfffe3340 add esp , 0x28 pop ebx ret
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly codes are from different architectures (ARM and x86) and exhibit different calling conventions and structure. Code1 uses register-based argument passing for a function with 4 arguments, while Code2 uses stack-based passing for 5 arguments. Additionally, Code2 includes an extra function call and manipulation of the ebx register. The only commonality is the use of the constant 0x3 as an argument, but this is insufficient to consider the codes similar.
------------------------------------------------------------

------------------------------------------------------------
Code1: mov r9 , rcx mov r8 , rdx mov rcx , rsi mov rdx , rdi mov edi , 0x51fe40 mov esi , 0x630921 jmp 0xffffffffffffd8a0 nop dword ptr [ rax + rax ]
Code2: lui gp , 0x65 addiu sp , sp , - 0x28 addiu gp , gp , 0x3ee0 sw a3 , 0x14 ( sp ) move a3 , a1 lui a1 , 0x61 sw a2 , 0x10 ( sp ) sw ra , 0x24 ( sp ) move a2 , a0 sw gp , 0x18 ( sp ) lw t9 , - 0x6a18 ( gp ) lw a0 , - 0x5f60 ( gp ) bal - 0x29f4 addiu a1 , a1 , 0x644 lw ra , 0x24 ( sp ) jr ra addiu sp , sp , 0x28
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The codes are from completely different architectures (x86-64 vs MIPS) with no overlapping instructions, registers, or control flow patterns. The first uses Intel-syntax registers (rcx, rdx, r9) and jmp instructions, while the second uses MIPS conventions (sp, gp, ra) and load/store operations. No functional or structural similarities exist.
------------------------------------------------------------

------------------------------------------------------------
Code1: push r15 push r14 push rbx mov rbx , rdx mov r14 , rsi mov r15 , rdi mov eax , dword ptr [ rip ] test eax , eax jne 0x274 mov al , byte ptr [ rip ] xor al , 0xfc mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x5b mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xbc mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x81 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xd9 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x4 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xa1 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x98 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x75 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xf mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x7e mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xdb mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x3d mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xf0 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xd9 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x35 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xa mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x8 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x3 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xa2 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x2c mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x42 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xc5 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xad mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x56 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x6 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x3e mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xbd mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x16 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x18 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x95 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x62 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xd0 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xee mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x61 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x4c mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x6c mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x57 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xfb mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x74 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x89 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x9e mov byte ptr [ rip ] , al mov dword ptr [ rip ] , 0x1 test r15 , r15 je 0x2b8 test rbx , rbx je 0x2cc mov eax , 0x10 cmp r14 , 0x40 jb 0x29f mov rdi , rbx call 0xfffffffffffff460 test eax , eax je 0x2a5 pop rbx pop r14 pop r15 ret mov rdi , r15 mov rsi , r14 mov rdx , rbx pop rbx pop r14 pop r15 jmp 0xfffffffffffff5e0 mov edi , 0x0 mov esi , 0x0 mov edx , 0x134 call 0x2cc mov edi , 0x0 mov esi , 0x0 mov edx , 0x135 call 0x2e0
Code2: push ebp push edi push esi push ebx call 0x5 add ebx , 0x2 sub esp , 0xc mov edi , dword ptr [ esp + 0x20 ] mov ebp , dword ptr [ esp + 0x24 ] mov esi , dword ptr [ esp + 0x28 ] test edi , edi je 0x70 test esi , esi je 0x89 cmp ebp , 0x3f jbe 0x48 sub esp , 0xc push esi call 0x30 add esp , 0x10 test eax , eax je 0x58 add esp , 0xc pop ebx pop esi pop edi pop ebp ret nop lea esi , [ esi ] add esp , 0xc mov eax , 0x10 pop ebx pop esi pop edi pop ebp ret lea esi , [ esi ] mov dword ptr [ esp + 0x28 ] , esi mov dword ptr [ esp + 0x24 ] , ebp mov dword ptr [ esp + 0x20 ] , edi add esp , 0xc pop ebx pop esi pop edi pop ebp jmp 0xfffffd80 lea ecx , [ ebx ] lea edi , [ ebx ] push edx push 0x134 push ecx push edi call 0x85 lea edx , [ ebx ] push eax lea eax , [ ebx ] push 0x135 push edx push eax call 0x9e lea esi , [ esi ] lea edi , [ edi ]
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly codes show significant architectural and functional differences. Code1 uses 64-bit registers (r15, rbx, etc.) and performs a sequence of byte-level XOR operations on memory addresses relative to the instruction pointer (rip), suggesting low-level data manipulation. Code2 employs 32-bit registers (ebp, edi, etc.), relies on stack-based parameter passing, and includes calls to absolute addresses without any XOR patterns. The register usage, memory operations, control flow structures, and core functionalities (data transformation vs. parameter handling) are fundamentally distinct, indicating no meaningful similarity.
------------------------------------------------------------

------------------------------------------------------------
Code1: push ebp mov ebp , esp push edi push esi push ebx sub esp , 0x3c call 0xfffd06a2 add ebx , 0x361fd4 mov eax , dword ptr [ ebp + 0x8 ] mov eax , dword ptr [ eax + 0xc ] mov dword ptr [ ebp - 0x28 ] , eax mov eax , dword ptr [ ebp + 0x8 ] mov eax , dword ptr [ eax + 0x8 ] mov dword ptr [ ebp - 0x24 ] , eax mov eax , dword ptr [ ebp + 0x8 ] mov eax , dword ptr [ eax + 0x4 ] mov dword ptr [ ebp - 0x20 ] , eax mov eax , dword ptr [ ebp + 0x8 ] mov eax , dword ptr [ eax ] mov dword ptr [ ebp - 0x1c ] , eax mov eax , dword ptr [ ebp - 0x1c ] mov eax , dword ptr [ eax + 0x1c ] mov esi , eax call 0xfffcd4f2 mov edi , eax call 0xfffce402 mov dword ptr [ ebp - 0x44 ] , eax mov eax , esi cdq idiv edi mov ecx , eax mov eax , esi cdq idiv edi mov eax , edx cmp dword ptr [ ebp - 0x44 ] , eax jl 0x1b6 mov edx , dword ptr [ ebp - 0x44 ] imul edx , ecx add eax , edx lea esi , [ eax + ecx ] cmp eax , esi jge 0x1c3 mov dword ptr [ ebp - 0x38 ] , eax mov eax , dword ptr [ ebp + 0x8 ] mov eax , dword ptr [ eax + 0x10 ] test eax , eax jne 0x94 nop add dword ptr [ ebp - 0x38 ] , 0x1 cmp dword ptr [ ebp - 0x38 ] , esi jl 0x7b jmp 0x1c3 mov eax , dword ptr [ ebp - 0x1c ] mov eax , dword ptr [ eax + 0x18 ] sub esp , 0x8 push dword ptr [ ebp - 0x24 ] push 0x1 push eax push dword ptr [ ebp - 0x38 ] push 0x0 push dword ptr [ ebp - 0x28 ] call 0xfffcdf22 add esp , 0x20 mov dword ptr [ ebp - 0x34 ] , eax cmp dword ptr [ ebp - 0x34 ] , 0x0 je 0x1a7 mov dword ptr [ ebp - 0x30 ] , 0x0 nop mov eax , dword ptr [ ebp - 0x1c ] mov eax , dword ptr [ eax + 0x18 ] cmp eax , dword ptr [ ebp - 0x30 ] jg 0xf4 sub esp , 0x8 push dword ptr [ ebp - 0x24 ] push dword ptr [ ebp - 0x28 ] call 0xfffce442 add esp , 0x10 test eax , eax jne 0x86 mov eax , dword ptr [ ebp + 0x8 ] mov dword ptr [ eax + 0x10 ] , 0x0 jmp 0x86 sub esp , 0x8 push dword ptr [ ebp - 0x34 ] push dword ptr [ ebp - 0x1c ] call 0xfffff4bf add esp , 0x10 fild dword ptr [ ebp - 0x20 ] faddp st ( 0x1 ) fnstcw word ptr [ ebp - 0x3a ] movzx eax , word ptr [ ebp - 0x3a ] or ah , 0xc mov word ptr [ ebp - 0x3c ] , ax fldcw word ptr [ ebp - 0x3c ] fistp dword ptr [ ebp - 0x40 ] fldcw word ptr [ ebp - 0x3a ] mov eax , dword ptr [ ebp - 0x40 ] mov edx , eax mov eax , dword ptr [ ebp - 0x1c ] mov ecx , dword ptr [ eax + 0x24 ] mov eax , edx mov edx , 0x0 div ecx mov eax , edx mov dword ptr [ ebp - 0x2c ] , eax cmp dword ptr [ ebp - 0x2c ] , 0x0 js 0x19c fild dword ptr [ ebp - 0x2c ] push dword ptr [ ebp - 0x34 ] lea esp , [ esp - 0x8 ] fstp qword ptr [ esp ] push dword ptr [ ebp - 0x1c ] call 0xfffff502 add esp , 0x10 mov eax , dword ptr [ ebp - 0x1c ] mov ecx , dword ptr [ eax + 0x28 ] mov edx , dword ptr [ ebp - 0x2c ] mov eax , edx shl eax , 0x2 add eax , edx shl eax , 0x4 add eax , ecx sub esp , 0x4 push dword ptr [ ebp - 0x34 ] push eax push dword ptr [ ebp - 0x1c ] call 0xfffff554 add esp , 0x10 sub esp , 0xc push dword ptr [ ebp - 0x1c ] call 0xfffff4a7 add esp , 0x10 shl eax , 0x3 add dword ptr [ ebp - 0x34 ] , eax add dword ptr [ ebp - 0x30 ] , 0x1 jmp 0xc8 mov eax , dword ptr [ ebp - 0x1c ] mov eax , dword ptr [ eax + 0x24 ] add dword ptr [ ebp - 0x2c ] , eax jmp 0x140 mov eax , dword ptr [ ebp + 0x8 ] mov dword ptr [ eax + 0x10 ] , 0x0 jmp 0x86 mov eax , 0x0 add ecx , 0x1 jmp 0x65 lea esp , [ ebp - 0xc ] pop ebx pop esi pop edi pop ebp ret
Code2: lui gp , 0x39 addiu gp , gp , 0x5674 addu gp , gp , t9 addiu sp , sp , - 0x50 sw ra , 0x3c ( sp ) sw s6 , 0x38 ( sp ) sw s5 , 0x34 ( sp ) sw s4 , 0x30 ( sp ) sw s3 , 0x2c ( sp ) sw s2 , 0x28 ( sp ) sw s1 , 0x24 ( sp ) sw s0 , 0x20 ( sp ) sdc1 f22 , 0x48 ( sp ) sdc1 f20 , 0x40 ( sp ) sw gp , 0x18 ( sp ) move s3 , a0 lw s0 , ( a0 ) lw s2 , 0x1c ( s0 ) lw t9 , - 0x6fa0 ( gp ) jalr t9 nop lw gp , 0x18 ( sp ) move s1 , v0 lw t9 , - 0x7398 ( gp ) jalr t9 nop lw gp , 0x18 ( sp ) teq s1 , zero , 0x7 div zero , s2 , s1 mfhi v1 move a0 , v1 slt v1 , v0 , v1 bnez v1 , 0x278 mflo s2 mul v1 , s2 , v0 addu s1 , v1 , a0 addu s2 , s2 , s1 slt v0 , s1 , s2 beqz v0 , 0x2c0 mtc1 zero , f20 lw s6 , 0xc ( s3 ) lw s5 , 0x8 ( s3 ) lw s4 , 0x4 ( s3 ) lw v0 , - 0x7fd0 ( gp ) b 0xe8 lwc1 f22 , 0x7f8 ( v0 ) move a1 , s5 move a0 , s6 lw t9 , - 0x73a8 ( gp ) jalr t9 nop lw gp , 0x18 ( sp ) bnez v0 , 0xdc nop sw zero , 0x10 ( s3 ) addiu s1 , s1 , 0x1 beq s2 , s1 , 0x2c4 lw ra , 0x3c ( sp ) lw v0 , 0x10 ( s3 ) beqz v0 , 0xdc addiu v0 , zero , 0x1 lw a3 , 0x18 ( s0 ) sw s5 , 0x14 ( sp ) sw v0 , 0x10 ( sp ) move a2 , s1 move a1 , zero move a0 , s6 lw t9 , - 0x7254 ( gp ) jalr t9 nop lw gp , 0x18 ( sp ) beqz v0 , 0x270 nop lw v1 , 0x18 ( s0 ) blez v1 , 0xb8 move a2 , zero b 0x16c addiu a3 , zero , 0x58 mov.s f0 , f22 lw v1 , 0x38 ( a0 ) sll v1 , v1 , 0x2 addu v1 , v0 , v1 swc1 f0 , ( v1 ) lw v1 , 0x2c0 ( s0 ) sll v1 , v1 , 0x2 addu v0 , v0 , v1 addiu a2 , a2 , 0x1 lw v1 , 0x18 ( s0 ) slt v1 , a2 , v1 beqz v1 , 0xbc move a1 , s5 lw a0 , 0x2d0 ( s0 ) lw v1 , 0x40 ( a0 ) beqz v1 , 0x290 mtc1 s4 , f0 lw t0 , 0x24 ( s0 ) lw v1 , 0x44 ( a0 ) sll v1 , v1 , 0x2 addu v1 , v0 , v1 cvt.s.w f0 , f0 lwc1 f2 , ( v1 ) add.s f0 , f0 , f2 trunc.w.s f0 , f0 mfc1 v1 , f0 teq t0 , zero , 0x7 divu zero , v1 , t0 mfhi a1 bgez a1 , 0x284 move v1 , a1 addu v1 , a1 , t0 mtc1 v1 , f0 cvt.s.w f0 , f0 lw a0 , 0x44 ( a0 ) sll a0 , a0 , 0x2 addu a0 , v0 , a0 swc1 f0 , ( a0 ) lw a0 , 0x28 ( s0 ) mul a1 , v1 , a3 addu v1 , a1 , a0 lw a0 , 0x2d0 ( s0 ) lw a1 , 0x8 ( a0 ) sll a1 , a1 , 0x2 addu a1 , v0 , a1 ldc1 f0 , 0x28 ( v1 ) cvt.s.d f0 , f0 swc1 f0 , ( a1 ) lw a1 , 0x14 ( a0 ) sll a1 , a1 , 0x2 addu a1 , v0 , a1 ldc1 f0 , 0x30 ( v1 ) cvt.s.d f0 , f0 swc1 f0 , ( a1 ) lw a1 , 0x20 ( a0 ) sll a1 , a1 , 0x2 addu a1 , v0 , a1 ldc1 f0 , 0x38 ( v1 ) cvt.s.d f0 , f0 swc1 f0 , ( a1 ) lw a1 , 0x28 ( a0 ) beqz a1 , 0x24c nop lw a1 , 0x2c ( a0 ) sll a1 , a1 , 0x2 addu a1 , v0 , a1 ldc1 f0 , 0x40 ( v1 ) cvt.s.d f0 , f0 swc1 f0 , ( a1 ) lw a1 , 0x34 ( a0 ) beqz a1 , 0x14c nop lw a1 , 0x8 ( v1 ) beqz a1 , 0x138 nop ldc1 f0 , 0x48 ( v1 ) b 0x13c cvt.s.d f0 , f0 b 0xdc sw zero , 0x10 ( s3 ) addiu s2 , s2 , 0x1 b 0x88 move a0 , zero mtc1 a1 , f0 b 0x1c0 cvt.s.w f0 , f0 lw a0 , 0x24 ( s0 ) cvt.s.w f0 , f0 add.s f0 , f0 , f20 trunc.w.s f0 , f0 mfc1 v1 , f0 teq a0 , zero , 0x7 divu zero , v1 , a0 mfhi a1 bgez a1 , 0x1d0 move v1 , a1 b 0x1d0 addu v1 , a1 , a0 lw ra , 0x3c ( sp ) lw s6 , 0x38 ( sp ) lw s5 , 0x34 ( sp ) lw s4 , 0x30 ( sp ) lw s3 , 0x2c ( sp ) lw s2 , 0x28 ( sp ) lw s1 , 0x24 ( sp ) lw s0 , 0x20 ( sp ) ldc1 f22 , 0x48 ( sp ) ldc1 f20 , 0x40 ( sp ) jr ra addiu sp , sp , 0x50
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly codes are fundamentally dissimilar due to multiple key factors:
1. **Different Architectures**: The first code uses x86 syntax (ebp, esp, eax registers) while the second uses MIPS syntax (gp, sp, t9 registers), indicating completely different CPU architectures.
2. **Divergent Operations**: 
   - Code1 relies heavily on x86-specific operations like `cdq`, `idiv`, and x87 FPU instructions (`fild`, `faddp`, `fnstcw`).
   - Code2 uses MIPS-specific features like delayed slots (`nop` after jumps), coprocessor moves (`mtc1`), and MIPS floating-point conversions (`cvt.s.w`).
3. **Structural Differences**: 
   - Code1 has a clear stack frame setup (ebp/esp) with local variable accesses via negative offsets.
   - Code2 uses MIPS calling conventions (sw/lw with stack offsets) and GP-relative addressing.
4. **Algorithmic Flow**: Control flow patterns (loops, branches) and function call mechanisms show no correspondence between the codes.
5. **Register Usage**: No overlapping register semantics or equivalent data movement patterns exist between x86 and MIPS implementations.
------------------------------------------------------------

------------------------------------------------------------
Code1: ldr r3 , [ pc , 0x4 ] ldr r2 , [ pc , 0x4 ] b 0xfffffef8 andeq sp , r1 , r4 , ror 0x21 andeq r2 , r1 , r0 , lsl 0x23
Code2: push ebp mov ebp , esp push esi sub esp , 0x24 mov eax , dword ptr [ ebp + 0xc ] mov ecx , dword ptr [ ebp + 0x8 ] mov edx , dword ptr [ ebp + 0x8 ] mov esi , dword ptr [ ebp + 0xc ] mov dword ptr [ esp ] , edx lea edx , [ 0x8080578 ] mov dword ptr [ esp + 0x4 ] , edx mov dword ptr [ esp + 0x8 ] , esi mov dword ptr [ esp + 0xc ] , 0x40 lea edx , [ 0x804b530 ] mov dword ptr [ esp + 0x10 ] , edx lea edx , [ 0x804be80 ] mov dword ptr [ esp + 0x14 ] , edx mov dword ptr [ ebp - 0x8 ] , eax mov dword ptr [ ebp - 0xc ] , ecx call 0x60 add esp , 0x24 pop esi pop ebp ret nop word ptr cs : [ eax + eax ] nop dword ptr [ eax + eax ]
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two code snippets are fundamentally dissimilar due to multiple factors: 
1. Architecture difference - Code1 uses ARM instructions while Code2 uses x86 instructions
2. Structural contrast - Code1 is a minimal sequence (5 instructions) with branch operations, while Code2 is a structured function prologue/epilogue with stack operations
3. No overlapping instructions - Zero common instructions or equivalent operations
4. Different purposes - Code1 appears to be position-dependent memory loading with branching, while Code2 implements complex stack-based operations with multiple memory accesses and function calls
------------------------------------------------------------

------------------------------------------------------------
Code1: push r14 push rbx push rax mov r14 , rsi mov rbx , rdi mov rdi , rsi call 0xfffffffffffcda20 mov rcx , qword ptr [ rbx + 0x60 ] mov rdi , qword ptr [ rcx + 0x8 ] test rdi , rdi je 0x51 movsxd rdx , dword ptr [ rcx ] cmp rax , rdx je 0x45 add rcx , 0x20 nop dword ptr [ rax + rax ] mov rdi , qword ptr [ rcx ] test rdi , rdi je 0x51 movsxd rdx , dword ptr [ rcx - 0x8 ] add rcx , 0x18 cmp rax , rdx jne 0x30 add rsp , 0x8 pop rbx pop r14 jmp 0xfffffffffffa5840 mov rdi , rbx mov rsi , r14 add rsp , 0x8 pop rbx pop r14 jmp 0xffffffffffffc210 nop word ptr cs : [ rax + rax ] nop dword ptr [ rax ]
Code2: push { r4 , r5 , r6 , lr } mov r4 , r0 mov r5 , r1 mov r0 , r1 bl 0xfffdca2c ldr r3 , [ r4 , 0x34 ] ldr r2 , [ r3 , 0x4 ] cmp r2 , 0x0 beq 0x54 ldr r1 , [ r3 ] cmp r0 , r1 beq 0x48 ldr r2 , [ r3 , 0x10 ] cmp r2 , 0x0 beq 0x54 ldr r1 , [ r3 , 0xc ] ! cmp r1 , r0 bne 0x30 mov r0 , r2 bl 0xfffc2cd4 pop { r4 , r5 , r6 , pc } mov r1 , r5 mov r0 , r4 bl 0xffffd438 pop { r4 , r5 , r6 , pc }
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two code snippets are fundamentally dissimilar due to targeting different CPU architectures (x86-64 vs ARM). The first uses x86-specific instructions like `movsxd`, `qword ptr`, and `jmp`, while
------------------------------------------------------------

------------------------------------------------------------
Code1: push rbp push r15 push r14 push r13 push r12 push rbx sub rsp , 0x18 mov rbx , rsi mov r14 , rdi mov eax , 0x8203d72d mov r12d , 0x5f558fe5 mov r13d , 0x9054f551 mov ebp , 0xd42cd7b jmp 0x50 call 0xffffffffffe6a000 mov r15 , rax mov rdi , rax xor esi , esi call 0xffffffffffe6afc0 mov eax , 0x3cda9cdb nop word ptr cs : [ rax + rax ] nop dword ptr [ rax ] cmp eax , 0xd42cd7a jle 0x90 cmp eax , 0xd42cd7b je 0x2c cmp eax , 0x3cda9cdb je 0xff cmp eax , 0x5f558fe5 jne 0x50 mov r14 , qword ptr [ rsp + 0x10 ] add r14 , 0x1 mov rbx , qword ptr [ rsp + 0x8 ] add rbx , - 0x1 mov eax , 0x8203d72d jmp 0x50 nop dword ptr [ rax ] cmp eax , 0x8203d72d je 0xc0 cmp eax , 0x9054f551 je 0xec cmp eax , 0xa2b7f511 jne 0x50 mov rsi , qword ptr [ rsp + 0x8 ] mov rdi , qword ptr [ rsp + 0x10 ] xor edx , edx call 0xffffffffffe6b0e0 mov r15 , rax mov eax , 0x3cda9cdb jmp 0x50 mov qword ptr [ rsp + 0x8 ] , rbx mov qword ptr [ rsp + 0x10 ] , r14 mov rax , qword ptr [ rsp + 0x10 ] movzx ecx , byte ptr [ rax ] cmp qword ptr [ rsp + 0x8 ] , 0x0 mov eax , 0x9054f551 cmovne eax , r12d test cl , cl cmovne eax , r13d jmp 0x50 cmp qword ptr [ rsp + 0x8 ] , 0x0 mov eax , 0xa2b7f511 cmove eax , ebp jmp 0x50 mov rax , r15 add rsp , 0x18 pop rbx pop r12 pop r13 pop r14 pop r15 pop rbp ret nop word ptr cs : [ rax + rax ] nop dword ptr [ rax + rax ]
Code2: mov rax , rdi test rsi , rsi je 0x35 mov cl , byte ptr [ rax ] test cl , cl jne 0x35 nop lea rdi , [ rax + 0x1 ] cmp rsi , 0x1 lea rsi , [ rsi - 0x1 ] je 0x29 movzx ecx , byte ptr [ rax + 0x1 ] mov rax , rdi test cl , cl je 0x10 test rsi , rsi je 0x3d xor edx , edx jmp 0xfffffffffff681a0 mov rdi , rax test rsi , rsi jne 0x2e push rbx call 0xfffffffffff67ca0 mov rbx , rax mov rdi , rax xor esi , esi call 0xfffffffffff68130 mov rax , rbx pop rbx ret nop word ptr cs : [ rax + rax ] nop
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly codes are fundamentally different in structure and purpose. Code1 implements a complex state machine using specific magic constants (e.g., 0x8203d72d, 0x5f558fe5) with extensive register manipulation and conditional jumps between multiple states. It preserves 6 registers and includes 20+ instructions with deep stack usage. Code2 is a simpler string/buffer handler with linear null-byte checking logic, minimal register usage (only rbx preserved), and straightforward length management. The control flow patterns, register usage, instruction sequences, and operational logic show no significant overlap, indicating entirely unrelated functionalities.
------------------------------------------------------------

------------------------------------------------------------
Code1: push rax mov eax , dword ptr [ rip ] test eax , eax je 0x36 mov dword ptr [ rip ] , 0x1 test rdx , rdx je 0x23a test rdi , rdi je 0x23e test rsi , rsi je 0x252 pop rax jmp 0x36 mov al , byte ptr [ rip ] xor al , 0x99 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xf8 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xe3 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x1f mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xb1 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xd7 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xc3 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x53 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xd mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x7c mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x61 mov byte ptr [ rip ] , al movaps xmm0 , xmmword ptr [ rip ] xorps xmm0 , xmmword ptr [ rip ] movaps xmmword ptr [ rip ] , xmm0 mov al , byte ptr [ rip ] xor al , 0x3e mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x27 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xd3 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xe2 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x10 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x7c mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x5c mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x3f mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x93 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x77 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xf7 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x60 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x41 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xce mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xc3 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x16 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x9f mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x43 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x69 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x31 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xcc mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x7f mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xdb mov byte ptr [ rip ] , al mov dword ptr [ rip ] , 0x1 test rdx , rdx jne 0x1e xor eax , eax pop rcx ret mov edi , 0x0 mov esi , 0x0 mov edx , 0x27 call 0x252 mov edi , 0x0 mov esi , 0x0 mov edx , 0x28 call 0x266 nop word ptr cs : [ rax + rax ]
Code2: test rdx , rdx je 0x20 sub rsp , 0x8 test rdi , rdi je 0x3b test rsi , rsi je 0x23 add rsp , 0x8 jmp 0x1c nop dword ptr [ rax ] xor eax , eax ret lea rsi , [ rip ] lea rdi , [ rip ] mov edx , 0x28 call 0x3b lea rsi , [ rip ] lea rdi , [ rip ] mov edx , 0x27 call 0x53 nop dword ptr [ rax ] nop word ptr cs : [ rax + rax ]
Similarity: -1
Label: 1
Similarity Score: 0.25
Explanation: The codes share some structural elements like conditional jumps (je), register tests, and function calls, but differ significantly in core operations. Code1 has extensive byte-level XOR operations on memory (30+ instructions) and XMM register manipulation, which are absent in Code2. Code2 uses LEA for address loading and has simpler call sequences. The control flow similarities are superficial, while the core functionality (encryption/decryption vs. parameter setup) differs substantially.
------------------------------------------------------------

------------------------------------------------------------
Code1: cmp dword ptr [ rdi + 0x158 ] , 0x0 je 0xa ret push rbp push rbx sub rsp , 0x18 mov eax , esi mov rbx , rdi mov dword ptr [ rdi + 0x15c ] , esi mov byte ptr [ rsp + 0x15 ] , 0x0 mov byte ptr [ rsp + 0x16 ] , ah mov byte ptr [ rsp + 0x17 ] , al mov dword ptr [ rdi + 0x158 ] , 0x0 lea rsi , [ rsp + 0x15 ] mov ebp , 0x3 mov edx , 0x3 call 0x910 test eax , eax js 0x8b sub ebp , eax mov dword ptr [ rbx + 0x158 ] , ebp jne 0x84 mov rax , qword ptr [ rbx + 0x98 ] test rax , rax je 0x84 mov esi , dword ptr [ rbx ] mov rcx , qword ptr [ rbx + 0xa0 ] mov qword ptr [ rsp ] , rcx lea rcx , [ rsp + 0x15 ] mov r8d , 0x3 mov edi , 0x1 xor edx , edx mov r9 , rbx call rax add rsp , 0x18 pop rbx pop rbp ret mov dword ptr [ rbx + 0x158 ] , 0x3 add rsp , 0x18 pop rbx pop rbp ret nop dword ptr [ rax ]
Code2: str lr , [ sp , - 0x4 ] ! sub sp , sp , 0xc str r0 , [ sp , 0x4 ] str r1 , [ sp ] ldr r3 , [ sp , 0x4 ] ldr r3 , [ r3 , 0xd4 ] cmp r3 , 0x0 bne 0x40 ldr r3 , [ sp , 0x4 ] mov r2 , 0x3 str r2 , [ r3 , 0xd4 ] ldr r3 , [ sp , 0x4 ] ldr r2 , [ sp ] str r2 , [ r3 , 0xd8 ] ldr r0 , [ sp , 0x4 ] bl 0x4c mov r0 , r0 add sp , sp , 0xc pop { pc }
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly code snippets are for different architectures (x86_64 and ARM) and have no instruction-level similarity. Although both check a value at an offset and conditionally set it, the overall structure and operations are fundamentally different due to architectural differences. Therefore, they are not similar.
------------------------------------------------------------

------------------------------------------------------------
Code1: push rbp mov rbp , rsp sub rsp , 0x130 mov qword ptr [ rbp - 0x8 ] , rdi mov qword ptr [ rbp - 0x18 ] , 0x0 mov rdi , qword ptr [ rbp - 0x8 ] mov qword ptr [ rbp - 0x10 ] , rdi mov rdi , qword ptr [ rip ] jmp rdi mov rax , qword ptr [ rbp - 0x10 ] test rax , rax setne cl movzx edx , cl mov eax , edx mov rax , qword ptr [ rax * 0x8 ] jmp rax mov rdi , qword ptr [ rip ] mov esi , 0x0 xor eax , eax mov cl , al mov al , cl call 0x58 mov rsi , qword ptr [ rbp - 0x8 ] mov rsi , qword ptr [ rsi + 0x58 ] test rsi , rsi setne cl movzx edx , cl mov esi , edx mov rsi , qword ptr [ rsi * 0x8 ] mov qword ptr [ rbp - 0x38 ] , rax jmp rsi mov rdi , qword ptr [ rip ] mov rdx , qword ptr [ rbp - 0x18 ] mov esi , 0x0 xor eax , eax mov cl , al mov al , cl call 0x94 mov rdx , qword ptr [ rip ] mov qword ptr [ rbp - 0x40 ] , rax jmp rdx mov rdi , qword ptr [ rip ] mov rax , qword ptr [ rbp - 0x10 ] mov ecx , dword ptr [ rax ] mov esi , ecx mov ecx , 0x26 mov qword ptr [ rbp - 0x48 ] , rdi mov edi , ecx call 0xc0 mov esi , 0x0 xor ecx , ecx mov dl , cl mov rdi , qword ptr [ rbp - 0x48 ] mov byte ptr [ rbp - 0x49 ] , dl mov rdx , rax mov al , byte ptr [ rbp - 0x49 ] call 0xdb mov rdx , qword ptr [ rbp - 0x10 ] movsd xmm0 , qword ptr [ rdx + 0x50 ] movaps xmm1 , xmmword ptr [ rip ] pand xmm0 , xmm1 movsd xmm1 , qword ptr [ rip ] ucomisd xmm0 , xmm1 setae r8b movzx ecx , r8b mov edx , ecx mov rdx , qword ptr [ rdx * 0x8 ] mov qword ptr [ rbp - 0x58 ] , rax jmp rdx mov rdi , qword ptr [ rip ] mov rax , qword ptr [ rbp - 0x10 ] movsd xmm0 , qword ptr [ rax + 0x50 ] mov esi , 0x0 mov al , 0x1 call 0x12f mov rsi , qword ptr [ rip ] mov qword ptr [ rbp - 0x60 ] , rax jmp rsi mov rdi , qword ptr [ rip ] mov rax , qword ptr [ rbp - 0x10 ] mov rdx , qword ptr [ rax + 0x8 ] mov rcx , qword ptr [ rax + 0x10 ] mov r8 , qword ptr [ rax + 0x18 ] mov r9 , qword ptr [ rax + 0x20 ] mov esi , 0x0 xor r10d , r10d mov r11b , r10b mov al , r11b call 0x16a mov rdi , qword ptr [ rip ] mov qword ptr [ rbp - 0x68 ] , rax mov qword ptr [ rbp - 0x70 ] , rdi call 0x17e mov rcx , qword ptr [ rbp - 0x10 ] movsd xmm0 , qword ptr [ rcx + 0x30 ] mov dword ptr [ rbp - 0x74 ] , eax movsd qword ptr [ rbp - 0x80 ] , xmm0 call 0x194 mov rcx , qword ptr [ rbp - 0x10 ] movsd xmm1 , qword ptr [ rcx + 0x38 ] mov esi , 0x0 mov r11b , 0x2 mov rdi , qword ptr [ rbp - 0x70 ] mov edx , dword ptr [ rbp - 0x74 ] movsd xmm0 , qword ptr [ rbp - 0x80 ] mov ecx , eax mov al , r11b mov byte ptr [ rbp - 0x81 ] , r11b call 0x1c2 mov rdi , qword ptr [ rip ] mov qword ptr [ rbp - 0x90 ] , rax mov qword ptr [ rbp - 0x98 ] , rdi call 0x1dc mov rsi , qword ptr [ rbp - 0x10 ] movsd xmm0 , qword ptr [ rsi + 0x40 ] mov dword ptr [ rbp - 0x9c ] , eax movsd qword ptr [ rbp - 0xa8 ] , xmm0 call 0x1f8 mov rsi , qword ptr [ rbp - 0x10 ] movsd xmm1 , qword ptr [ rsi + 0x48 ] mov esi , 0x0 mov rdi , qword ptr [ rbp - 0x98 ] mov edx , dword ptr [ rbp - 0x9c ] movsd xmm0 , qword ptr [ rbp - 0xa8 ] mov ecx , eax mov al , byte ptr [ rbp - 0x81 ] call 0x228 mov rsi , qword ptr [ rbp - 0x10 ] movsd xmm0 , qword ptr [ rsi + 0x40 ] movsd xmm1 , qword ptr [ rsi + 0x48 ] addsd xmm1 , xmm0 movaps xmm0 , xmmword ptr [ rip ] pand xmm1 , xmm0 movsd xmm0 , qword ptr [ rip ] ucomisd xmm0 , xmm1 seta r11b movzx ecx , r11b mov esi , ecx mov rsi , qword ptr [ rsi * 0x8 ] mov qword ptr [ rbp - 0xb0 ] , rax jmp rsi mov rdi , qword ptr [ rip ] mov esi , 0x0 xor eax , eax mov cl , al mov al , cl call 0x283 mov rsi , qword ptr [ rip ] mov qword ptr [ rbp - 0xb8 ] , rax jmp rsi mov rax , qword ptr [ rbp - 0x10 ] movsd xmm0 , qword ptr [ rax + 0x40 ] movsd xmm1 , qword ptr [ rax + 0x48 ] addsd xmm1 , xmm0 movsd xmm0 , qword ptr [ rip ] addsd xmm1 , xmm0 movaps xmm0 , xmmword ptr [ rip ] pand xmm1 , xmm0 movsd xmm0 , qword ptr [ rip ] ucomisd xmm0 , xmm1 seta cl movzx edx , cl mov eax , edx mov rax , qword ptr [ rax * 0x8 ] jmp rax mov rdi , qword ptr [ rip ] mov esi , 0x0 xor eax , eax mov cl , al mov al , cl call 0x2f1 mov rsi , qword ptr [ rip ] mov qword ptr [ rbp - 0xc0 ] , rax jmp rsi mov rdi , qword ptr [ rip ] mov qword ptr [ rbp - 0xc8 ] , rdi call 0x314 mov rdi , qword ptr [ rbp - 0x10 ] movsd xmm0 , qword ptr [ rdi + 0x40 ] movsd xmm1 , qword ptr [ rdi + 0x48 ] addsd xmm1 , xmm0 mov esi , 0x0 mov cl , 0x1 mov rdi , qword ptr [ rbp - 0xc8 ] mov edx , eax movaps xmm0 , xmm1 mov al , cl call 0x340 mov rsi , qword ptr [ rip ] mov qword ptr [ rbp - 0xd0 ] , rax jmp rsi mov rax , qword ptr [ rip ] jmp rax mov qword ptr [ rbp - 0x30 ] , 0x0 mov qword ptr [ rbp - 0x20 ] , 0x0 mov rax , qword ptr [ rip ] jmp rax mov rax , qword ptr [ rbp - 0x30 ] mov rcx , qword ptr [ rbp - 0x10 ] mov rcx , qword ptr [ rcx + 0x10 ] sub rax , rcx setb dl movzx esi , dl mov ecx , esi mov rcx , qword ptr [ rcx * 0x8 ] mov qword ptr [ rbp - 0xd8 ] , rax jmp rcx mov rdi , qword ptr [ rip ] mov rdx , qword ptr [ rbp - 0x30 ] mov esi , 0x0 xor eax , eax mov cl , al mov al , cl call 0x3b5 mov qword ptr [ rbp - 0x28 ] , 0x0 mov rdx , qword ptr [ rip ] mov qword ptr [ rbp - 0xe0 ] , rax jmp rdx mov rax , qword ptr [ rbp - 0x28 ] mov rcx , qword ptr [ rbp - 0x10 ] mov rcx , qword ptr [ rcx + 0x8 ] sub rax , rcx setb dl movzx esi , dl mov ecx , esi mov rcx , qword ptr [ rcx * 0x8 ] mov qword ptr [ rbp - 0xe8 ] , rax jmp rcx mov rax , qword ptr [ rip ] jmp rax mov rax , qword ptr [ rbp - 0x10 ] mov rax , qword ptr [ rax + 0x28 ] mov rcx , qword ptr [ rbp - 0x20 ] movsd xmm0 , qword ptr [ rax + rcx * 0x8 ] cvtsd2ss xmm0 , xmm0 call 0x418 test eax , eax setne dl movzx eax , dl mov ecx , eax mov rcx , qword ptr [ rcx * 0x8 ] jmp rcx mov rax , qword ptr [ rip ] jmp rax mov rax , qword ptr [ rbp - 0x10 ] mov rax , qword ptr [ rax + 0x28 ] mov rcx , qword ptr [ rbp - 0x20 ] movsd xmm0 , qword ptr [ rax + rcx * 0x8 ] call 0x44b test eax , eax setne dl movzx eax , dl mov ecx , eax mov rcx , qword ptr [ rcx * 0x8 ] jmp rcx mov rax , qword ptr [ rbp - 0x10 ] mov rax , qword ptr [ rax + 0x28 ] mov rcx , qword ptr [ rbp - 0x20 ] fld qword ptr [ rax + rcx * 0x8 ] mov rax , rsp fstp xword ptr [ rax ] call 0x478 test eax , eax setne dl movzx eax , dl mov ecx , eax mov rcx , qword ptr [ rcx * 0x8 ] jmp rcx mov rdi , qword ptr [ rip ] mov qword ptr [ rbp - 0xf0 ] , rdi call 0x49f add eax , 0x3 mov esi , 0x0 mov ecx , 0x0 xor edx , edx mov r8b , dl mov rdi , qword ptr [ rbp - 0xf0 ] mov edx , eax mov al , r8b call 0x4c2 mov rcx , qword ptr [ rip ] mov qword ptr [ rbp - 0xf8 ] , rax jmp rcx mov rdi , qword ptr [ rip ] mov qword ptr [ rbp - 0x100 ] , rdi call 0x4e5 add eax , 0x3 mov dword ptr [ rbp - 0x104 ] , eax call 0x4f3 mov rdi , qword ptr [ rbp - 0x10 ] mov rdi , qword ptr [ rdi + 0x28 ] mov rcx , qword ptr [ rbp - 0x20 ] movsd xmm0 , qword ptr [ rdi + rcx * 0x8 ] mov esi , 0x0 mov dl , 0x1 mov rdi , qword ptr [ rbp - 0x100 ] mov r8d , dword ptr [ rbp - 0x104 ] mov byte ptr [ rbp - 0x105 ] , dl mov edx , r8d mov ecx , eax mov al , byte ptr [ rbp - 0x105 ] call 0x52f mov rsi , qword ptr [ rip ] mov qword ptr [ rbp - 0x110 ] , rax jmp rsi mov rax , qword ptr [ rip ] jmp rax mov rax , qword ptr [ rbp - 0x28 ] add rax , 0x1 mov qword ptr [ rbp - 0x28 ] , rax mov rax , qword ptr [ rbp - 0x20 ] add rax , 0x1 mov qword ptr [ rbp - 0x20 ] , rax mov rax , qword ptr [ rip ] jmp rax mov rdi , qword ptr [ rip ] mov esi , 0x0 xor eax , eax mov cl , al mov al , cl call 0x580 mov rsi , qword ptr [ rip ] mov qword ptr [ rbp - 0x118 ] , rax jmp rsi mov rax , qword ptr [ rbp - 0x30 ] add rax , 0x1 mov qword ptr [ rbp - 0x30 ] , rax mov rax , qword ptr [ rip ] jmp rax mov rax , qword ptr [ rip ] jmp rax mov rax , qword ptr [ rbp - 0x18 ] add rax , 0x1 mov qword ptr [ rbp - 0x18 ] , rax mov rax , qword ptr [ rbp - 0x10 ] mov rax , qword ptr [ rax + 0x58 ] mov qword ptr [ rbp - 0x10 ] , rax mov rax , qword ptr [ rip ] jmp rax add rsp , 0x130 pop rbp ret nop dword ptr [ rax + rax ]
Code2: push rbp mov rbp , rsp sub rsp , 0x110 mov qword ptr [ rbp - 0x8 ] , rdi mov qword ptr [ rbp - 0x18 ] , 0x0 mov rdi , qword ptr [ rbp - 0x8 ] mov qword ptr [ rbp - 0x10 ] , rdi cmp qword ptr [ rbp - 0x10 ] , 0x0 je 0x51a mov rdi , qword ptr [ 0x0 ] movabs rsi , 0x0 mov al , 0x0 call 0x43 mov rsi , qword ptr [ rbp - 0x8 ] cmp qword ptr [ rsi + 0x58 ] , 0x0 mov qword ptr [ rbp - 0x38 ] , rax je 0x77 mov rdi , qword ptr [ 0x0 ] mov rdx , qword ptr [ rbp - 0x18 ] movabs rsi , 0x0 mov al , 0x0 call 0x73 mov qword ptr [ rbp - 0x40 ] , rax mov rdi , qword ptr [ 0x0 ] mov rax , qword ptr [ rbp - 0x10 ] mov ecx , dword ptr [ rax ] mov esi , ecx mov ecx , 0x26 mov qword ptr [ rbp - 0x48 ] , rdi mov edi , ecx call 0x97 mov rdi , qword ptr [ rbp - 0x48 ] movabs rsi , 0x0 mov rdx , rax mov al , 0x0 call 0xaf movsd xmm0 , qword ptr [ rip ] mov rdx , qword ptr [ rbp - 0x10 ] movsd xmm1 , qword ptr [ rdx + 0x50 ] movaps xmm2 , xmmword ptr [ rip ] pand xmm1 , xmm2 ucomisd xmm1 , xmm0 mov qword ptr [ rbp - 0x50 ] , rax jb 0xff mov rdi , qword ptr [ 0x0 ] mov rax , qword ptr [ rbp - 0x10 ] movsd xmm0 , qword ptr [ rax + 0x50 ] movabs rsi , 0x0 mov al , 0x1 call 0xfb mov qword ptr [ rbp - 0x58 ] , rax mov rdi , qword ptr [ 0x0 ] mov rax , qword ptr [ rbp - 0x10 ] mov rdx , qword ptr [ rax + 0x8 ] mov rax , qword ptr [ rbp - 0x10 ] mov rcx , qword ptr [ rax + 0x10 ] mov rax , qword ptr [ rbp - 0x10 ] mov r8 , qword ptr [ rax + 0x18 ] mov rax , qword ptr [ rbp - 0x10 ] mov r9 , qword ptr [ rax + 0x20 ] movabs rsi , 0x0 mov al , 0x0 call 0x138 mov rdi , qword ptr [ 0x0 ] mov qword ptr [ rbp - 0x60 ] , rax mov qword ptr [ rbp - 0x68 ] , rdi call 0x14d mov rcx , qword ptr [ rbp - 0x10 ] movsd xmm0 , qword ptr [ rcx + 0x30 ] mov dword ptr [ rbp - 0x6c ] , eax movsd qword ptr [ rbp - 0x78 ] , xmm0 call 0x163 mov rcx , qword ptr [ rbp - 0x10 ] movsd xmm1 , qword ptr [ rcx + 0x38 ] mov rdi , qword ptr [ rbp - 0x68 ] movabs rsi , 0x0 mov edx , dword ptr [ rbp - 0x6c ] movsd xmm0 , qword ptr [ rbp - 0x78 ] mov ecx , eax mov al , 0x2 call 0x18b mov rdi , qword ptr [ 0x0 ] mov qword ptr [ rbp - 0x80 ] , rax mov qword ptr [ rbp - 0x88 ] , rdi call 0x1a3 mov rsi , qword ptr [ rbp - 0x10 ] movsd xmm0 , qword ptr [ rsi + 0x40 ] mov dword ptr [ rbp - 0x8c ] , eax movsd qword ptr [ rbp - 0x98 ] , xmm0 call 0x1bf mov rsi , qword ptr [ rbp - 0x10 ] movsd xmm1 , qword ptr [ rsi + 0x48 ] mov rdi , qword ptr [ rbp - 0x88 ] movabs rsi , 0x0 mov edx , dword ptr [ rbp - 0x8c ] movsd xmm0 , qword ptr [ rbp - 0x98 ] mov ecx , eax mov al , 0x2 call 0x1f0 movsd xmm0 , qword ptr [ rip ] mov rsi , qword ptr [ rbp - 0x10 ] movsd xmm1 , qword ptr [ rsi + 0x48 ] mov rsi , qword ptr [ rbp - 0x10 ] addsd xmm1 , qword ptr [ rsi + 0x40 ] movaps xmm2 , xmmword ptr [ rip ] pand xmm1 , xmm2 ucomisd xmm0 , xmm1 mov qword ptr [ rbp - 0xa0 ] , rax jbe 0x24b mov rdi , qword ptr [ 0x0 ] movabs rsi , 0x0 mov al , 0x0 call 0x23f mov qword ptr [ rbp - 0xa8 ] , rax jmp 0x2f7 movsd xmm0 , qword ptr [ rip ] movsd xmm1 , qword ptr [ rip ] mov rax , qword ptr [ rbp - 0x10 ] movsd xmm2 , qword ptr [ rax + 0x48 ] mov rax , qword ptr [ rbp - 0x10 ] addsd xmm2 , qword ptr [ rax + 0x40 ] subsd xmm2 , xmm1 movaps xmm1 , xmmword ptr [ rip ] pand xmm2 , xmm1 ucomisd xmm0 , xmm2 jbe 0x2ab mov rdi , qword ptr [ 0x0 ] movabs rsi , 0x0 mov al , 0x0 call 0x29f mov qword ptr [ rbp - 0xb0 ] , rax jmp 0x2f2 mov rdi , qword ptr [ 0x0 ] mov qword ptr [ rbp - 0xb8 ] , rdi call 0x2bf mov rdi , qword ptr [ rbp - 0x10 ] movsd xmm0 , qword ptr [ rdi + 0x48 ] mov rdi , qword ptr [ rbp - 0x10 ] addsd xmm0 , qword ptr [ rdi + 0x40 ] mov rdi , qword ptr [ rbp - 0xb8 ] movabs rsi , 0x0 mov edx , eax mov al , 0x1 call 0x2eb mov qword ptr [ rbp - 0xc0 ] , rax jmp 0x2f7 mov qword ptr [ rbp - 0x30 ] , 0x0 mov qword ptr [ rbp - 0x20 ] , 0x0 mov rax , qword ptr [ rbp - 0x30 ] mov rcx , qword ptr [ rbp - 0x10 ] cmp rax , qword ptr [ rcx + 0x10 ] jae 0x4e8 mov rdi , qword ptr [ 0x0 ] mov rdx , qword ptr [ rbp - 0x30 ] movabs rsi , 0x0 mov al , 0x0 call 0x336 mov qword ptr [ rbp - 0x28 ] , 0x0 mov qword ptr [ rbp - 0xc8 ] , rax mov rax , qword ptr [ rbp - 0x28 ] mov rcx , qword ptr [ rbp - 0x10 ] cmp rax , qword ptr [ rcx + 0x8 ] jae 0x4b0 xor eax , eax mov cl , al test cl , 0x1 jne 0x369 jmp 0x391 mov rax , qword ptr [ rbp - 0x10 ] mov rax , qword ptr [ rax + 0x28 ] mov rcx , qword ptr [ rbp - 0x20 ] movsd xmm0 , qword ptr [ rax + rcx * 0x8 ] cvtsd2ss xmm0 , xmm0 call 0x383 cmp eax , 0x0 jne 0x3e6 jmp 0x42d mov al , 0x1 test al , 0x1 jne 0x3a0 jmp 0x3c4 mov rax , qword ptr [ rbp - 0x10 ] mov rax , qword ptr [ rax + 0x28 ] mov rcx , qword ptr [ rbp - 0x20 ] movsd xmm0 , qword ptr [ rax + rcx * 0x8 ] call 0x3b6 cmp eax , 0x0 jne 0x3e6 jmp 0x42d mov rax , qword ptr [ rbp - 0x10 ] mov rax , qword ptr [ rax + 0x28 ] mov rcx , qword ptr [ rbp - 0x20 ] fld qword ptr [ rax + rcx * 0x8 ] mov rax , rsp fstp xword ptr [ rax ] call 0x3dd cmp eax , 0x0 je 0x42d mov rdi , qword ptr [ 0x0 ] mov qword ptr [ rbp - 0xd0 ] , rdi call 0x3fa add eax , 0x3 mov rdi , qword ptr [ rbp - 0xd0 ] movabs rsi , 0x0 mov edx , eax movabs rcx , 0x0 mov al , 0x0 call 0x421 mov qword ptr [ rbp - 0xd8 ] , rax jmp 0x487 mov rdi , qword ptr [ 0x0 ] mov qword ptr [ rbp - 0xe0 ] , rdi call 0x441 add eax , 0x3 mov dword ptr [ rbp - 0xe4 ] , eax call 0x44f mov rdi , qword ptr [ rbp - 0x10 ] mov rdi , qword ptr [ rdi + 0x28 ] mov rcx , qword ptr [ rbp - 0x20 ] movsd xmm0 , qword ptr [ rdi + rcx * 0x8 ] mov rdi , qword ptr [ rbp - 0xe0 ] movabs rsi , 0x0 mov edx , dword ptr [ rbp - 0xe4 ] mov ecx , eax mov al , 0x1 call 0x480 mov qword ptr [ rbp - 0xf0 ] , rax jmp 0x48c xor eax , eax mov ecx , eax mov rdx , qword ptr [ rbp - 0x28 ] add rdx , 0x1 mov qword ptr [ rbp - 0x28 ] , rdx mov rdx , qword ptr [ rbp - 0x20 ] sub rcx , 0x1 sub rdx , rcx mov qword ptr [ rbp - 0x20 ] , rdx jmp 0x345 mov rdi , qword ptr [ 0x0 ] movabs rsi , 0x0 mov al , 0x0 call 0x4c9 mov qword ptr [ rbp - 0xf8 ] , rax xor eax , eax mov ecx , eax mov rdx , qword ptr [ rbp - 0x30 ] sub rcx , 0x1 sub rdx , rcx mov qword ptr [ rbp - 0x30 ] , rdx jmp 0x307 jmp 0x4ed mov rax , qword ptr [ rbp - 0x18 ] movabs rcx , 0xdb597835bab4f17f sub rax , rcx add rax , 0x1 add rax , rcx mov qword ptr [ rbp - 0x18 ] , rax mov rax , qword ptr [ rbp - 0x10 ] mov rax , qword ptr [ rax + 0x58 ] mov qword ptr [ rbp - 0x10 ] , rax jmp 0x1f add rsp , 0x110 pop rbp ret nop word ptr cs : [ rax + rax ] nop dword ptr [ rax ]
Similarity: -1
Label: 1
Similarity Score: 0.35
Explanation: Both codes share structural similarities like stack frame setup (push rbp/mov rbp,rsp), local variable initialization, and floating-point operations using xmm registers. However, significant differences exist: Code1 uses extensive indirect jumps (jmp rdi/jmp rsi) and function pointer calls, while Code2 relies on conditional direct jumps (je/jb) and absolute calls. Code1's control flow is more fragmented with dynamic dispatch, whereas Code2 has structured loops with counter comparisons. The memory access patterns differ, particularly in handling arrays and function arguments. These implementation divergences outweigh the structural parallels, indicating distinct functionality despite superficial resemblances.
------------------------------------------------------------

------------------------------------------------------------
Code1: lui gp , 0x6c lui a2 , 0x6b addiu gp , gp , 0x2ee0 lw t9 , - 0x5cb8 ( gp ) jr t9 addiu a2 , a2 , - 0x689c
Code2: push { r4 , lr } ldr r2 , [ pc , 0x4 ] bl 0xfffda090 pop { r4 , pc } andseq pc , sl , r4 , asr 0x6
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two code snippets are fundamentally dissimilar due to differences in architecture (MIPS vs ARM), instruction sets, and control flow patterns. The first code uses MIPS-specific operations like lui, addiu, lw, and jr with delay slots, while the second uses ARM-specific features like push/pop, bl, and conditional execution. There are no overlapping instructions or equivalent structural patterns, indicating completely unrelated functionality and implementation approaches.
------------------------------------------------------------

------------------------------------------------------------
Code1: push { r3 , r4 , r5 , r6 , r7 , r8 , sb , sl , fp , lr } ldrb ip , [ r0 , 0x1 ] ldrb lr , [ r1 , 0x1 ] sub r4 , ip , 0x2f sub lr , lr , 0x2f clz r4 , r4 clz lr , lr lsr r4 , r4 , 0x5 lsr lr , lr , 0x5 cmp lr , r4 beq 0x38 mov r4 , 0x0 mov r0 , r4 pop { r3 , r4 , r5 , r6 , r7 , r8 , sb , sl , fp , pc } mov r5 , r2 ldrb r2 , [ r0 ] mov r6 , r3 clz r4 , r2 ldrb r3 , [ r1 ] lsr r4 , r4 , 0x5 cmp r3 , 0x0 beq 0x2c cmp r2 , r3 orrne r4 , r4 , 0x1 cmp r4 , 0x0 bne 0x2c mov sb , r1 mov lr , r4 add r8 , r0 , 0x1 b 0x7c ldrb ip , [ r8 , 0x1 ] ! clz r2 , ip cmp r3 , 0x2f ldrb r3 , [ sb , 0x1 ] ! sub r7 , r8 , r0 moveq lr , r7 cmp r3 , 0x0 lsr r2 , r2 , 0x5 beq 0x1b0 cmp r3 , ip moveq ip , r2 orrne ip , r2 , 0x1 cmp ip , 0x0 beq 0x78 cmp r3 , 0x2f movne r3 , 0x0 andeq r3 , r2 , 0x1 cmp r3 , 0x0 movne lr , r7 cmp lr , 0x0 beq 0x30 ldrb r3 , [ r1 , lr ] add r8 , r0 , lr cmp r3 , 0x2f add r7 , r1 , lr ldrb r2 , [ r8 ] ldrbeq r3 , [ r7 , 0x1 ] addeq r7 , r7 , 0x1 cmp r2 , 0x2f addeq r8 , r8 , 0x1 cmp r3 , 0x0 bne 0x14c ldrb r2 , [ r8 ] ldr r3 , [ pc , 0x1fc ] cmp r2 , 0x0 moveq r8 , r3 cmp r5 , 0x0 beq 0x200 mov r0 , r8 bl 0xfffff414 cmp r0 , r6 blo 0x1e8 mov r2 , 0x5 ldr r1 , [ pc , 0x1d8 ] mov r0 , 0x0 bl 0xfffff2f4 ldr r2 , [ pc , 0x1d0 ] mov r3 , r0 mov r1 , 0x24 mov r0 , 0x0 bl 0xfffff3a8 mov r0 , r4 pop { r3 , r4 , r5 , r6 , r7 , r8 , sb , sl , fp , pc } cmp r5 , 0x0 beq 0x2c0 cmp r6 , 0x2 movls sb , 0x1 bhi 0x218 ldr fp , [ pc , 0x1a4 ] ldr sl , [ pc , 0x1a4 ] b 0x178 ldrb r3 , [ r7 , 0x1 ] ! cmp r3 , 0x0 beq 0x1c8 cmp r3 , 0x2f bne 0x16c cmp r5 , 0x0 beq 0x2a8 cmp r6 , 0x3 movls sb , 0x1 bls 0x16c mov r0 , r5 mov r2 , 0x4 mov r1 , sl sub r6 , r6 , 0x3 bl 0xfffff2b8 add r5 , r5 , 0x3 b 0x16c cmp ip , 0x2f movne ip , r2 orreq ip , r2 , 0x1 cmp ip , 0x0 movne lr , r7 b 0xc4 ldrb r3 , [ r8 ] cmp r3 , 0x0 bne 0x250 cmp sb , 0x0 bne 0x120 mov r4 , 0x1 mov r0 , r4 pop { r3 , r4 , r5 , r6 , r7 , r8 , sb , sl , fp , pc } add r2 , r0 , 0x1 mov r1 , r8 mov r0 , r5 bl 0xfffff2b8 mov r4 , 0x1 b 0x30 ldr r3 , [ pc , 0x104 ] mov r0 , r8 ldr r1 , [ r3 ] bl 0xfffff258 mov r4 , 0x1 b 0x30 mov r0 , r5 mov r2 , 0x3 ldr r1 , [ pc , 0xec ] bl 0xfffff2b8 sub r6 , r6 , 0x2 add r5 , r5 , 0x2 ldrb r3 , [ r7 ] cmp r3 , 0x0 movne sb , 0x0 bne 0x160 ldrb r2 , [ r8 ] cmp r2 , 0x0 beq 0x1dc mov sb , r3 cmp r5 , 0x0 beq 0x288 cmp r6 , 0x1 movls sb , 0x1 bhi 0x2dc mov r0 , r8 bl 0xfffff414 cmp r0 , r6 bhs 0x120 add r2 , r0 , 0x1 mov r1 , r8 mov r0 , r5 bl 0xfffff2b8 b 0x1d4 ldr sl , [ pc , 0x7c ] mov r0 , 0x2f ldr r1 , [ sl ] bl 0xfffff2e8 ldr r1 , [ sl ] mov r0 , r8 bl 0xfffff258 b 0x1d4 ldr r3 , [ fp ] mov r2 , 0x3 mov r1 , 0x1 mov r0 , sl bl 0xfffff2d0 b 0x16c ldr sl , [ pc , 0x44 ] mov r2 , 0x2 ldr r3 , [ sl ] mov r1 , 0x1 ldr r0 , [ pc , 0x3c ] bl 0xfffff2d0 b 0x230 mov r0 , r5 mov r2 , 0x2 ldr r1 , [ pc , 0x2c ] bl 0xfffff2b8 adds r5 , r5 , 0x1 sub r6 , r6 , 0x1 ldreq sl , [ pc , 0x10 ] bne 0x264 b 0x298 andeq sp , r1 , ip , lsl 0x17 muleq r1 , ip , r8 ldrdeq sp , lr , [ r1 ] , -r0 andeq lr , r2 , r4 , lsl 0x3 muleq r1 , r4 , r8 muleq r1 , r0 , r8 muleq r1 , r8 , r8
Code2: push ebp mov ebp , esp push ebx push edi push esi sub esp , 0xac mov eax , dword ptr [ ebp + 0x14 ] mov ecx , dword ptr [ ebp + 0x10 ] mov edx , dword ptr [ ebp + 0xc ] mov esi , dword ptr [ ebp + 0x8 ] mov byte ptr [ ebp - 0x12 ] , 0x0 mov edi , dword ptr [ ebp + 0xc ] mov ebx , dword ptr [ ebp + 0x8 ] mov dword ptr [ esp ] , edi mov dword ptr [ esp + 0x4 ] , ebx mov dword ptr [ ebp - 0x2c ] , eax mov dword ptr [ ebp - 0x30 ] , ecx mov dword ptr [ ebp - 0x34 ] , edx mov dword ptr [ ebp - 0x38 ] , esi call 0x5d0 mov dword ptr [ ebp - 0x18 ] , eax mov eax , dword ptr [ ebp - 0x18 ] mov dword ptr [ ebp - 0x10 ] , eax mov dword ptr [ ebp - 0x24 ] , 0xcbea8ff3 mov eax , dword ptr [ ebp - 0x24 ] mov ecx , eax sub ecx , 0x89c5b340 mov dword ptr [ ebp - 0x3c ] , eax mov dword ptr [ ebp - 0x40 ] , ecx je 0x4a6 jmp 0x66 mov eax , dword ptr [ ebp - 0x3c ] sub eax , 0x94942e04 mov dword ptr [ ebp - 0x44 ] , eax je 0x3f5 jmp 0x7c mov eax , dword ptr [ ebp - 0x3c ] sub eax , 0x95540193 mov dword ptr [ ebp - 0x48 ] , eax je 0x3b3 jmp 0x92 mov eax , dword ptr [ ebp - 0x3c ] sub eax , 0xa42fee50 mov dword ptr [ ebp - 0x4c ] , eax je 0x416 jmp 0xa8 mov eax , dword ptr [ ebp - 0x3c ] sub eax , 0xac46a619 mov dword ptr [ ebp - 0x50 ] , eax je 0x308 jmp 0xbe mov eax , dword ptr [ ebp - 0x3c ] sub eax , 0xbb914110 mov dword ptr [ ebp - 0x54 ] , eax je 0x4f7 jmp 0xd4 mov eax , dword ptr [ ebp - 0x3c ] sub eax , 0xc5a6ecca mov dword ptr [ ebp - 0x58 ] , eax je 0x31d jmp 0xea mov eax , dword ptr [ ebp - 0x3c ] sub eax , 0xcbea8ff3 mov dword ptr [ ebp - 0x5c ] , eax je 0x27a jmp 0x100 mov eax , dword ptr [ ebp - 0x3c ] sub eax , 0xd97473ce mov dword ptr [ ebp - 0x60 ] , eax je 0x401 jmp 0x116 mov eax , dword ptr [ ebp - 0x3c ] sub eax , 0xdb377b39 mov dword ptr [ ebp - 0x64 ] , eax je 0x594 jmp 0x12c mov eax , dword ptr [ ebp - 0x3c ] sub eax , 0xe7e4c540 mov dword ptr [ ebp - 0x68 ] , eax je 0x2d5 jmp 0x142 mov eax , dword ptr [ ebp - 0x3c ] sub eax , 0xed07d756 mov dword ptr [ ebp - 0x6c ] , eax je 0x37a jmp 0x158 mov eax , dword ptr [ ebp - 0x3c ] sub eax , 0xff0b6daf mov dword ptr [ ebp - 0x70 ] , eax je 0x550 jmp 0x16e mov eax , dword ptr [ ebp - 0x3c ] sub eax , 0xff1a9044 mov dword ptr [ ebp - 0x74 ] , eax je 0x2ea jmp 0x184 mov eax , dword ptr [ ebp - 0x3c ] sub eax , 0x102babf mov dword ptr [ ebp - 0x78 ] , eax je 0x395 jmp 0x19a mov eax , dword ptr [ ebp - 0x3c ] sub eax , 0x1647cdfe mov dword ptr [ ebp - 0x7c ] , eax je 0x5aa jmp 0x1b0 mov eax , dword ptr [ ebp - 0x3c ] sub eax , 0x177d9c9d mov dword ptr [ ebp - 0x80 ] , eax je 0x4d0 jmp 0x1c6 mov eax , dword ptr [ ebp - 0x3c ] sub eax , 0x26d0dde1 mov dword ptr [ ebp - 0x84 ] , eax je 0x536 jmp 0x1df mov eax , dword ptr [ ebp - 0x3c ] sub eax , 0x2b8db4fa mov dword ptr [ ebp - 0x88 ] , eax je 0x338 jmp 0x1f8 mov eax , dword ptr [ ebp - 0x3c ] sub eax , 0x323417dd mov dword ptr [ ebp - 0x8c ] , eax je 0x2a5 jmp 0x211 mov eax , dword ptr [ ebp - 0x3c ] sub eax , 0x4c034498 mov dword ptr [ ebp - 0x90 ] , eax je 0x295 jmp 0x22a mov eax , dword ptr [ ebp - 0x3c ] sub eax , 0x578ee10f mov dword ptr [ ebp - 0x94 ] , eax je 0x431 jmp 0x243 mov eax , dword ptr [ ebp - 0x3c ] sub eax , 0x62b15e48 mov dword ptr [ ebp - 0x98 ] , eax je 0x4b2 jmp 0x25c mov eax , dword ptr [ ebp - 0x3c ] sub eax , 0x64a8dde8 mov dword ptr [ ebp - 0x9c ] , eax je 0x4e2 jmp 0x275 jmp 0x5bd mov eax , dword ptr [ ebp - 0x10 ] cmp eax , 0x0 mov eax , 0x323417dd mov ecx , 0x4c034498 cmovne ecx , eax mov dword ptr [ ebp - 0x24 ] , ecx jmp 0x5bd mov byte ptr [ ebp - 0x11 ] , 0x0 mov dword ptr [ ebp - 0x24 ] , 0x1647cdfe jmp 0x5bd mov eax , dword ptr [ ebp + 0xc ] add eax , dword ptr [ ebp - 0x18 ] mov dword ptr [ ebp - 0x1c ] , eax mov eax , dword ptr [ ebp + 0x8 ] add eax , dword ptr [ ebp - 0x18 ] mov dword ptr [ ebp - 0x20 ] , eax mov eax , dword ptr [ ebp - 0x1c ] movsx eax , byte ptr [ eax ] cmp eax , 0x2f mov eax , 0xe7e4c540 mov ecx , 0xff1a9044 cmove ecx , eax mov dword ptr [ ebp - 0x24 ] , ecx jmp 0x5bd mov eax , dword ptr [ ebp - 0x1c ] add eax , 0x1 mov dword ptr [ ebp - 0x1c ] , eax mov dword ptr [ ebp - 0x24 ] , 0xff1a9044 jmp 0x5bd mov eax , dword ptr [ ebp - 0x20 ] movsx eax , byte ptr [ eax ] cmp eax , 0x2f mov eax , 0xac46a619 mov ecx , 0xc5a6ecca cmove ecx , eax mov dword ptr [ ebp - 0x24 ] , ecx jmp 0x5bd mov eax , dword ptr [ ebp - 0x20 ] add eax , 0x1 mov dword ptr [ ebp - 0x20 ] , eax mov dword ptr [ ebp - 0x24 ] , 0xc5a6ecca jmp 0x5bd mov eax , dword ptr [ ebp - 0x1c ] cmp byte ptr [ eax ] , 0x0 mov eax , 0x2b8db4fa mov ecx , 0x62b15e48 cmovne ecx , eax mov dword ptr [ ebp - 0x24 ] , ecx jmp 0x5bd lea eax , [ 0x8058b09 ] mov dword ptr [ esp ] , eax lea eax , [ ebp + 0x10 ] mov dword ptr [ esp + 0x4 ] , eax lea eax , [ ebp + 0x14 ] mov dword ptr [ esp + 0x8 ] , eax call 0x9e0 and al , 0x1 movzx ecx , al mov al , byte ptr [ ebp - 0x12 ] and al , 0x1 movzx edx , al or edx , ecx cmp edx , 0x0 setne al and al , 0x1 mov byte ptr [ ebp - 0x12 ] , al mov dword ptr [ ebp - 0x24 ] , 0xed07d756 jmp 0x5bd mov eax , dword ptr [ ebp - 0x1c ] cmp byte ptr [ eax ] , 0x0 mov eax , 0x102babf mov ecx , 0xa42fee50 cmovne ecx , eax mov dword ptr [ ebp - 0x24 ] , ecx jmp 0x5bd mov eax , dword ptr [ ebp - 0x1c ] movsx eax , byte ptr [ eax ] cmp eax , 0x2f mov eax , 0x95540193 mov ecx , 0x94942e04 cmove ecx , eax mov dword ptr [ ebp - 0x24 ] , ecx jmp 0x5bd lea eax , [ 0x8058b08 ] mov dword ptr [ esp ] , eax lea eax , [ ebp + 0x10 ] mov dword ptr [ esp + 0x4 ] , eax lea eax , [ ebp + 0x14 ] mov dword ptr [ esp + 0x8 ] , eax call 0x9e0 and al , 0x1 movzx ecx , al mov al , byte ptr [ ebp - 0x12 ] and al , 0x1 movzx edx , al or edx , ecx cmp edx , 0x0 setne al and al , 0x1 mov byte ptr [ ebp - 0x12 ] , al mov dword ptr [ ebp - 0x24 ] , 0x94942e04 jmp 0x5bd mov dword ptr [ ebp - 0x24 ] , 0xd97473ce jmp 0x5bd mov eax , dword ptr [ ebp - 0x1c ] add eax , 0x1 mov dword ptr [ ebp - 0x1c ] , eax mov dword ptr [ ebp - 0x24 ] , 0xed07d756 jmp 0x5bd mov eax , dword ptr [ ebp - 0x20 ] cmp byte ptr [ eax ] , 0x0 mov eax , 0x578ee10f mov ecx , 0x89c5b340 cmovne ecx , eax mov dword ptr [ ebp - 0x24 ] , ecx jmp 0x5bd lea eax , [ 0x8058c1e ] mov dword ptr [ esp ] , eax lea eax , [ ebp + 0x10 ] mov dword ptr [ esp + 0x4 ] , eax lea eax , [ ebp + 0x14 ] mov dword ptr [ esp + 0x8 ] , eax call 0x9e0 and al , 0x1 movzx ecx , al mov al , byte ptr [ ebp - 0x12 ] and al , 0x1 movzx edx , al or edx , ecx cmp edx , 0x0 setne al and al , 0x1 mov byte ptr [ ebp - 0x12 ] , al mov ecx , dword ptr [ ebp - 0x20 ] mov dword ptr [ esp ] , ecx lea ecx , [ ebp + 0x10 ] mov dword ptr [ esp + 0x4 ] , ecx lea ecx , [ ebp + 0x14 ] mov dword ptr [ esp + 0x8 ] , ecx call 0x9e0 and al , 0x1 movzx ecx , al mov al , byte ptr [ ebp - 0x12 ] and al , 0x1 movzx edx , al or edx , ecx cmp edx , 0x0 setne al and al , 0x1 mov byte ptr [ ebp - 0x12 ] , al mov dword ptr [ ebp - 0x24 ] , 0x89c5b340 jmp 0x5bd mov dword ptr [ ebp - 0x24 ] , 0x26d0dde1 jmp 0x5bd mov eax , dword ptr [ ebp - 0x20 ] movsx eax , byte ptr [ eax ] cmp eax , 0x0 mov eax , 0x177d9c9d mov ecx , 0x64a8dde8 cmovne ecx , eax mov dword ptr [ ebp - 0x24 ] , ecx jmp 0x5bd mov eax , dword ptr [ ebp - 0x20 ] mov dword ptr [ ebp - 0x24 ] , 0xbb914110 mov dword ptr [ ebp - 0x28 ] , eax jmp 0x5bd mov dword ptr [ ebp - 0x24 ] , 0xbb914110 lea eax , [ 0x8058b0a ] mov dword ptr [ ebp - 0x28 ] , eax jmp 0x5bd mov eax , dword ptr [ ebp - 0x28 ] mov dword ptr [ esp ] , eax lea eax , [ ebp + 0x10 ] mov dword ptr [ esp + 0x4 ] , eax lea eax , [ ebp + 0x14 ] mov dword ptr [ esp + 0x8 ] , eax call 0x9e0 and al , 0x1 movzx ecx , al mov al , byte ptr [ ebp - 0x12 ] and al , 0x1 movzx edx , al or edx , ecx cmp edx , 0x0 setne al and al , 0x1 mov byte ptr [ ebp - 0x12 ] , al mov dword ptr [ ebp - 0x24 ] , 0x26d0dde1 jmp 0x5bd mov al , byte ptr [ ebp - 0x12 ] test al , 0x1 mov ecx , 0xff0b6daf mov edx , 0xdb377b39 cmovne edx , ecx mov dword ptr [ ebp - 0x24 ] , edx jmp 0x5bd lea eax , [ 0x8058b0c ] mov dword ptr [ esp ] , eax call 0xffffe9f0 xor ecx , ecx mov dword ptr [ esp ] , 0x0 mov dword ptr [ esp + 0x4 ] , 0x24 lea edx , [ 0x8058b3a ] mov dword ptr [ esp + 0x8 ] , edx mov dword ptr [ esp + 0xc ] , eax mov dword ptr [ ebp - 0xa0 ] , ecx call 0xffffe9a0 mov dword ptr [ ebp - 0x24 ] , 0xdb377b39 jmp 0x5bd mov al , byte ptr [ ebp - 0x12 ] xor al , 0xff and al , 0x1 mov byte ptr [ ebp - 0x11 ] , al mov dword ptr [ ebp - 0x24 ] , 0x1647cdfe jmp 0x5bd mov al , byte ptr [ ebp - 0x11 ] and al , 0x1 movzx eax , al add esp , 0xac pop esi pop edi pop ebx pop ebp ret jmp 0x4a nop word ptr cs : [ eax + eax ] nop dword ptr [ eax ]
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly codes are fundamentally dissimilar due to multiple factors:
1. Architecture difference: Code1 uses ARM instruction set (with registers like r0-r8, lr, pc) while Code2 uses x86 (with registers like eax, ebp, esp). The instruction syntax, register sets, and calling conventions are completely different.
2. Structural differences: Code1 has a linear control flow with conditional branches (beq/bne) and direct memory operations, while Code2 implements a large switch-like structure using constant comparisons and je jumps, with multiple function calls.
3. Purpose mismatch: Code1 appears to perform byte-level string comparisons and path processing (with 0x2f '/' checks), while Code2 shows stack-based state machine behavior with magic number comparisons and external function calls.
4. No overlapping logic: There are no equivalent algorithmic patterns, register usage sequences, or control flow similarities between the codes. The operations and memory access patterns are entirely distinct.
------------------------------------------------------------

------------------------------------------------------------
Code1: push rbp push r14 push rbx mov r14 , rdi mov rdi , rsi call 0x8e270 test rax , rax je 0x32 mov rbx , rax mov rdi , rax mov esi , 0x3a call 0xfffffffffffcbd60 test rax , rax je 0x3c mov byte ptr [ rax ] , 0x0 add rax , 0x1 jmp 0x3e mov eax , 0xffffffff pop rbx pop r14 pop rbp ret xor eax , eax mov rdi , r14 mov rsi , rbx mov rdx , rax call 0xa75c0 mov ebp , eax mov rdi , rbx call 0x4aa40 mov eax , ebp pop rbx pop r14 pop rbp ret nop dword ptr [ rax ]
Code2: push ebx sub esp , 0x18 call 0xfffc3322 add ebx , 0x2a2df5 mov dword ptr [ esp + 0x4 ] , 0x0 sub esp , 0xc push dword ptr [ esp + 0x30 ] call 0xb6740 add esp , 0x10 mov dword ptr [ esp + 0x8 ] , eax cmp dword ptr [ esp + 0x8 ] , 0x0 jne 0x38 mov eax , 0xffffffff jmp 0x8e sub esp , 0x8 push 0x3a push dword ptr [ esp + 0x14 ] call 0xfffc2ef2 add esp , 0x10 mov dword ptr [ esp + 0x4 ] , eax cmp dword ptr [ esp + 0x4 ] , 0x0 je 0x60 mov eax , dword ptr [ esp + 0x4 ] mov byte ptr [ eax ] , 0x0 add dword ptr [ esp + 0x4 ] , 0x1 sub esp , 0x4 push dword ptr [ esp + 0x8 ] push dword ptr [ esp + 0x10 ] push dword ptr [ esp + 0x2c ] call 0xd30bc add esp , 0x10 mov dword ptr [ esp + 0xc ] , eax sub esp , 0xc push dword ptr [ esp + 0x14 ] call 0x6266a add esp , 0x10 mov eax , dword ptr [ esp + 0xc ] add esp , 0x18 pop ebx ret
Similarity: -1
Label: 1
Similarity Score: 0.2
Explanation: The codes are for different architectures (64-bit and 32-bit) and have significant differences in instructions and function calls. However, both involve a colon character (0x3a) and null-termination, indicating a possible similar high-level purpose, but the implementations are too different to be considered similar.
------------------------------------------------------------

------------------------------------------------------------
Code1: push rbp mov rbp , rsp sub rsp , 0x30 mov qword ptr [ rbp - 0x8 ] , rdi mov rax , rsp add rax , - 0x10 mov rsp , rax mov rcx , rsp add rcx , - 0x10 mov rsp , rcx mov rdx , rsp add rdx , - 0x10 mov rsp , rdx mov rsi , qword ptr [ rbp - 0x8 ] mov qword ptr [ rcx ] , rsi cmp qword ptr [ rcx ] , 0x0 sete dil mov qword ptr [ rbp - 0x10 ] , rax mov qword ptr [ rbp - 0x18 ] , rcx mov qword ptr [ rbp - 0x20 ] , rdx mov byte ptr [ rbp - 0x21 ] , dil mov al , byte ptr [ rbp - 0x21 ] test al , 0x1 jne 0x59 jmp 0x68 mov rax , qword ptr [ rbp - 0x10 ] mov dword ptr [ rax ] , 0xffffffff jmp 0x125 mov rax , qword ptr [ rbp - 0x18 ] mov rcx , qword ptr [ rax ] mov rdx , qword ptr [ rbp - 0x20 ] mov qword ptr [ rdx ] , rcx mov rcx , qword ptr [ rdx ] cmp dword ptr [ rcx + 0x18 ] , 0x1c4f jne 0xb8 mov rax , qword ptr [ rbp - 0x20 ] mov rcx , qword ptr [ rax ] cmp dword ptr [ rcx + 0x6c ] , 0x0 setne dl mov byte ptr [ rbp - 0x22 ] , dl mov al , byte ptr [ rbp - 0x22 ] test al , 0x1 jne 0xa7 jmp 0xc7 mov rax , qword ptr [ rbp - 0x20 ] mov rcx , qword ptr [ rax ] cmp dword ptr [ rcx + 0x6c ] , - 0x5 je 0xc7 mov rax , qword ptr [ rbp - 0x10 ] mov dword ptr [ rax ] , 0xffffffff jmp 0x125 xor edx , edx mov rax , qword ptr [ rbp - 0x20 ] mov rcx , qword ptr [ rax ] mov edi , dword ptr [ rcx + 0x1c ] mov rcx , qword ptr [ rax ] mov rsi , qword ptr [ rcx + 0x48 ] call 0xffffffffffe93860 cmp rax , - 0x1 sete r8b mov byte ptr [ rbp - 0x23 ] , r8b mov al , byte ptr [ rbp - 0x23 ] test al , 0x1 jne 0xfb jmp 0x10a mov rax , qword ptr [ rbp - 0x10 ] mov dword ptr [ rax ] , 0xffffffff jmp 0x125 mov rax , qword ptr [ rbp - 0x20 ] mov rdi , qword ptr [ rax ] call 0x1c0 mov rax , qword ptr [ rbp - 0x10 ] mov dword ptr [ rax ] , 0x0 jmp 0x125 mov rax , qword ptr [ rbp - 0x10 ] mov ecx , dword ptr [ rax ] mov dword ptr [ rbp - 0x28 ] , ecx mov eax , dword ptr [ rbp - 0x28 ] mov rsp , rbp pop rbp ret mov rax , rsp add rax , - 0x10 mov rsp , rax mov rax , rsp add rax , - 0x10 mov rsp , rax mov rcx , qword ptr [ rbp - 0x8 ] mov qword ptr [ rax ] , rcx jmp 0xc jmp 0x86 mov rax , qword ptr [ rbp - 0x10 ] mov dword ptr [ rax ] , 0xffffffff jmp 0xb8 xor edx , edx mov rax , qword ptr [ rbp - 0x20 ] mov rcx , qword ptr [ rax ] mov edi , dword ptr [ rcx + 0x1c ] mov rcx , qword ptr [ rax ] mov rsi , qword ptr [ rcx + 0x48 ] call 0xffffffffffe93860 mov qword ptr [ rbp - 0x30 ] , rax jmp 0xc7 mov rax , qword ptr [ rbp - 0x10 ] mov dword ptr [ rax ] , 0xffffffff jmp 0xfb mov rax , qword ptr [ rbp - 0x20 ] mov rdi , qword ptr [ rax ] call 0x1c0 mov rax , qword ptr [ rbp - 0x10 ] mov dword ptr [ rax ] , 0x0 jmp 0x10a jmp 0x125 nop word ptr [ rax + rax ]
Code2: push { r4 , r5 , r6 , lr } subs r4 , r0 , 0x0 beq 0xb0 ldr r3 , [ pc , 0xa4 ] ldr r6 , [ r4 , 0xc ] cmp r6 , r3 bne 0xb0 ldr r3 , [ r4 , 0x4c ] adds r5 , r3 , 0x5 movne r5 , 0x1 cmp r3 , 0x0 moveq r5 , 0x0 cmp r5 , 0x0 bne 0xb0 mov r2 , r5 ldr r1 , [ r4 , 0x30 ] ldr r0 , [ r4 , 0x10 ] bl 0xfff81648 cmn r0 , 0x1 beq 0xb0 ldr r3 , [ r4 , 0xc ] ldr r0 , [ r4 , 0x50 ] cmp r3 , r6 mov r3 , 0x0 streq r5 , [ r4 , 0x34 ] streq r5 , [ r4 , 0x38 ] streq r5 , [ r4 , 0x2c ] cmp r0 , r3 str r5 , [ r4 ] str r3 , [ r4 , 0x48 ] beq 0x90 ldr r3 , [ r4 , 0x4c ] cmn r3 , 0x4 bne 0xa8 mov r3 , 0x0 str r3 , [ r4 , 0x50 ] mov r3 , 0x0 mov r0 , r3 str r3 , [ r4 , 0x4c ] str r3 , [ r4 , 0x8 ] str r3 , [ r4 , 0x58 ] pop { r4 , r5 , r6 , pc } bl 0xfff81618 b 0x88 mvn r0 , 0x0 pop { r4 , r5 , r6 , pc } andeq r1 , r0 , pc , asr 0x24
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly code snippets are fundamentally dissimilar due to multiple factors:
1. Architecture difference: Code1 uses x86_64 instructions (rbp/rsp registers, jmp/jne) while Code2 uses ARM instructions (ldr/str, bne/beq).
2. Structural patterns: Code1 employs a traditional x86 stack frame (push rbp/mov rbp,rsp/sub rsp) with complex stack manipulation, while Code2 uses ARM's load/store architecture with multi-register push/pop.
3. Control flow: Code1 uses conditional jumps (test al/jne) and absolute calls, while Code2 uses conditional branches (cmp/bne) and PC-relative calls (bl).
4. Register usage: Code1 heavily uses rax/rcx/rdx for operations, while Code2 relies on r4-r6 with different operand patterns.
5. Constant values and memory offsets show no meaningful overlap in structure or purpose. The functional behaviors appear unrelated based on instruction patterns and control flow.
------------------------------------------------------------

------------------------------------------------------------
Code1: push ebp push edi push esi push ebx call 0xffff4520 add ebx , 0x3d4ae7 sub esp , 0x28 push 0xc4 call 0xfffec6c0 mov dword ptr [ esp ] , eax mov ebp , eax call 0xfffed630 add esp , 0x10 mov esi , dword ptr [ esp + 0x30 ] test esi , esi je 0x77 mov eax , dword ptr [ esp + 0x30 ] mov ecx , 0x31 mov edi , ebp mov edx , dword ptr [ ebp + 0xb8 ] mov esi , dword ptr [ esp + 0x30 ] rep movsd dword ptr es : [ edi ] , dword ptr [ esi ] mov ecx , dword ptr [ eax + 0x10 ] test ecx , ecx jne 0x88 sub esp , 0xc mov dword ptr [ ebp + 0xb8 ] , edx push edx call 0xfffeb8d0 mov dword ptr [ ebp + 0xbc ] , 0x1 pop eax push dword ptr [ ebp + 0xb8 ] call 0xfffec620 add esp , 0x10 add esp , 0x1c mov eax , ebp pop ebx pop esi pop edi pop ebp ret lea esi , [ esi ] mov dword ptr [ esp + 0xc ] , edx sub esp , 0x4 xor edi , edi mov eax , dword ptr [ esp + 0x34 ] mov esi , dword ptr [ eax ] push edi push esi push 0x5 call 0xfffeb470 add esp , 0x10 mov edx , dword ptr [ esp + 0xc ] jmp 0x4f lea esi , [ esi ]
Code2: lui gp , 0x3b addiu gp , gp , 0x10d8 addu gp , gp , t9 addiu sp , sp , - 0x28 lw t9 , - 0x7564 ( gp ) sw s1 , 0x1c ( sp ) move s1 , a0 addiu a0 , zero , 0x108 sw gp , 0x10 ( sp ) sw ra , 0x24 ( sp ) sw s0 , 0x18 ( sp ) jalr t9 sw s2 , 0x20 ( sp ) lw gp , 0x10 ( sp ) move a0 , v0 lw t9 , - 0x7970 ( gp ) jalr t9 move s0 , v0 beqz s1 , 0x118 lw gp , 0x10 ( sp ) lw s2 , 0xf8 ( s0 ) addiu t0 , s1 , 0x100 move v1 , s1 move v0 , s0 lwl a3 , ( v1 ) lwl a2 , 0x4 ( v1 ) lwl a1 , 0x8 ( v1 ) lwl a0 , 0xc ( v1 ) lwr a3 , 0x3 ( v1 ) lwr a2 , 0x7 ( v1 ) lwr a1 , 0xb ( v1 ) lwr a0 , 0xf ( v1 ) addiu v1 , v1 , 0x10 swl a3 , ( v0 ) swr a3 , 0x3 ( v0 ) swl a2 , 0x4 ( v0 ) swr a2 , 0x7 ( v0 ) swl a1 , 0x8 ( v0 ) swr a1 , 0xb ( v0 ) swl a0 , 0xc ( v0 ) swr a0 , 0xf ( v0 ) bne v1 , t0 , 0x60 addiu v0 , v0 , 0x10 lwl a1 , ( v1 ) lwl a0 , 0x4 ( v1 ) lwr a1 , 0x3 ( v1 ) lwr a0 , 0x7 ( v1 ) swl a1 , ( v0 ) swr a1 , 0x3 ( v0 ) swl a0 , 0x4 ( v0 ) swr a0 , 0x7 ( v0 ) lw v0 , 0x10 ( s1 ) beqz v0 , 0xf4 lw t9 , - 0x71d0 ( gp ) lw t9 , - 0x70a0 ( gp ) move a2 , zero lw a3 , ( s1 ) jalr t9 addiu a0 , zero , 0x5 lw gp , 0x10 ( sp ) lw t9 , - 0x71d0 ( gp ) move a0 , s2 jalr t9 sw s2 , 0xf8 ( s0 ) addiu v0 , zero , 0x1 lw gp , 0x10 ( sp ) lw a0 , 0xf8 ( s0 ) lw t9 , - 0x7538 ( gp ) jalr t9 sw v0 , 0xfc ( s0 ) lw ra , 0x24 ( sp ) move v0 , s0 lw s2 , 0x20 ( sp ) lw s1 , 0x1c ( sp ) lw s0 , 0x18 ( sp ) jr ra addiu sp , sp , 0x28
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The code snippets are from entirely different architectures (x86 vs MIPS) with no overlapping
------------------------------------------------------------

------------------------------------------------------------
Code1: lui gp , 0x43 addiu sp , sp , - 0x80 addiu gp , gp , - 0x5f60 sw s3 , 0x64 ( sp ) lw s3 , - 0x7db0 ( gp ) lw t9 , - 0x7df0 ( gp ) sw s0 , 0x58 ( sp ) move s0 , a0 sw gp , 0x10 ( sp ) sw ra , 0x7c ( sp ) sw fp , 0x78 ( sp ) sw s7 , 0x74 ( sp ) sw s6 , 0x70 ( sp ) sw s5 , 0x6c ( sp ) sw s4 , 0x68 ( sp ) sw s2 , 0x60 ( sp ) sw s1 , 0x5c ( sp ) lw v0 , ( s3 ) sw v0 , 0x54 ( sp ) jalr t9 nop sltiu v0 , v0 , 0x2 beqz v0 , 0xb4 lw gp , 0x10 ( sp ) lw t9 , - 0x7e34 ( gp ) jalr t9 move a0 , s0 lw gp , 0x10 ( sp ) move s1 , v0 lw a0 , 0x54 ( sp ) move v0 , s1 lw v1 , ( s3 ) bne a0 , v1 , 0x280 lw ra , 0x7c ( sp ) lw fp , 0x78 ( sp ) lw s7 , 0x74 ( sp ) lw s6 , 0x70 ( sp ) lw s5 , 0x6c ( sp ) lw s4 , 0x68 ( sp ) lw s3 , 0x64 ( sp ) lw s2 , 0x60 ( sp ) lw s1 , 0x5c ( sp ) lw s0 , 0x58 ( sp ) jr ra addiu sp , sp , 0x80 addiu s7 , sp , 0x20 lw s4 , - 0x7fc8 ( gp ) sw zero , 0x20 ( sp ) move s1 , zero sw s0 , 0x2c ( sp ) addiu fp , sp , 0x38 sw zero , 0x4 ( s7 ) addiu s5 , zero , - 0x1 sb zero , 0x1c ( sp ) addiu s6 , zero , - 0x2 sb zero , 0x28 ( sp ) b 0x144 addiu s2 , zero , 0x1 lbu a0 , ( s0 ) srl v1 , a0 , 0x5 sll v1 , v1 , 0x2 addu v1 , s4 , v1 lw v0 , ( v1 ) srlv v0 , v0 , a0 andi v0 , v0 , 0x1 beqz v0 , 0x1d0 lw t9 , - 0x7db4 ( gp ) addiu v0 , zero , 0x1 sw v0 , 0x30 ( sp ) lb s0 , ( s0 ) sb v0 , 0x34 ( sp ) sb v0 , 0x28 ( sp ) sw s0 , 0x38 ( sp ) beqz s0 , 0x74 nop lw s0 , 0x2c ( sp ) lw v0 , 0x30 ( sp ) addiu s1 , s1 , 0x1 sb zero , 0x28 ( sp ) addu s0 , s0 , v0 sw s0 , 0x2c ( sp ) lbu v0 , 0x1c ( sp ) beqz v0 , 0xe8 nop lw t9 , - 0x7df0 ( gp ) jalr t9 nop move a0 , s0 lw gp , 0x10 ( sp ) lw t9 , - 0x7fc4 ( gp ) bal - 0x3270 move a1 , v0 move a3 , s7 lw gp , 0x10 ( sp ) move a2 , v0 move a1 , s0 lw t9 , - 0x7fc0 ( gp ) bal - 0x9f0 move a0 , fp lw gp , 0x10 ( sp ) beq v0 , s5 , 0x1e8 sw v0 , 0x30 ( sp ) beq v0 , s6 , 0x1fc lw s0 , 0x2c ( sp ) beqz v0 , 0x220 addiu v0 , zero , 0x1 lw s0 , 0x38 ( sp ) lw t9 , - 0x7db4 ( gp ) move a0 , s7 jalr t9 sb s2 , 0x34 ( sp ) beqz v0 , 0x218 lw gp , 0x10 ( sp ) sb zero , 0x1c ( sp ) b 0x124 sb s2 , 0x28 ( sp ) jalr t9 move a0 , s7 beqz v0 , 0x25c lw gp , 0x10 ( sp ) b 0x150 sb s2 , 0x1c ( sp ) addiu v0 , zero , 0x1 lw s0 , 0x2c ( sp ) sb zero , 0x34 ( sp ) b 0x130 sw v0 , 0x30 ( sp ) lw t9 , - 0x7e34 ( gp ) jalr t9 move a0 , s0 lw gp , 0x10 ( sp ) sw v0 , 0x30 ( sp ) b 0x130 sb zero , 0x34 ( sp ) b 0x124 sb s2 , 0x28 ( sp ) sw v0 , 0x30 ( sp ) lb v0 , ( s0 ) bnez v0 , 0x28c lw s0 , 0x38 ( sp ) beqz s0 , 0x1b0 lw t9 , - 0x7db4 ( gp ) lui a3 , 0x41 lw t9 , - 0x7ee0 ( gp ) lui a1 , 0x41 lui a0 , 0x41 addiu a3 , a3 , 0x14b0 addiu a2 , zero , 0xb3 addiu a1 , a1 , 0x388 jalr t9 addiu a0 , a0 , 0x394 lui a3 , 0x41 lw t9 , - 0x7ee0 ( gp ) lui a1 , 0x41 lui a0 , 0x41 addiu a3 , a3 , 0x14b0 addiu a2 , zero , 0x96 addiu a1 , a1 , 0x388 jalr t9 addiu a0 , a0 , 0x3a8 lw t9 , - 0x7dc8 ( gp ) jalr t9 nop lui a3 , 0x41 lw t9 , - 0x7ee0 ( gp ) lui a1 , 0x41 lui a0 , 0x41 addiu a3 , a3 , 0x14b0 addiu a2 , zero , 0xb2 addiu a1 , a1 , 0x388 jalr t9 addiu a0 , a0 , 0x3c0
Code2: push ebp mov ebp , esp sub esp , 0x58 mov eax , dword ptr [ ebp + 0x8 ] mov dword ptr [ ebp - 0x44 ] , eax call 0xffff2dc0 sub eax , 0x1 seta cl movzx edx , cl mov edx , dword ptr [ edx * 0x4 + 0x805e0b4 ] mov dword ptr [ ebp - 0x48 ] , eax jmp edx mov dword ptr [ ebp - 0x8 ] , 0x0 mov eax , dword ptr [ ebp + 0x8 ] mov dword ptr [ ebp - 0x30 ] , eax mov byte ptr [ ebp - 0x40 ] , 0x0 mov dword ptr [ ebp - 0x38 ] , 0x0 mov dword ptr [ ebp - 0x3c ] , 0x0 mov byte ptr [ ebp - 0x34 ] , 0x0 mov eax , dword ptr [ 0x805e094 ] jmp eax mov eax , esp lea ecx , [ ebp - 0x40 ] mov dword ptr [ eax ] , ecx call 0xffffaa80 movzx eax , byte ptr [ ebp - 0x28 ] and eax , 0x1 mov eax , dword ptr [ eax * 0x4 + 0x805e0bc ] xor ecx , ecx mov dl , cl mov byte ptr [ ebp - 0x49 ] , dl jmp eax mov eax , dword ptr [ ebp - 0x24 ] test eax , eax sete cl mov eax , dword ptr [ 0x805e09c ] mov byte ptr [ ebp - 0x49 ] , cl jmp eax mov al , byte ptr [ ebp - 0x49 ] not al movzx ecx , al and ecx , 0x1 mov ecx , dword ptr [ ecx * 0x4 + 0x805e0c4 ] jmp ecx mov eax , dword ptr [ ebp - 0x8 ] inc eax mov dword ptr [ ebp - 0x8 ] , eax mov eax , dword ptr [ 0x805e0a4 ] jmp eax mov eax , dword ptr [ ebp - 0x30 ] mov ecx , dword ptr [ ebp - 0x2c ] add eax , ecx mov dword ptr [ ebp - 0x30 ] , eax mov byte ptr [ ebp - 0x34 ] , 0x0 mov eax , dword ptr [ 0x805e094 ] jmp eax mov eax , dword ptr [ ebp - 0x8 ] mov dword ptr [ ebp - 0x4 ] , eax mov eax , dword ptr [ 0x805e0b0 ] jmp eax mov eax , dword ptr [ ebp + 0x8 ] mov ecx , esp mov dword ptr [ ecx ] , eax call 0xffff2ef0 mov dword ptr [ ebp - 0x4 ] , eax mov eax , dword ptr [ 0x805e0b0 ] jmp eax mov eax , dword ptr [ ebp - 0x4 ] add esp , 0x58 pop ebp ret nop nop nop nop
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The codes are fundamentally dissimilar due to architecture differences (MIPS vs x86) and lack of functional overlap. Key differences:
1. Architecture: MIPS uses GP registers (gp, s0-s7) and delay slots (nop after jalr), while x86 uses Intel syntax (ebp, esp, eax) with no delay slots
2. Stack management: MIPS uses explicit addiu for stack adjustment (-0x80), while x86 uses push/sub
3. Control flow: MIPS has complex branch/jump structures (beqz, bal) while x86 uses jmp tables (edx/ecx jumps)
4. Operations: MIPS has lui/addiu/sb/lbu for byte manipulation, while x86 uses movzx/and/test for similar operations
5. No matching instruction sequences or functional patterns observed
------------------------------------------------------------

------------------------------------------------------------
Code1: push { r4 , r6 , r7 , lr } sub sp , sp , 0x8 mov r4 , r2 mov ip , r3 add r7 , r2 , 0x30 ldm r7 , { r6 , r7 } mvn r2 , 0x0 mvn r3 , 0x0 cmp r7 , r3 cmpeq r6 , r2 beq 0x4c add r3 , r4 , 0x30 ldm r3 , { r2 , r3 } cmp r2 , 0x0 sbcs r3 , r3 , 0x0 movge r0 , 0x0 blt 0x90 add sp , sp , 0x8 pop { r4 , r6 , r7 , pc } str ip , [ sp ] mov r3 , r4 mov r2 , r1 mov r1 , r0 mov r0 , 0x3 bl 0xffffede0 cmp r0 , 0x0 beq 0x2c mvn r2 , 0x1 mvn r3 , 0x0 str r2 , [ r4 , 0x30 ] str r3 , [ r4 , 0x34 ] bl 0xffffef60 ldr r2 , [ r0 ] asr r3 , r2 , 0x1f str r2 , [ r4 , 0x60 ] str r3 , [ r4 , 0x64 ] bl 0xffffef60 ldr r3 , [ r4 , 0x60 ] str r3 , [ r0 ] mvn r0 , 0x0 b 0x44
Code2: push ebp mov ebp , esp push edi push esi sub esp , 0x60 mov eax , dword ptr [ ebp + 0x14 ] mov ecx , dword ptr [ ebp + 0x10 ] mov edx , dword ptr [ ebp + 0xc ] mov esi , dword ptr [ ebp + 0x8 ] mov edi , dword ptr [ ebp + 0x10 ] movsd xmm0 , qword ptr [ edi + 0x2c ] movsd qword ptr [ ebp - 0x10 ] , xmm0 mov dword ptr [ ebp - 0x18 ] , 0x3d2b4d9 mov dword ptr [ ebp - 0x1c ] , eax mov dword ptr [ ebp - 0x20 ] , ecx mov dword ptr [ ebp - 0x24 ] , edx mov dword ptr [ ebp - 0x28 ] , esi mov eax , dword ptr [ ebp - 0x18 ] mov ecx , eax sub ecx , 0xa4f546c3 mov dword ptr [ ebp - 0x2c ] , eax mov dword ptr [ ebp - 0x30 ] , ecx je 0x196 jmp 0x50 mov eax , dword ptr [ ebp - 0x2c ] sub eax , 0xb3eb879a mov dword ptr [ ebp - 0x34 ] , eax je 0x1bc jmp 0x66 mov eax , dword ptr [ ebp - 0x2c ] sub eax , 0xc6db220c mov dword ptr [ ebp - 0x38 ] , eax je 0x183 jmp 0x7c mov eax , dword ptr [ ebp - 0x2c ] sub eax , 0xd685625b mov dword ptr [ ebp - 0x3c ] , eax je 0x134 jmp 0x92 mov eax , dword ptr [ ebp - 0x2c ] sub eax , 0x3d2b4d9 mov dword ptr [ ebp - 0x40 ] , eax je 0xd9 jmp 0xa8 mov eax , dword ptr [ ebp - 0x2c ] sub eax , 0x41f463b mov dword ptr [ ebp - 0x44 ] , eax je 0xfc jmp 0xbe mov eax , dword ptr [ ebp - 0x2c ] sub eax , 0x186af958 mov dword ptr [ ebp - 0x48 ] , eax je 0x166 jmp 0xd4 jmp 0x1c6 mov eax , dword ptr [ ebp - 0x10 ] mov ecx , dword ptr [ ebp - 0xc ] and eax , ecx sub eax , - 0x1 mov ecx , 0x41f463b mov edx , 0x186af958 cmove edx , ecx mov dword ptr [ ebp - 0x18 ] , edx mov dword ptr [ ebp - 0x4c ] , eax jmp 0x1c6 mov eax , dword ptr [ ebp + 0x8 ] mov ecx , dword ptr [ ebp + 0xc ] mov edx , dword ptr [ ebp + 0x10 ] mov esi , dword ptr [ ebp + 0x14 ] mov dword ptr [ esp ] , eax mov dword ptr [ esp + 0x4 ] , ecx mov dword ptr [ esp + 0x8 ] , edx mov dword ptr [ esp + 0xc ] , esi call 0x373d0 cmp eax , 0x0 mov eax , 0xd685625b mov ecx , 0x186af958 cmovne ecx , eax mov dword ptr [ ebp - 0x18 ] , ecx jmp 0x1c6 mov eax , dword ptr [ ebp + 0x10 ] mov dword ptr [ eax + 0x30 ] , 0xffffffff mov dword ptr [ eax + 0x2c ] , 0xfffffffe call 0xffffbbe0 mov eax , dword ptr [ eax ] mov ecx , eax sar ecx , 0x1f mov edx , dword ptr [ ebp + 0x10 ] mov dword ptr [ edx + 0x58 ] , eax mov dword ptr [ edx + 0x5c ] , ecx mov dword ptr [ ebp - 0x18 ] , 0x186af958 jmp 0x1c6 mov eax , dword ptr [ ebp + 0x10 ] mov eax , dword ptr [ eax + 0x30 ] test eax , eax mov eax , 0xc6db220c mov ecx , 0xa4f546c3 cmovns ecx , eax mov dword ptr [ ebp - 0x18 ] , ecx jmp 0x1c6 mov dword ptr [ ebp - 0x14 ] , 0x0 mov dword ptr [ ebp - 0x18 ] , 0xb3eb879a jmp 0x1c6 mov eax , dword ptr [ ebp + 0x10 ] mov eax , dword ptr [ eax + 0x58 ] mov dword ptr [ ebp - 0x50 ] , eax call 0xffffbbe0 mov ecx , dword ptr [ ebp - 0x50 ] mov dword ptr [ eax ] , ecx mov dword ptr [ ebp - 0x14 ] , 0xffffffff mov dword ptr [ ebp - 0x18 ] , 0xb3eb879a jmp 0x1c6 mov eax , dword ptr [ ebp - 0x14 ] add esp , 0x60 pop esi pop edi pop ebp ret jmp 0x34 nop dword ptr [ eax + eax ]
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly codes show fundamental differences in architecture, structure, and functionality. Code1 uses ARM instruction set (r0-r7 registers, ldm/stm instructions) while Code2 uses x86 (ebp/esp, movsd, dword ptr). Code1 has a linear control flow with conditional branches (beq/blt) and memory operations at fixed offsets, while Code2 implements a complex jump table with multiple conditional subtractions and memory operations using variable stack offsets. The register usage patterns, instruction sets, and control flow strategies are entirely dissimilar with no overlapping logic sequences. The architectural mismatch alone results in near-zero similarity.
------------------------------------------------------------

------------------------------------------------------------
Code1: push ebp mov ebp , esp sub esp , 0x28 mov eax , dword ptr [ ebp + 0xc ] mov ecx , dword ptr [ ebp + 0x8 ] mov dword ptr [ ebp - 0xc ] , eax mov dword ptr [ ebp - 0x10 ] , ecx mov eax , dword ptr [ ebp + 0x8 ] mov dword ptr [ esp ] , eax call 0x630 and al , 0x1 mov byte ptr [ ebp - 0x5 ] , al mov ecx , dword ptr [ ebp + 0xc ] mov dword ptr [ esp ] , ecx call 0x630 and al , 0x1 mov byte ptr [ ebp - 0x6 ] , al test byte ptr [ ebp - 0x5 ] , 0x1 je 0x52 test byte ptr [ ebp - 0x6 ] , 0x1 jne 0x52 mov dword ptr [ ebp - 0x4 ] , 0xffffffff jmp 0x96 test byte ptr [ ebp - 0x5 ] , 0x1 jne 0x72 test byte ptr [ ebp - 0x6 ] , 0x1 je 0x72 mov dword ptr [ ebp - 0x4 ] , 0x1 jmp 0x96 jmp 0x77 mov eax , dword ptr [ ebp + 0x8 ] mov ecx , dword ptr [ ebp + 0xc ] mov dword ptr [ esp ] , eax mov dword ptr [ esp + 0x4 ] , ecx lea eax , [ 0x80494e0 ] mov dword ptr [ esp + 0x8 ] , eax call 0x930 mov dword ptr [ ebp - 0x4 ] , eax mov eax , dword ptr [ ebp - 0x4 ] add esp , 0x28 pop ebp ret nop
Code2: ldr r3 , [ r1 , 0x78 ] ldr r2 , [ r0 , 0x78 ] cmp r3 , 0x9 cmpne r3 , 0x3 moveq r3 , 0x1 movne r3 , 0x0 cmp r2 , 0x9 cmpne r2 , 0x3 beq 0x48 ldr r2 , [ r0 , 0x7c ] cmp r3 , 0x0 and r2 , r2 , 0xf000 beq 0x6c cmp r2 , 0x4000 beq 0x84 mov r3 , 0x1 mov r0 , r3 bx lr cmp r3 , 0x0 bne 0x84 ldr r3 , [ r1 , 0x7c ] and r3 , r3 , 0xf000 cmp r3 , 0x4000 beq 0x84 mvn r3 , 0x0 mov r0 , r3 bx lr ldr r3 , [ r1 , 0x7c ] and r3 , r3 , 0xf000 cmp r3 , 0x4000 beq 0x34 cmp r2 , 0x4000 beq 0x60 ldr r2 , [ r1 , 0x68 ] ldr r3 , [ r0 , 0x68 ] cmp r2 , r3 blt 0x60 bgt 0x3c ldr r3 , [ r1 , 0x6c ] ldr r2 , [ r0 , 0x6c ] subs r3 , r3 , r2 bne 0x40 ldr r1 , [ r1 ] ldr r0 , [ r0 ] b 0xffffc168
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly code snippets are not similar for several reasons. First, they target different CPU architectures (x86 vs ARM), resulting in fundamentally different instruction sets and calling conventions. Second, their control flow structures diverge significantly: Code1 uses stack-based operations with multiple call instructions (0x630, 0x930) and conditional jumps (je/jne), while Code2 relies on direct memory comparisons and conditional branching without function calls. Third, their memory access patterns differ, with Code1 using EBP-relative offsets and Code2 using register-relative addressing. Finally, the operational logic shows no equivalent steps—Code1 tests bit flags via helper functions to determine return values, while Code2 performs direct numeric comparisons and bitmask operations. These architectural, structural, and functional disparities indicate no meaningful similarity.
------------------------------------------------------------

------------------------------------------------------------
Code1: xor edx , edx lea rax , [ rip + 0x2ef937 ] cmp rdi , rdx lea rcx , [ rax + 0x80 ] je 0x26 add rax , 0x10 cmp rax , rcx je 0x30 mov rdx , qword ptr [ rax ] cmp rdi , rdx jne 0x15 mov rax , qword ptr [ rax + 0x8 ] ret nop dword ptr [ rax + rax ] lea rax , [ rip + 0x90f75 ] ret nop dword ptr [ rax + rax ]
Code2: mov edx , dword ptr [ esp + 0x4 ] call 0xffed5086 add ecx , 0x187083 test edx , edx je 0x40 cmp edx , 0x1 je 0x50 cmp edx , 0x2 je 0x60 cmp edx , 0x3 je 0x70 cmp edx , 0x4 je 0x80 cmp edx , 0x5 je 0x90 cmp edx , 0x6 je 0xb0 cmp edx , 0x8 lea eax , [ ecx - 0xdd7d0 ] je 0xa0 repz ret nop lea eax , [ ecx - 0x6adc ] mov eax , dword ptr [ eax + 0x4 ] ret lea esi , [ esi ] lea eax , [ ecx - 0x6ad4 ] jmp 0x46 nop lea esi , [ esi ] lea eax , [ ecx - 0x6acc ] jmp 0x46 nop lea esi , [ esi ] lea eax , [ ecx - 0x6ac4 ] jmp 0x46 nop lea esi , [ esi ] lea eax , [ ecx - 0x6abc ] jmp 0x46 nop lea esi , [ esi ] lea eax , [ ecx - 0x6ab4 ] jmp 0x46 nop lea esi , [ esi ] lea eax , [ ecx - 0x6aa4 ] jmp 0x46 nop lea esi , [ esi ] lea eax , [ ecx - 0x6aac ] jmp 0x46 nop lea esi , [ esi ]
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly codes show significant differences in architecture, structure, and purpose. Code1 uses 64-bit registers (rax, rcx, rdi) and RIP-relative addressing, indicating x86-64 architecture, while Code2 relies on 32-bit registers (eax, ecx, esp) and absolute calls, suggesting x86. Structurally, Code1 implements a loop-based search through a data structure (likely an array of pointers), whereas Code2 features a switch-case pattern branching on the value of edx. The instruction sets diverge notably—Code1 focuses on comparisons and memory traversal, while Code2 uses call instructions and repetitive offset calculations. These fundamental disparities in design, register usage, and functionality result in no meaningful similarity.
------------------------------------------------------------

------------------------------------------------------------
Code1: push { r4 , r5 , r6 , r7 , r8 , sb , sl , fp , lr } sub sp , sp , 0x34 ldr r4 , [ sp , 0x60 ] ldr ip , [ pc , 0x534 ] ldr lr , [ pc , 0x534 ] add ip , pc , ip str r4 , [ sp , 0x10 ] ldr lr , [ ip , lr ] mov r5 , r3 ldr r3 , [ sp , 0x64 ] str lr , [ sp , 0x14 ] str r3 , [ sp ] ldr lr , [ lr ] ldr r3 , [ sp , 0x68 ] cmp r4 , 0x0 str lr , [ sp , 0x2c ] str r3 , [ sp , 0x4 ] beq 0x520 ldr r3 , [ sp ] cmp r3 , 0x0 beq 0x4fc ldr r3 , [ sp , 0x4 ] cmp r3 , 0x0 beq 0x4d8 mov r4 , r2 ldr r3 , [ pc , 0x4e4 ] mov r2 , 0x0 bl 0x225180 mov r2 , 0x0 str r0 , [ sp , 0x8 ] str r1 , [ sp , 0xc ] ldr r3 , [ pc , 0x4d0 ] mov r0 , r4 mov r1 , r5 bl 0x224dc8 mov r2 , 0x0 ldr r3 , [ pc , 0x4c0 ] bl 0x225180 mov r2 , 0x0 mov r6 , r0 mov r7 , r1 add r1 , sp , 0x58 ldm r1 , { r0 , r1 } ldr r3 , [ pc , 0x4a8 ] bl 0x225180 ldr r2 , [ pc , 0x4a4 ] ldr r3 , [ pc , 0x4a4 ] bl 0x225180 mov r2 , 0x0 ldr r3 , [ pc , 0x49c ] bl 0x2253ec add r3 , sp , 0x18 add r2 , sp , 0x20 bl 0xfff21d5c add r1 , sp , 0x8 ldm r1 , { r0 , r1 } add sb , sp , 0x18 ldm sb , { r8 , sb } add fp , sp , 0x20 ldm fp , { sl , fp } mov r2 , 0x0 ldr r3 , [ pc , 0x470 ] bl 0x224dcc mov r2 , 0x0 ldr r3 , [ pc , 0x468 ] bl 0x2253ec mov r4 , r0 mov r5 , r1 mov r2 , r6 mov r3 , r7 mov r0 , r8 mov r1 , sb bl 0x225180 mov r2 , 0x0 ldr r3 , [ pc , 0x444 ] bl 0x2253ec mov r2 , r4 mov r3 , r5 bl 0x224dcc mov r2 , r6 mov r8 , r0 mov sb , r1 mov r3 , r7 mov r0 , sl mov r1 , fp bl 0x225180 mov r2 , 0x0 ldr r3 , [ pc , 0x414 ] bl 0x2253ec mov r2 , r0 mov r3 , r1 mov r0 , r4 mov r1 , r5 bl 0x224dc8 mov r2 , r8 mov r3 , sb mov r6 , r0 mov r7 , r1 mov r0 , r8 mov r1 , sb bl 0x225180 mov r2 , r8 mov r3 , sb bl 0x225180 ldr r2 , [ pc , 0x3d4 ] ldr r3 , [ pc , 0x3d4 ] mov sl , r0 mov fp , r1 bl 0x225708 cmp r0 , 0x0 beq 0x4a0 mov r2 , r4 mov r3 , r5 mov r0 , r4 mov r1 , r5 bl 0x225180 mov r2 , r4 mov r3 , r5 bl 0x225180 ldr r2 , [ pc , 0x398 ] ldr r3 , [ pc , 0x398 ] mov r8 , r0 mov sb , r1 bl 0x225708 cmp r0 , 0x0 beq 0x480 mov r2 , r6 mov r3 , r7 mov r0 , r6 mov r1 , r7 bl 0x225180 mov r2 , r6 mov r3 , r7 bl 0x225180 ldr r2 , [ pc , 0x35c ] ldr r3 , [ pc , 0x35c ] mov r4 , r0 mov r5 , r1 bl 0x225708 cmp r0 , 0x0 bne 0x268 mov r2 , 0x0 ldr r3 , [ pc , 0x330 ] mov r0 , r6 mov r1 , r7 bl 0x225180 mov r2 , 0x0 ldr r3 , [ pc , 0x318 ] bl 0x224dc8 ldr r2 , [ pc , 0x328 ] ldr r3 , [ pc , 0x328 ] bl 0x2253ec mov r4 , r0 mov r5 , r1 ldr r2 , [ pc , 0x31c ] ldr r3 , [ pc , 0x31c ] mov r0 , sl mov r1 , fp bl 0x225180 ldr r2 , [ pc , 0x310 ] mov r6 , r0 mov r7 , r1 ldr r3 , [ pc , 0x308 ] mov r0 , r4 mov r1 , r5 bl 0x225180 ldr r2 , [ pc , 0x2fc ] mov sl , r0 mov fp , r1 ldr r3 , [ pc , 0x2f4 ] mov r0 , r6 mov r1 , r7 bl 0x225180 ldr r2 , [ pc , 0x2e8 ] mov r4 , r0 mov r5 , r1 ldr r3 , [ pc , 0x2e0 ] mov r0 , r8 mov r1 , sb bl 0x225180 mov r2 , r0 mov r3 , r1 mov r0 , r4 mov r1 , r5 bl 0x224dcc ldr r2 , [ pc , 0x2c0 ] mov r4 , r0 mov r5 , r1 ldr r3 , [ pc , 0x2b8 ] mov r0 , sl mov r1 , fp bl 0x225180 mov r2 , r0 mov r3 , r1 mov r0 , r4 mov r1 , r5 bl 0x224dcc ldr r2 , [ pc , 0x298 ] str r0 , [ sp , 0x8 ] str r1 , [ sp , 0xc ] ldr r3 , [ pc , 0x290 ] mov r0 , r6 mov r1 , r7 bl 0x225180 ldr r2 , [ pc , 0x284 ] mov r4 , r0 mov r5 , r1 ldr r3 , [ pc , 0x27c ] mov r0 , r8 mov r1 , sb bl 0x225180 mov r2 , r0 mov r3 , r1 mov r0 , r4 mov r1 , r5 bl 0x224dc8 ldr r2 , [ pc , 0x25c ] mov r4 , r0 mov r5 , r1 ldr r3 , [ pc , 0x254 ] mov r0 , sl mov r1 , fp bl 0x225180 mov r2 , r0 mov r3 , r1 mov r0 , r4 mov r1 , r5 bl 0x224dcc ldr r2 , [ pc , 0x234 ] mov r4 , r0 mov r5 , r1 ldr r3 , [ pc , 0x22c ] mov r0 , r6 mov r1 , r7 bl 0x225180 ldr r2 , [ pc , 0x220 ] mov r6 , r0 mov r7 , r1 ldr r3 , [ pc , 0x218 ] mov r0 , r8 mov r1 , sb bl 0x225180 mov r2 , r0 mov r3 , r1 mov r0 , r6 mov r1 , r7 bl 0x224dc8 ldr r2 , [ pc , 0x1f8 ] mov r6 , r0 mov r7 , r1 ldr r3 , [ pc , 0x1f0 ] mov r0 , sl mov r1 , fp bl 0x225180 mov r2 , r0 mov r3 , r1 mov r0 , r6 mov r1 , r7 bl 0x224dc8 mov r2 , 0x0 ldr r3 , [ pc , 0x1cc ] bl 0x225180 bl 0xfff21ea0 ldr ip , [ sp , 0x10 ] mov r2 , 0x0 stm ip , { r0 , r1 } add r1 , sp , 0x8 ldm r1 , { r0 , r1 } ldr r3 , [ pc , 0x1ac ] bl 0x225180 bl 0xfff21ea0 ldr ip , [ sp ] mov r2 , 0x0 stm ip , { r0 , r1 } ldr r3 , [ pc , 0x194 ] mov r0 , r4 mov r1 , r5 bl 0x225180 bl 0xfff21ea0 ldr r3 , [ sp , 0x14 ] ldr r2 , [ sp , 0x2c ] ldr r3 , [ r3 ] ldr ip , [ sp , 0x4 ] cmp r2 , r3 stm ip , { r0 , r1 } bne 0x544 add sp , sp , 0x34 pop { r4 , r5 , r6 , r7 , r8 , sb , sl , fp , pc } ldr r2 , [ pc , 0xfc ] ldr r3 , [ pc , 0xfc ] add r1 , sp , 0x8 ldm r1 , { r0 , r1 } bl 0x2253ec mov r8 , r0 mov sb , r1 b 0x1f8 mov r2 , 0x0 ldr r3 , [ pc , 0xc4 ] mov r0 , r8 mov r1 , sb bl 0x225180 mov r2 , 0x0 ldr r3 , [ pc , 0xac ] bl 0x224dc8 ldr r2 , [ pc , 0xbc ] ldr r3 , [ pc , 0xbc ] bl 0x2253ec mov sl , r0 mov fp , r1 b 0x1bc ldr r3 , [ pc , 0x108 ] ldr r1 , [ pc , 0x108 ] ldr r0 , [ pc , 0x108 ] add r3 , pc , r3 mov r2 , 0x2fc add r3 , r3 , 0xa4 add r1 , pc , r1 add r0 , pc , r0 bl 0xfff22014 ldr r3 , [ pc , 0xf0 ] ldr r1 , [ pc , 0xf0 ] ldr r0 , [ pc , 0xf0 ] add r3 , pc , r3 ldr r2 , [ pc , 0xec ] add r3 , r3 , 0xa4 add r1 , pc , r1 add r0 , pc , r0 bl 0xfff22014 ldr r3 , [ pc , 0xdc ] ldr r1 , [ pc , 0xdc ] ldr r0 , [ pc , 0xdc ] add r3 , pc , r3 ldr r2 , [ pc , 0xd8 ] add r3 , r3 , 0xa4 add r1 , pc , r1 add r0 , pc , r0 bl 0xfff22014 bl 0xfff23070 strhteq r4 , [ ip ] , -r4 andeq r0 , r0 , ip , lsr 0x27 subsmi r0 , sb , r0 svclo 0xe00000 rsbmi lr , pc , r0 rsbsmi r8 , r6 , r0 strbpl r2 , [ r4 ] , - 0xd18 strdmi r2 , r3 , [ sb ] , - fp rsbmi r8 , r6 , r0 eorsmi r0 , r0 , r0 subsmi r0 , sp , r0 rsbsmi r4 , pc , r0 rsbmi r0 , sb , r0 addle r7 , pc , 0xd600 svclo 0x822354 addsle fp , r7 , r6 , lsr 0x8 addmi r3 , ip , lr , asr sl orrlt r2 , sb , 0x232 , 0x28 svclo 0xee6a22 rsbspl r3 , r6 , sb , lsl sl svclo 0xf16b89
Code2: push { r4 , r5 , r6 , r7 , r8 , fp , lr } add fp , sp , 0x18 sub sp , sp , 0x5c str r0 , [ fp , - 0x44 ] str r1 , [ fp , - 0x40 ] str r2 , [ fp , - 0x4c ] str r3 , [ fp , - 0x48 ] ldr r3 , [ fp , 0xc ] str r3 , [ fp , - 0x50 ] ldr r3 , [ fp , 0x10 ] str r3 , [ fp , - 0x54 ] ldr r3 , [ fp , 0x14 ] str r3 , [ fp , - 0x58 ] ldr r4 , [ pc , 0x1a8 ] add r4 , pc , r4 ldr r3 , [ pc , 0x1a4 ] ldr r3 , [ r4 , r3 ] ldr r3 , [ r3 ] str r3 , [ fp , - 0x20 ] ldr r3 , [ fp , - 0x50 ] cmp r3 , 0x0 bne 0x78 ldr r3 , [ pc , 0x18c ] add r3 , pc , r3 ldr r2 , [ pc , 0x188 ] ldr r1 , [ pc , 0x188 ] add r1 , pc , r1 ldr r0 , [ pc , 0x184 ] add r0 , pc , r0 bl 0xffed39c0 ldr r3 , [ fp , - 0x54 ] cmp r3 , 0x0 bne 0xa4 ldr r3 , [ pc , 0x170 ] add r3 , pc , r3 ldr r2 , [ pc , 0x16c ] ldr r1 , [ pc , 0x16c ] add r1 , pc , r1 ldr r0 , [ pc , 0x168 ] add r0 , pc , r0 bl 0xffed39c0 ldr r3 , [ fp , - 0x58 ] cmp r3 , 0x0 bne 0xd0 ldr r3 , [ pc , 0x154 ] add r3 , pc , r3 mov r2 , 0x2fc ldr r1 , [ pc , 0x14c ] add r1 , pc , r1 ldr r0 , [ pc , 0x148 ] add r0 , pc , r0 bl 0xffed39c0 mov r2 , 0x0 ldr r3 , [ pc , 0x13c ] sub r1 , fp , 0x44 ldm r1 , { r0 , r1 } bl 0x2c3e54 mov r2 , r0 mov r3 , r1 mov r5 , r2 mov r6 , r3 mov r2 , 0x0 ldr r3 , [ pc , 0x11c ] sub r1 , fp , 0x4c ldm r1 , { r0 , r1 } bl 0x2c3a9c mov r2 , r0 mov r3 , r1 mov r0 , r2 mov r1 , r3 mov r2 , 0x0 ldr r3 , [ pc , 0xfc ] bl 0x2c3e54 mov r2 , r0 mov r3 , r1 mov r7 , r2 mov r8 , r3 mov r2 , 0x0 ldr r3 , [ pc , 0xe4 ] ldmib fp , { r0 , r1 } bl 0x2c3e54 mov r2 , r0 mov r3 , r1 sub r1 , fp , 0x2c str r1 , [ sp , 0x10 ] sub r1 , fp , 0x34 str r1 , [ sp , 0xc ] sub r1 , fp , 0x3c str r1 , [ sp , 0x8 ] stm sp , { r2 , r3 } mov r2 , r7 mov r3 , r8 mov r0 , r5 mov r1 , r6 bl 0xfffffeec sub r1 , fp , 0x3c ldm r1 , { r0 , r1 } sub r6 , fp , 0x34 ldm r6 , { r5 , r6 } sub r3 , fp , 0x2c ldm r3 , { r2 , r3 } ldr ip , [ fp , - 0x58 ] str ip , [ sp , 0x10 ] ldr ip , [ fp , - 0x54 ] str ip , [ sp , 0xc ] ldr ip , [ fp , - 0x50 ] str ip , [ sp , 0x8 ] stm sp , { r2 , r3 } mov r2 , r5 mov r3 , r6 bl 0xffffcf18 mov r0 , r0 ldr r3 , [ pc , 0x20 ] ldr r3 , [ r4 , r3 ] ldr r2 , [ fp , - 0x20 ] ldr r3 , [ r3 ] cmp r2 , r3 beq 0x1dc bl 0xffed49e0 sub sp , fp , 0x18 pop { r4 , r5 , r6 , r7 , r8 , fp , pc } eorseq sl , r7 , ip , ror 0x22 andeq r0 , r0 , ip , lsl 0x27
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly codes show significant structural and functional differences:
1. Prologue/stack setup: Code1 uses "push {multiple regs} sub sp,sp,0x34" while Code2 uses "push {fewer regs} add fp,sp,0x18 sub sp,sp,0x5c" with frame pointer usage
2. Register usage: Code1 extensively uses sb/sl/fp registers absent in Code2
3. Control flow: Code1 has 24 branch instructions vs Code2's 5, with different condition patterns
4. Function calls: All called addresses differ (e.g., Code1 calls 0x225180/0xfff21d5c vs Code2's 0x2c3e54/0xffed39c0)
5. Memory access: Code1 uses sp-relative addressing exclusively, while Code2 uses fp-based offsets
6. Operational density: Code1 performs 50+ load/store operations vs Code2's 20+, indicating different computational complexity
The fundamental stack management, register usage patterns, and called functions show no meaningful overlap.
------------------------------------------------------------

------------------------------------------------------------
Code1: push r12 push rbp mov r12 , rdi push rbx xor ebp , ebp xor ebx , ebx sub rsp , 0x20 mov rdi , qword ptr [ rdi ] mov rax , qword ptr fs : [ 0x28 ] mov qword ptr [ rsp + 0x18 ] , rax xor eax , eax test rdi , rdi je 0x45 nop word ptr [ rax + rax ] add rbx , 0x1 call 0xfffffffffffe9290 mov rdi , qword ptr [ r12 + rbx * 0x8 ] add rbp , rax test rdi , rdi jne 0x30 lea rdi , [ rip + 0x30bb4 ] call 0xfffffffffffe9070 test rax , rax je 0x80 lea rcx , [ rsp + 0x10 ] lea rsi , [ rsp + 0x8 ] xor r8d , r8d mov edx , 0xa mov rdi , rax call 0x12e40 test eax , eax jne 0xe5 cmp qword ptr [ rsp + 0x10 ] , rbx mov eax , 0x1 jb 0xb7 lea rdi , [ rip + 0x30ba1 ] call 0xfffffffffffe9070 test rax , rax je 0xd0 lea rcx , [ rsp + 0x10 ] lea rsi , [ rsp + 0x8 ] xor r8d , r8d mov edx , 0xa mov rdi , rax call 0x12e40 test eax , eax jne 0xd9 cmp qword ptr [ rsp + 0x10 ] , rbp setb al mov rdx , qword ptr [ rsp + 0x18 ] xor rdx , qword ptr fs : [ 0x28 ] jne 0xd4 add rsp , 0x20 pop rbx pop rbp pop r12 ret xor eax , eax jmp 0xb7 call 0xfffffffffffe92d0 lea rdi , [ rip + 0x30b48 ] call 0xfffffffffffe9a75 lea rdi , [ rip + 0x30b14 ] call 0xfffffffffffe9a75 nop word ptr cs : [ rax + rax ] nop dword ptr [ rax + rax ]
Code2: push ebp mov ebp , esp sub esp , 0x38 mov eax , dword ptr [ ebp + 0x8 ] mov dword ptr [ ebp - 0x8 ] , 0x0 mov dword ptr [ ebp - 0x4 ] , 0x0 mov dword ptr [ ebp - 0xc ] , 0xe2769dc9 mov dword ptr [ ebp - 0x14 ] , eax mov eax , dword ptr [ ebp - 0xc ] mov ecx , eax sub ecx , 0x82ca3d20 mov dword ptr [ ebp - 0x18 ] , eax mov dword ptr [ ebp - 0x1c ] , ecx je 0x109 jmp 0x3d mov eax , dword ptr [ ebp - 0x18 ] sub eax , 0xa5e82c09 mov dword ptr [ ebp - 0x20 ] , eax je 0x13a jmp 0x53 mov eax , dword ptr [ ebp - 0x18 ] sub eax , 0xa9c3fd4a mov dword ptr [ ebp - 0x24 ] , eax je 0xcb jmp 0x69 mov eax , dword ptr [ ebp - 0x18 ] sub eax , 0xe2769dc9 mov dword ptr [ ebp - 0x28 ] , eax je 0xb0 jmp 0x7f mov eax , dword ptr [ ebp - 0x18 ] sub eax , 0x4aca8a1e mov dword ptr [ ebp - 0x2c ] , eax je 0x167 jmp 0x95 mov eax , dword ptr [ ebp - 0x18 ] sub eax , 0x6d75d3ee mov dword ptr [ ebp - 0x30 ] , eax je 0xf4 jmp 0xab jmp 0x174 mov eax , dword ptr [ ebp + 0x8 ] cmp dword ptr [ eax ] , 0x0 mov eax , 0xa9c3fd4a mov ecx , 0x82ca3d20 cmovne ecx , eax mov dword ptr [ ebp - 0xc ] , ecx jmp 0x174 mov eax , dword ptr [ ebp - 0x8 ] add eax , 0x1 mov dword ptr [ ebp - 0x8 ] , eax mov eax , dword ptr [ ebp + 0x8 ] mov eax , dword ptr [ eax ] mov ecx , esp mov dword ptr [ ecx ] , eax call 0xfffde950 add eax , dword ptr [ ebp - 0x4 ] mov dword ptr [ ebp - 0x4 ] , eax mov dword ptr [ ebp - 0xc ] , 0x6d75d3ee jmp 0x174 mov eax , dword ptr [ ebp + 0x8 ] add eax , 0x4 mov dword ptr [ ebp + 0x8 ] , eax mov dword ptr [ ebp - 0xc ] , 0xe2769dc9 jmp 0x174 mov eax , dword ptr [ ebp - 0x8 ] lea ecx , [ 0x8148d05 ] mov dword ptr [ esp ] , ecx mov dword ptr [ esp + 0x4 ] , eax call 0x180 cmp eax , 0x0 mov eax , 0x4aca8a1e mov ecx , 0xa5e82c09 cmovne ecx , eax mov dword ptr [ ebp - 0xc ] , ecx mov byte ptr [ ebp - 0xd ] , 0x1 jmp 0x174 mov eax , dword ptr [ ebp - 0x4 ] lea ecx , [ 0x8148d2a ] mov dword ptr [ esp ] , ecx mov dword ptr [ esp + 0x4 ] , eax call 0x180 cmp eax , 0x0 setne dl mov dword ptr [ ebp - 0xc ] , 0x4aca8a1e and dl , 0x1 mov byte ptr [ ebp - 0xd ] , dl jmp 0x174 mov al , byte ptr [ ebp - 0xd ] and al , 0x1 movzx eax , al add esp , 0x38 pop ebp ret jmp 0x21 nop dword ptr [ eax ]
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly codes are fundamentally dissimilar due to multiple critical differences:
1. Architecture - Code1 uses 64-bit registers (r*) and instructions, while Code2 uses 32-bit architecture (e* registers)
2. Structure - Code1 features a loop processing array elements with function calls, whereas Code2 implements a complex state machine with magic number comparisons and conditional jumps
3. Operations - Code1 calculates cumulative sums of function returns, while Code2 performs arithmetic comparisons of hardcoded constants (e.g., 0xe2769dc9)
4. Stack management - Code1 uses RSP-relative addressing, Code2 uses EBP-based stack frames
5. Register usage - Code1 preserves R12/RBX/RBP across calls, while Code2 relies entirely on general-purpose registers
The absence of overlapping instructions, control flow patterns, or algorithmic approaches confirms these are unrelated programs.
------------------------------------------------------------

------------------------------------------------------------
Code1: lui gp , 0x44 lw a1 , ( a1 ) addiu gp , gp , - 0x1e80 lw t9 , - 0x7c78 ( gp ) jr t9 lw a0 , ( a0 )
Code2: push ebp mov ebp , esp push edi push esi sub esp , 0x20 mov eax , dword ptr [ ebp + 0xc ] mov ecx , dword ptr [ ebp + 0x8 ] mov edx , dword ptr [ ebp + 0x8 ] mov dword ptr [ ebp - 0xc ] , edx mov edx , dword ptr [ ebp + 0xc ] mov dword ptr [ ebp - 0x10 ] , edx mov edx , dword ptr [ ebp - 0xc ] mov edx , dword ptr [ edx ] mov esi , dword ptr [ ebp - 0x10 ] mov esi , dword ptr [ esi ] mov edi , esp mov dword ptr [ edi + 0x4 ] , esi mov dword ptr [ edi ] , edx mov dword ptr [ ebp - 0x14 ] , eax mov dword ptr [ ebp - 0x18 ] , ecx call 0xfffe82e0 add esp , 0x20 pop esi pop edi pop ebp ret nop dword ptr [ eax ]
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two code snippets are fundamentally dissimilar due to differences in architecture, structure, and functionality. Code1 uses MIPS assembly instructions (lui, lw, addiu, jr) with register names like gp, a1, t9, and a0, while Code2 uses x86 assembly instructions (push, mov, sub, call) with registers like ebp, esp, edi, and esi. Code1 is extremely concise (6 instructions) and appears to be a function trampoline that loads and jumps to an address, whereas Code2 is a full function prologue/epilogue with stack management (20+ instructions), local variable storage, and an explicit function call. There are no overlapping instructions, equivalent operations, or structural parallels beyond basic low-level concepts. The architectural mismatch and functional divergence result in no meaningful similarity.
------------------------------------------------------------

------------------------------------------------------------
Code1: push ebp mov ebp , esp push ebx push edi push esi sub esp , 0x7c mov eax , dword ptr [ ebp + 0x18 ] mov ecx , dword ptr [ ebp + 0x14 ] mov edx , dword ptr [ ebp + 0x10 ] mov esi , dword ptr [ ebp + 0xc ] mov edi , dword ptr [ ebp + 0x8 ] mov ebx , dword ptr [ ebp + 0x8 ] mov dword ptr [ ebp - 0x1c ] , eax mov eax , dword ptr [ ebp + 0x10 ] add eax , 0x8 mov dword ptr [ ebp - 0x20 ] , eax mov eax , dword ptr [ ebp + 0x10 ] mov eax , dword ptr [ eax ] mov dword ptr [ ebp - 0x24 ] , eax mov eax , dword ptr [ ebp + 0x10 ] add eax , 0x4 mov dword ptr [ ebp - 0x28 ] , ecx mov dword ptr [ ebp - 0x2c ] , edx mov dword ptr [ ebp - 0x30 ] , esi mov dword ptr [ ebp - 0x34 ] , edi mov dword ptr [ ebp - 0x38 ] , ebx mov dword ptr [ ebp - 0x3c ] , eax mov eax , dword ptr [ ebp - 0x3c ] mov ecx , dword ptr [ eax ] mov edx , dword ptr [ ebp + 0x14 ] mov esi , dword ptr [ ebp + 0x18 ] mov edi , dword ptr [ ebp - 0x38 ] mov dword ptr [ esp ] , edi mov ebx , dword ptr [ ebp - 0x20 ] mov dword ptr [ esp + 0x4 ] , ebx mov eax , dword ptr [ ebp - 0x24 ] mov dword ptr [ esp + 0x8 ] , eax mov dword ptr [ esp + 0xc ] , ecx mov dword ptr [ esp + 0x10 ] , edx mov dword ptr [ esp + 0x14 ] , esi mov dword ptr [ esp + 0x18 ] , 0x8 call 0x2d0 mov dword ptr [ ebp - 0x40 ] , eax mov eax , dword ptr [ ebp - 0x40 ] mov dword ptr [ ebp - 0x14 ] , eax cmp dword ptr [ ebp - 0x14 ] , 0x0 je 0xa3 mov eax , dword ptr [ ebp - 0x14 ] mov dword ptr [ ebp - 0x44 ] , eax mov eax , dword ptr [ ebp - 0x44 ] mov dword ptr [ ebp - 0x10 ] , eax jmp 0x13d mov eax , dword ptr [ ebp + 0x8 ] mov ecx , dword ptr [ ebp + 0x14 ] mov edx , dword ptr [ ebp + 0x18 ] mov esi , dword ptr [ ebp + 0xc ] mov esi , dword ptr [ esi ] mov dword ptr [ ebp - 0x48 ] , eax mov dword ptr [ ebp - 0x4c ] , ecx mov dword ptr [ ebp - 0x50 ] , edx mov dword ptr [ ebp - 0x54 ] , esi mov eax , dword ptr [ ebp + 0x10 ] mov dword ptr [ ebp - 0x58 ] , eax mov eax , dword ptr [ ebp - 0x58 ] mov ecx , dword ptr [ eax + 0x4 ] mov edx , dword ptr [ ebp - 0x48 ] mov dword ptr [ esp ] , edx mov esi , dword ptr [ ebp - 0x4c ] mov dword ptr [ esp + 0x4 ] , esi mov edi , dword ptr [ ebp - 0x50 ] mov dword ptr [ esp + 0x8 ] , edi mov ebx , dword ptr [ ebp - 0x54 ] mov dword ptr [ esp + 0xc ] , ebx mov dword ptr [ esp + 0x10 ] , ecx call 0x1350 mov dword ptr [ ebp - 0x14 ] , eax cmp dword ptr [ ebp - 0x14 ] , 0x0 je 0x10b mov eax , dword ptr [ ebp - 0x14 ] mov dword ptr [ ebp - 0x5c ] , eax mov eax , dword ptr [ ebp - 0x5c ] mov dword ptr [ ebp - 0x10 ] , eax jmp 0x13d mov eax , dword ptr [ ebp + 0x18 ] mov dword ptr [ ebp - 0x60 ] , eax mov eax , dword ptr [ ebp + 0x10 ] mov ecx , dword ptr [ ebp - 0x60 ] add ecx , dword ptr [ eax + 0x4 ] mov eax , dword ptr [ ebp + 0xc ] sub ecx , dword ptr [ eax ] mov dword ptr [ ebp - 0x18 ] , ecx mov eax , dword ptr [ ebp + 0x8 ] mov dword ptr [ ebp - 0x64 ] , eax mov eax , dword ptr [ ebp - 0x18 ] mov ecx , dword ptr [ ebp - 0x64 ] mov dword ptr [ esp ] , ecx mov dword ptr [ esp + 0x4 ] , eax call 0xfffffe60 mov dword ptr [ ebp - 0x10 ] , eax mov eax , dword ptr [ ebp - 0x10 ] mov dword ptr [ ebp - 0x68 ] , eax mov eax , dword ptr [ ebp - 0x68 ] add esp , 0x7c pop esi pop edi pop ebx pop ebp ret nop
Code2: push { r4 , r5 , r6 , r7 , r8 , sb , sl , lr } sub sp , sp , 0x10 mov r4 , r0 mov r8 , r1 mov r5 , r2 mov r7 , r3 ldr r6 , [ sp , 0x30 ] mov r1 , r2 ldr r2 , [ r1 ] , 0x8 mov r3 , 0x8 str r3 , [ sp , 0x8 ] str r6 , [ sp , 0x4 ] str r7 , [ sp ] ldr r3 , [ r5 , 0x4 ] bl 0xfffff974 cmp r0 , 0x0 beq 0x4c add sp , sp , 0x10 pop { r4 , r5 , r6 , r7 , r8 , sb , sl , pc } ldr sl , [ r8 ] ldr sb , [ r5 , 0x4 ] ldr r1 , [ r4 , 0x70 ] ldr r3 , [ r4 , 0x6c ] cmp r3 , r1 bge 0x14c ldr r3 , [ r4 , 0x6c ] cmp r3 , 0x0 ble 0x94 add r3 , r3 , r3 , lsl 0x2 lsl r3 , r3 , 0x2 sub r3 , r3 , 0x14 ldr r2 , [ r4 , 0x74 ] add r3 , r2 , r3 ldr r2 , [ r3 , 0x4 ] cmp r6 , r2 moveq r2 , 0x1 strbeq r2 , [ r3 , 0x10 ] ldr r3 , [ r4 , 0x6c ] ldr r2 , [ r4 , 0x74 ] add r3 , r3 , r3 , lsl 0x2 str r7 , [ r2 , r3 , lsl 0x2 ] ldr r3 , [ r4 , 0x6c ] ldr r2 , [ r4 , 0x74 ] add r3 , r3 , r3 , lsl 0x2 add r3 , r2 , r3 , lsl 0x2 str r6 , [ r3 , 0x4 ] ldr r3 , [ r4 , 0x6c ] ldr r2 , [ r4 , 0x74 ] add r3 , r3 , r3 , lsl 0x2 add r3 , r2 , r3 , lsl 0x2 str sl , [ r3 , 0x8 ] ldr r3 , [ r4 , 0x6c ] ldr r2 , [ r4 , 0x74 ] add r3 , r3 , r3 , lsl 0x2 add r3 , r2 , r3 , lsl 0x2 str sb , [ r3 , 0xc ] ldr r3 , [ r4 , 0x6c ] ldr r2 , [ r4 , 0x74 ] add r3 , r3 , r3 , lsl 0x2 add r3 , r2 , r3 , lsl 0x2 cmp sl , sb movne r2 , 0x0 mvneq r2 , 0x0 strh r2 , [ r3 , 0x12 ] ldr r2 , [ r4 , 0x74 ] ldr r3 , [ r4 , 0x6c ] add r1 , r3 , 0x1 str r1 , [ r4 , 0x6c ] add r3 , r3 , r3 , lsl 0x2 add r3 , r2 , r3 , lsl 0x2 mov r2 , 0x0 strb r2 , [ r3 , 0x10 ] sub sb , sb , sl ldr r3 , [ r4 , 0x78 ] cmp r3 , sb strlt sb , [ r4 , 0x78 ] ldr r1 , [ r5 , 0x4 ] add r6 , r6 , r1 ldr r1 , [ r8 ] sub r1 , r6 , r1 mov r0 , r4 bl 0xffffa1c8 b 0x44 add r1 , r1 , r1 , lsl 0x2 lsl r1 , r1 , 0x3 ldr r0 , [ r4 , 0x74 ] bl 0xfffeec98 cmp r0 , 0x0 beq 0x198 str r0 , [ r4 , 0x74 ] ldr r2 , [ r4 , 0x70 ] add r2 , r2 , r2 , lsl 0x2 ldr r3 , [ r4 , 0x6c ] add r3 , r3 , r3 , lsl 0x2 lsl r2 , r2 , 0x2 mov r1 , 0x0 add r0 , r0 , r3 , lsl 0x2 bl 0xfffeee18 ldr r3 , [ r4 , 0x70 ] lsl r3 , r3 , 0x1 str r3 , [ r4 , 0x70 ] b 0x64 ldr r0 , [ r4 , 0x74 ] bl 0xfffeebfc mov r0 , 0xc b 0x44
Similarity: -1
Label: 1
Similarity Score: 0.15
Explanation: The codes show some structural similarities like function prologue/epilogue patterns, register saving, and conditional branching. However, significant differences exist: code1 uses x86 architecture with ebp/esp stack management and 32-bit operations, while code2 uses ARM architecture with r-registers and complex shift operations. The memory access patterns, calling conventions (call vs bl), and instruction sets are fundamentally different. Core logic like arithmetic operations and function calls don't align meaningfully. While both have conditional jumps (je/beq) and stack adjustments, the architectural differences and lack of matching operational sequences result in low similarity.
------------------------------------------------------------

------------------------------------------------------------
Code1: push { r4 , r5 , lr } sub sp , sp , 0xc mov r4 , r0 ldr r3 , [ pc , 0xf4 ] ldr r1 , [ r3 ] str r1 , [ sp , 0x4 ] bl 0x18 cmp r0 , 0x0 bne 0x84 add r0 , r4 , r4 , lsl 0x1 add r2 , r4 , r0 , lsl 0x2 ldr r5 , [ pc , 0xd8 ] add ip , r5 , r2 , lsl 0x3 ldr r3 , [ ip , 0x10 ] str r3 , [ sp ] cmp r3 , 0x8 ble 0xfc ldr lr , [ pc , 0xc0 ] add r1 , lr , r2 , lsl 0x3 ldr r2 , [ r1 , 0x2c ] mov r0 , sp blx r2 cmp r0 , 0x0 bne 0x84 add r5 , r4 , r4 , lsl 0x1 add ip , r4 , r5 , lsl 0x2 ldr r3 , [ pc , 0x9c ] add r1 , r3 , ip , lsl 0x3 ldr r2 , [ r1 , 0x10 ] ldr r5 , [ sp ] cmp r2 , r5 movne r0 , 0xa beq 0xa0 ldr r1 , [ sp , 0x4 ] ldr ip , [ pc , 0x78 ] ldr r2 , [ ip ] cmp r1 , r2 bne 0x104 add sp , sp , 0xc pop { r4 , r5 , pc } ldr r0 , [ pc , 0x68 ] bl 0xa4 mov r5 , r0 bl 0xac cmp r0 , 0x0 bne 0x84 add ip , r4 , r4 , lsl 0x1 add r1 , r4 , ip , lsl 0x2 ldr r3 , [ pc , 0x44 ] add r2 , r3 , r1 , lsl 0x3 ldr r1 , [ r2 , 0x10 ] ldr r2 , [ pc , 0x40 ] add ip , r5 , r5 , lsl 0x1 lsl r3 , ip , 0x2 add ip , r3 , r5 add r2 , r2 , ip , lsl 0x3 str r1 , [ r2 , 0xc ] str r1 , [ r2 , 0x8 ] ldr r3 , [ pc , 0x28 ] str r4 , [ r3 ] ldr r4 , [ pc , 0x24 ] str r1 , [ r4 ] b 0x84 mov r0 , 0xa b 0x84 bl 0x104 andeq r0 , r0 , ip , lsr r0
Code2: push rbp mov rbp , rsp push r15 push r14 push rbx push rax mov r14d , edi mov eax , dword ptr [ rip ] test eax , eax jne 0x95 mov al , byte ptr [ rip ] xor al , 0xf7 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x10 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x44 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xa9 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x6 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x11 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x72 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x22 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x6a mov byte ptr [ rip ] , al mov dword ptr [ rip ] , 0x1 mov rbx , rsp add rbx , - 0x10 mov rsp , rbx mov edi , r14d call 0xb1 test eax , eax jne 0x139 movsxd rax , r14d lea r15 , [ rax + rax * 0x2 ] shl r15 , 0x6 mov ecx , dword ptr [ r15 ] mov dword ptr [ rbx ] , ecx mov eax , 0xa cmp ecx , 0x9 jl 0x139 mov rdi , rbx call qword ptr [ r15 ] test eax , eax jne 0x139 lea r15 , [ r15 ] mov ecx , dword ptr [ rbx ] mov eax , 0xa cmp ecx , dword ptr [ r15 ] jne 0x139 mov edi , 0x0 call 0x102 mov ebx , eax mov edi , eax call 0x10b test eax , eax jne 0x139 movsxd rax , dword ptr [ r15 ] movsxd rcx , ebx imul rcx , rcx , 0xd0 mov qword ptr [ rcx ] , rax mov qword ptr [ rcx ] , rax mov dword ptr [ rip ] , r14d mov dword ptr [ rip ] , eax xor eax , eax lea rsp , [ rbp - 0x18 ] pop rbx pop r14 pop r15 pop rbp ret
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly codes are fundamentally dissimilar due to differences in architecture (ARM vs x86_64), instruction sets, and operational patterns. The first code uses ARM-specific operations like shift-and-add addressing (e.g., `add r4, r4, r4, lsl 0x1`), while the second relies on x86_64 instructions like `xor` and `lea`. The second code features a distinctive sequence of byte-level XOR operations absent in the first, and the first code includes complex conditional branching structures not mirrored in the second. Both have function prologues/epilogues and conditional jumps, but these common structural elements are outweighed by significant differences in core operations and architecture-specific implementations.
------------------------------------------------------------

------------------------------------------------------------
Code1: push ebp mov ebp , esp sub esp , 0x18 mov eax , dword ptr [ ebp + 0x8 ] mov ecx , dword ptr [ ebp + 0x8 ] mov edx , esp mov dword ptr [ edx ] , ecx mov dword ptr [ edx + 0x4 ] , 0x8000 mov dword ptr [ ebp - 0x8 ] , eax call 0xffffe6d0 mov dword ptr [ ebp - 0x4 ] , eax mov eax , dword ptr [ ebp - 0x4 ] not eax shr eax , 0x1f mov eax , dword ptr [ eax * 0x4 + 0x8079a6c ] jmp eax mov eax , dword ptr [ ebp - 0x4 ] mov ecx , esp mov dword ptr [ ecx ] , eax mov dword ptr [ ecx + 0x8 ] , 0x1 mov dword ptr [ ecx + 0x4 ] , 0x2 call 0xcde0 test eax , eax setne dl movzx eax , dl mov eax , dword ptr [ eax * 0x4 + 0x8079a74 ] jmp eax mov eax , dword ptr [ ebp - 0x4 ] mov ecx , esp mov dword ptr [ ecx ] , eax call 0xffffec80 mov dword ptr [ ebp - 0x4 ] , 0xffffffff mov ecx , dword ptr [ 0x80793e8 ] mov dword ptr [ ebp - 0xc ] , eax jmp ecx mov eax , dword ptr [ 0x80793ec ] jmp eax mov eax , dword ptr [ ebp - 0x4 ] add esp , 0x18 pop ebp ret nop dword ptr [ eax + eax ]
Code2: push { r4 , lr } mov r1 , 0x20000 bl 0xffffec94 subs r4 , r0 , 0x0 blt 0x28 mov r2 , 0x1 mov r1 , 0x2 bl 0x9394 cmp r0 , 0x0 bne 0x30 mov r0 , r4 pop { r4 , pc } mov r0 , r4 bl 0xffffef58 mvn r4 , 0x0 b 0x28
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The first code is written in x86 assembly (Intel syntax) while the second is ARM assembly. The architectures, instruction sets, registers, and calling conventions are fundamentally different. There is no direct correspondence in instructions, structure, or flow. The x86 code uses ebp/esp stack frames and conditional jumps via jump tables, while ARM uses bl instructions and conditional branches. The functional intent may differ as well, but the assembler code itself shows no similarity.
------------------------------------------------------------

------------------------------------------------------------
Code1: addiu sp , sp , - 0x20 sw ra , 0x1c ( sp ) lui gp , 0x68 addiu gp , gp , 0x1de0 sw gp , 0x10 ( sp ) lui a3 , 0x67 addiu a3 , a3 , - 0x7b94 lw t9 , - 0x6784 ( gp ) jalr t9 nop lw gp , 0x10 ( sp ) lw ra , 0x1c ( sp ) jr ra addiu sp , sp , 0x20
Code2: push ebx sub esp , 0x8 call 0xffeb3384 add eax , 0x191a3c lea edx , [ eax - 0x6efc ] push edx push dword ptr [ esp + 0x1c ] push dword ptr [ esp + 0x1c ] push dword ptr [ esp + 0x1c ] mov ebx , eax call 0xfffd3451 add esp , 0x10 add esp , 0x8 pop ebx ret
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two code snippets are for different processor architectures: the first is MIPS and the second is x86. The instruction sets, register names, and calling conventions are entirely different. Therefore, the codes are not similar.
------------------------------------------------------------

------------------------------------------------------------
Code1: push { r4 , r5 , r6 , lr } mov r4 , r0 mov r5 , r1 mov r2 , 0x0 sub r1 , r1 , r0 bl 0x945c cmp r5 , r4 popls { r4 , r5 , r6 , pc } ldrb r3 , [ r4 ] , 0x1 cmp r3 , 0x9 addeq r0 , r0 , 0x1 cmp r5 , r4 bne 0x20 pop { r4 , r5 , r6 , pc }
Code2: push ebp mov ebp , esp push ebx push edi push esi sub esp , 0x3c mov eax , dword ptr [ ebp + 0xc ] mov ecx , dword ptr [ ebp + 0x8 ] xor edx , edx mov esi , dword ptr [ ebp + 0x8 ] mov edi , dword ptr [ ebp + 0xc ] mov ebx , dword ptr [ ebp + 0x8 ] sub edi , ebx mov dword ptr [ esp ] , esi mov dword ptr [ esp + 0x4 ] , edi mov dword ptr [ esp + 0x8 ] , 0x0 mov dword ptr [ ebp - 0x18 ] , eax mov dword ptr [ ebp - 0x1c ] , ecx mov dword ptr [ ebp - 0x20 ] , edx call 0x107a0 mov dword ptr [ ebp - 0x10 ] , eax mov dword ptr [ ebp - 0x14 ] , 0xcf1af3f3 mov eax , dword ptr [ ebp - 0x14 ] mov ecx , eax sub ecx , 0xa74a538e mov dword ptr [ ebp - 0x24 ] , eax mov dword ptr [ ebp - 0x28 ] , ecx je 0xd7 jmp 0x5f mov eax , dword ptr [ ebp - 0x24 ] sub eax , 0xcf1af3f3 mov dword ptr [ ebp - 0x2c ] , eax je 0x90 jmp 0x75 mov eax , dword ptr [ ebp - 0x24 ] sub eax , 0x62d33a2 mov dword ptr [ ebp - 0x30 ] , eax je 0xab jmp 0x8b jmp 0xe2 mov eax , dword ptr [ ebp + 0x8 ] cmp eax , dword ptr [ ebp + 0xc ] mov eax , 0x62d33a2 mov ecx , 0xa74a538e cmovb ecx , eax mov dword ptr [ ebp - 0x14 ] , ecx jmp 0xe2 mov eax , dword ptr [ ebp + 0x8 ] mov ecx , eax add ecx , 0x1 mov dword ptr [ ebp + 0x8 ] , ecx movsx eax , byte ptr [ eax ] cmp eax , 0x9 sete dl and dl , 0x1 movzx eax , dl add eax , dword ptr [ ebp - 0x10 ] mov dword ptr [ ebp - 0x10 ] , eax mov dword ptr [ ebp - 0x14 ] , 0xcf1af3f3 jmp 0xe2 mov eax , dword ptr [ ebp - 0x10 ] add esp , 0x3c pop esi pop edi pop ebx pop ebp ret jmp 0x43 nop word ptr [ eax + eax ]
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly codes show fundamental differences in architecture (ARM vs x86), structure, and functionality. Code1 is compact (15 instructions) with simple register operations and conditional branching, while Code2 is significantly longer (40+ instructions) with complex stack manipulation, multiple memory operations, and different control flow patterns. Although both contain a comparison with 0x9 (tab character), this isolated similarity is outweighed by architectural disparities, structural complexity differences, and divergent operational logic (e.g., Code2 uses explicit stack frames and 32-bit constants absent in Code1). The lack of overlapping instructions, register usage patterns, or control flow confirms they implement different functionalities.
------------------------------------------------------------

------------------------------------------------------------
Code1: push ebp push edi push esi push ebx mov esi , eax call 0xfffeed90 add ebx , 0xb2e5 sub esp , 0x18 mov ebp , dword ptr [ eax + 0x20 ] lea eax , [ ebp + ebp ] push eax call 0xfffeebd0 add esp , 0x10 test eax , eax mov dword ptr [ esi + 0x24 ] , eax je 0xcc mov edx , dword ptr [ esi + 0x2c ] test edx , edx je 0x48 mov dword ptr [ esi + 0x1c ] , ebp xor eax , eax add esp , 0xc pop ebx pop esi pop edi pop ebp ret nop lea esi , [ esi ] sub esp , 0xc mov edi , eax push ebp call 0xfffeebd0 add esp , 0x10 test eax , eax mov dword ptr [ esi + 0x28 ] , eax je 0x104 lea eax , [ ebx - 0x558c ] push 0x38 mov dword ptr [ esi + 0x80 ] , 0x0 mov dword ptr [ esi + 0x84 ] , 0x0 mov dword ptr [ esi + 0x88 ] , 0x0 push eax lea eax , [ esi + 0x60 ] push dword ptr [ esi + 0x48 ] push 0x8 push 0x1f push 0x8 push dword ptr [ esi + 0x44 ] push eax call 0xfffeebb0 add esp , 0x20 test eax , eax jne 0xeb mov eax , dword ptr [ esi + 0x2c ] mov edx , dword ptr [ esi + 0x20 ] mov dword ptr [ esi + 0x60 ] , 0x0 test eax , eax mov dword ptr [ esi + 0x1c ] , edx jne 0x39 mov dword ptr [ esi + 0x70 ] , edx mov edx , dword ptr [ esi + 0x28 ] mov dword ptr [ esi + 0x6c ] , edx mov dword ptr [ esi + 0x4 ] , edx add esp , 0xc pop ebx pop esi pop edi pop ebp ret sub esp , 0x4 lea eax , [ ebx - 0x5514 ] push eax push - 0x4 push esi call 0xffffe990 add esp , 0x10 mov eax , 0xffffffff jmp 0x3b sub esp , 0xc push dword ptr [ esi + 0x28 ] call 0xfffeeb20 pop eax push dword ptr [ esi + 0x24 ] call 0xfffeeb20 add esp , 0xc jmp 0xcf sub esp , 0xc push edi jmp 0xfa lea esi , [ esi ]
Code2: push r12 push rbp push rbx mov rbx , rdi mov r12d , dword ptr [ rdi + 0x2c ] lea edi , [ r12 + r12 ] mov edi , edi call 0xffffffffffff4515 mov qword ptr [ rbx + 0x30 ] , rax test rax , rax je 0x53 mov rbp , rax cmp dword ptr [ rbx + 0x40 ] , 0x0 je 0x6e mov edx , dword ptr [ rbx + 0x2c ] mov dword ptr [ rbx + 0x28 ] , edx mov eax , dword ptr [ rbx + 0x40 ] test eax , eax jne 0x135 mov dword ptr [ rbx + 0x98 ] , edx mov rdx , qword ptr [ rbx + 0x38 ] mov qword ptr [ rbx + 0x90 ] , rdx mov qword ptr [ rbx + 0x8 ] , rdx pop rbx pop rbp pop r12 ret lea rdx , [ rip + 0x4baf ] mov esi , 0xfffffffc mov rdi , rbx call 0xffffffffffffec70 mov eax , 0xffffffff jmp 0x4e mov edi , r12d call 0xffffffffffff4515 mov qword ptr [ rbx + 0x38 ] , rax test rax , rax je 0xdf mov qword ptr [ rbx + 0xb8 ] , 0x0 mov qword ptr [ rbx + 0xc0 ] , 0x0 mov qword ptr [ rbx + 0xc8 ] , 0x0 mov esi , dword ptr [ rbx + 0x58 ] lea rdi , [ rbx + 0x78 ] push 0x70 lea rax , [ rip + 0x4ae9 ] push rax mov r9d , dword ptr [ rbx + 0x5c ] mov r8d , 0x8 mov ecx , 0x1f mov edx , 0x8 call 0xffffffffffff4485 add rsp , 0x10 test eax , eax jne 0x105 mov qword ptr [ rbx + 0x78 ] , 0x0 jmp 0x28 mov rdi , rbp call 0xffffffffffff4395 lea rdx , [ rip + 0x4b1b ] mov esi , 0xfffffffc mov rdi , rbx call 0xffffffffffffec70 mov eax , 0xffffffff jmp 0x4e mov rdi , qword ptr [ rbx + 0x38 ] call 0xffffffffffff4395 mov rdi , qword ptr [ rbx + 0x30 ] call 0xffffffffffff4395 lea rdx , [ rip + 0x4aeb ] mov esi , 0xfffffffc mov rdi , rbx call 0xffffffffffffec70 mov eax , 0xffffffff jmp 0x4e mov eax , 0x0 jmp 0x4e
Similarity: -1
Label: 1
Similarity Score: -0.85
Explanation: The codes show significant architectural differences (32-bit vs 64-bit ISA) with distinct register usage (e.g., EAX/EBX vs RDI/R12), memory addressing modes, and calling conventions. While both share common patterns like register pushes/pops and conditional jumps, critical structural elements differ: stack management (explicit ESP adjustments vs RSP-relative), memory offset patterns (0x20/0x24 vs 0x30/0x98), and function call argument handling. Key operations like memory writes (dword ptr vs qword ptr) and arithmetic logic (sub esp vs add rsp) are ISA-specific. The control flow diverges substantially in error handling paths and register dependency chains.
------------------------------------------------------------

------------------------------------------------------------
Code1: push rbp mov rbp , rsp sub rsp , 0x10 mov rax , qword ptr [ rip + 0x53e911 ] mov rax , qword ptr [ rax + 0x90 ] mov qword ptr [ rbp - 0x8 ] , rax mov rax , qword ptr [ rip + 0x47aadf ] jmp rax mov rax , qword ptr [ rbp - 0x8 ] test rax , rax setne cl movzx edx , cl mov eax , edx mov rax , qword ptr [ rax * 0x8 + 0x8c8308 ] jmp rax mov rdi , qword ptr [ rbp - 0x8 ] call 0x4c70 mov rdi , qword ptr [ rip + 0x47aac4 ] jmp rdi mov rax , qword ptr [ rbp - 0x8 ] mov rax , qword ptr [ rax + 0x18 ] mov qword ptr [ rbp - 0x8 ] , rax mov rax , qword ptr [ rip + 0x47aa9f ] jmp rax add rsp , 0x10 pop rbp ret nop dword ptr [ rax ]
Code2: push ebp mov ebp , esp sub esp , 0x8 mov eax , dword ptr [ ebp + 0x8 ] mov ecx , dword ptr [ ebp + 0x8 ] test ecx , ecx setne dl movzx ecx , dl mov ecx , dword ptr [ ecx * 0x4 + 0x8075a2c ] mov dword ptr [ ebp - 0x4 ] , eax jmp ecx mov eax , esp mov dword ptr [ eax ] , 0x4 call 0xffffaac0 movzx ecx , al mov ecx , dword ptr [ ecx * 0x4 + 0x8075a34 ] jmp ecx call 0xffffd3b0 mov eax , dword ptr [ 0x80741fc ] jmp eax mov eax , esp mov dword ptr [ eax ] , 0x80731d0 call 0xffffdcd0 mov eax , dword ptr [ ebp + 0x8 ] mov ecx , esp mov dword ptr [ ecx ] , eax call 0xffffdcd0 mov eax , esp mov dword ptr [ eax ] , 0x80731d8 call 0xffffdcd0 mov eax , dword ptr [ 0x8074200 ] jmp eax cmp dword ptr [ ebp + 0x8 ] , 0x0 setne al and al , 0x1 movzx eax , al add esp , 0x8 pop ebp ret nop word ptr cs : [ eax + eax ] nop dword ptr [ eax ]
Similarity: 1
Label: -1
Similarity Score: 0.65
Explanation: Both codes share structural similarities in their function prologues (stack frame setup) and epilogues (stack cleanup and return). They utilize conditional tests (test/setne) and jump tables for control flow. Key differences include architecture (64-bit vs 32-bit registers), memory addressing modes (RIP-relative vs absolute), and additional call instructions in code2. The shared pattern of jump-table-driven logic suggests functional similarity despite architectural variations.
------------------------------------------------------------

------------------------------------------------------------
Code1: test rsi , rsi je 0x3d4 push r14 push r13 push r12 push rbp push rbx mov ebp , edx mov r13 , rsi mov rbx , rdi test edx , edx jle 0x48 mov r12d , 0x0 lea r14 , [ rip + 0x2bf7d ] mov rcx , rbx mov edx , 0x4 mov esi , 0x1 mov rdi , r14 call 0xffffffffffffc2e5 add r12d , 0x1 cmp ebp , r12d jne 0x2a mov rcx , rbx mov edx , 0x6 mov esi , 0x1 lea rdi , [ rip + 0x2c490 ] call 0xffffffffffffc2e5 mov rsi , r13 mov rdi , rbx call 0xfffffffffffffa93 mov eax , dword ptr [ r13 + 0x14 ] mov esi , eax test ax , ax je 0x20c lea rax , [ rip + 0x23b443 ] mov edx , 0x0 add edx , 0x1 movzx ecx , word ptr [ rax + 0x10 ] add rax , 0x10 cmp cx , - 0x1 je 0x9d cmp si , cx jne 0x87 movsxd rdx , edx shl rdx , 0x4 lea rax , [ rip + 0x23b41a ] mov r8 , qword ptr [ rax + rdx + 0x8 ] mov eax , dword ptr [ r13 + 0x10 ] mov esi , eax test ax , ax je 0x216 lea rax , [ rip + 0x23b37f ] mov edx , 0x0 add edx , 0x1 movzx ecx , word ptr [ rax + 0x10 ] add rax , 0x10 cmp cx , - 0x1 je 0xe1 cmp si , cx jne 0xcb movsxd rdx , edx shl rdx , 0x4 lea rax , [ rip + 0x23b356 ] mov rcx , qword ptr [ rax + rdx + 0x8 ] lea rdx , [ rip + 0x2c3f8 ] mov esi , 0x1 mov rdi , rbx mov eax , 0x0 call 0xffffffffffffc2f5 cmp byte ptr [ r13 + 0x18 ] , 0x0 lea r8 , [ rip + 0x300b7 ] lea rax , [ rip + 0x2c3c0 ] cmove r8 , rax pxor xmm0 , xmm0 cvtss2sd xmm0 , dword ptr [ r13 + 0x24 ] mov ecx , dword ptr [ r13 + 0x20 ] cmp ecx , dword ptr [ rip + 0x23d58d ] je 0x220 lea rdx , [ rip + 0x23d590 ] mov eax , 0x1 cmp ecx , dword ptr [ rdx ] je 0x225 add eax , 0x1 add rdx , 0x10 cmp eax , 0xb jne 0x14a lea rcx , [ rip + 0x2c37f ] lea rdx , [ rip + 0x2ca49 ] mov esi , 0x1 mov rdi , rbx mov eax , 0x1 call 0xffffffffffffc2f5 movabs rax , 0xffffff0000 test qword ptr [ r13 + 0x18 ] , rax jne 0x23c mov rsi , rbx mov edi , 0xa call 0xffffffffffffbec5 test ebp , ebp jle 0x1ce mov r12d , 0x0 lea r14 , [ rip + 0x2bdf7 ] mov rcx , rbx mov edx , 0x4 mov esi , 0x1 mov rdi , r14 call 0xffffffffffffc2e5 add r12d , 0x1 cmp ebp , r12d jne 0x1b0 cmp qword ptr [ r13 + 0x110 ] , 0x0 je 0x2f7 mov rcx , rbx mov edx , 0x6 mov esi , 0x1 lea rdi , [ rip + 0x2c339 ] call 0xffffffffffffc2e5 lea edx , [ rbp + 0x1 ] mov rsi , qword ptr [ r13 + 0x110 ] mov rdi , rbx call 0x0 jmp 0x31a mov edx , 0x0 jmp 0x9d mov edx , 0x0 jmp 0xe1 mov eax , 0x0 mov eax , eax shl rax , 0x4 lea rdx , [ rip + 0x23d493 ] mov rcx , qword ptr [ rdx + rax + 0x8 ] jmp 0x165 mov rcx , rbx mov edx , 0x6 mov esi , 0x1 lea rdi , [ rip + 0x2c2b5 ] call 0xffffffffffffc2e5 cmp byte ptr [ r13 + 0x1a ] , 0x0 jne 0x27a cmp byte ptr [ r13 + 0x1c ] , 0x0 jne 0x2ee lea rcx , [ rip + 0x2ff62 ] cmp byte ptr [ r13 + 0x1b ] , 0x0 jne 0x2d0 jmp 0x192 mov rcx , rbx mov edx , 0x4 mov esi , 0x1 lea rdi , [ rip + 0x2ef8b ] call 0xffffffffffffc2e5 lea rcx , [ rip + 0x2c189 ] cmp byte ptr [ r13 + 0x1c ] , 0x0 je 0x3bd lea rdx , [ rip + 0x2c260 ] mov esi , 0x1 mov rdi , rbx mov eax , 0x0 call 0xffffffffffffc2f5 lea rcx , [ rip + 0x2c15e ] cmp byte ptr [ r13 + 0x1b ] , 0x0 je 0x192 lea rdx , [ rip + 0x2c23d ] mov esi , 0x1 mov rdi , rbx mov eax , 0x0 call 0xffffffffffffc2f5 jmp 0x192 lea rcx , [ rip + 0x2fedb ] jmp 0x2a5 cmp qword ptr [ r13 + 0x118 ] , 0x0 je 0x375 mov rcx , rbx mov edx , 0x9 mov esi , 0x1 lea rdi , [ rip + 0x2c21b ] call 0xffffffffffffc2e5 mov r12d , 0x0 lea r14 , [ rip + 0x2bc80 ] test ebp , ebp jle 0x349 mov rcx , rbx mov edx , 0x4 mov esi , 0x1 mov rdi , r14 call 0xffffffffffffc2e5 add r12d , 0x1 cmp ebp , r12d jne 0x32b cmp qword ptr [ r13 + 0x118 ] , 0x0 jne 0x390 mov rcx , rbx mov edx , 0xa mov esi , 0x1 lea rdi , [ rip + 0x2c1db ] call 0xffffffffffffc2e5 pop rbx pop rbp pop r12 pop r13 pop r14 ret mov rcx , rbx mov edx , 0xd mov esi , 0x1 lea rdi , [ rip + 0x2c192 ] call 0xffffffffffffc2e5 jmp 0x36c mov rcx , rbx mov edx , 0x7 mov esi , 0x1 lea rdi , [ rip + 0x2c196 ] call 0xffffffffffffc2e5 lea edx , [ rbp + 0x1 ] mov rsi , qword ptr [ r13 + 0x118 ] mov rdi , rbx call 0x0 jmp 0x36c cmp byte ptr [ r13 + 0x1b ] , 0x0 je 0x192 lea rcx , [ rip + 0x2c054 ] jmp 0x2d0 repz ret
Code2: push ebp mov ebp , esp push ebx push esi sub esp , 0x80 mov eax , dword ptr [ ebp + 0x10 ] mov ecx , dword ptr [ ebp + 0xc ] mov edx , dword ptr [ ebp + 0x8 ] cmp dword ptr [ ebp + 0xc ] , 0x0 mov dword ptr [ ebp - 0x14 ] , eax mov dword ptr [ ebp - 0x18 ] , ecx mov dword ptr [ ebp - 0x1c ] , edx jne 0x2c jmp 0x3d7 mov dword ptr [ ebp - 0xc ] , 0x0 mov eax , dword ptr [ ebp - 0xc ] cmp eax , dword ptr [ ebp + 0x10 ] jge 0x65 mov eax , dword ptr [ ebp + 0x8 ] mov dword ptr [ esp ] , eax lea eax , [ 0x80d058f ] mov dword ptr [ esp + 0x4 ] , eax call 0xffff7840 mov dword ptr [ ebp - 0x20 ] , eax mov eax , dword ptr [ ebp - 0xc ] add eax , 0x1 mov dword ptr [ ebp - 0xc ] , eax jmp 0x33 mov eax , dword ptr [ ebp + 0x8 ] mov dword ptr [ esp ] , eax lea eax , [ 0x80d110b ] mov dword ptr [ esp + 0x4 ] , eax call 0xffff7840 mov ecx , dword ptr [ ebp + 0x8 ] mov edx , dword ptr [ ebp + 0xc ] mov dword ptr [ esp ] , ecx mov dword ptr [ esp + 0x4 ] , edx mov dword ptr [ ebp - 0x24 ] , eax call 0x2e70 mov eax , dword ptr [ ebp + 0x8 ] mov ecx , dword ptr [ ebp + 0xc ] mov ecx , dword ptr [ ecx + 0x8 ] mov si , cx movsx ecx , si mov dword ptr [ esp ] , ecx mov dword ptr [ ebp - 0x28 ] , eax call 0xf70 mov ecx , dword ptr [ ebp + 0xc ] mov ecx , dword ptr [ ecx + 0xc ] mov si , cx movsx ecx , si mov dword ptr [ esp ] , ecx mov dword ptr [ ebp - 0x2c ] , eax call 0x2eb0 mov ecx , dword ptr [ ebp - 0x28 ] mov dword ptr [ esp ] , ecx lea ecx , [ 0x80d1112 ] mov dword ptr [ esp + 0x4 ] , ecx mov ecx , dword ptr [ ebp - 0x2c ] mov dword ptr [ esp + 0x8 ] , ecx mov dword ptr [ esp + 0xc ] , eax call 0xffff7840 mov ecx , dword ptr [ ebp + 0x8 ] mov edx , dword ptr [ ebp + 0xc ] mov edx , dword ptr [ edx + 0x18 ] mov dword ptr [ esp ] , edx mov dword ptr [ ebp - 0x30 ] , eax mov dword ptr [ ebp - 0x34 ] , ecx call 0x1050 mov ecx , dword ptr [ ebp + 0xc ] movss xmm0 , dword ptr [ ecx + 0x1c ] cvtss2sd xmm0 , xmm0 mov ecx , dword ptr [ ebp + 0xc ] mov bl , byte ptr [ ecx + 0x10 ] test bl , 0x1 lea ecx , [ 0x80d1e40 ] lea edx , [ 0x80d1154 ] cmovne edx , ecx mov ecx , dword ptr [ ebp - 0x34 ] mov dword ptr [ esp ] , ecx lea ecx , [ 0x80d1124 ] mov dword ptr [ esp + 0x4 ] , ecx mov dword ptr [ esp + 0x8 ] , eax movsd qword ptr [ esp + 0xc ] , xmm0 mov dword ptr [ esp + 0x14 ] , edx call 0x2f10 mov ecx , dword ptr [ ebp + 0xc ] test byte ptr [ ecx + 0x12 ] , 0x1 mov dword ptr [ ebp - 0x38 ] , eax jne 0x168 mov eax , dword ptr [ ebp + 0xc ] test byte ptr [ eax + 0x13 ] , 0x1 jne 0x168 mov eax , dword ptr [ ebp + 0xc ] test byte ptr [ eax + 0x14 ] , 0x1 je 0x23b mov dword ptr [ ebp - 0x10 ] , 0x0 mov eax , dword ptr [ ebp + 0x8 ] mov dword ptr [ esp ] , eax lea eax , [ 0x80d1158 ] mov dword ptr [ esp + 0x4 ] , eax call 0xffff7840 mov ecx , dword ptr [ ebp + 0xc ] test byte ptr [ ecx + 0x12 ] , 0x1 mov dword ptr [ ebp - 0x3c ] , eax je 0x1b3 mov eax , dword ptr [ ebp + 0x8 ] mov dword ptr [ esp ] , eax lea eax , [ 0x80d39f4 ] mov dword ptr [ esp + 0x4 ] , eax call 0xffff7840 mov dword ptr [ ebp - 0x10 ] , 0x1 mov dword ptr [ ebp - 0x40 ] , eax mov eax , dword ptr [ ebp + 0xc ] test byte ptr [ eax + 0x14 ] , 0x1 je 0x1f8 mov eax , dword ptr [ ebp + 0x8 ] mov ecx , dword ptr [ ebp - 0x10 ] cmp ecx , 0x0 lea ecx , [ 0x80d1167 ] lea edx , [ 0x80d1e40 ] cmovne edx , ecx mov dword ptr [ esp ] , eax lea eax , [ 0x80d115f ] mov dword ptr [ esp + 0x4 ] , eax mov dword ptr [ esp + 0x8 ] , edx call 0xffff7840 mov dword ptr [ ebp - 0x10 ] , 0x1 mov dword ptr [ ebp - 0x44 ] , eax mov eax , dword ptr [ ebp + 0xc ] test byte ptr [ eax + 0x13 ] , 0x1 je 0x236 mov eax , dword ptr [ ebp + 0x8 ] mov ecx , dword ptr [ ebp - 0x10 ] cmp ecx , 0x0 lea ecx , [ 0x80d1167 ] lea edx , [ 0x80d1e40 ] cmovne edx , ecx mov dword ptr [ esp ] , eax lea eax , [ 0x80d1169 ] mov dword ptr [ esp + 0x4 ] , eax mov dword ptr [ esp + 0x8 ] , edx call 0xffff7840 mov dword ptr [ ebp - 0x48 ] , eax jmp 0x23b mov eax , dword ptr [ ebp + 0x8 ] mov dword ptr [ esp ] , eax lea eax , [ 0x80d1e3f ] mov dword ptr [ esp + 0x4 ] , eax call 0xffff7840 mov dword ptr [ ebp - 0xc ] , 0x0 mov dword ptr [ ebp - 0x4c ] , eax mov eax , dword ptr [ ebp - 0xc ] cmp eax , dword ptr [ ebp + 0x10 ] jge 0x28c mov eax , dword ptr [ ebp + 0x8 ] mov dword ptr [ esp ] , eax lea eax , [ 0x80d058f ] mov dword ptr [ esp + 0x4 ] , eax call 0xffff7840 mov dword ptr [ ebp - 0x50 ] , eax mov eax , dword ptr [ ebp - 0xc ] add eax , 0x1 mov dword ptr [ ebp - 0xc ] , eax jmp 0x25a xor eax , eax mov ecx , dword ptr [ ebp + 0xc ] cmp eax , dword ptr [ ecx + 0x9c ] jne 0x2cb xor eax , eax mov ecx , dword ptr [ ebp + 0xc ] cmp eax , dword ptr [ ecx + 0xa0 ] jne 0x2cb mov eax , dword ptr [ ebp + 0x8 ] mov dword ptr [ esp ] , eax lea eax , [ 0x80d1170 ] mov dword ptr [ esp + 0x4 ] , eax call 0x2f70 mov dword ptr [ ebp - 0x54 ] , eax jmp 0x3d7 mov eax , dword ptr [ ebp + 0xc ] cmp dword ptr [ eax + 0x9c ] , 0x0 je 0x31a mov eax , dword ptr [ ebp + 0x8 ] mov dword ptr [ esp ] , eax lea eax , [ 0x80d117e ] mov dword ptr [ esp + 0x4 ] , eax call 0xffff7840 mov ecx , dword ptr [ ebp + 0x8 ] mov edx , dword ptr [ ebp + 0xc ] mov edx , dword ptr [ edx + 0x9c ] mov esi , dword ptr [ ebp + 0x10 ] add esi , 0x1 mov dword ptr [ esp ] , ecx mov dword ptr [ esp + 0x4 ] , edx mov dword ptr [ esp + 0x8 ] , esi mov dword ptr [ ebp - 0x58 ] , eax call 0x0 jmp 0x332 mov eax , dword ptr [ ebp + 0x8 ] mov dword ptr [ esp ] , eax lea eax , [ 0x80d1185 ] mov dword ptr [ esp + 0x4 ] , eax call 0x2fb0 mov dword ptr [ ebp - 0x5c ] , eax mov dword ptr [ ebp - 0xc ] , 0x0 mov eax , dword ptr [ ebp - 0xc ] cmp eax , dword ptr [ ebp + 0x10 ] jge 0x36b mov eax , dword ptr [ ebp + 0x8 ] mov dword ptr [ esp ] , eax lea eax , [ 0x80d058f ] mov dword ptr [ esp + 0x4 ] , eax call 0xffff7840 mov dword ptr [ ebp - 0x60 ] , eax mov eax , dword ptr [ ebp - 0xc ] add eax , 0x1 mov dword ptr [ ebp - 0xc ] , eax jmp 0x339 mov eax , dword ptr [ ebp + 0xc ] cmp dword ptr [ eax + 0xa0 ] , 0x0 je 0x3ba mov eax , dword ptr [ ebp + 0x8 ] mov dword ptr [ esp ] , eax lea eax , [ 0x80d118f ] mov dword ptr [ esp + 0x4 ] , eax call 0xffff7840 mov ecx , dword ptr [ ebp + 0x8 ] mov edx , dword ptr [ ebp + 0xc ] mov edx , dword ptr [ edx + 0xa0 ] mov esi , dword ptr [ ebp + 0x10 ] add esi , 0x1 mov dword ptr [ esp ] , ecx mov dword ptr [ esp + 0x4 ] , edx mov dword ptr [ esp + 0x8 ] , esi mov dword ptr [ ebp - 0x64 ] , eax call 0x0 jmp 0x3d2 mov eax , dword ptr [ ebp + 0x8 ] mov dword ptr [ esp ] , eax lea eax , [ 0x80d1197 ] mov dword ptr [ esp + 0x4 ] , eax call 0xffff7840 mov dword ptr [ ebp - 0x68 ] , eax jmp 0x3d7 add esp , 0x80 pop esi pop ebx pop ebp ret nop word ptr cs : [ eax + eax ] nop dword ptr [ eax + eax ]
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly codes show fundamental architectural differences—the first uses 64-bit registers (rsi, rdi, r13) and AMD64 syntax, while the second uses 32-bit registers (ebp, esp, ebx) and x86 syntax. Their control flow, stack management, and operand handling are entirely distinct. The first code features complex loops and conditional jumps with RIP-relative addressing, whereas the second relies on EBP-based stack frames and different function call patterns. No overlapping logic or structural similarities exist, indicating completely unrelated functionality.
------------------------------------------------------------

------------------------------------------------------------
Code1: push r14 push r13 push r12 push rbp push rbx sub rsp , 0x10 mov rax , qword ptr fs : [ 0x28 ] mov qword ptr [ rsp + 0x8 ] , rax xor eax , eax test rdi , rdi je 0x11a mov r14 , rdi mov rdi , rsp call qword ptr [ rip ] test eax , eax mov r12d , eax jne 0xe1 mov rdi , qword ptr [ r14 + 0x20 ] mov rdx , qword ptr [ rsp ] mov esi , 0x1 call qword ptr [ rip ] test eax , eax mov r12d , eax jne 0xd7 mov rdi , qword ptr [ r14 + 0x10 ] mov rsi , qword ptr [ rsp ] call qword ptr [ rip ] cmp eax , - 0x1 jne 0x108 mov rdi , qword ptr [ r14 + 0x10 ] mov esi , 0x1 call qword ptr [ rip ] cmp eax , 0x1 jne 0x108 mov rdi , qword ptr [ r14 + 0x10 ] xor ebx , ebx xor ebp , ebp call qword ptr [ rip ] test eax , eax mov r13d , eax jle 0x108 nop mov rdi , qword ptr [ r14 + 0x10 ] mov esi , ebp call qword ptr [ rip ] test rax , rax je 0xc5 nop dword ptr [ rax ] mov rdx , rax and edx , 0x1 add ebx , edx shr rax , 0x1 jne 0xb8 add ebp , 0x1 cmp r13d , ebp jle 0xd2 cmp ebx , 0x1 jle 0xa0 cmp ebx , 0x1 jle 0x108 mov rdi , qword ptr [ rsp ] call qword ptr [ rip ] mov rcx , qword ptr [ rsp + 0x8 ] xor rcx , qword ptr fs : [ 0x28 ] mov eax , r12d jne 0x132 add rsp , 0x10 pop rbx pop rbp pop r12 pop r13 pop r14 ret nop dword ptr [ rax ] mov r12d , 0x10 mov rdi , qword ptr [ rsp ] call qword ptr [ rip ] jmp 0xe1 lea rsi , [ rip ] lea rdi , [ rip ] mov edx , 0x19 call 0x132 call 0x137
Code2: addiu sp , sp , - 0x40 sw ra , 0x3c ( sp ) sw s5 , 0x38 ( sp ) sw s4 , 0x34 ( sp ) sw s3 , 0x30 ( sp ) sw s2 , 0x2c ( sp ) sw s1 , 0x28 ( sp ) sw s0 , 0x24 ( sp ) lui gp , 0x0 addiu gp , gp , 0x0 sw gp , 0x10 ( sp ) lw v0 , ( gp ) lw v1 , ( v0 ) sw v1 , 0x1c ( sp ) beqz a0 , 0x100 move s2 , a0 lw a0 , ( gp ) lw t9 , 0x8 ( a0 ) addiu a0 , sp , 0x18 jalr t9 nop lw gp , 0x10 ( sp ) bnez v0 , 0x19c move s3 , v0 lw a1 , ( gp ) lw t9 , 0x60 ( a1 ) lw a2 , 0x18 ( sp ) addiu a1 , zero , 0x1 lw a0 , 0x10 ( s2 ) jalr t9 nop lw gp , 0x10 ( sp ) bnez v0 , 0x184 move s3 , v0 lw a2 , ( gp ) lw t9 , 0x2c ( a2 ) lw a1 , 0x18 ( sp ) lw a0 , 0x8 ( s2 ) jalr t9 nop lw gp , 0x10 ( sp ) addiu a3 , zero , - 0x1 bne v0 , a3 , 0x1d4 lw t0 , ( gp ) lw t9 , 0x30 ( t0 ) addiu a1 , zero , 0x1 lw a0 , 0x8 ( s2 ) jalr t9 nop lw gp , 0x10 ( sp ) addiu t1 , zero , 0x1 bne v0 , t1 , 0x1dc lw t2 , ( gp ) lw t9 , 0x28 ( t2 ) lw a0 , 0x8 ( s2 ) jalr t9 nop lw gp , 0x10 ( sp ) blez v0 , 0x1e4 move s4 , v0 move s0 , s3 move s1 , s3 b 0x150 lw s5 , ( gp ) addiu a2 , zero , 0x19 lui v0 , 0x0 addiu a1 , v0 , 0x0 lui s2 , 0x0 addiu a0 , s2 , 0x0 lw t9 , ( gp ) jalr t9 nop srl v0 , v0 , 0x1 beqz v0 , 0x13c andi t3 , v0 , 0x1 beqz t3 , 0x120 nop b 0x120 addiu s0 , s0 , 0x1 addiu s1 , s1 , 0x1 beq s4 , s1 , 0x178 slti t6 , s0 , 0x2 beqz t6 , 0x188 lw t7 , ( gp ) lw t9 , 0x24 ( s5 ) move a1 , s1 lw a0 , 0x8 ( s2 ) jalr t9 nop lw gp , 0x10 ( sp ) bnez v0 , 0x12c andi t3 , v0 , 0x1 b 0x140 addiu s1 , s1 , 0x1 slti t4 , s0 , 0x2 addiu t5 , zero , 0x10 movn s3 , t5 , t4 lw t7 , ( gp ) lw t9 , 0x10 ( t7 ) lw a0 , 0x18 ( sp ) jalr t9 nop lw gp , 0x10 ( sp ) move v0 , s3 lw t8 , 0x1c ( sp ) lw ra , ( gp ) lw v1 , ( ra ) bne t8 , v1 , 0x1ec lw ra , 0x3c ( sp ) lw s5 , 0x38 ( sp ) lw s4 , 0x34 ( sp ) lw s3 , 0x30 ( sp ) lw s2 , 0x2c ( sp ) lw s1 , 0x28 ( sp ) lw s0 , 0x24 ( sp ) jr ra addiu sp , sp , 0x40 b 0x184 addiu s3 , zero , 0x10 b 0x184 addiu s3 , zero , 0x10 b 0x184 addiu s3 , zero , 0x10 lw t9 , ( gp ) jalr t9 nop
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly codes are fundamentally dissimilar due to multiple factors:
1. Architecture difference: Code1 uses x86_64 instructions (push/pop, rax/rbx registers) while Code2 uses MIPS instructions (lw/sw, addiu, jalr).
2. Stack management: Code1 uses x86_64 stack operations (push/pop) while Code2 uses MIPS-specific stack management (sw ra, 0x3c(sp)).
3. Calling conventions: Code1 uses RIP-relative calls (call qword ptr [rip]) while Code2 uses MIPS jump-and-link register (jalr t9).
4. Control flow: Branch instructions differ (je/jne in Code1 vs beqz/bnez in Code2) with different offset handling.
5. Register usage: Code1 uses Intel registers (r14, r12) while Code2 uses MIPS registers (s0-s5, gp).
6. Instruction sets: No overlapping instructions except basic arithmetic/logic, with architecture-specific operations (e.g., Code2 uses lui for address loading).

These differences indicate completely distinct implementations rather than variations of the same functionality.
------------------------------------------------------------

------------------------------------------------------------
Code1: push { r3 , r4 , r5 , r6 , r7 , r8 , sb , sl , fp , lr } mov r6 , r0 mov r1 , 0x2 bl 0xde0 ldr r4 , [ pc , 0x398 ] mov r3 , 0x0 strb r3 , [ r4 , 0x34 ] str r3 , [ r4 , 0x4 ] mov r0 , r6 bl 0xfffff874 str r0 , [ r4 , 0x50 ] mov r5 , r4 mov sb , 0x0 mov sl , sb ldr r7 , [ pc , 0x374 ] ldr fp , [ pc , 0x374 ] b 0x174 str sb , [ r5 , 0x44 ] ldr r0 , [ r5 , 0x18 ] ldr r3 , [ r5 , 0x10 ] cmp r3 , r0 bgt 0x180 cmp r4 , 0xa cmnne r4 , 0x1 bne 0x2ec cmn r4 , 0x1 beq 0x22c ldr r0 , [ r7 ] ldr r3 , [ r0 , 0x14 ] ldr r2 , [ r0 , 0x18 ] cmp r3 , r2 addlo r2 , r3 , 0x1 strlo r2 , [ r0 , 0x14 ] movlo r2 , 0xa strblo r2 , [ r3 ] bhs 0x23c mov r0 , r6 bl 0xfffff874 mov r4 , r0 cmn r4 , 0x1 cmpne r4 , 0xa beq 0x44 ldr r3 , [ r5 , 0x18 ] ldr r2 , [ r5 , 0x3c ] cmp r3 , r2 blt 0x44 ldr r1 , [ r5 , 0x10 ] ldr r2 , [ r5 , 0x20 ] add r2 , r3 , r2 cmp r2 , r1 bgt 0x44 str r3 , [ r5 , 0x1c ] str r1 , [ r5 , 0x8 ] ldr r3 , [ pc , 0x2e0 ] str r3 , [ r5 , 0x48 ] str fp , [ r5 , 0x24 ] mov r1 , r4 mov r0 , r6 bl 0xfffffd9c mov r8 , r0 bl 0xfffff588 bl 0xfffff4c4 ldrb r3 , [ r5 ] cmp r3 , 0x0 bne 0x14c ldrb r3 , [ r5 , 0xc ] cmp r3 , 0x0 beq 0x248 mov r0 , r8 bl 0xfffff588 cmp r0 , 0x0 beq 0x14c mov r1 , r8 mov r0 , r6 bl 0xfffffd9c mov r8 , r0 bl 0xfffff588 cmp r0 , 0x0 beq 0x14c ldr r2 , [ r5 , 0x10 ] ldr r3 , [ r5 , 0x4 ] cmp r2 , r3 beq 0x120 ldr r4 , [ r5 , 0x24 ] cmp r4 , fp bls 0x2d8 ldrb r3 , [ r4 , - 0x10 ] orr r3 , r3 , 0xa strb r3 , [ r4 , - 0x10 ] str r8 , [ r5 , 0x50 ] bl 0xfffff5dc mov r0 , r4 bl 0xfffffbe8 str sl , [ r5 , 0x30 ] ldr r4 , [ r5 , 0x50 ] b 0x9c bl 0xfffff9e0 ldr r8 , [ r5 , 0x40 ] ldr r3 , [ r5 , 0x44 ] ldr r0 , [ r5 , 0x10 ] cmp r3 , r0 beq 0x1b0 ldrb r1 , [ r8 ] cmp r1 , 0x0 bne 0x310 b 0x354 bl 0xfffff350 b 0x330 mov r3 , r0 b 0x354 mov r3 , r0 sub r0 , r0 , r3 bl 0xfffff9e0 b 0x360 and r1 , r4 , 0xff bl 0xfffff350 b 0x20c mov r0 , r6 bl 0xfffff344 mov r4 , r0 cmp r4 , 0xa cmnne r4 , 0x1 beq 0x64 ldr r0 , [ r7 ] ldr r3 , [ r0 , 0x14 ] ldr r2 , [ r0 , 0x18 ] cmp r3 , r2 addlo r2 , r3 , 0x1 strlo r2 , [ r0 , 0x14 ] strblo r4 , [ r3 ] bhs 0x1c8 ldr r3 , [ r6 , 0x4 ] ldr r2 , [ r6 , 0x8 ] cmp r3 , r2 bhs 0x1d4 add r2 , r3 , 0x1 str r2 , [ r6 , 0x4 ] ldrb r4 , [ r3 ] b 0x1e0 ldr r3 , [ pc , 0x17c ] mvn r2 , 0x0 str r2 , [ r3 , 0x50 ] pop { r3 , r4 , r5 , r6 , r7 , r8 , sb , sl , fp , pc } mov r1 , 0xa bl 0xfffff350 b 0x90 ldrb r3 , [ r5 , 0x14 ] cmp r3 , 0x0 beq 0x2b4 mov r0 , r8 bl 0xfffff588 cmp r0 , 0x0 beq 0x14c ldr r2 , [ r5 , 0x10 ] ldr r3 , [ r5 , 0x8 ] cmp r2 , r3 beq 0x14c mov r1 , r8 mov r0 , r6 bl 0xfffffd9c mov r8 , r0 bl 0xfffff588 cmp r0 , 0x0 beq 0x14c ldr r2 , [ r5 , 0x10 ] ldr r3 , [ r5 , 0x4 ] cmp r2 , r3 beq 0x274 b 0x14c mov r1 , r8 mov r0 , r6 bl 0xfffffd9c mov r8 , r0 mov r0 , r8 bl 0xfffff588 cmp r0 , 0x0 beq 0x14c ldr r2 , [ r5 , 0x10 ] ldr r3 , [ r5 , 0x4 ] cmp r2 , r3 beq 0x2a4 b 0x14c ldr r3 , [ pc , 0xe0 ] ldr r2 , [ pc , 0xe0 ] ldr r1 , [ pc , 0xe0 ] ldr r0 , [ pc , 0xe0 ] bl 0xfffff3c8 bl 0xfffff9e0 ldr r8 , [ r5 , 0x40 ] ldr r3 , [ r5 , 0x44 ] ldr r0 , [ r5 , 0x10 ] cmp r3 , r0 beq 0x1b8 ldrb r1 , [ r8 ] cmp r1 , 0x0 beq 0x1bc ldr r0 , [ r7 ] ldr r3 , [ r0 , 0x14 ] ldr r2 , [ r0 , 0x18 ] cmp r3 , r2 addlo r2 , r3 , 0x1 strlo r2 , [ r0 , 0x14 ] strblo r1 , [ r3 ] bhs 0x1a8 ldr r3 , [ r5 , 0x44 ] add r3 , r3 , 0x1 str r3 , [ r5 , 0x44 ] ldr r0 , [ r5 , 0x10 ] cmp r3 , r0 beq 0x354 ldrb r1 , [ r8 , 0x1 ] ! cmp r1 , 0x0 bne 0x310 cmp r4 , 0xa cmnne r4 , 0x1 bne 0x1bc cmn r4 , 0x1 bne 0x1e0 ldr r3 , [ r5 , 0x18 ] ldr r2 , [ r5 , 0x38 ] add r3 , r3 , r2 ldr r2 , [ r5 , 0x10 ] cmp r3 , r2 bgt 0x1e0 ldr r0 , [ r7 ] ldr r3 , [ r0 , 0x14 ] ldr r2 , [ r0 , 0x18 ] cmp r3 , r2 addlo r2 , r3 , 0x1 strlo r2 , [ r0 , 0x14 ] movlo r2 , 0xa strblo r2 , [ r3 ] blo 0x1e0 mov r1 , 0xa bl 0xfffff350 b 0x1e0 andeq r8 , r2 , r4 , ror 0x2 andeq r8 , r2 , ip , asr r1 strheq r8 , [ r2 ] , -r8 andeq lr , r2 , r8 , lsl pc strdeq r6 , r7 , [ r1 ] , -ip andeq r0 , r0 , lr , asr r2 strdeq r6 , r7 , [ r1 ] , -r8 andeq r6 , r1 , r4 , lsl 0x28
Code2: push { fp , lr } add fp , sp , 0x4 sub sp , sp , 0x8 str r0 , [ fp , - 0x8 ] mov r1 , 0x2 ldr r0 , [ fp , - 0x8 ] bl 0x1934 ldr r3 , [ pc , 0x5c ] mov r2 , 0x0 strb r2 , [ r3 ] ldr r3 , [ pc , 0x54 ] mov r2 , 0x0 str r2 , [ r3 ] ldr r0 , [ fp , - 0x8 ] bl 0x9b0 mov r2 , r0 ldr r3 , [ pc , 0x40 ] str r2 , [ r3 ] b 0x60 bl 0xf54 ldr r3 , [ pc , 0x34 ] ldr r3 , [ r3 ] mov r0 , r3 bl 0x1444 ldr r0 , [ fp , - 0x8 ] bl 0x1c4 mov r3 , r0 cmp r3 , 0x0 bne 0x4c mov r0 , r0 sub sp , fp , 0x4 pop { fp , pc } andeq r3 , r3 , r0 , lsl 0x5 andeq r3 , r3 , ip , lsl 0x5 muleq r3 , r0 , r2 andeq r3 , r3 , ip , ror r2
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly codes are both for ARM architecture and share basic elements like function prologues/epilogues and branch instructions. However, the first code is significantly longer (over 100 instructions) and more complex, featuring multiple loops, conditionals, and extensive register usage (r3-r8, sb, sl, fp, lr). In contrast, the second code is short (about 20 instructions), uses minimal registers (fp, lr), and has a simpler linear structure with one conditional branch. Core functionalities differ substantially—code1 appears to handle input processing with buffering and error checks, while code2 performs straightforward setup and function calls. The stack management also differs: code1 relies solely on push/pop without an explicit frame pointer, while code2 sets up a stack frame. Given these structural, functional, and implementation disparities, the codes are not similar.
------------------------------------------------------------

------------------------------------------------------------
Code1: addiu sp , sp , - 0x28 lui v0 , 0x44 sw s0 , 0x1c ( sp ) sw ra , 0x24 ( sp ) sw s1 , 0x20 ( sp ) lw s0 , 0x4490 ( v0 ) beqz s0 , 0x60 move s1 , a0 b 0x34 lw t9 , ( s0 ) beqz s0 , 0x50 lw ra , 0x24 ( sp ) lw t9 , ( s0 ) move a0 , s1 jalr t9 lw a1 , 0x4 ( s0 ) andi v1 , v0 , 0x3 bnez v1 , 0x28 lw s0 , 0x8 ( s0 ) lw ra , 0x24 ( sp ) lw s1 , 0x20 ( sp ) lw s0 , 0x1c ( sp ) jr ra addiu sp , sp , 0x28 b 0x4c addiu v0 , zero , 0x3
Code2: push ebp mov ebp , esp push esi sub esp , 0x24 mov eax , dword ptr [ ebp + 0x8 ] xor ecx , ecx mov edx , dword ptr [ 0x8083aa0 ] mov esi , dword ptr [ ebp + 0x8 ] mov dword ptr [ esp ] , edx mov dword ptr [ esp + 0x4 ] , 0x3 mov dword ptr [ esp + 0x8 ] , esi mov dword ptr [ esp + 0xc ] , 0x0 mov dword ptr [ ebp - 0x8 ] , eax mov dword ptr [ ebp - 0xc ] , ecx call 0x8b0 add esp , 0x24 pop esi pop ebp ret nop dword ptr [ eax ]
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly codes show fundamental differences in functionality and structure. Code1 (MIPS) implements a loop with conditional branching and linked list traversal, featuring multiple memory accesses and function calls (jalr t9) that depend on dynamic values. Code2 (x86) performs a single function call with static arguments and no branching logic. The instruction sets, calling conventions, and control flow patterns are entirely different, with no overlapping algorithmic purpose or structural similarities.
------------------------------------------------------------

------------------------------------------------------------
Code1: push ebp mov ebp , esp sub esp , 0x18 mov eax , dword ptr [ ebp + 0x8 ] mov ecx , dword ptr [ ebp + 0x8 ] mov dword ptr [ ebp - 0x4 ] , ecx mov ecx , dword ptr [ ebp - 0x4 ] mov ecx , dword ptr [ ecx + 0x8 ] mov dword ptr [ esp ] , ecx mov dword ptr [ ebp - 0x8 ] , eax call 0x7080 mov eax , dword ptr [ ebp - 0x4 ] mov dword ptr [ esp ] , eax call 0xfffec540 add esp , 0x18 pop ebp ret
Code2: lui gp , 0x45 addiu sp , sp , - 0x20 addiu gp , gp , 0x60e0 sw s0 , 0x18 ( sp ) move s0 , a0 sw ra , 0x1c ( sp ) sw gp , 0x10 ( sp ) lw t9 , - 0x7eec ( gp ) bal 0x4be0 lw a0 , 0x8 ( a0 ) move a0 , s0 lw gp , 0x10 ( sp ) lw ra , 0x1c ( sp ) lw s0 , 0x18 ( sp ) lw t9 , - 0x7c64 ( gp ) jr t9 addiu sp , sp , 0x20
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two code snippets are from different architectures (x86 vs MIPS) with fundamentally different instruction sets and calling conventions. The first uses x86-specific registers (ebp, esp, eax, ecx) and instructions (push, mov, sub, call, pop, ret), while the second uses MIPS-specific registers (gp, sp, s0, ra, t9, a0) and instructions (lui, addiu, sw, move, lw, bal, jr). The structure and operations show no meaningful similarity beyond generic function prologue/epilogue patterns, which are implemented differently. The absence of overlapping instructions, register usage, or control flow patterns confirms they are not similar.
------------------------------------------------------------

------------------------------------------------------------
Code1: str lr , [ sp , - 0x4 ] ! sub sp , sp , 0x24 str r0 , [ sp , 0xc ] str r1 , [ sp , 0x8 ] str r2 , [ sp , 0x4 ] str r3 , [ sp ] ldr r3 , [ pc , 0x50 ] ldr r3 , [ r3 ] str r3 , [ sp , 0x1c ] ldr r3 , [ sp , 0x4 ] str r3 , [ sp , 0x14 ] ldr r3 , [ sp ] str r3 , [ sp , 0x18 ] add r3 , sp , 0x14 mov r2 , 0x0 ldr r1 , [ sp , 0x8 ] ldr r0 , [ sp , 0xc ] bl 0xfff0daf0 mov r3 , r0 mov r0 , r3 ldr r3 , [ pc , 0x18 ] ldr r2 , [ sp , 0x1c ] ldr r3 , [ r3 ] cmp r2 , r3 beq 0x68 bl 0xffde5a90 add sp , sp , 0x24 pop { pc } eoreq r4 , sl , r0 , lsl 0x30
Code2: push rbp mov rbp , rsp sub rsp , 0x30 xor eax , eax mov r8d , eax mov qword ptr [ rbp - 0x8 ] , rdi mov dword ptr [ rbp - 0xc ] , esi mov qword ptr [ rbp - 0x18 ] , rdx mov qword ptr [ rbp - 0x20 ] , rcx mov rcx , qword ptr [ rbp - 0x18 ] mov qword ptr [ rbp - 0x30 ] , rcx mov rcx , qword ptr [ rbp - 0x20 ] mov qword ptr [ rbp - 0x28 ] , rcx mov rdi , qword ptr [ rbp - 0x8 ] mov esi , dword ptr [ rbp - 0xc ] lea rcx , [ rbp - 0x30 ] mov rdx , r8 call 0xffffffffffee7e60 mov esi , eax mov eax , esi add rsp , 0x30 pop rbp ret nop dword ptr [ rax ]
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The first code is ARM assembly (using registers like r0-r3, lr, sp, and instructions like str/ldr/bl), while the second is x86_64 assembly (using registers like rbp/rsp/rax and instructions like push/mov/call). The architectures are fundamentally different—ARM uses load/store with PC-relative addressing, while x86
------------------------------------------------------------

------------------------------------------------------------
Code1: push ebp push edi push esi push ebx call 0x5 add ebx , 0x2 sub esp , 0x3c mov ebp , dword ptr [ esp + 0x78 ] mov eax , dword ptr [ esp + 0x54 ] mov esi , dword ptr [ esp + 0x6c ] mov edx , dword ptr [ esp + 0x5c ] mov ecx , dword ptr [ esp + 0x64 ] mov edi , dword ptr [ esp + 0x74 ] mov dword ptr [ esp + 0x1c ] , ebp mov ebp , dword ptr [ esp + 0x80 ] mov dword ptr [ esp + 0x8 ] , eax mov dword ptr [ esp + 0x14 ] , esi mov eax , dword ptr gs : [ 0x14 ] mov dword ptr [ esp + 0x2c ] , eax xor eax , eax test ebp , ebp mov dword ptr [ esp + 0xc ] , edx mov dword ptr [ esp + 0x10 ] , ecx mov dword ptr [ esp + 0x18 ] , edi mov esi , dword ptr [ esp + 0x7c ] je 0x1f1 cmp esi , 0x80 mov eax , 0x80 mov dword ptr [ ebp ] , 0x0 cmova esi , eax sub esp , 0xc push esi call 0x7b mov dword ptr [ esp ] , 0x2538 mov edi , eax call 0x89 add esp , 0x10 test eax , eax mov edx , eax je 0x9a test edi , edi jne 0xe8 test edx , edx je 0xaa sub esp , 0xc push edx call 0xa3 add esp , 0x10 test edi , edi mov esi , 0xd je 0xc7 mov dword ptr [ esp + 0x8 ] , esi sub esp , 0xc push edi call 0xbc add esp , 0x10 mov esi , dword ptr [ esp + 0x8 ] mov edi , dword ptr [ esp + 0x2c ] xor edi , dword ptr gs : [ 0x14 ] mov eax , esi jne 0x207 add esp , 0x3c pop ebx pop esi pop edi pop ebp ret lea esi , [ esi ] sub esp , 0x4 push esi push dword ptr [ esp + 0x68 ] push dword ptr [ esp + 0x18 ] push dword ptr [ esp + 0x68 ] push dword ptr [ esp + 0x1c ] push dword ptr [ esp + 0x68 ] push eax mov dword ptr [ esp + 0x28 ] , eax call 0x106 add esp , 0x20 test eax , eax mov edx , dword ptr [ esp + 0x8 ] jne 0x146 mov ecx , dword ptr [ esp + 0x10 ] test ecx , ecx jne 0x170 mov eax , dword ptr [ esp + 0x68 ] test eax , eax jne 0x170 push dword ptr [ esp + 0x18 ] push dword ptr [ esp + 0x74 ] push dword ptr [ esp + 0x1c ] push edx mov dword ptr [ esp + 0x18 ] , edx call 0x137 add esp , 0x10 test eax , eax mov edx , dword ptr [ esp + 0x8 ] je 0x198 mov dword ptr [ esp + 0x8 ] , eax sub esp , 0xc push edx call 0x14f mov dword ptr [ esp ] , edi call 0x157 add esp , 0x10 mov esi , dword ptr [ esp + 0x8 ] jmp 0xc7 mov esi , esi lea edi , [ edi ] sub esp , 0x4 push dword ptr [ esp + 0x6c ] push dword ptr [ esp + 0x18 ] push edx mov dword ptr [ esp + 0x18 ] , edx call 0x181 add esp , 0x10 test eax , eax mov edx , dword ptr [ esp + 0x8 ] jne 0x146 jmp 0x125 lea esi , [ esi ] mov dword ptr [ esp + 0x28 ] , esi sub esp , 0x4 lea ecx , [ esp + 0x2c ] push ecx push edi push edx mov dword ptr [ esp + 0x18 ] , edx call 0x1ab add esp , 0x10 test eax , eax mov edx , dword ptr [ esp + 0x8 ] jne 0x146 cmp dword ptr [ esp + 0x28 ] , esi jb 0x146 mov dword ptr [ esp + 0xc ] , eax sub esp , 0x4 push esi push dword ptr [ esp + 0x24 ] push edi call 0x1ce add esp , 0x10 test eax , eax mov edx , dword ptr [ esp + 0x8 ] mov eax , dword ptr [ esp + 0xc ] jne 0x146 mov dword ptr [ ebp ] , 0x1 jmp 0x146 lea ebp , [ ebx ] lea edi , [ ebx ] push esi push 0x31 push ebp push edi call 0x203 call 0x208
Code2: push rbp mov rbp , rsp push r15 push r14 push r13 push r12 push rbx sub rsp , 0x28 mov qword ptr [ rbp - 0x30 ] , r9 mov qword ptr [ rbp - 0x50 ] , r8 mov qword ptr [ rbp - 0x48 ] , rcx mov qword ptr [ rbp - 0x40 ] , rdx mov qword ptr [ rbp - 0x38 ] , rsi mov r14d , edi mov rcx , qword ptr [ rbp + 0x40 ] mov eax , dword ptr [ rip ] test eax , eax jne 0x1de mov al , byte ptr [ rip ] xor al , 0xe4 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xb8 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x3f mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xd3 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x72 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x25 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xd1 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xeb mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xb4 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x75 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x11 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xbc mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x9a movaps xmm0 , xmmword ptr [ rip ] xorps xmm0 , xmmword ptr [ rip ] movaps xmmword ptr [ rip ] , xmm0 movaps xmm0 , xmmword ptr [ rip ] xorps xmm0 , xmmword ptr [ rip ] mov byte ptr [ rip ] , al movaps xmmword ptr [ rip ] , xmm0 mov al , byte ptr [ rip ] xor al , 0xe1 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x4b mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] not al mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x1d mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x9b mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x66 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x1 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x4c mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xec mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xf2 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x72 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x49 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xa2 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x3f mov byte ptr [ rip ] , al mov dword ptr [ rip ] , 0x1 mov r13 , rsp add r13 , - 0x10 mov rsp , r13 test rcx , rcx je 0x322 mov rax , qword ptr [ rbp + 0x38 ] mov dword ptr [ rcx ] , 0x0 cmp rax , 0x80 mov ebx , 0x80 cmovb rbx , rax mov rdi , rbx call 0x21c mov r15 , rax mov edi , 0x2548 call 0x229 mov r12 , rax test r15 , r15 je 0x2f0 test r12 , r12 je 0x2f0 sub rsp , 0x8 mov rdi , r12 mov esi , r14d mov rdx , qword ptr [ rbp - 0x38 ] mov rcx , qword ptr [ rbp - 0x40 ] mov r8 , qword ptr [ rbp - 0x48 ] mov r9 , qword ptr [ rbp - 0x50 ] push rbx call 0x25e add rsp , 0x10 mov r14d , eax test eax , eax jne 0x2e6 mov rdx , qword ptr [ rbp + 0x10 ] cmp qword ptr [ rbp - 0x30 ] , 0x0 jne 0x279 test rdx , rdx je 0x28c mov rdi , r12 mov rsi , qword ptr [ rbp - 0x30 ] call 0x285 mov r14d , eax test eax , eax jne 0x2e6 mov rcx , qword ptr [ rbp + 0x28 ] mov rdx , qword ptr [ rbp + 0x20 ] mov rsi , qword ptr [ rbp + 0x18 ] mov rdi , r12 call 0x2a0 mov r14d , eax test eax , eax jne 0x2e6 mov qword ptr [ r13 ] , rbx mov rdi , r12 mov rsi , r15 mov rdx , r13 call 0x2b9 mov r14d , eax test eax , eax jne 0x2e6 xor r14d , r14d cmp qword ptr [ r13 ] , rbx jb 0x2e6 mov rsi , qword ptr [ rbp + 0x30 ] mov rdi , r15 mov rdx , rbx call 0x2d8 test eax , eax jne 0x2e6 mov rax , qword ptr [ rbp + 0x40 ] mov dword ptr [ rax ] , 0x1 mov rdi , r12 call 0x2ee jmp 0x308 test r12 , r12 je 0x2fd mov rdi , r12 call 0x2fd mov r14d , 0xd test r15 , r15 je 0x310 mov rdi , r15 call 0x310 mov eax , r14d lea rsp , [ rbp - 0x28 ] pop rbx pop r12 pop r13 pop r14 pop r15 pop rbp ret mov edi , 0x0 mov esi , 0x0 mov edx , 0x31 call 0x336
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly code snippets are fundamentally dissimilar due to key differences:
1. Architecture: Code1 uses 32-bit registers (ebp, eax, esi) while Code2 uses 64-bit registers (rbp, rsp, r15)
2. Stack management: Code1 manipulates esp (32-bit stack pointer) with fixed offsets like +0x78, while Code2 uses rbp-relative addressing (e.g., [rbp - 0x30])
3. Calling conventions: Code1 passes arguments via stack (push instructions), whereas Code2 uses register-based parameter passing (rdi, rsi, etc.)
4. Core logic: Code1 focuses on conditional jumps and memory operations, while Code2 features extensive byte-level manipulation (xor/not operations) and XMM register usage
5. Prologue/epilogue: Code1 uses traditional push/pop sequence for register preservation, while Code2 employs RSP-relative pushes and modern red-zone optimizations

The architectural differences (32-bit vs 64-bit) alone make functional similarity impossible, and the operational patterns show no significant overlap.
------------------------------------------------------------

------------------------------------------------------------
Code1: push ebx call 0xfff24070 add ebx , 0x20dc26 sub esp , 0x8 mov edx , dword ptr [ esp + 0x10 ] mov eax , dword ptr [ edx + 0x10 ] test eax , eax je 0x48 lea eax , [ ebx - 0xe6600 ] sub esp , 0x8 push 0x1 push 0x1 push eax lea eax , [ ebx - 0x20dd5c ] push edx push eax lea eax , [ ebx + 0xdf80 ] push eax call 0xd0230 add esp , 0x20 add esp , 0x8 pop ebx ret lea esi , [ esi ] add esp , 0x8 mov eax , 0x1 pop ebx ret lea esi , [ esi ] lea edi , [ edi ]
Code2: cmp qword ptr [ rdi + 0x20 ] , 0x0 je 0x2a mov rdx , rdi mov edi , 0x90c820 mov esi , 0x4f2150 mov ecx , 0x625970 mov r8d , 0x1 mov r9d , 0x1 jmp 0xc8190 mov eax , 0x1 ret
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly codes are from entirely different architectures (32-bit vs 64-bit) with incompatible instruction sets and register usage. Code1 uses 32-bit registers (ebx, esp, eax, edx) and stack-based operations with 32-bit memory addressing (dword ptr), while Code2 uses 64-bit registers (rdi, rdx) and 64-bit memory operations (qword ptr). The control flow patterns, function call mechanisms, and operand sizes are fundamentally different. No meaningful similarity exists beyond basic low-level instructions (mov, ret) common to all x86 code.
------------------------------------------------------------

------------------------------------------------------------
Code1: addiu sp , sp , - 0x20 sw ra , 0x1c ( sp ) lui gp , 0x43 addiu gp , gp , 0x60f0 addiu v1 , zero , - 0x1 beq a1 , v1 , 0x44 sw gp , 0x10 ( sp ) move v0 , a1 move a1 , a2 move a0 , v0 lw t9 , - 0x7de0 ( gp ) jalr t9 nop lw gp , 0x10 ( sp ) lw ra , 0x1c ( sp ) jr ra addiu sp , sp , 0x20 move a1 , a2 lw t9 , - 0x7d9c ( gp ) jalr t9 nop lw gp , 0x10 ( sp ) b 0x3c lw ra , 0x1c ( sp )
Code2: push ebp mov ebp , esp push esi sub esp , 0x34 mov eax , dword ptr [ ebp + 0x10 ] mov ecx , dword ptr [ ebp + 0xc ] mov edx , dword ptr [ ebp + 0x8 ] mov esi , dword ptr [ ebp + 0xc ] mov dword ptr [ ebp - 0x8 ] , esi mov dword ptr [ ebp - 0x10 ] , 0xfbeeeefd mov dword ptr [ ebp - 0x14 ] , eax mov dword ptr [ ebp - 0x18 ] , ecx mov dword ptr [ ebp - 0x1c ] , edx mov eax , dword ptr [ ebp - 0x10 ] mov ecx , eax sub ecx , 0xfbeeeefd mov dword ptr [ ebp - 0x20 ] , eax mov dword ptr [ ebp - 0x24 ] , ecx je 0x89 jmp 0x42 mov eax , dword ptr [ ebp - 0x20 ] sub eax , 0x54fb648b mov dword ptr [ ebp - 0x28 ] , eax je 0xa4 jmp 0x58 mov eax , dword ptr [ ebp - 0x20 ] sub eax , 0x75be9ed7 mov dword ptr [ ebp - 0x2c ] , eax je 0xc5 jmp 0x6e mov eax , dword ptr [ ebp - 0x20 ] sub eax , 0x7981b584 mov dword ptr [ ebp - 0x30 ] , eax je 0xe6 jmp 0x84 jmp 0xef mov eax , dword ptr [ ebp - 0x8 ] cmp eax , - 0x1 mov eax , 0x54fb648b mov ecx , 0x75be9ed7 cmovne ecx , eax mov dword ptr [ ebp - 0x10 ] , ecx jmp 0xef mov eax , dword ptr [ ebp + 0xc ] mov ecx , dword ptr [ ebp + 0x10 ] mov dword ptr [ esp ] , eax mov dword ptr [ esp + 0x4 ] , ecx call 0xfffd4230 mov dword ptr [ ebp - 0xc ] , eax mov dword ptr [ ebp - 0x10 ] , 0x7981b584 jmp 0xef mov eax , dword ptr [ ebp + 0x8 ] mov ecx , dword ptr [ ebp + 0x10 ] mov dword ptr [ esp ] , eax mov dword ptr [ esp + 0x4 ] , ecx call 0xfffd4100 mov dword ptr [ ebp - 0xc ] , eax mov dword ptr [ ebp - 0x10 ] , 0x7981b584 jmp 0xef mov eax , dword ptr [ ebp - 0xc ] add esp , 0x34 pop esi pop ebp ret jmp 0x26 nop word ptr cs : [ eax + eax ] nop
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly codes are fundamentally dissimilar due to multiple factors:
1. Architecture Difference: Code1 uses MIPS instructions (e.g., addiu, lui, jalr) while Code2 uses x86 instructions (e.g., push, mov, call).
2. Control Flow Structure: Code1 has a simple conditional branch (beq) and two function call paths. Code2 features complex jump tables with multiple conditional blocks and four distinct function call possibilities.
3. Register Usage: MIPS relies on registers like gp, ra, and a0-a2, while x86 uses ebp, esp, eax, and ecx with memory operands.
4. Stack Management: Code1 adjusts the stack by a fixed size (-0x20) with explicit ra saves. Code2 uses variable local storage (-0x34) and preserves registers via push/pop.
5. Constants/Operands: Code2 contains
------------------------------------------------------------

------------------------------------------------------------
Code1: push ebp mov ebp , esp push ebx push edi push esi sub esp , 0x5c mov eax , dword ptr [ ebp + 0xc ] mov ecx , dword ptr [ ebp + 0x8 ] mov dword ptr [ ebp - 0x10 ] , eax mov dword ptr [ ebp - 0x14 ] , ecx mov eax , esp add eax , - 0x10 mov esp , eax mov ecx , esp add ecx , - 0x10 mov esp , ecx mov edx , esp add edx , - 0x10 mov esp , edx mov esi , esp add esi , - 0x10 mov esp , esi mov edi , esp add edi , - 0x10 mov esp , edi mov ebx , esp add ebx , - 0x10 mov esp , ebx mov dword ptr [ ebp - 0x18 ] , eax mov eax , esp add eax , - 0x10 mov esp , eax mov dword ptr [ ebp - 0x1c ] , eax mov eax , esp add eax , - 0x10 mov esp , eax mov dword ptr [ ebp - 0x20 ] , eax mov eax , esp add eax , - 0x10 mov esp , eax mov dword ptr [ ebp - 0x24 ] , eax mov eax , dword ptr [ ebp - 0x18 ] mov dword ptr [ ebp - 0x28 ] , ecx mov ecx , dword ptr [ ebp - 0x14 ] mov dword ptr [ eax ] , ecx mov eax , dword ptr [ ebp - 0x28 ] mov ecx , dword ptr [ ebp - 0x10 ] mov dword ptr [ eax ] , ecx mov eax , dword ptr [ ebp - 0x18 ] mov eax , dword ptr [ eax ] sub esp , 0x10 mov ecx , esp mov dword ptr [ ecx ] , eax mov dword ptr [ ebp - 0x2c ] , edx mov dword ptr [ ebp - 0x30 ] , esi mov dword ptr [ ebp - 0x34 ] , edi mov dword ptr [ ebp - 0x38 ] , ebx call 0xffffe0a0 add esp , 0x10 add eax , 0x1 mov ecx , dword ptr [ ebp - 0x2c ] mov dword ptr [ ecx ] , eax mov eax , dword ptr [ ebp - 0x18 ] mov edx , dword ptr [ eax ] sub esp , 0x10 mov dword ptr [ esp ] , edx call 0x760 add esp , 0x10 mov ecx , dword ptr [ ebp - 0x38 ] mov dword ptr [ ecx ] , eax cmp dword ptr [ ecx ] , 0x0 setne al mov byte ptr [ ebp - 0x39 ] , al mov al , byte ptr [ ebp - 0x39 ] test al , 0x1 jne 0xcc jmp 0x14b mov eax , dword ptr [ ebp - 0x28 ] mov ecx , dword ptr [ eax ] sub esp , 0x10 mov edx , esp mov dword ptr [ edx ] , ecx call 0xffffe0a0 add esp , 0x10 mov ecx , dword ptr [ ebp - 0x1c ] mov dword ptr [ ecx ] , eax mov eax , dword ptr [ ebp - 0x38 ] mov edx , dword ptr [ eax ] imul edx , dword ptr [ ecx ] mov esi , dword ptr [ ebp - 0x20 ] mov dword ptr [ esi ] , edx mov edx , dword ptr [ esi ] sub edx , dword ptr [ eax ] mov edi , dword ptr [ ebp - 0x2c ] add edx , dword ptr [ edi ] mov dword ptr [ edi ] , edx mov eax , 0x7fffffff xor edx , edx mov ebx , dword ptr [ ebp - 0x38 ] div dword ptr [ ebx ] cmp eax , dword ptr [ ecx ] setb al mov byte ptr [ ebp - 0x3a ] , al mov al , byte ptr [ ebp - 0x3a ] test al , 0x1 jne 0x141 jmp 0x121 mov eax , dword ptr [ ebp - 0x2c ] mov ecx , dword ptr [ eax ] mov edx , dword ptr [ ebp - 0x20 ] cmp ecx , dword ptr [ edx ] setb bl mov byte ptr [ ebp - 0x3b ] , bl mov al , byte ptr [ ebp - 0x3b ] test al , 0x1 jne 0x141 jmp 0x146 call 0x8c90 jmp 0x14b mov eax , dword ptr [ ebp - 0x2c ] mov ecx , dword ptr [ eax ] sub esp , 0x10 mov dword ptr [ esp ] , ecx call 0x84b0 add esp , 0x10 mov ecx , dword ptr [ ebp - 0x30 ] mov dword ptr [ ecx ] , eax mov edx , dword ptr [ ebp - 0x34 ] mov dword ptr [ edx ] , eax jmp 0x16d mov eax , dword ptr [ ebp - 0x18 ] mov ecx , dword ptr [ eax ] cmp byte ptr [ ecx ] , 0x0 setne dl mov byte ptr [ ebp - 0x3c ] , dl mov al , byte ptr [ ebp - 0x3c ] test al , 0x1 jne 0x18b jmp 0x2aa mov eax , dword ptr [ ebp - 0x18 ] mov ecx , dword ptr [ eax ] movsx ecx , byte ptr [ ecx ] cmp ecx , 0x26 sete dl mov byte ptr [ ebp - 0x3d ] , dl mov al , byte ptr [ ebp - 0x3d ] test al , 0x1 jne 0x1ac jmp 0x286 mov eax , dword ptr [ ebp - 0x28 ] mov ecx , dword ptr [ eax ] mov edx , dword ptr [ ebp - 0x24 ] mov dword ptr [ edx ] , ecx call 0xffffe230 mov eax , dword ptr [ eax ] mov ecx , dword ptr [ ebp - 0x24 ] mov edx , dword ptr [ ecx ] sub esp , 0x10 movsx edx , byte ptr [ edx ] mov dword ptr [ esp ] , edx mov dword ptr [ ebp - 0x44 ] , eax call 0x810 add esp , 0x10 movzx ecx , al mov edx , dword ptr [ ebp - 0x44 ] movzx ecx , word ptr [ edx + ecx * 0x2 ] and ecx , 0x200 cmp ecx , 0x0 setne al mov byte ptr [ ebp - 0x45 ] , al mov al , byte ptr [ ebp - 0x45 ] test al , 0x1 jne 0x1ff jmp 0x23d mov eax , dword ptr [ ebp - 0x24 ] mov ecx , dword ptr [ eax ] mov edx , ecx add edx , 0x1 mov dword ptr [ eax ] , edx sub esp , 0x10 movsx ecx , byte ptr [ ecx ] mov dword ptr [ esp ] , ecx call 0x810 add esp , 0x10 movzx ecx , al sub esp , 0x10 mov dword ptr [ esp ] , ecx call 0xffffe170 add esp , 0x10 mov bl , al mov eax , dword ptr [ ebp - 0x34 ] mov ecx , dword ptr [ eax ] mov edx , ecx add edx , 0x1 mov dword ptr [ eax ] , edx mov byte ptr [ ecx ] , bl jmp 0x242 mov eax , dword ptr [ ebp - 0x24 ] mov ecx , dword ptr [ eax ] cmp byte ptr [ ecx ] , 0x0 setne dl mov byte ptr [ ebp - 0x46 ] , dl mov al , byte ptr [ ebp - 0x46 ] test al , 0x1 jne 0x260 jmp 0x281 mov eax , dword ptr [ ebp - 0x24 ] mov ecx , dword ptr [ eax ] mov edx , ecx add edx , 0x1 mov dword ptr [ eax ] , edx mov bl , byte ptr [ ecx ] mov ecx , dword ptr [ ebp - 0x34 ] mov edx , dword ptr [ ecx ] mov esi , edx add esi , 0x1 mov dword ptr [ ecx ] , esi mov byte ptr [ edx ] , bl jmp 0x242 jmp 0x29b mov eax , dword ptr [ ebp - 0x18 ] mov ecx , dword ptr [ eax ] mov dl , byte ptr [ ecx ] mov ecx , dword ptr [ ebp - 0x34 ] mov esi , dword ptr [ ecx ] mov edi , esi add edi , 0x1 mov dword ptr [ ecx ] , edi mov byte ptr [ esi ] , dl mov eax , dword ptr [ ebp - 0x18 ] mov ecx , dword ptr [ eax ] add ecx , 0x1 mov dword ptr [ eax ] , ecx jmp 0x16d mov eax , dword ptr [ ebp - 0x34 ] mov ecx , dword ptr [ eax ] mov byte ptr [ ecx ] , 0x0 mov ecx , dword ptr [ ebp - 0x30 ] mov eax , dword ptr [ ecx ] mov dword ptr [ ebp - 0x4c ] , eax mov eax , dword ptr [ ebp - 0x4c ] lea esp , [ ebp - 0xc ] pop esi pop edi pop ebx pop ebp ret mov eax , esp add eax , - 0x10 mov esp , eax mov ecx , esp add ecx , - 0x10 mov esp , ecx mov edx , esp add edx , - 0x10 mov esp , edx mov esi , esp add esi , - 0x10 mov esp , esi mov esi , esp add esi , - 0x10 mov esp , esi mov esi , esp add esi , - 0x10 mov esp , esi mov edi , dword ptr [ ebp - 0x14 ] mov dword ptr [ eax ] , edi mov ebx , dword ptr [ ebp - 0x10 ] mov dword ptr [ ecx ] , ebx mov ecx , dword ptr [ eax ] sub esp , 0x10 mov edi , esp mov dword ptr [ edi ] , ecx mov dword ptr [ ebp - 0x50 ] , eax mov dword ptr [ ebp - 0x54 ] , edx mov dword ptr [ ebp - 0x58 ] , esi call 0xffffe0a0 add esp , 0x10 add eax , 0x1 mov ecx , dword ptr [ ebp - 0x54 ] mov dword ptr [ ecx ] , eax mov eax , dword ptr [ ebp - 0x50 ] mov edx , dword ptr [ eax ] sub esp , 0x10 mov dword ptr [ esp ] , edx call 0x760 add esp , 0x10 mov ecx , dword ptr [ ebp - 0x58 ] mov dword ptr [ ecx ] , eax jmp 0x15 mov eax , dword ptr [ ebp - 0x28 ] mov ecx , dword ptr [ eax ] sub esp , 0x10 mov edx , esp mov dword ptr [ edx ] , ecx call 0xffffe0a0 add esp , 0x10 mov ecx , dword ptr [ ebp - 0x1c ] mov dword ptr [ ecx ] , eax mov eax , dword ptr [ ebp - 0x38 ] mov edx , dword ptr [ eax ] mov esi , dword ptr [ ecx ] imul edx , esi mov esi , dword ptr [ ebp - 0x20 ] mov dword ptr [ esi ] , edx mov edx , dword ptr [ esi ] mov edi , dword ptr [ eax ] sub edx , edi mov edi , dword ptr [ ebp - 0x2c ] mov ebx , dword ptr [ edi ] add ebx , edx mov dword ptr [ edi ] , ebx jmp 0xcc jmp 0x121 call 0x8c90 jmp 0x141 jmp 0x146 mov eax , dword ptr [ ebp - 0x2c ] mov ecx , dword ptr [ eax ] sub esp , 0x10 mov dword ptr [ esp ] , ecx call 0x84b0 add esp , 0x10 mov ecx , dword ptr [ ebp - 0x30 ] mov dword ptr [ ecx ] , eax mov edx , dword ptr [ ebp - 0x34 ] mov dword ptr [ edx ] , eax jmp 0x14b jmp 0x16d jmp 0x18b mov eax , dword ptr [ ebp - 0x28 ] mov ecx , dword ptr [ eax ] mov edx , dword ptr [ ebp - 0x24 ] mov dword ptr [ edx ] , ecx mov ecx , dword ptr [ edx ] sub esp , 0x10 movsx ecx , byte ptr [ ecx ] mov dword ptr [ esp ] , ecx call 0x810 add esp , 0x10 mov byte ptr [ ebp - 0x59 ] , al jmp 0x1ac jmp 0x242 mov eax , dword ptr [ ebp - 0x24 ] mov ecx , dword ptr [ eax ] mov edx , ecx add edx , 0x1 mov dword ptr [ eax ] , edx mov bl , byte ptr [ ecx ] mov ecx , dword ptr [ ebp - 0x34 ] mov edx , dword ptr [ ecx ] mov esi , edx add esi , 0x1 mov dword ptr [ ecx ] , esi mov byte ptr [ edx ] , bl jmp 0x260 mov eax , dword ptr [ ebp - 0x34 ] mov ecx , dword ptr [ eax ] mov byte ptr [ ecx ] , 0x0 jmp 0x2aa nop dword ptr [ eax ]
Code2: push ebp mov ebp , esp push edi push esi sub esp , 0x30 mov eax , dword ptr [ ebp + 0xc ] mov ecx , dword ptr [ ebp + 0x8 ] xor edx , edx mov esi , dword ptr [ ebp + 0x8 ] mov edi , esp mov dword ptr [ edi ] , esi mov dword ptr [ ebp - 0x28 ] , eax mov dword ptr [ ebp - 0x2c ] , ecx mov dword ptr [ ebp - 0x30 ] , edx call 0xffffee50 mov ecx , dword ptr [ ebp - 0x30 ] sub ecx , eax mov eax , dword ptr [ ebp - 0x30 ] sub eax , 0x1 add ecx , eax mov eax , dword ptr [ ebp - 0x30 ] sub eax , ecx mov dword ptr [ ebp - 0xc ] , eax mov eax , dword ptr [ ebp + 0x8 ] mov dword ptr [ esp ] , eax call 0x340 mov dword ptr [ ebp - 0x18 ] , eax cmp dword ptr [ ebp - 0x18 ] , 0x0 je 0xae mov eax , dword ptr [ ebp + 0xc ] mov ecx , esp mov dword ptr [ ecx ] , eax call 0xffffee50 mov dword ptr [ ebp - 0x1c ] , eax mov eax , dword ptr [ ebp - 0x18 ] imul eax , dword ptr [ ebp - 0x1c ] mov dword ptr [ ebp - 0x20 ] , eax mov eax , dword ptr [ ebp - 0x20 ] sub eax , dword ptr [ ebp - 0x18 ] mov ecx , dword ptr [ ebp - 0xc ] add ecx , 0x40437d74 add ecx , eax sub ecx , 0x40437d74 mov dword ptr [ ebp - 0xc ] , ecx mov eax , 0x7fffffff xor edx , edx div dword ptr [ ebp - 0x18 ] cmp eax , dword ptr [ ebp - 0x1c ] jb 0xa4 mov eax , dword ptr [ ebp - 0xc ] cmp eax , dword ptr [ ebp - 0x20 ] jae 0xa9 call 0x3db0 jmp 0xae mov eax , dword ptr [ ebp - 0xc ] mov dword ptr [ esp ] , eax call 0x3a30 mov dword ptr [ ebp - 0x10 ] , eax mov dword ptr [ ebp - 0x14 ] , eax mov eax , dword ptr [ ebp + 0x8 ] cmp byte ptr [ eax ] , 0x0 je 0x196 mov eax , dword ptr [ ebp + 0x8 ] movsx eax , byte ptr [ eax ] cmp eax , 0x26 jne 0x176 mov eax , dword ptr [ ebp + 0xc ] mov dword ptr [ ebp - 0x24 ] , eax call 0xffffefe0 mov eax , dword ptr [ eax ] mov ecx , dword ptr [ ebp - 0x24 ] movsx ecx , byte ptr [ ecx ] mov dword ptr [ esp ] , ecx mov dword ptr [ ebp - 0x34 ] , eax call 0x3a0 movzx ecx , al mov edx , dword ptr [ ebp - 0x34 ] movzx ecx , word ptr [ edx + ecx * 0x2 ] and ecx , 0x200 cmp ecx , 0x0 je 0x141 mov eax , dword ptr [ ebp - 0x24 ] mov ecx , eax add ecx , 0x1 mov dword ptr [ ebp - 0x24 ] , ecx movsx eax , byte ptr [ eax ] mov dword ptr [ esp ] , eax call 0x3a0 movzx ecx , al mov dword ptr [ esp ] , ecx call 0xffffef20 mov dl , al mov eax , dword ptr [ ebp - 0x14 ] mov ecx , eax add ecx , 0x1 mov dword ptr [ ebp - 0x14 ] , ecx mov byte ptr [ eax ] , dl jmp 0x146 mov eax , dword ptr [ ebp - 0x24 ] cmp byte ptr [ eax ] , 0x0 je 0x171 mov eax , dword ptr [ ebp - 0x24 ] mov ecx , eax add ecx , 0x1 mov dword ptr [ ebp - 0x24 ] , ecx mov dl , byte ptr [ eax ] mov eax , dword ptr [ ebp - 0x14 ] mov ecx , eax add ecx , 0x1 mov dword ptr [ ebp - 0x14 ] , ecx mov byte ptr [ eax ] , dl jmp 0x146 jmp 0x188 mov eax , dword ptr [ ebp + 0x8 ] mov cl , byte ptr [ eax ] mov eax , dword ptr [ ebp - 0x14 ] mov edx , eax add edx , 0x1 mov dword ptr [ ebp - 0x14 ] , edx mov byte ptr [ eax ] , cl mov eax , dword ptr [ ebp + 0x8 ] add eax , 0x1 mov dword ptr [ ebp + 0x8 ] , eax jmp 0xbf mov eax , dword ptr [ ebp - 0x14 ] mov byte ptr [ eax ] , 0x0 mov eax , dword ptr [ ebp - 0x10 ] add esp , 0x30 pop esi pop edi pop ebp ret nop word ptr cs : [ eax + eax ]
Similarity: -1
Label: 1
Similarity Score: 0.4
Explanation: Both codes are string processing functions that handle the '&' character specially. However
------------------------------------------------------------

------------------------------------------------------------
Code1: push rbp mov rbp , rsp sub rsp , 0x10 mov qword ptr [ rbp - 0x8 ] , rdi mov rdi , qword ptr [ rbp - 0x8 ] movabs rsi , 0x6a5af0 call 0xfffffffffffc7ce0 add rsp , 0x10 pop rbp ret nop word ptr cs : [ rax + rax ] nop
Code2: push ebx sub esp , 0x8 call 0xffeb32fe add eax , 0x1919b6 sub esp , 0x8 lea edx , [ eax - 0x6efc ] push edx push dword ptr [ esp + 0x1c ] mov ebx , eax call 0xfffd1a23 add esp , 0x10 nop add esp , 0x8 pop ebx ret
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly codes show significant differences in architecture, structure, and operations. Code1 uses 64-bit registers (rbp, rsp, rdi, rsi) and features a single function call after setting up arguments. Code2 employs 32-bit registers (ebx, esp, eax, edx), includes arithmetic operations (add/sub), and makes two function calls. The stack management, register usage, and instruction sequences are fundamentally different, indicating no meaningful similarity in functionality or implementation.
------------------------------------------------------------

------------------------------------------------------------
Code1: push rbp mov rbp , rsp sub rsp , 0x100 mov qword ptr [ rbp - 0x10 ] , rdi mov qword ptr [ rbp - 0x18 ] , rsi mov qword ptr [ rbp - 0x20 ] , rdx mov qword ptr [ rbp - 0x28 ] , rcx mov qword ptr [ rbp - 0x30 ] , r8 test byte ptr [ 0x6539e9 ] , 0x1 mov al , 0x1 mov byte ptr [ rbp - 0xd9 ] , al jne 0x47 cmp qword ptr [ 0x6539c8 ] , 0x0 setne al mov byte ptr [ rbp - 0xd9 ] , al mov al , byte ptr [ rbp - 0xd9 ] xor ecx , ecx mov dl , cl and al , 0x1 mov byte ptr [ rbp - 0x61 ] , al mov al , byte ptr [ 0x6539e9 ] and al , 0x1 movzx ecx , al sub ecx , 0x1 movsxd rsi , ecx mov qword ptr [ rbp - 0x70 ] , rsi test byte ptr [ 0x6539e9 ] , 0x1 mov byte ptr [ rbp - 0xda ] , dl je 0x95 mov eax , 0x2 cmp eax , dword ptr [ 0x6538e8 ] setbe cl mov byte ptr [ rbp - 0xda ] , cl mov al , byte ptr [ rbp - 0xda ] xor ecx , ecx mov dl , cl and al , 0x1 mov byte ptr [ rbp - 0x71 ] , al test byte ptr [ rbp - 0x71 ] , 0x1 mov byte ptr [ rbp - 0xdb ] , dl je 0xc9 mov eax , 0x4 cmp eax , dword ptr [ 0x6538e8 ] setbe cl mov byte ptr [ rbp - 0xdb ] , cl mov al , byte ptr [ rbp - 0xdb ] and al , 0x1 mov byte ptr [ rbp - 0x72 ] , al mov rcx , qword ptr [ 0x653aa8 ] mov qword ptr [ rbp - 0x80 ] , rcx mov rcx , qword ptr [ 0x653bd8 ] mov qword ptr [ rbp - 0x88 ] , rcx mov qword ptr [ rbp - 0x58 ] , 0x0 mov qword ptr [ rbp - 0x50 ] , 0x0 mov rcx , qword ptr [ rbp - 0x10 ] mov rcx , qword ptr [ rcx + 0x18 ] mov rdx , qword ptr [ rbp - 0x18 ] mov qword ptr [ rdx ] , rcx mov rcx , qword ptr [ rbp - 0x10 ] mov rcx , qword ptr [ rcx + 0x20 ] mov rdx , qword ptr [ rbp - 0x28 ] mov qword ptr [ rdx ] , rcx mov rcx , qword ptr [ rbp - 0x10 ] mov qword ptr [ rbp - 0x38 ] , rcx mov rax , qword ptr [ rbp - 0x38 ] mov rax , qword ptr [ rax + 0x18 ] mov rcx , qword ptr [ rbp - 0x38 ] add rax , qword ptr [ rcx + 0x10 ] sub rax , 0x1 mov qword ptr [ rbp - 0x40 ] , rax mov rax , qword ptr [ rbp - 0x38 ] mov rax , qword ptr [ rax + 0x20 ] mov rcx , qword ptr [ rbp - 0x38 ] add rax , qword ptr [ rcx + 0x8 ] sub rax , 0x1 mov qword ptr [ rbp - 0x48 ] , rax mov rax , qword ptr [ rbp - 0x38 ] mov rax , qword ptr [ rax + 0x10 ] add rax , qword ptr [ rbp - 0x50 ] mov qword ptr [ rbp - 0x50 ] , rax mov rax , qword ptr [ rbp - 0x38 ] mov rax , qword ptr [ rax + 0x8 ] add rax , qword ptr [ rbp - 0x58 ] mov qword ptr [ rbp - 0x58 ] , rax mov rax , qword ptr [ rbp - 0x38 ] mov rax , qword ptr [ rax + 0x18 ] mov qword ptr [ rbp - 0x60 ] , rax xor eax , eax mov cl , al mov rdx , qword ptr [ rbp - 0x60 ] cmp rdx , qword ptr [ rbp - 0x40 ] mov byte ptr [ rbp - 0xdc ] , cl jg 0x1a2 mov al , byte ptr [ rbp - 0x61 ] mov byte ptr [ rbp - 0xdc ] , al mov al , byte ptr [ rbp - 0xdc ] test al , 0x1 jne 0x1b5 jmp 0x33f mov rax , qword ptr [ rbp - 0x80 ] mov rcx , qword ptr [ rbp - 0x60 ] mov rax , qword ptr [ rax + rcx * 0x8 ] mov qword ptr [ rbp - 0x90 ] , rax mov rax , qword ptr [ rbp - 0x80 ] mov rcx , qword ptr [ rbp - 0x60 ] mov rax , qword ptr [ rax + rcx * 0x8 + 0x8 ] add rax , - 0x1 mov qword ptr [ rbp - 0x98 ] , rax mov rax , qword ptr [ rbp - 0x98 ] mov rcx , qword ptr [ rbp - 0x98 ] movsx edx , byte ptr [ rcx ] cmp edx , 0xa setne sil and sil , 0x1 movzx edx , sil movsxd rcx , edx add rax , rcx mov qword ptr [ rbp - 0xa0 ] , rax mov rax , qword ptr [ rbp - 0xa0 ] mov rcx , qword ptr [ rbp - 0x90 ] sub rax , rcx mov qword ptr [ rbp - 0xa8 ] , rax mov rax , qword ptr [ rbp - 0x90 ] mov qword ptr [ rbp - 0xb0 ] , rax test byte ptr [ rbp - 0x71 ] , 0x1 je 0x2bb jmp 0x242 mov rax , qword ptr [ rbp - 0xb0 ] movsx ecx , byte ptr [ rax ] cmp ecx , 0xa je 0x2b6 call 0xffffffffffff04d0 mov rax , qword ptr [ rax ] mov rcx , qword ptr [ rbp - 0xb0 ] movzx edx , byte ptr [ rcx ] movsxd rcx , edx movzx edx , word ptr [ rax + rcx * 0x2 ] and edx , 0x2000 cmp edx , 0x0 jne 0x29a test byte ptr [ rbp - 0x72 ] , 0x1 jne 0x295 mov rax , qword ptr [ rbp - 0x90 ] mov qword ptr [ rbp - 0xb0 ] , rax jmp 0x2b6 jmp 0x29f mov rax , qword ptr [ rbp - 0xb0 ] add rax , 0x1 mov qword ptr [ rbp - 0xb0 ] , rax jmp 0x242 jmp 0x2bb mov rax , qword ptr [ rbp - 0xa0 ] mov rcx , qword ptr [ rbp - 0xb0 ] sub rax , rcx cmp rax , qword ptr [ rbp - 0x70 ] je 0x329 cmp qword ptr [ 0x6539c8 ] , 0x0 je 0x325 xor eax , eax mov ecx , eax mov rsi , qword ptr [ rbp - 0x90 ] mov rdx , qword ptr [ rbp - 0xa8 ] mov r8 , qword ptr [ rbp - 0xa8 ] movabs rdi , 0x6539a8 mov qword ptr [ rbp - 0xe8 ] , rcx mov r9 , qword ptr [ rbp - 0xe8 ] call 0xe8d0 cmp rax , 0x0 jge 0x329 mov byte ptr [ rbp - 0x61 ] , 0x0 jmp 0x32e mov rax , qword ptr [ rbp - 0x60 ] add rax , 0x1 mov qword ptr [ rbp - 0x60 ] , rax jmp 0x181 mov rax , qword ptr [ rbp - 0x38 ] mov rax , qword ptr [ rax + 0x20 ] mov qword ptr [ rbp - 0x60 ] , rax xor eax , eax mov cl , al mov rdx , qword ptr [ rbp - 0x60 ] cmp rdx , qword ptr [ rbp - 0x48 ] mov byte ptr [ rbp - 0xe9 ] , cl jg 0x36c mov al , byte ptr [ rbp - 0x61 ] mov byte ptr [ rbp - 0xe9 ] , al mov al , byte ptr [ rbp - 0xe9 ] test al , 0x1 jne 0x37f jmp 0x50f mov rax , qword ptr [ rbp - 0x88 ] mov rcx , qword ptr [ rbp - 0x60 ] mov rax , qword ptr [ rax + rcx * 0x8 ] mov qword ptr [ rbp - 0xb8 ] , rax mov rax , qword ptr [ rbp - 0x88 ] mov rcx , qword ptr [ rbp - 0x60 ] mov rax , qword ptr [ rax + rcx * 0x8 + 0x8 ] add rax , - 0x1 mov qword ptr [ rbp - 0xc0 ] , rax mov rax , qword ptr [ rbp - 0xc0 ] mov rcx , qword ptr [ rbp - 0xc0 ] movsx edx , byte ptr [ rcx ] cmp edx , 0xa setne sil and sil , 0x1 movzx edx , sil movsxd rcx , edx add rax , rcx mov qword ptr [ rbp - 0xc8 ] , rax mov rax , qword ptr [ rbp - 0xc8 ] mov rcx , qword ptr [ rbp - 0xb8 ] sub rax , rcx mov qword ptr [ rbp - 0xd0 ] , rax mov rax , qword ptr [ rbp - 0xb8 ] mov qword ptr [ rbp - 0xd8 ] , rax test byte ptr [ rbp - 0x71 ] , 0x1 je 0x48b jmp 0x412 mov rax , qword ptr [ rbp - 0xd8 ] movsx ecx , byte ptr [ rax ] cmp ecx , 0xa je 0x486 call 0xffffffffffff04d0 mov rax , qword ptr [ rax ] mov rcx , qword ptr [ rbp - 0xd8 ] movzx edx , byte ptr [ rcx ] movsxd rcx , edx movzx edx , word ptr [ rax + rcx * 0x2 ] and edx , 0x2000 cmp edx , 0x0 jne 0x46a test byte ptr [ rbp - 0x72 ] , 0x1 jne 0x465 mov rax , qword ptr [ rbp - 0xb8 ] mov qword ptr [ rbp - 0xd8 ] , rax jmp 0x486 jmp 0x46f mov rax , qword ptr [ rbp - 0xd8 ] add rax , 0x1 mov qword ptr [ rbp - 0xd8 ] , rax jmp 0x412 jmp 0x48b mov rax , qword ptr [ rbp - 0xc8 ] mov rcx , qword ptr [ rbp - 0xd8 ] sub rax , rcx cmp rax , qword ptr [ rbp - 0x70 ] je 0x4f9 cmp qword ptr [ 0x6539c8 ] , 0x0 je 0x4f5 xor eax , eax mov ecx , eax mov rsi , qword ptr [ rbp - 0xb8 ] mov rdx , qword ptr [ rbp - 0xd0 ] mov r8 , qword ptr [ rbp - 0xd0 ] movabs rdi , 0x6539a8 mov qword ptr [ rbp - 0xf8 ] , rcx mov r9 , qword ptr [ rbp - 0xf8 ] call 0x1620 cmp rax , 0x0 jge 0x4f9 mov byte ptr [ rbp - 0x61 ] , 0x0 jmp 0x4fe mov rax , qword ptr [ rbp - 0x60 ] add rax , 0x1 mov qword ptr [ rbp - 0x60 ] , rax jmp 0x34b jmp 0x514 mov rax , qword ptr [ rbp - 0x38 ] mov rax , qword ptr [ rax ] mov qword ptr [ rbp - 0x38 ] , rax cmp rax , 0x0 jne 0x125 mov rax , qword ptr [ rbp - 0x40 ] mov rcx , qword ptr [ rbp - 0x20 ] mov qword ptr [ rcx ] , rax mov rax , qword ptr [ rbp - 0x48 ] mov rcx , qword ptr [ rbp - 0x30 ] mov qword ptr [ rcx ] , rax test byte ptr [ rbp - 0x61 ] , 0x1 je 0x555 mov dword ptr [ rbp - 0x4 ] , 0x0 jmp 0x57e xor eax , eax mov rcx , qword ptr [ rbp - 0x50 ] cmp rcx , 0x0 mov edx , 0x1 mov esi , eax cmovne esi , edx mov rcx , qword ptr [ rbp - 0x58 ] cmp rcx , 0x0 mov edx , 0x2 cmovne eax , edx or esi , eax mov dword ptr [ rbp - 0x4 ] , esi mov eax , dword ptr [ rbp - 0x4 ] add rsp , 0x100 pop rbp ret nop word ptr [ rax + rax ]
Code2: push ebp push edi call 0xffffaf7c add edi , 0x3303d push esi push ebx sub esp , 0x4c lea eax , [ edi + 0x270d ] mov dword ptr [ esp + 0x10 ] , edi movzx edx , byte ptr [ eax ] test dl , dl jne 0x371 lea eax , [ edi + 0x26ec ] mov dword ptr [ esp + 0xc ] , 0x0 mov dword ptr [ esp + 0x8 ] , 0xffffffff mov dword ptr [ esp + 0x2c ] , 0x0 mov ecx , dword ptr [ eax + 0x10 ] test ecx , ecx setne dl lea eax , [ edi + 0x272c ] mov dword ptr [ esp + 0x34 ] , 0x0 mov dword ptr [ esp + 0x30 ] , 0x0 mov esi , dword ptr [ eax + 0x74 ] mov eax , dword ptr [ eax + 0x124 ] mov dword ptr [ esp + 0x3c ] , eax mov eax , dword ptr [ esp + 0x60 ] mov dword ptr [ esp + 0x38 ] , esi mov ecx , dword ptr [ eax + 0xc ] mov eax , dword ptr [ esp + 0x64 ] mov dword ptr [ eax ] , ecx mov eax , dword ptr [ esp + 0x60 ] mov ecx , dword ptr [ eax + 0x10 ] mov eax , dword ptr [ esp + 0x6c ] mov dword ptr [ eax ] , ecx lea eax , [ edi + 0x26ec ] mov edi , dword ptr [ esp + 0x60 ] mov dword ptr [ esp + 0x1c ] , eax mov eax , edx nop mov esi , dword ptr [ esp + 0x60 ] mov edi , dword ptr [ edi + 0xc ] mov ebx , dword ptr [ esp + 0x60 ] mov edx , dword ptr [ esp + 0x60 ] mov ecx , dword ptr [ esi + 0x8 ] add dword ptr [ esp + 0x30 ] , ecx mov edx , dword ptr [ edx + 0x4 ] mov ebx , dword ptr [ ebx + 0x10 ] add dword ptr [ esp + 0x34 ] , edx mov dword ptr [ esp + 0x4 ] , edi lea esi , [ ecx + edi - 0x1 ] mov dword ptr [ esp ] , ebx lea ebx , [ edx + ebx - 0x1 ] cmp edi , esi mov dword ptr [ esp + 0x18 ] , esi setle dl mov dword ptr [ esp + 0x14 ] , ebx and dl , al mov byte ptr [ esp + 0x2b ] , dl je 0x260 mov eax , dword ptr [ esp + 0x38 ] lea edi , [ eax + edi * 0x4 ] mov eax , dword ptr [ esp + 0x10 ] lea eax , [ eax + 0x26ec ] mov dword ptr [ esp ] , eax lea esi , [ esi ] mov eax , dword ptr [ edi + 0x4 ] xor edx , edx mov esi , dword ptr [ edi ] cmp byte ptr [ eax - 0x1 ] , 0xa setne dl lea ecx , [ eax + edx - 0x1 ] mov edx , dword ptr [ esp + 0xc ] mov ebp , ecx sub ebp , esi test edx , edx mov eax , ebp jne 0x1f8 cmp dword ptr [ esp + 0x8 ] , eax je 0x1e8 mov eax , dword ptr [ esp ] mov ecx , dword ptr [ eax + 0x10 ] test ecx , ecx je 0x190 sub esp , 0x8 push 0x0 push ebp push 0x0 push ebp push esi push eax mov ebx , dword ptr [ esp + 0x30 ] call 0x1a0f0 not eax add esp , 0x20 shr eax , 0x1f add dword ptr [ esp + 0x4 ] , 0x1 add edi , 0x4 mov ebx , dword ptr [ esp + 0x4 ] cmp dword ptr [ esp + 0x18 ] , ebx jl 0x16a test al , al jne 0x100 mov edi , dword ptr [ esp + 0x60 ] mov edi , dword ptr [ edi + 0x10 ] cmp dword ptr [ esp + 0x14 ] , edi mov dword ptr [ esp ] , edi setge dl and edx , eax mov byte ptr [ esp + 0x24 ] , dl jmp 0x26c lea esi , [ esi ] lea edi , [ edi ] xor eax , eax mov edi , dword ptr [ esp + 0x60 ] mov edi , dword ptr [ edi ] test edi , edi mov dword ptr [ esp + 0x60 ] , edi jne 0xa0 mov edx , eax mov edi , dword ptr [ esp + 0x18 ] mov eax , dword ptr [ esp + 0x68 ] mov dword ptr [ eax ] , edi mov eax , dword ptr [ esp + 0x70 ] mov edi , dword ptr [ esp + 0x14 ] mov dword ptr [ eax ] , edi xor eax , eax test dl , dl jne 0x1d9 mov eax , dword ptr [ esp + 0x30 ] xor edx , edx mov ecx , dword ptr [ esp + 0x34 ] test eax , eax setne dl mov eax , edx or eax , 0x2 test ecx , ecx cmove eax , edx add esp , 0x4c pop ebx pop esi pop edi pop ebp ret lea esi , [ esi ] movzx eax , byte ptr [ esp + 0x2b ] jmp 0x154 lea esi , [ esi ] movzx edx , byte ptr [ esi ] mov dword ptr [ esp + 0x24 ] , ecx cmp dl , 0xa mov byte ptr [ esp + 0x20 ] , dl je 0x124 mov ebx , dword ptr [ esp + 0x10 ] call 0xffff32f0 mov ecx , dword ptr [ esp + 0x24 ] mov ebx , dword ptr [ eax ] mov eax , esi movzx edx , byte ptr [ esp + 0x20 ] jmp 0x233 lea esi , [ esi ] add eax , 0x1 movzx edx , byte ptr [ eax ] cmp dl , 0xa je 0x250 test byte ptr [ ebx + edx * 0x2 + 0x1 ] , 0x20 jne 0x228 mov ebx , dword ptr [ esp + 0x2c ] sub ecx , eax mov eax , ecx test ebx , ebx cmove eax , ebp jmp 0x124 lea esi , [ esi ] sub ecx , eax mov eax , ecx jmp 0x124 lea esi , [ esi ] cmp dword ptr [ esp ] , ebx setle dl and edx , eax mov byte ptr [ esp + 0x24 ] , dl cmp byte ptr [ esp + 0x24 ] , 0x0 je 0x192 mov eax , dword ptr [ esp + 0x3c ] mov edi , dword ptr [ esp ] lea edi , [ eax + edi * 0x4 ] lea esi , [ esi ] mov eax , dword ptr [ edi + 0x4 ] xor edx , edx mov esi , dword ptr [ edi ] cmp byte ptr [ eax - 0x1 ] , 0xa setne dl lea ecx , [ eax + edx - 0x1 ] mov edx , dword ptr [ esp + 0xc ] mov ebp , ecx sub ebp , esi test edx , edx mov eax , ebp jne 0x310 cmp dword ptr [ esp + 0x8 ] , eax je 0x300 mov eax , dword ptr [ esp + 0x1c ] mov ebx , dword ptr [ eax + 0x10 ] test ebx , ebx je 0x190 sub esp , 0x8 push 0x0 push ebp push 0x0 push ebp push esi push eax mov ebx , dword ptr [ esp + 0x30 ] call 0x1a0f0 not eax add esp , 0x20 shr eax , 0x1f add dword ptr [ esp ] , 0x1 add edi , 0x4 mov esi , dword ptr [ esp ] cmp dword ptr [ esp + 0x14 ] , esi jl 0x192 test al , al jne 0x288 jmp 0x192 lea esi , [ esi ] lea edi , [ edi ] movzx eax , byte ptr [ esp + 0x24 ] jmp 0x2d9 mov esi , esi lea edi , [ edi ] movzx edx , byte ptr [ esi ] mov dword ptr [ esp + 0x20 ] , ecx cmp dl , 0xa mov byte ptr [ esp + 0x4 ] , dl je 0x2a8 mov ebx , dword ptr [ esp + 0x10 ] call 0xffff32f0 mov ecx , dword ptr [ esp + 0x20 ] mov ebx , dword ptr [ eax ] mov eax , esi movzx edx , byte ptr [ esp + 0x4 ] jmp 0x34b nop lea esi , [ esi ] add eax , 0x1 movzx edx , byte ptr [ eax ] cmp dl , 0xa je 0x368 test byte ptr [ ebx + edx * 0x2 + 0x1 ] , 0x20 jne 0x340 sub ecx , eax mov eax , dword ptr [ esp + 0x2c ] test eax , eax mov eax , ecx cmove eax , ebp jmp 0x2a8 lea esi , [ esi ] sub ecx , eax mov eax , ecx jmp 0x2a8 lea eax , [ edi + 0x2664 ] mov eax , dword ptr [ eax ] cmp eax , 0x1 jbe 0x3a4 cmp eax , 0x3 mov dword ptr [ esp + 0xc ] , 0x1 mov dword ptr [ esp + 0x8 ] , 0x0 seta al mov edi , dword ptr [ esp + 0x10 ] movzx eax , al mov dword ptr [ esp + 0x2c ] , eax jmp 0x4d mov dword ptr [ esp + 0xc ] , 0x0 mov dword ptr [ esp + 0x8 ] , 0x0 mov dword ptr [ esp + 0x2c ] , 0x0 mov edi , dword ptr [ esp + 0x10 ] jmp 0x4d lea esi , [ esi ] lea edi , [ edi ]
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly codes show fundamental architectural differences (x86-64 vs x86), distinct register usage patterns, and different control flow structures. The first code uses 64-bit registers (r8, r9, rdi, rsi) and complex memory operations with 64-bit offsets, while the second relies on 32-bit registers (ebp, edi, esi) and smaller stack adjustments. Their loop structures and branching logic show no significant overlap, with the first code featuring multi-level conditional jumps and the second using simpler comparisons. The memory access patterns and function call mechanisms also differ substantially, indicating they implement unrelated functionality.
------------------------------------------------------------

------------------------------------------------------------
Code1: push ebp mov ebp , esp push esi sub esp , 0x74 mov eax , dword ptr [ ebp + 0xc ] mov ecx , dword ptr [ ebp + 0x8 ] mov byte ptr [ ebp - 0x5 ] , 0x1 mov edx , dword ptr [ ebp + 0x8 ] add edx , 0x2 mov dword ptr [ esp ] , edx mov dword ptr [ ebp - 0x34 ] , eax mov dword ptr [ ebp - 0x38 ] , ecx call 0x43a0 mov dword ptr [ ebp - 0xc ] , eax mov eax , dword ptr [ ebp + 0x8 ] add eax , 0x1 mov dword ptr [ esp ] , eax mov dword ptr [ esp + 0x4 ] , 0x4 call 0x4360 mov dword ptr [ ebp - 0x10 ] , eax mov byte ptr [ ebp - 0x15 ] , 0x0 mov dword ptr [ ebp - 0x14 ] , 0x0 mov eax , dword ptr [ ebp - 0x14 ] cmp eax , dword ptr [ ebp + 0x8 ] jae 0x168 mov eax , dword ptr [ ebp + 0xc ] mov ecx , dword ptr [ ebp - 0x14 ] mov eax , dword ptr [ eax + ecx * 0x4 ] mov ecx , esp mov dword ptr [ ecx ] , eax mov dword ptr [ ecx + 0x4 ] , 0x8051422 call 0xffffe500 cmp eax , 0x0 jne 0x94 mov byte ptr [ 0x8053170 ] , 0x1 mov eax , dword ptr [ 0x8053160 ] mov ecx , dword ptr [ ebp - 0x10 ] mov edx , dword ptr [ ebp - 0x14 ] mov dword ptr [ ecx + edx * 0x4 ] , eax jmp 0x155 mov eax , dword ptr [ ebp + 0xc ] mov ecx , dword ptr [ ebp - 0x14 ] mov eax , dword ptr [ eax + ecx * 0x4 ] mov dword ptr [ esp ] , eax lea eax , [ 0x8051321 ] mov dword ptr [ esp + 0x4 ] , eax call 0xffffe5d0 mov ecx , dword ptr [ ebp - 0x10 ] mov edx , dword ptr [ ebp - 0x14 ] mov dword ptr [ ecx + edx * 0x4 ] , eax mov eax , dword ptr [ ebp - 0x10 ] mov ecx , dword ptr [ ebp - 0x14 ] cmp dword ptr [ eax + ecx * 0x4 ] , 0x0 jne 0x119 call 0xffffe6f0 xor ecx , ecx mov eax , dword ptr [ eax ] mov edx , dword ptr [ ebp + 0xc ] mov esi , dword ptr [ ebp - 0x14 ] mov edx , dword ptr [ edx + esi * 0x4 ] mov dword ptr [ esp ] , 0x0 mov dword ptr [ esp + 0x4 ] , 0x3 mov dword ptr [ esp + 0x8 ] , edx mov dword ptr [ ebp - 0x3c ] , ecx mov dword ptr [ ebp - 0x40 ] , eax call 0x3000 mov dword ptr [ esp ] , 0x1 mov ecx , dword ptr [ ebp - 0x40 ] mov dword ptr [ esp + 0x4 ] , ecx lea ecx , [ 0x805112b ] mov dword ptr [ esp + 0x8 ] , ecx mov dword ptr [ esp + 0xc ] , eax call 0xffffe630 mov eax , dword ptr [ ebp - 0x10 ] mov ecx , dword ptr [ ebp - 0x14 ] mov eax , dword ptr [ eax + ecx * 0x4 ] mov dword ptr [ esp ] , eax call 0xffffe700 cmp eax , 0x0 jne 0x137 mov byte ptr [ ebp - 0x15 ] , 0x1 jmp 0x13c mov eax , dword ptr [ ebp - 0x10 ] mov ecx , dword ptr [ ebp - 0x14 ] mov eax , dword ptr [ eax + ecx * 0x4 ] mov dword ptr [ esp ] , eax mov dword ptr [ esp + 0x4 ] , 0x2 call 0x820 jmp 0x15a mov eax , dword ptr [ ebp - 0x14 ] add eax , 0x1 mov dword ptr [ ebp - 0x14 ] , eax jmp 0x4c test byte ptr [ ebp - 0x15 ] , 0x1 je 0x1aa test byte ptr [ 0x8053170 ] , 0x1 je 0x1aa lea eax , [ 0x8051323 ] mov dword ptr [ esp ] , eax call 0xffffe680 xor ecx , ecx mov dword ptr [ esp ] , 0x1 mov dword ptr [ esp + 0x4 ] , 0x0 mov dword ptr [ esp + 0x8 ] , eax mov dword ptr [ ebp - 0x44 ] , ecx call 0xffffe630 jmp 0x1af cmp dword ptr [ ebp - 0x14 ] , 0x0 je 0x5af mov byte ptr [ ebp - 0x16 ] , 0x0 mov eax , dword ptr [ 0x8053174 ] mov dword ptr [ ebp - 0x1c ] , eax mov dword ptr [ ebp - 0x20 ] , 0x0 mov dword ptr [ ebp - 0x24 ] , 0x0 xor eax , eax mov cl , al mov eax , dword ptr [ ebp - 0x24 ] cmp eax , dword ptr [ ebp + 0x8 ] mov byte ptr [ ebp - 0x45 ] , cl jae 0x1f0 cmp dword ptr [ ebp - 0x14 ] , 0x0 setne al mov byte ptr [ ebp - 0x45 ] , al mov al , byte ptr [ ebp - 0x45 ] test al , 0x1 jne 0x200 jmp 0x5aa mov byte ptr [ ebp - 0x2d ] , 0x0 mov eax , dword ptr [ ebp - 0x10 ] mov ecx , dword ptr [ ebp - 0x24 ] cmp dword ptr [ eax + ecx * 0x4 ] , 0x0 je 0x2e1 mov eax , dword ptr [ ebp - 0x10 ] mov ecx , dword ptr [ ebp - 0x24 ] mov eax , dword ptr [ eax + ecx * 0x4 ] mov dword ptr [ esp ] , eax call 0xffffe580 mov dword ptr [ ebp - 0x28 ] , eax call 0xffffe6f0 mov eax , dword ptr [ eax ] mov dword ptr [ ebp - 0x2c ] , eax cmp dword ptr [ ebp - 0x28 ] , - 0x1 je 0x27f cmp dword ptr [ ebp - 0x20 ] , 0x0 je 0x27f mov eax , dword ptr [ ebp - 0xc ] mov ecx , dword ptr [ ebp - 0x20 ] mov edx , dword ptr [ 0x8053164 ] mov dword ptr [ esp ] , eax mov dword ptr [ esp + 0x4 ] , 0x1 mov dword ptr [ esp + 0x8 ] , ecx mov dword ptr [ esp + 0xc ] , edx call 0xffffe710 cmp eax , dword ptr [ ebp - 0x20 ] je 0x278 call 0x610 mov dword ptr [ ebp - 0x20 ] , 0x0 jmp 0x284 cmp dword ptr [ ebp - 0x28 ] , - 0x1 je 0x2dc mov byte ptr [ ebp - 0x2d ] , 0x1 mov eax , dword ptr [ ebp - 0x28 ] movzx ecx , byte ptr [ 0x80530d0 ] cmp eax , ecx jne 0x2a9 jmp 0x2dc mov eax , dword ptr [ ebp - 0x28 ] mov cl , al movsx eax , cl mov dword ptr [ esp ] , eax call 0x5e0 mov eax , dword ptr [ ebp - 0x10 ] mov edx , dword ptr [ ebp - 0x24 ] mov eax , dword ptr [ eax + edx * 0x4 ] mov dword ptr [ esp ] , eax call 0xffffe580 mov dword ptr [ ebp - 0x28 ] , eax call 0xffffe6f0 mov eax , dword ptr [ eax ] mov dword ptr [ ebp - 0x2c ] , eax jmp 0x284 jmp 0x2e1 test byte ptr [ ebp - 0x2d ] , 0x1 jne 0x4e1 mov eax , dword ptr [ ebp - 0x10 ] mov ecx , dword ptr [ ebp - 0x24 ] cmp dword ptr [ eax + ecx * 0x4 ] , 0x0 je 0x425 mov eax , dword ptr [ ebp - 0x10 ] mov ecx , dword ptr [ ebp - 0x24 ] mov eax , dword ptr [ eax + ecx * 0x4 ] mov dword ptr [ esp ] , eax call 0xffffe5e0 cmp eax , 0x0 je 0x36b xor eax , eax mov ecx , dword ptr [ ebp - 0x2c ] mov edx , dword ptr [ ebp + 0xc ] mov esi , dword ptr [ ebp - 0x24 ] mov edx , dword ptr [ edx + esi * 0x4 ] mov dword ptr [ esp ] , 0x0 mov dword ptr [ esp + 0x4 ] , 0x3 mov dword ptr [ esp + 0x8 ] , edx mov dword ptr [ ebp - 0x4c ] , eax mov dword ptr [ ebp - 0x50 ] , ecx call 0x3000 xor ecx , ecx mov dword ptr [ esp ] , 0x0 mov edx , dword ptr [ ebp - 0x50 ] mov dword ptr [ esp + 0x4 ] , edx lea edx , [ 0x805112b ] mov dword ptr [ esp + 0x8 ] , edx mov dword ptr [ esp + 0xc ] , eax mov dword ptr [ ebp - 0x54 ] , ecx call 0xffffe630 mov byte ptr [ ebp - 0x5 ] , 0x0 mov eax , dword ptr [ ebp - 0x10 ] mov ecx , dword ptr [ ebp - 0x24 ] mov eax , dword ptr [ eax + ecx * 0x4 ] cmp eax , dword ptr [ 0x8053160 ] jne 0x396 mov eax , dword ptr [ ebp - 0x10 ] mov ecx , dword ptr [ ebp - 0x24 ] mov eax , dword ptr [ eax + ecx * 0x4 ] mov dword ptr [ esp ] , eax call 0xffffe740 jmp 0x40f mov eax , dword ptr [ ebp - 0x10 ] mov ecx , dword ptr [ ebp - 0x24 ] mov eax , dword ptr [ eax + ecx * 0x4 ] mov dword ptr [ esp ] , eax call 0x4750 cmp eax , - 0x1 jne 0x40a call 0xffffe6f0 xor ecx , ecx mov eax , dword ptr [ eax ] mov edx , dword ptr [ ebp + 0xc ] mov esi , dword ptr [ ebp - 0x24 ] mov edx , dword ptr [ edx + esi * 0x4 ] mov dword ptr [ esp ] , 0x0 mov dword ptr [ esp + 0x4 ] , 0x3 mov dword ptr [ esp + 0x8 ] , edx mov dword ptr [ ebp - 0x58 ] , ecx mov dword ptr [ ebp - 0x5c ] , eax call 0x3000 xor ecx , ecx mov dword ptr [ esp ] , 0x0 mov edx , dword ptr [ ebp - 0x5c ] mov dword ptr [ esp + 0x4 ] , edx lea edx , [ 0x805112b ] mov dword ptr [ esp + 0x8 ] , edx mov dword ptr [ esp + 0xc ] , eax mov dword ptr [ ebp - 0x60 ] , ecx call 0xffffe630 mov byte ptr [ ebp - 0x5 ] , 0x0 jmp 0x40f mov eax , dword ptr [ ebp - 0x10 ] mov ecx , dword ptr [ ebp - 0x24 ] mov dword ptr [ eax + ecx * 0x4 ] , 0x0 mov eax , dword ptr [ ebp - 0x14 ] add eax , - 0x1 mov dword ptr [ ebp - 0x14 ] , eax mov eax , dword ptr [ ebp - 0x24 ] add eax , 0x1 cmp eax , dword ptr [ ebp + 0x8 ] jne 0x495 test byte ptr [ ebp - 0x16 ] , 0x1 je 0x490 cmp dword ptr [ ebp - 0x20 ] , 0x0 je 0x481 mov eax , dword ptr [ ebp - 0xc ] mov ecx , dword ptr [ ebp - 0x20 ] mov edx , dword ptr [ 0x8053164 ] mov dword ptr [ esp ] , eax mov dword ptr [ esp + 0x4 ] , 0x1 mov dword ptr [ esp + 0x8 ] , ecx mov dword ptr [ esp + 0xc ] , edx call 0xffffe710 cmp eax , dword ptr [ ebp - 0x20 ] je 0x47a call 0x610 mov dword ptr [ ebp - 0x20 ] , 0x0 movsx eax , byte ptr [ 0x80530d0 ] mov dword ptr [ esp ] , eax call 0x5e0 jmp 0x59c mov eax , dword ptr [ ebp - 0x1c ] movsx eax , byte ptr [ eax ] cmp eax , 0x0 je 0x4ba mov eax , dword ptr [ ebp - 0x1c ] mov cl , byte ptr [ eax ] mov eax , dword ptr [ ebp - 0xc ] mov edx , dword ptr [ ebp - 0x20 ] mov esi , edx add esi , 0x1 mov dword ptr [ ebp - 0x20 ] , esi mov byte ptr [ eax + edx ] , cl mov eax , dword ptr [ ebp - 0x1c ] add eax , 0x1 mov dword ptr [ ebp - 0x1c ] , eax cmp eax , dword ptr [ 0x8053178 ] jne 0x4d7 mov eax , dword ptr [ 0x8053174 ] mov dword ptr [ ebp - 0x1c ] , eax jmp 0x4dc jmp 0x597 mov byte ptr [ ebp - 0x16 ] , 0x1 mov eax , dword ptr [ ebp - 0x24 ] add eax , 0x1 cmp eax , dword ptr [ ebp + 0x8 ] je 0x55f mov eax , dword ptr [ ebp - 0x28 ] movzx ecx , byte ptr [ 0x80530d0 ] cmp eax , ecx je 0x520 cmp dword ptr [ ebp - 0x28 ] , - 0x1 je 0x520 mov eax , dword ptr [ ebp - 0x28 ] mov cl , al movsx eax , cl mov dword ptr [ esp ] , eax call 0x5e0 mov eax , dword ptr [ ebp - 0x1c ] movsx eax , byte ptr [ eax ] cmp eax , 0x0 je 0x53d mov eax , dword ptr [ ebp - 0x1c ] movsx eax , byte ptr [ eax ] mov dword ptr [ esp ] , eax call 0x5e0 mov eax , dword ptr [ ebp - 0x1c ] add eax , 0x1 mov dword ptr [ ebp - 0x1c ] , eax cmp eax , dword ptr [ 0x8053178 ] jne 0x55a mov eax , dword ptr [ 0x8053174 ] mov dword ptr [ ebp - 0x1c ] , eax jmp 0x592 cmp dword ptr [ ebp - 0x28 ] , - 0x1 jne 0x578 movzx eax , byte ptr [ 0x80530d0 ] mov dword ptr [ ebp - 0x64 ] , eax jmp 0x57e mov eax , dword ptr [ ebp - 0x28 ] mov dword ptr [ ebp - 0x64 ] , eax mov eax , dword ptr [ ebp - 0x64 ] mov cl , al mov byte ptr [ ebp - 0x2e ] , cl movsx eax , byte ptr [ ebp - 0x2e ] mov dword ptr [ esp ] , eax call 0x5e0 jmp 0x597 jmp 0x59c mov eax , dword ptr [ ebp - 0x24 ] add eax , 0x1 mov dword ptr [ ebp - 0x24 ] , eax jmp 0x1d3 jmp 0x1af mov eax , dword ptr [ ebp - 0x10 ] mov dword ptr [ esp ] , eax call 0xffffe540 mov eax , dword ptr [ ebp - 0xc ] mov dword ptr [ esp ] , eax call 0xffffe540 mov cl , byte ptr [ ebp - 0x5 ] and cl , 0x1 movzx eax , cl add esp , 0x74 pop esi pop ebp ret nop word ptr cs : [ eax + eax ] nop
Code2: lui gp , 0x42 addiu sp , sp , - 0x68 addiu gp , gp , 0x10d0 sw s6 , 0x58 ( sp ) move s6 , a0 sw gp , 0x10 ( sp ) addiu a0 , a0 , 0x2 sw ra , 0x64 ( sp ) sw fp , 0x60 ( sp ) sw s7 , 0x5c ( sp ) sw s5 , 0x54 ( sp ) sw s4 , 0x50 ( sp ) sw s3 , 0x4c ( sp ) sw s2 , 0x48 ( sp ) sw s1 , 0x44 ( sp ) sw s0 , 0x40 ( sp ) lw t9 , - 0x7fcc ( gp ) bal 0x36e0 sw a1 , 0x6c ( sp ) addiu v1 , s6 , 0x1 lw gp , 0x10 ( sp ) sll a0 , v1 , 0x2 bltz a0 , 0x6cc sw v0 , 0x28 ( sp ) srl v0 , v1 , 0x1e sltu v0 , zero , v0 bnez v0 , 0x6cc lw t9 , - 0x7fcc ( gp ) bal 0x36e0 nop lw gp , 0x10 ( sp ) beqz s6 , 0x624 sw v0 , 0x3c ( sp ) lui s7 , 0x40 lw s0 , 0x6c ( sp ) sw zero , 0x34 ( sp ) move s5 , zero lui s2 , 0x40 addiu s7 , s7 , 0x72c4 lui s3 , 0x42 addiu s4 , zero , 0x1 b 0xcc move s1 , v0 lw v0 , - 0x7ee0 ( gp ) addiu s5 , s5 , 0x1 sb s4 , - 0x6d67 ( s3 ) addiu s0 , s0 , 0x4 addiu s1 , s1 , 0x4 lw v0 , ( v0 ) beq s6 , s5 , 0x14c sw v0 , - 0x4 ( s1 ) lw fp , ( s0 ) addiu a1 , s2 , 0x72c0 lw t9 , - 0x7e68 ( gp ) jalr t9 move a0 , fp beqz v0 , 0xac lw gp , 0x10 ( sp ) lw t9 , - 0x7f2c ( gp ) move a0 , fp jalr t9 move a1 , s7 lw gp , 0x10 ( sp ) move fp , v0 beqz v0 , 0x658 sw v0 , ( s1 ) lw t9 , - 0x7ef4 ( gp ) move a0 , v0 addiu s5 , s5 , 0x1 jalr t9 addiu s0 , s0 , 0x4 addiu v1 , zero , 0x1 lw a2 , 0x34 ( sp ) addiu a1 , zero , 0x2 lw gp , 0x10 ( sp ) move a0 , fp addiu s1 , s1 , 0x4 movz a2 , v1 , v0 lw t9 , - 0x7fd8 ( gp ) bal 0xcf4 sw a2 , 0x34 ( sp ) bne s6 , s5 , 0xcc lw gp , 0x10 ( sp ) lw v0 , 0x34 ( sp ) beqz v0 , 0x614 lui v0 , 0x42 sw s6 , 0x1c ( sp ) lbu v0 , - 0x6d67 ( v0 ) bnez v0 , 0x6a0 lui a1 , 0x40 lui v0 , 0x42 lui s1 , 0x42 sw v0 , 0x30 ( sp ) lui v0 , 0x42 sw v0 , 0x20 ( sp ) lui v0 , 0x40 addiu v0 , v0 , 0x7780 sw v0 , 0x38 ( sp ) lw v0 , 0x30 ( sp ) addiu s3 , zero , 0x1 lw s0 , - 0x7ef8 ( gp ) move s4 , zero lw fp , 0x3c ( sp ) sw zero , 0x2c ( sp ) lw s2 , - 0x6d6c ( v0 ) lw s7 , ( fp ) beqz s7 , 0x2f4 lw t9 , - 0x7ef0 ( gp ) jalr t9 lw s6 , 0x4 ( s7 ) lw v1 , 0x8 ( s7 ) lw gp , 0x10 ( sp ) sltu v1 , s6 , v1 beqz v1 , 0x288 sw v0 , 0x24 ( sp ) addiu v0 , s6 , 0x1 sw v0 , 0x4 ( s7 ) lbu v1 , ( s6 ) beqz s4 , 0x20c lbu v0 , - 0x6fb8 ( s1 ) lw t9 , - 0x7e8c ( gp ) addiu a1 , zero , 0x1 lw a3 , ( s0 ) move a2 , s4 lw a0 , 0x28 ( sp ) jalr t9 sw v1 , 0x24 ( sp ) lw gp , 0x10 ( sp ) bne v0 , s4 , 0x280 lw v1 , 0x24 ( sp ) lbu v0 , - 0x6fb8 ( s1 ) beq v0 , v1 , 0x54c addiu s4 , zero , - 0x1 b 0x258 lw a0 , ( s0 ) addiu v0 , a1 , 0x1 sw v0 , 0x14 ( a0 ) sb v1 , ( a1 ) lw a0 , ( fp ) lw v1 , 0x4 ( a0 ) lw v0 , 0x8 ( a0 ) sltu v0 , v1 , v0 beqz v0 , 0x390 addiu v0 , v1 , 0x1 sw v0 , 0x4 ( a0 ) lbu v1 , ( v1 ) lbu v0 , - 0x6fb8 ( s1 ) beq v0 , v1 , 0x3f4 nop lw a0 , ( s0 ) lw a1 , 0x14 ( a0 ) lw v0 , 0x18 ( a0 ) sltu v0 , a1 , v0 bnez v0 , 0x21c seb v1 , v1 lw t9 , - 0x7f1c ( gp ) jalr t9 andi a1 , v1 , 0xff bgez v0 , 0x228 lw gp , 0x10 ( sp ) jal 0x4011f0 nop lw t9 , - 0x7f04 ( gp ) jalr t9 move a0 , s7 addiu a0 , zero , - 0x1 move v1 , v0 lw v0 , 0x24 ( sp ) lw gp , 0x10 ( sp ) lw v0 , ( v0 ) bne v1 , a0 , 0x1d8 move s6 , v0 lw v0 , ( s7 ) andi v0 , v0 , 0x20 bnez v0 , 0x494 lw v0 , - 0x7ee0 ( gp ) lw v0 , ( v0 ) beq s7 , v0 , 0x4ec lw t9 , - 0x7f14 ( gp ) lw t9 , - 0x7fd0 ( gp ) bal 0x3ae0 move a0 , s7 addiu v1 , zero , - 0x1 beq v0 , v1 , 0x4fc lw gp , 0x10 ( sp ) lw v0 , 0x1c ( sp ) sw zero , ( fp ) addiu v0 , v0 , - 0x1 sw v0 , 0x1c ( sp ) beq s5 , s3 , 0x578 lw v0 , 0x2c ( sp ) lb v0 , ( s2 ) beqz v0 , 0x314 lw v1 , 0x28 ( sp ) addu v1 , v1 , s4 addiu s4 , s4 , 0x1 sb v0 , ( v1 ) lw v0 , 0x20 ( sp ) addiu s2 , s2 , 0x1 lw v0 , - 0x6d70 ( v0 ) beq v0 , s2 , 0x48c lw v0 , 0x30 ( sp ) sltu v0 , s3 , s5 beqz v0 , 0x42c lw v0 , 0x1c ( sp ) addiu fp , fp , 0x4 bnez v0 , 0x1a4 addiu s3 , s3 , 0x1 lw t9 , - 0x7e7c ( gp ) jalr t9 lw a0 , 0x3c ( sp ) lw gp , 0x10 ( sp ) lw t9 , - 0x7e7c ( gp ) jalr t9 lw a0 , 0x28 ( sp ) lw ra , 0x64 ( sp ) lw v0 , 0x34 ( sp ) lw fp , 0x60 ( sp ) lw s7 , 0x5c ( sp ) lw s6 , 0x58 ( sp ) lw s5 , 0x54 ( sp ) lw s4 , 0x50 ( sp ) lw s3 , 0x4c ( sp ) lw s2 , 0x48 ( sp ) lw s1 , 0x44 ( sp ) lw s0 , 0x40 ( sp ) jr ra addiu sp , sp , 0x68 lw t9 , - 0x7f04 ( gp ) jalr t9 nop lw gp , 0x10 ( sp ) bne v0 , s4 , 0x248 move v1 , v0 beq s5 , s3 , 0x5e0 nop lb a1 , ( s2 ) bnez a1 , 0x440 nop lw v0 , 0x20 ( sp ) addiu s2 , s2 , 0x1 lw v0 , - 0x6d70 ( v0 ) beq v0 , s2 , 0x478 lw v0 , 0x30 ( sp ) sltu v0 , s3 , s5 beqz v0 , 0x430 lw v0 , 0x1c ( sp ) addiu v0 , zero , 0x1 addiu fp , fp , 0x4 addiu s3 , s3 , 0x1 sw v0 , 0x2c ( sp ) b 0x1a4 move s4 , zero bne s5 , s3 , 0x3b0 nop lw a0 , ( s0 ) lw v0 , 0x14 ( a0 ) lw a1 , 0x18 ( a0 ) sltu a1 , v0 , a1 beqz a1 , 0x5f8 seb v1 , v1 addiu a1 , v0 , 0x1 sw a1 , 0x14 ( a0 ) sb v1 , ( v0 ) sltu v0 , s3 , s5 bnez v0 , 0x3e0 addiu v0 , zero , 0x1 lw v0 , 0x1c ( sp ) bnez v0 , 0x18c lw v0 , 0x30 ( sp ) b 0x344 lw t9 , - 0x7e7c ( gp ) lw a0 , ( s0 ) lw v1 , 0x14 ( a0 ) lw v0 , 0x18 ( a0 ) sltu v0 , v1 , v0 beqz v0 , 0x55c addiu v0 , v1 , 0x1 addiu s2 , s2 , 0x1 sw v0 , 0x14 ( a0 ) lw v0 , 0x20 ( sp ) sb a1 , ( v1 ) lw v0 , - 0x6d70 ( v0 ) bne v0 , s2 , 0x3d4 sltu v0 , s3 , s5 lw v0 , 0x30 ( sp ) move s4 , zero lw s2 , - 0x6d6c ( v0 ) addiu v0 , zero , 0x1 b 0x328 sw v0 , 0x2c ( sp ) b 0x328 lw s2 , - 0x6d6c ( v0 ) lw v1 , 0x6c ( sp ) sll v0 , s3 , 0x2 lw t9 , - 0x7fd4 ( gp ) addiu a1 , zero , 0x3 move a0 , zero addu v0 , v1 , v0 bal 0x2d7c lw a2 , - 0x4 ( v0 ) move a0 , zero lw gp , 0x10 ( sp ) move a3 , v0 lw a2 , 0x38 ( sp ) lw t9 , - 0x7eb8 ( gp ) jalr t9 move a1 , s6 lw gp , 0x10 ( sp ) sw zero , 0x34 ( sp ) lw v0 , - 0x7ee0 ( gp ) lw v0 , ( v0 ) bne s7 , v0 , 0x2d0 lw t9 , - 0x7fd0 ( gp ) lw t9 , - 0x7f14 ( gp ) jalr t9 move a0 , s7 b 0x2e4 lw gp , 0x10 ( sp ) lw v1 , 0x24 ( sp ) sll v0 , s3 , 0x2 lw t9 , - 0x7fd4 ( gp ) addiu a1 , zero , 0x3 move a0 , zero lw s6 , ( v1 ) lw v1 , 0x6c ( sp ) addu v0 , v1 , v0 bal 0x2d7c lw a2 , - 0x4 ( v0 ) move a0 , zero lw gp , 0x10 ( sp ) move a3 , v0 lw a2 , 0x38 ( sp ) lw t9 , - 0x7eb8 ( gp ) jalr t9 move a1 , s6 lw gp , 0x10 ( sp ) b 0x2e4 sw zero , 0x34 ( sp ) beq s5 , s3 , 0x3fc nop b 0x3b4 lb a1 , ( s2 ) lw t9 , - 0x7f1c ( gp ) jalr t9 andi a1 , a1 , 0xff bgez v0 , 0x3bc lw gp , 0x10 ( sp ) b 0x280 nop beqz v0 , 0x42c lw s0 , - 0x7ef8 ( gp ) beqz s4 , 0x5ac lw a0 , ( s0 ) lw t9 , - 0x7e8c ( gp ) move a3 , a0 lw a0 , 0x28 ( sp ) addiu a1 , zero , 0x1 jalr t9 move a2 , s4 bne v0 , s4 , 0x280 lw gp , 0x10 ( sp ) lw a0 , ( s0 ) lw v0 , 0x14 ( a0 ) lw v1 , 0x18 ( a0 ) sltu v1 , v0 , v1 beqz v1 , 0x630 lb a1 , - 0x6fb8 ( s1 ) addiu v1 , v0 , 0x1 sw v1 , 0x14 ( a0 ) sb a1 , ( v0 ) lw v0 , 0x1c ( sp ) bnez v0 , 0x18c lw v0 , 0x30 ( sp ) b 0x344 lw t9 , - 0x7e7c ( gp ) lw a0 , ( s0 ) lw v0 , 0x14 ( a0 ) lw a1 , 0x18 ( a0 ) sltu a1 , v0 , a1 bnez a1 , 0x414 lb v1 , - 0x6fb8 ( s1 ) lw t9 , - 0x7f1c ( gp ) jalr t9 andi a1 , v1 , 0xff bgez v0 , 0x3d0 lw gp , 0x10 ( sp ) b 0x280 nop addiu v0 , zero , 0x1 sw s5 , 0x1c ( sp ) b 0x168 sw v0 , 0x34 ( sp ) addiu v0 , zero , 0x1 b 0x340 sw v0 , 0x34 ( sp ) lw t9 , - 0x7f1c ( gp ) jalr t9 andi a1 , a1 , 0xff bltz v0 , 0x280 lw gp , 0x10 ( sp ) lw v0 , 0x1c ( sp ) bnez v0 , 0x18c lw v0 , 0x30 ( sp ) b 0x344 lw t9 , - 0x7e7c ( gp ) lw t9 , - 0x7ef0 ( gp ) jalr t9 nop addiu a1 , zero , 0x3 lw gp , 0x10 ( sp ) move a0 , zero lw a2 , ( s0 ) lw t9 , - 0x7fd4 ( gp ) bal 0x2d7c lw s0 , ( v0 ) lui a2 , 0x40 lw gp , 0x10 ( sp ) addiu a0 , zero , 0x1 addiu a2 , a2 , 0x7780 move a3 , v0 lw t9 , - 0x7eb8 ( gp ) jalr t9 move a1 , s0 lw t9 , - 0x7e94 ( gp ) addiu a2 , zero , 0x5 addiu a1 , a1 , 0x72c8 jalr t9 move a0 , zero move a1 , zero lw gp , 0x10 ( sp ) addiu a0 , zero , 0x1 lw t9 , - 0x7eb8 ( gp ) jalr t9 move a2 , v0 lw t9 , - 0x7fc8 ( gp ) bal 0x3a70 nop
Similarity: -1
Label: 1
Similarity Score: -0.9
Explanation: The two assembly code snippets show significant differences:
1. Architecture: Code1 uses x86 instructions (ebp/esp registers, call) while Code2 uses MIPS (lui/addiu, sw/jalr).
2. Structure: Code1 has complex stack management with local variables and nested conditionals. Code2 uses GP-relative addressing and distinct calling conventions.
3. Control flow: Code1 uses jmp/je/jne for loops and conditionals. Code2 relies on MIPS branch instructions (beq/bnez) with delay slots.
4. Key operations: Code1
------------------------------------------------------------

------------------------------------------------------------
Code1: push edi push esi push ebx mov edi , dword ptr [ esp + 0x10 ] call 0xfffcdbf0 add ebx , 0x240430 sub esp , 0xc lea eax , [ ebx - 0x24330c ] push eax lea eax , [ ebx - 0x242cdc ] push eax push 0x0 push 0x3 push dword ptr [ edi + 0x4 ] call 0xdcd00 add esp , 0x20 test eax , eax je 0x98 mov eax , dword ptr [ edi ] test eax , eax jne 0x50 mov esi , 0x1 mov eax , esi pop ebx pop esi pop edi ret mov esi , esi lea edi , [ edi ] lea eax , [ ebx - 0x2432bc ] sub esp , 0xc push eax lea eax , [ ebx - 0x242cfc ] push eax lea eax , [ ebx - 0x24331c ] push eax push 0x5 push dword ptr [ edi + 0x4 ] call 0xdcd00 add esp , 0x20 test eax , eax mov esi , eax jne 0x3c mov eax , dword ptr [ edi + 0x4 ] sub esp , 0xc push dword ptr [ eax + 0x18 ] push dword ptr [ eax + 0x14 ] push dword ptr [ eax + 0x10 ] lea eax , [ ebx - 0xf180c ] jmp 0xaf lea esi , [ esi ] mov esi , eax mov eax , dword ptr [ edi + 0x4 ] sub esp , 0xc push dword ptr [ eax + 0x18 ] push dword ptr [ eax + 0x14 ] push dword ptr [ eax + 0x10 ] lea eax , [ ebx - 0xf1840 ] push eax lea eax , [ ebx + 0xc9c4 ] push dword ptr [ eax ] call 0x904a0 add esp , 0x20 mov eax , esi pop ebx pop esi pop edi ret lea esi , [ esi ] lea edi , [ edi ]
Code2: lui gp , 0x6c addiu sp , sp , - 0x30 addiu gp , gp , 0x3de0 lui v0 , 0x46 lui a3 , 0x46 sw s1 , 0x28 ( sp ) sw gp , 0x18 ( sp ) addiu v0 , v0 , - 0x690c sw ra , 0x2c ( sp ) move s1 , a0 sw s0 , 0x24 ( sp ) addiu a3 , a3 , - 0x6080 lw t9 , - 0x71dc ( gp ) move a2 , zero lw a0 , 0x4 ( a0 ) addiu a1 , zero , 0x3 jalr t9 sw v0 , 0x10 ( sp ) beqz v0 , 0xc0 lw gp , 0x18 ( sp ) lw v0 , ( s1 ) bnez v0 , 0x78 lui v0 , 0x46 lw ra , 0x2c ( sp ) addiu s0 , zero , 0x1 lw s1 , 0x28 ( sp ) move v0 , s0 lw s0 , 0x24 ( sp ) jr ra addiu sp , sp , 0x30 lw t9 , - 0x71dc ( gp ) lui a3 , 0x46 lw a0 , 0x4 ( s1 ) lui a2 , 0x46 addiu v0 , v0 , - 0x68b0 addiu a3 , a3 , - 0x6094 addiu a2 , a2 , - 0x6920 sw v0 , 0x10 ( sp ) jalr t9 addiu a1 , zero , 0x5 lw gp , 0x18 ( sp ) bnez v0 , 0x5c move s0 , v0 lui a1 , 0x65 lw v0 , 0x4 ( s1 ) lw t9 , - 0x7fa8 ( gp ) b 0xd4 addiu a1 , a1 , 0x3968 lui a1 , 0x65 lw t9 , - 0x7fa8 ( gp ) move s0 , v0 lw v0 , 0x4 ( s1 ) addiu a1 , a1 , 0x3934 lw v1 , - 0x7fa4 ( gp ) lw a3 , 0x14 ( v0 ) lw a2 , 0x10 ( v0 ) lw v0 , 0x18 ( v0 ) lw a0 , ( v1 ) jalr t9 sw v0 , 0x10 ( sp ) move v0 , s0 lw ra , 0x2c ( sp ) lw s1 , 0x28 ( sp ) lw s0 , 0x24 ( sp ) jr ra addiu sp , sp , 0x30
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly code snippets are fundamentally dissimilar due to differences in architecture (x86 vs MIPS), instruction sets, register usage, and calling conventions. The first code uses x86-specific instructions like `push`/`pop` and registers such as `edi`/`esi`, while the second uses MIPS-specific instructions like `lui`/`addiu` and registers like `gp`/`v0`. The control flow patterns, stack management, and function call mechanisms show no meaningful alignment. Key structural elements—such as argument setup for function calls and branch conditions—are implemented in entirely different ways, with no overlapping logic or equivalent operations between the two codes.
------------------------------------------------------------

------------------------------------------------------------
Code1: lui gp , 0x42 addiu sp , sp , - 0x48 addiu gp , gp , 0x70e0 sw ra , 0x44 ( sp ) sw s7 , 0x40 ( sp ) sw s6 , 0x3c ( sp ) sw s5 , 0x38 ( sp ) sw s4 , 0x34 ( sp ) sw s3 , 0x30 ( sp ) sw s2 , 0x2c ( sp ) sw s1 , 0x28 ( sp ) sw s0 , 0x24 ( sp ) beqz a0 , 0x84 sw gp , 0x10 ( sp ) lui s3 , 0x42 lw s1 , - 0xd18 ( s3 ) beqz s1 , 0x2d0 lui a3 , 0x41 lw v0 , ( a0 ) andi v0 , v0 , 0x20 bnez v0 , 0x254 move s0 , a0 lui s2 , 0x41 lw t9 , - 0x7e28 ( gp ) move a0 , s1 jalr t9 addiu a1 , s2 , - 0x2b54 bnez v0 , 0x1e4 lw gp , 0x10 ( sp ) lw t9 , - 0x7ed8 ( gp ) jalr t9 move a0 , s0 lw gp , 0x10 ( sp ) lui s1 , 0x42 lw v0 , - 0xd10 ( s1 ) addiu v1 , v0 , 0x4 lw s0 , ( v0 ) beqz s0 , 0x1b4 sw v1 , - 0xd10 ( s1 ) lui s7 , 0x41 lui s3 , 0x41 lui s2 , 0x41 addiu s7 , s7 , - 0x2b50 lui s6 , 0x42 addiu s5 , zero , 0x1 addiu s3 , s3 , - 0x2bdc b 0x138 lui s4 , 0x42 lw v0 , - 0x7ea0 ( gp ) sb s5 , - 0xd14 ( s6 ) lw v0 , ( v0 ) bnez v0 , 0x16c lui v1 , 0x42 lw t9 , - 0x7eb0 ( gp ) jalr t9 nop addiu a1 , zero , 0x3 lw gp , 0x10 ( sp ) move a0 , zero move a2 , s0 lw t9 , - 0x7f6c ( gp ) bal 0x3ff4 lw s0 , ( v0 ) move a0 , zero lw gp , 0x10 ( sp ) move a3 , v0 move a1 , s0 lw t9 , - 0x7e78 ( gp ) jalr t9 move a2 , s3 addiu v1 , zero , 0x1 lw v0 , - 0xd10 ( s1 ) lw gp , 0x10 ( sp ) sw v1 , - 0xd20 ( s4 ) addiu v1 , v0 , 0x4 lw s0 , ( v0 ) beqz s0 , 0x1b4 sw v1 , - 0xd10 ( s1 ) lw t9 , - 0x7e28 ( gp ) addiu a1 , s2 , - 0x2b54 jalr t9 move a0 , s0 beqz v0 , 0xc0 lw gp , 0x10 ( sp ) lw t9 , - 0x7ef0 ( gp ) move a1 , s7 jalr t9 move a0 , s0 beqz v0 , 0xd4 lw gp , 0x10 ( sp ) lui v1 , 0x42 lw t9 , - 0x7f68 ( gp ) addiu a1 , zero , 0x2 sw v0 , 0x1c ( sp ) move a0 , v0 bal 0x544 sw s0 , - 0xd18 ( v1 ) lw ra , 0x44 ( sp ) lw v0 , 0x1c ( sp ) lw s7 , 0x40 ( sp ) lw s6 , 0x3c ( sp ) lw s5 , 0x38 ( sp ) lw s4 , 0x34 ( sp ) lw s3 , 0x30 ( sp ) lw s2 , 0x2c ( sp ) lw s1 , 0x28 ( sp ) lw s0 , 0x24 ( sp ) jr ra addiu sp , sp , 0x48 lw ra , 0x44 ( sp ) move v0 , zero lw s7 , 0x40 ( sp ) lw s6 , 0x3c ( sp ) lw s5 , 0x38 ( sp ) lw s4 , 0x34 ( sp ) lw s3 , 0x30 ( sp ) lw s2 , 0x2c ( sp ) lw s1 , 0x28 ( sp ) lw s0 , 0x24 ( sp ) jr ra addiu sp , sp , 0x48 lw t9 , - 0x7f64 ( gp ) bal 0x70e0 move a0 , s0 beqz v0 , 0x84 lw gp , 0x10 ( sp ) lw t9 , - 0x7eb0 ( gp ) jalr t9 lui s1 , 0x42 addiu a1 , zero , 0x3 lw gp , 0x10 ( sp ) move a0 , zero lw a2 , - 0xd18 ( s3 ) lw t9 , - 0x7f6c ( gp ) bal 0x3ff4 lw s0 , ( v0 ) lui a2 , 0x41 lw gp , 0x10 ( sp ) move a0 , zero addiu a2 , a2 , - 0x2bdc move a3 , v0 lw t9 , - 0x7e78 ( gp ) jalr t9 move a1 , s0 lui v0 , 0x42 addiu v1 , zero , 0x1 lw gp , 0x10 ( sp ) b 0x88 sw v1 , - 0xd20 ( v0 ) lw t9 , - 0x7eb0 ( gp ) jalr t9 lui s2 , 0x41 addiu a1 , zero , 0x3 lw gp , 0x10 ( sp ) move a0 , zero move a2 , s1 lw t9 , - 0x7f6c ( gp ) bal 0x3ff4 lw s1 , ( v0 ) lui a2 , 0x41 lw gp , 0x10 ( sp ) move a0 , zero addiu a2 , a2 , - 0x2bdc move a3 , v0 lw t9 , - 0x7e78 ( gp ) jalr t9 move a1 , s1 lui v0 , 0x42 lw gp , 0x10 ( sp ) addiu v1 , zero , 0x1 lw s1 , - 0xd18 ( s3 ) addiu a1 , s2 , - 0x2b54 sw v1 , - 0xd20 ( v0 ) lw t9 , - 0x7e28 ( gp ) jalr t9 move a0 , s1 bnez v0 , 0x1e4 lw gp , 0x10 ( sp ) b 0x78 lw t9 , - 0x7ed8 ( gp ) lw t9 , - 0x7f14 ( gp ) lui a1 , 0x41 lui a0 , 0x41 addiu a3 , a3 , - 0x2990 addiu a2 , zero , 0x155 addiu a1 , a1 , - 0x2b74 jalr t9 addiu a0 , a0 , - 0x2b60
Code2: push ebp mov ebp , esp sub esp , 0x28 mov eax , dword ptr [ ebp + 0x8 ] mov ecx , dword ptr [ ebp + 0x8 ] test ecx , ecx setne dl movzx ecx , dl mov ecx , dword ptr [ ecx * 0x4 + 0x8052734 ] mov dword ptr [ ebp - 0xc ] , eax jmp ecx mov eax , dword ptr [ 0x80538e8 ] test eax , eax setne cl movzx eax , cl mov eax , dword ptr [ eax * 0x4 + 0x805273c ] jmp eax mov eax , dword ptr [ 0x8052570 ] jmp eax lea eax , [ 0x804ff18 ] mov dword ptr [ esp ] , eax lea eax , [ 0x804ff22 ] mov dword ptr [ esp + 0x4 ] , eax mov dword ptr [ esp + 0x8 ] , 0x155 lea eax , [ 0x804ff36 ] mov dword ptr [ esp + 0xc ] , eax call 0xffffe380 mov eax , dword ptr [ ebp + 0x8 ] mov ecx , esp mov dword ptr [ ecx ] , eax call 0xffffe180 test eax , eax setne dl movzx eax , dl mov eax , dword ptr [ eax * 0x4 + 0x8052744 ] jmp eax call 0xffffe290 mov eax , dword ptr [ eax ] mov ecx , dword ptr [ 0x80538e8 ] mov edx , esp mov dword ptr [ edx + 0x8 ] , ecx mov dword ptr [ edx + 0x4 ] , 0x3 mov dword ptr [ edx ] , 0x0 mov dword ptr [ ebp - 0x10 ] , eax call 0x2f30 mov ecx , esp mov dword ptr [ ecx + 0xc ] , eax mov eax , dword ptr [ ebp - 0x10 ] mov dword ptr [ ecx + 0x4 ] , eax mov dword ptr [ ecx + 0x8 ] , 0x804ff15 mov dword ptr [ ecx ] , 0x0 call 0xffffe1d0 mov dword ptr [ 0x80538b4 ] , 0x1 mov eax , dword ptr [ 0x8052578 ] jmp eax mov eax , dword ptr [ 0x80538e8 ] mov ecx , esp mov dword ptr [ ecx ] , eax mov dword ptr [ ecx + 0x4 ] , 0x8050203 call 0xffffe0a0 test eax , eax sete dl movzx eax , dl mov eax , dword ptr [ eax * 0x4 + 0x805274c ] jmp eax mov eax , dword ptr [ ebp + 0x8 ] mov ecx , esp mov dword ptr [ ecx ] , eax call 0xffffe2f0 mov eax , dword ptr [ 0x805258c ] jmp eax mov eax , dword ptr [ ebp + 0x8 ] mov ecx , esp mov dword ptr [ ecx ] , eax call 0x4080 test eax , eax setne dl movzx eax , dl mov eax , dword ptr [ eax * 0x4 + 0x8052754 ] jmp eax call 0xffffe290 mov eax , dword ptr [ eax ] mov ecx , dword ptr [ 0x80538e8 ] mov edx , esp mov dword ptr [ edx + 0x8 ] , ecx mov dword ptr [ edx + 0x4 ] , 0x3 mov dword ptr [ edx ] , 0x0 mov dword ptr [ ebp - 0x14 ] , eax call 0x2f30 mov ecx , esp mov dword ptr [ ecx + 0xc ] , eax mov eax , dword ptr [ ebp - 0x14 ] mov dword ptr [ ecx + 0x4 ] , eax mov dword ptr [ ecx + 0x8 ] , 0x804ff15 mov dword ptr [ ecx ] , 0x0 call 0xffffe1d0 mov dword ptr [ 0x80538b4 ] , 0x1 mov eax , dword ptr [ 0x8052588 ] jmp eax mov eax , dword ptr [ 0x805258c ] jmp eax mov eax , dword ptr [ 0x8052590 ] jmp eax mov eax , dword ptr [ 0x8052594 ] jmp eax mov eax , dword ptr [ 0x80538e4 ] mov ecx , eax add ecx , 0x4 mov dword ptr [ 0x80538e4 ] , ecx mov eax , dword ptr [ eax ] mov dword ptr [ ebp - 0x8 ] , eax test eax , eax setne dl movzx eax , dl mov eax , dword ptr [ eax * 0x4 + 0x805275c ] jmp eax mov eax , dword ptr [ ebp - 0x8 ] mov ecx , esp mov dword ptr [ ecx ] , eax mov dword ptr [ ecx + 0x4 ] , 0x8050203 call 0xffffe0a0 test eax , eax sete dl movzx eax , dl mov eax , dword ptr [ eax * 0x4 + 0x8052764 ] jmp eax mov byte ptr [ 0x80538e0 ] , 0x1 mov eax , dword ptr [ 0x80538a0 ] mov dword ptr [ ebp + 0x8 ] , eax mov eax , dword ptr [ 0x80525a4 ] jmp eax mov eax , dword ptr [ ebp - 0x8 ] mov ecx , esp mov dword ptr [ ecx ] , eax mov dword ptr [ ecx + 0x4 ] , 0x804fdc4 call 0xffffe170 mov dword ptr [ ebp + 0x8 ] , eax mov eax , dword ptr [ 0x80525a4 ] jmp eax mov eax , dword ptr [ ebp + 0x8 ] test eax , eax setne cl movzx eax , cl mov eax , dword ptr [ eax * 0x4 + 0x805276c ] jmp eax mov eax , dword ptr [ ebp - 0x8 ] mov dword ptr [ 0x80538e8 ] , eax mov eax , dword ptr [ ebp + 0x8 ] mov ecx , esp mov dword ptr [ ecx ] , eax mov dword ptr [ ecx + 0x4 ] , 0x2 call 0x570 mov eax , dword ptr [ ebp + 0x8 ] mov dword ptr [ ebp - 0x4 ] , eax mov eax , dword ptr [ 0x80525b4 ] jmp eax call 0xffffe290 mov eax , dword ptr [ eax ] mov ecx , dword ptr [ ebp - 0x8 ] mov edx , esp mov dword ptr [ edx + 0x8 ] , ecx mov dword ptr [ edx + 0x4 ] , 0x3 mov dword ptr [ edx ] , 0x0 mov dword ptr [ ebp - 0x18 ] , eax call 0x2f30 mov ecx , esp mov dword ptr [ ecx + 0xc ] , eax mov eax , dword ptr [ ebp - 0x18 ] mov dword ptr [ ecx + 0x4 ] , eax mov dword ptr [ ecx + 0x8 ] , 0x804ff15 mov dword ptr [ ecx ] , 0x0 call 0xffffe1d0 mov dword ptr [ 0x80538b4 ] , 0x1 mov eax , dword ptr [ 0x8052594 ] jmp eax mov dword ptr [ ebp - 0x4 ] , 0x0 mov eax , dword ptr [ 0x80525b4 ] jmp eax mov eax , dword ptr [ ebp - 0x4 ] add esp , 0x28 pop ebp ret nop word ptr [ eax + eax ]
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly codes are fundamentally dissimilar due to architectural differences (MIPS vs x86), distinct instruction sets, and unrelated control flow patterns. The MIPS code uses architecture-specific operations like lui, addiu, jalr, and MIPS register conventions (gp, sp, s0-s7), while the x86 code relies on x86-specific instructions like mov, test, call, and uses registers like ebp, esp, eax. No structural or functional similarities exist in memory operations, branching logic, or subroutine handling. The codes appear to solve entirely different problems with no overlapping logic or sequences.
------------------------------------------------------------

------------------------------------------------------------
Code1: push rbp mov rbp , rsp add rsp , - 0x80 mov dword ptr [ rbp - 0x64 ] , edi mov qword ptr [ rbp - 0x70 ] , rsi mov qword ptr [ rbp - 0x78 ] , rdx mov dword ptr [ rbp - 0x68 ] , ecx mov qword ptr [ rbp - 0x80 ] , r8 mov rax , qword ptr fs : [ 0x28 ] mov qword ptr [ rbp - 0x8 ] , rax xor eax , eax lea rdi , [ rip + 0x23b2df ] call 0xfffffffffffffe88 mov qword ptr [ rbp - 0x58 ] , rax mov eax , dword ptr [ rbp - 0x68 ] movsxd rdx , eax mov rax , qword ptr [ rbp - 0x58 ] mov rax , qword ptr [ rax + 0x8 ] mov rcx , qword ptr [ rbp - 0x78 ] mov rsi , rcx mov rdi , rax call 0xfffffffffffe700e cmp dword ptr [ rbp - 0x64 ] , 0x0 je 0x75 mov eax , dword ptr [ rbp - 0x64 ] movsxd rdx , eax mov rax , qword ptr [ rbp - 0x58 ] mov rax , qword ptr [ rax + 0x8 ] mov rsi , rdx mov rdi , rax call 0xfffffffffffe71ea lea rdx , [ rbp - 0x50 ] mov rax , qword ptr [ rbp - 0x58 ] mov rsi , rdx mov rdi , rax call 0xfffffffffffffea6 mov rcx , qword ptr [ rbp - 0x80 ] lea rdx , [ rbp - 0x50 ] mov rax , qword ptr [ rbp - 0x70 ] mov r8 , rcx mov ecx , 0x40 mov esi , 0x40 mov rdi , rax call 0xffffffffffffff7d lea rax , [ rbp - 0x50 ] mov esi , 0x40 mov rdi , rax call 0x257b8 nop mov rax , qword ptr [ rbp - 0x8 ] xor rax , qword ptr fs : [ 0x28 ] je 0xcf call 0xfffffffffffd93ff leave ret
Code2: push ebp push edi push esi push ebx call 0xfffdfe90 add ebx , 0x542bf sub esp , 0x78 mov eax , dword ptr [ esp + 0x90 ] mov esi , dword ptr [ esp + 0x94 ] mov ebp , dword ptr [ esp + 0x9c ] mov dword ptr [ esp + 0x18 ] , eax mov eax , dword ptr gs : [ 0x14 ] mov dword ptr [ esp + 0x68 ] , eax xor eax , eax lea eax , [ ebx - 0x2e8 ] push eax call dword ptr [ eax ] add esp , 0xc mov edi , eax push dword ptr [ esp + 0x90 ] push esi push dword ptr [ eax + 0x4 ] call 0xfffe9c20 add esp , 0x10 mov ecx , dword ptr [ esp + 0x80 ] test ecx , ecx je 0x78 sub esp , 0x8 push dword ptr [ esp + 0x88 ] push dword ptr [ edi + 0x4 ] call 0xfffe9d70 add esp , 0x10 sub esp , 0x8 mov eax , dword ptr [ edi ] lea edx , [ esp + 0x24 ] mov dword ptr [ esp + 0x10 ] , edx push edx push edi mov edi , 0x40 call dword ptr [ eax + 0x8 ] call 0x1d00 mov esi , eax mov dword ptr [ esp ] , eax call 0x1540 mov dword ptr [ esp ] , 0x40 push dword ptr [ esp + 0x18 ] push 0x40 push dword ptr [ esp + 0x24 ] push esi call 0x1680 add esp , 0x20 nop lea esi , [ esi ] sub esp , 0xc push 0x0 push 0x0 push 0x40 push dword ptr [ esp + 0x20 ] push esi call 0x1680 add esp , 0x14 push 0x0 push 0x0 push 0x40 push dword ptr [ esp + 0x24 ] push esi call 0x1680 add esp , 0x20 sub edi , 0x1 jne 0xc0 mov dword ptr [ ebp ] , 0x4f787963 mov dword ptr [ ebp + 0x4 ] , 0x68726f6d mov edi , 0x40 mov dword ptr [ ebp + 0x8 ] , 0x61746963 mov dword ptr [ ebp + 0xc ] , 0x426c6f77 mov dword ptr [ ebp + 0x10 ] , 0x66697368 mov dword ptr [ ebp + 0x14 ] , 0x53776174 mov dword ptr [ ebp + 0x18 ] , 0x44796e61 mov dword ptr [ ebp + 0x1c ] , 0x6d697465 nop lea esi , [ esi ] sub esp , 0x4 push esi push 0x20 push ebp call 0x1470 add esp , 0x10 sub edi , 0x1 jne 0x130 sub esp , 0xc push esi call 0x1d30 pop eax pop edx push 0x40 push dword ptr [ esp + 0x14 ] call 0x30530 add esp , 0x10 mov eax , dword ptr [ esp + 0x5c ] xor eax , dword ptr gs : [ 0x14 ] jne 0x172 add esp , 0x6c pop ebx pop esi pop edi pop ebp ret call 0x31080 mov esi , esi lea edi , [ edi ]
Similarity: -1
Label: 1
Similarity Score: -0.85
Explanation: The two assembly codes show significant dissimilarities due to architectural differences (x86_64 vs x86) and functional implementation. Key differences include:
1. Stack management: Different register usage (RBP vs EBP) and stack adjustment methods
2. Argument handling: 64-bit uses registers (RDI, RSI), 32-bit uses stack offsets
3. Control flow: Code2 contains loops with counter decrements (EDI) and multiple call patterns absent in Code1
4. Data operations: Code2 writes explicit string constants to memory (e.g., "Oxyc", "hrom", etc.) while Code1 performs pointer-based operations
------------------------------------------------------------

------------------------------------------------------------
Code1: push ebp mov ebp , esp push edi push esi sub esp , 0x30 mov eax , dword ptr [ ebp + 0xc ] mov ecx , dword ptr [ ebp + 0x8 ] mov dword ptr [ ebp - 0x10 ] , eax mov dword ptr [ ebp - 0x14 ] , ecx mov eax , esp add eax , - 0x10 mov esp , eax mov ecx , esp add ecx , - 0x10 mov esp , ecx mov edx , esp add edx , - 0x10 mov esp , edx mov esi , esp add esi , - 0x10 mov esp , esi mov edi , dword ptr [ ebp - 0x14 ] mov dword ptr [ eax ] , edi mov dword ptr [ ebp - 0x18 ] , eax mov dword ptr [ ebp - 0x1c ] , ecx mov dword ptr [ ebp - 0x20 ] , edx mov dword ptr [ ebp - 0x24 ] , esi mov eax , dword ptr [ ebp - 0x1c ] mov ecx , dword ptr [ ebp - 0x10 ] mov dword ptr [ eax ] , ecx mov eax , dword ptr [ ebp - 0x18 ] mov ecx , dword ptr [ eax ] sub esp , 0x10 mov dword ptr [ esp ] , ecx call 0x5e0 add esp , 0x10 and al , 0x1 mov ecx , dword ptr [ ebp - 0x20 ] mov byte ptr [ ecx ] , al mov edx , dword ptr [ ebp - 0x1c ] mov esi , dword ptr [ edx ] sub esp , 0x10 mov dword ptr [ esp ] , esi call 0x5e0 add esp , 0x10 and al , 0x1 mov ecx , dword ptr [ ebp - 0x24 ] mov byte ptr [ ecx ] , al mov edx , dword ptr [ ebp - 0x20 ] mov al , byte ptr [ edx ] mov byte ptr [ ebp - 0x25 ] , al mov al , byte ptr [ ebp - 0x25 ] test al , 0x1 jne 0x95 jmp 0xb9 mov eax , dword ptr [ ebp - 0x24 ] mov cl , byte ptr [ eax ] mov byte ptr [ ebp - 0x26 ] , cl mov al , byte ptr [ ebp - 0x26 ] test al , 0x1 jne 0xb9 jmp 0xad mov dword ptr [ ebp - 0xc ] , 0xffffffff jmp 0x135 mov eax , dword ptr [ ebp - 0x20 ] mov cl , byte ptr [ eax ] mov byte ptr [ ebp - 0x27 ] , cl mov al , byte ptr [ ebp - 0x27 ] test al , 0x1 jne 0xf5 jmp 0xd1 mov eax , dword ptr [ ebp - 0x24 ] mov cl , byte ptr [ eax ] mov byte ptr [ ebp - 0x28 ] , cl mov al , byte ptr [ ebp - 0x28 ] test al , 0x1 jne 0xe9 jmp 0xf5 mov dword ptr [ ebp - 0xc ] , 0x1 jmp 0x135 jmp 0xfa mov eax , dword ptr [ ebp - 0x1c ] mov ecx , dword ptr [ eax ] mov dword ptr [ ebp - 0x2c ] , ecx mov eax , dword ptr [ ebp - 0x2c ] mov ecx , dword ptr [ ebp - 0x18 ] mov edx , dword ptr [ ecx ] mov dword ptr [ ebp - 0x30 ] , eax mov dword ptr [ ebp - 0x34 ] , edx sub esp , 0x10 mov eax , dword ptr [ ebp - 0x30 ] mov dword ptr [ esp ] , eax mov ecx , dword ptr [ ebp - 0x34 ] mov dword ptr [ esp + 0x4 ] , ecx lea edx , [ 0x8058220 ] mov dword ptr [ esp + 0x8 ] , edx call 0xaf0 add esp , 0x10 mov dword ptr [ ebp - 0xc ] , eax mov eax , dword ptr [ ebp - 0xc ] mov dword ptr [ ebp - 0x38 ] , eax mov eax , dword ptr [ ebp - 0x38 ] lea esp , [ ebp - 0x8 ] pop esi pop edi pop ebp ret nop word ptr cs : [ eax + eax ] nop
Code2: push ebp mov ebp , esp sub esp , 0x48 mov eax , dword ptr [ ebp + 0xc ] mov ecx , dword ptr [ ebp + 0x8 ] mov dword ptr [ ebp - 0xc ] , 0x646b8374 mov dword ptr [ ebp - 0x10 ] , eax mov dword ptr [ ebp - 0x14 ] , ecx mov eax , dword ptr [ ebp - 0xc ] mov ecx , eax sub ecx , 0x8d118f22 mov dword ptr [ ebp - 0x18 ] , eax mov dword ptr [ ebp - 0x1c ] , ecx je 0x1cf jmp 0x35 mov eax , dword ptr [ ebp - 0x18 ] sub eax , 0x99d20447 mov dword ptr [ ebp - 0x20 ] , eax je 0x198 jmp 0x4b mov eax , dword ptr [ ebp - 0x18 ] sub eax , 0x9fac9ebf mov dword ptr [ ebp - 0x24 ] , eax je 0x16b jmp 0x61 mov eax , dword ptr [ ebp - 0x18 ] sub eax , 0xaa240ff5 mov dword ptr [ ebp - 0x28 ] , eax je 0x185 jmp 0x77 mov eax , dword ptr [ ebp - 0x18 ] sub eax , 0xcf3f5541 mov dword ptr [ ebp - 0x2c ] , eax je 0x124 jmp 0x8d mov eax , dword ptr [ ebp - 0x18 ] sub eax , 0xd48c38d2 mov dword ptr [ ebp - 0x30 ] , eax je 0x1a4 jmp 0xa3 mov eax , dword ptr [ ebp - 0x18 ] sub eax , 0xec1fc4f7 mov dword ptr [ ebp - 0x34 ] , eax je 0x151 jmp 0xb9 mov eax , dword ptr [ ebp - 0x18 ] sub eax , 0x2f6a2f3e mov dword ptr [ ebp - 0x38 ] , eax je 0x13e jmp 0xcf mov eax , dword ptr [ ebp - 0x18 ] sub eax , 0x646b8374 mov dword ptr [ ebp - 0x3c ] , eax je 0xea jmp 0xe5 jmp 0x1d7 mov eax , dword ptr [ ebp + 0x8 ] mov dword ptr [ esp ] , eax call 0x750 and al , 0x1 mov byte ptr [ ebp - 0x5 ] , al mov ecx , dword ptr [ ebp + 0xc ] mov dword ptr [ esp ] , ecx call 0x750 and al , 0x1 mov byte ptr [ ebp - 0x6 ] , al mov al , byte ptr [ ebp - 0x5 ] test al , 0x1 mov ecx , 0xcf3f5541 mov edx , 0xec1fc4f7 cmovne edx , ecx mov dword ptr [ ebp - 0xc ] , edx jmp 0x1d7 mov al , byte ptr [ ebp - 0x6 ] test al , 0x1 mov ecx , 0xec1fc4f7 mov edx , 0x2f6a2f3e cmovne edx , ecx mov dword ptr [ ebp - 0xc ] , edx jmp 0x1d7 mov dword ptr [ ebp - 0x4 ] , 0xffffffff mov dword ptr [ ebp - 0xc ] , 0x8d118f22 jmp 0x1d7 mov al , byte ptr [ ebp - 0x5 ] test al , 0x1 mov ecx , 0x99d20447 mov edx , 0x9fac9ebf cmovne edx , ecx mov dword ptr [ ebp - 0xc ] , edx jmp 0x1d7 mov al , byte ptr [ ebp - 0x6 ] test al , 0x1 mov ecx , 0xaa240ff5 mov edx , 0x99d20447 cmovne edx , ecx mov dword ptr [ ebp - 0xc ] , edx jmp 0x1d7 mov dword ptr [ ebp - 0x4 ] , 0x1 mov dword ptr [ ebp - 0xc ] , 0x8d118f22 jmp 0x1d7 mov dword ptr [ ebp - 0xc ] , 0xd48c38d2 jmp 0x1d7 mov eax , dword ptr [ ebp + 0xc ] mov ecx , dword ptr [ ebp + 0x8 ] mov dword ptr [ esp ] , eax mov dword ptr [ esp + 0x4 ] , ecx lea eax , [ 0x805a790 ] mov dword ptr [ esp + 0x8 ] , eax call 0xf00 mov dword ptr [ ebp - 0x4 ] , eax mov dword ptr [ ebp - 0xc ] , 0x8d118f22 jmp 0x1d7 mov eax , dword ptr [ ebp - 0x4 ] add esp , 0x48 pop ebp ret jmp 0x19 nop dword ptr [ eax ]
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly codes have fundamentally different structures and control flows. Code1 uses a linear sequence of stack allocations and two calls to the same function (0x5e0) to test the arguments, then branches based on the results. Code2 uses a switch statement based on a constant and conditionally sets the return value or calls different functions (0x750 and 0xf00). The functions called are different, the branching logic is dissimilar, and the overall algorithm does not match. Therefore, the codes are not similar.
------------------------------------------------------------

------------------------------------------------------------
Code1: push ebp mov ebp , esp push edi push esi sub esp , 0x40 mov eax , dword ptr [ ebp + 0xc ] mov ecx , dword ptr [ ebp + 0x8 ] mov edx , dword ptr [ ebp + 0x8 ] mov esi , dword ptr [ ebp + 0xc ] mov dword ptr [ esp ] , edx mov dword ptr [ esp + 0x4 ] , esi mov dword ptr [ ebp - 0x1c ] , eax mov dword ptr [ ebp - 0x20 ] , ecx call 0x220 mov eax , dword ptr [ ebp + 0xc ] cmp dword ptr [ eax ] , 0x0 jbe 0x37 jmp 0x61 lea eax , [ 0x807d197 ] mov dword ptr [ esp ] , eax lea eax , [ 0x807d1ab ] mov dword ptr [ esp + 0x4 ] , eax mov dword ptr [ esp + 0x8 ] , 0x115 lea eax , [ 0x807d1b6 ] mov dword ptr [ esp + 0xc ] , eax call 0xfffea1e0 mov eax , dword ptr [ ebp + 0xc ] mov eax , dword ptr [ eax + 0x4 ] mov ecx , dword ptr [ ebp + 0xc ] mov ecx , dword ptr [ ecx ] sub ecx , 0x1 cmp dword ptr [ eax + ecx * 0x4 ] , 0x0 jne 0x7e jmp 0xa8 lea eax , [ 0x807d1fa ] mov dword ptr [ esp ] , eax lea eax , [ 0x807d1ab ] mov dword ptr [ esp + 0x4 ] , eax mov dword ptr [ esp + 0x8 ] , 0x116 lea eax , [ 0x807d1b6 ] mov dword ptr [ esp + 0xc ] , eax call 0xfffea1e0 mov eax , dword ptr [ ebp + 0xc ] mov eax , dword ptr [ eax ] add eax , 0x1 shl eax , 0x2 mov dword ptr [ esp ] , eax call 0xef70 mov dword ptr [ ebp - 0xc ] , eax mov dword ptr [ ebp - 0x14 ] , 0x0 mov eax , dword ptr [ ebp + 0xc ] mov eax , dword ptr [ eax ] mov dword ptr [ ebp - 0x10 ] , eax mov eax , dword ptr [ ebp + 0x8 ] mov ecx , dword ptr [ ebp + 0xc ] mov edx , dword ptr [ ebp - 0xc ] mov esi , dword ptr [ ebp - 0x10 ] mov edi , dword ptr [ ebp - 0x14 ] mov dword ptr [ esp ] , eax mov dword ptr [ esp + 0x4 ] , ecx mov dword ptr [ esp + 0x8 ] , edx mov dword ptr [ esp + 0xc ] , esi mov dword ptr [ esp + 0x10 ] , edi call 0x280 mov dword ptr [ ebp - 0x18 ] , eax mov eax , dword ptr [ ebp + 0x8 ] mov eax , dword ptr [ eax + 0x20 ] mov ecx , dword ptr [ ebp + 0x8 ] mov edx , dword ptr [ ebp + 0xc ] mov edx , dword ptr [ edx + 0x18 ] mov esi , dword ptr [ ebp - 0x18 ] mov edi , dword ptr [ ebp - 0xc ] mov dword ptr [ esp ] , ecx mov dword ptr [ esp + 0x4 ] , edx mov dword ptr [ esp + 0x8 ] , esi mov dword ptr [ esp + 0xc ] , edi call eax cmp eax , 0x0 je 0x15e mov eax , dword ptr [ ebp + 0x8 ] mov ecx , dword ptr [ ebp + 0xc ] mov edx , dword ptr [ ebp - 0x10 ] mov dword ptr [ esp ] , eax mov dword ptr [ esp + 0x4 ] , ecx mov dword ptr [ esp + 0x8 ] , 0x1 mov dword ptr [ esp + 0xc ] , edx call 0x3b0 mov dword ptr [ ebp - 0x10 ] , eax mov eax , dword ptr [ ebp - 0x18 ] mov ecx , dword ptr [ ebp + 0x8 ] sub eax , dword ptr [ ecx + 0x1c ] add eax , dword ptr [ ebp - 0x14 ] mov dword ptr [ ebp - 0x14 ] , eax jmp 0x1d0 mov eax , dword ptr [ ebp - 0x10 ] mov ecx , dword ptr [ ebp + 0x8 ] mov ecx , dword ptr [ ecx + 0x1c ] add ecx , 0x1 cmp eax , ecx ja 0x1a2 lea eax , [ 0x807d225 ] mov dword ptr [ esp ] , eax call 0xfffe9dd0 xor ecx , ecx mov dword ptr [ esp ] , 0x1 mov dword ptr [ esp + 0x4 ] , 0x0 mov dword ptr [ esp + 0x8 ] , eax mov dword ptr [ ebp - 0x24 ] , ecx call 0xfffe9d20 jmp 0x1cb xor eax , eax mov ecx , dword ptr [ ebp + 0x8 ] mov edx , dword ptr [ ebp + 0xc ] mov esi , dword ptr [ ebp - 0x10 ] mov dword ptr [ esp ] , ecx mov dword ptr [ esp + 0x4 ] , edx mov dword ptr [ esp + 0x8 ] , 0x0 mov dword ptr [ esp + 0xc ] , esi mov dword ptr [ ebp - 0x28 ] , eax call 0x3b0 mov dword ptr [ ebp - 0x10 ] , eax jmp 0x1d0 jmp 0x1d5 mov eax , dword ptr [ ebp - 0x14 ] add eax , 0x1 mov ecx , dword ptr [ ebp + 0xc ] mov ecx , dword ptr [ ecx ] mov edx , dword ptr [ ebp + 0x8 ] sub ecx , dword ptr [ edx + 0x1c ] cmp eax , ecx jb 0xcd mov eax , dword ptr [ ebp - 0xc ] mov dword ptr [ esp ] , eax call 0xfffe9a60 mov eax , dword ptr [ ebp + 0x8 ] mov ecx , dword ptr [ ebp + 0xc ] mov dword ptr [ esp ] , eax mov dword ptr [ esp + 0x4 ] , ecx call 0x530 add esp , 0x40 pop esi pop edi pop ebp ret nop word ptr cs : [ eax + eax ] nop dword ptr [ eax ]
Code2: addiu sp , sp , - 0x50 lui gp , 0x47 lui a2 , 0x45 addiu gp , gp , 0x43a0 sw s4 , 0x38 ( sp ) move a3 , zero sw zero , 0x18 ( sp ) move s4 , a1 sw zero , 0x14 ( sp ) addiu a2 , a2 , 0x7fe8 sw zero , 0x10 ( sp ) sw s5 , 0x3c ( sp ) move s5 , a0 sw gp , 0x20 ( sp ) sw ra , 0x4c ( sp ) sw fp , 0x48 ( sp ) sw s7 , 0x44 ( sp ) sw s6 , 0x40 ( sp ) sw s3 , 0x34 ( sp ) sw s2 , 0x30 ( sp ) sw s1 , 0x2c ( sp ) jal 0x41ed68 sw s0 , 0x28 ( sp ) lw a0 , ( s4 ) beqz a0 , 0x398 lw gp , 0x20 ( sp ) sll a0 , a0 , 0x2 lw v0 , 0x4 ( s4 ) addiu a0 , a0 , - 0x4 addu v0 , v0 , a0 lw v0 , ( v0 ) bnez v0 , 0x374 lw t9 , - 0x7f34 ( gp ) addiu a0 , a0 , 0x8 lui s1 , 0x46 bal 0x12304 move s7 , zero addiu s1 , s1 , - 0x7f44 lw a2 , ( s4 ) addiu s2 , zero , - 0x1 lw gp , 0x20 ( sp ) move s6 , v0 lw fp , 0x1c ( s5 ) move s3 , a2 beqz fp , 0x338 nop lw v0 , 0x4 ( s4 ) sll a1 , fp , 0x2 move v1 , s6 addu a1 , a1 , v0 lw a0 , ( v0 ) addiu v1 , v1 , 0x4 addiu v0 , v0 , 0x4 bne v0 , a1 , 0xc8 sw a0 , - 0x4 ( v1 ) addu a0 , s7 , fp move s0 , fp sltu v0 , a0 , a2 beqz v0 , 0x148 sltu v0 , s0 , s3 beqz v0 , 0x13c addu a1 , a2 , s0 lw v1 , 0x4 ( s4 ) sll v0 , s0 , 0x2 sll a3 , a0 , 0x2 addiu s0 , s0 , 0x1 addu v1 , v1 , a3 addu v0 , s6 , v0 subu a1 , a1 , a0 b 0x130 addiu a2 , s3 , 0x1 addiu a0 , s0 , 0x1 addiu v1 , v1 , 0x4 beq a2 , a0 , 0x13c addiu v0 , v0 , 0x4 move s0 , a0 lw a0 , ( v1 ) bne a1 , s0 , 0x11c sw a0 , ( v0 ) sltu fp , s0 , fp bnez fp , 0x354 lui a3 , 0x46 sll v0 , s0 , 0x2 lw t9 , 0x20 ( s5 ) lw a1 , 0x18 ( s4 ) move a3 , s6 addu v0 , s6 , v0 move a2 , s0 move a0 , s5 jalr t9 sw zero , ( v0 ) bnez v0 , 0x264 lw gp , 0x20 ( sp ) lw v0 , 0x1c ( s5 ) addiu a0 , v0 , 0x1 sltu v1 , a0 , s3 bnez v1 , 0x220 lw t9 , - 0x7aa4 ( gp ) addiu a2 , zero , 0x5 move a0 , zero jalr t9 move a1 , s1 move a1 , zero lw gp , 0x20 ( sp ) addiu a0 , zero , 0x1 lw t9 , - 0x7b14 ( gp ) jalr t9 move a2 , v0 lw gp , 0x20 ( sp ) lw fp , 0x1c ( s5 ) lw a2 , ( s4 ) addiu v0 , s7 , 0x1 subu v1 , a2 , fp sltu v0 , v0 , v1 bnez v0 , 0xb0 lw t9 , - 0x7a58 ( gp ) jalr t9 move a0 , s6 lw v0 , 0x14 ( s4 ) lw ra , 0x4c ( sp ) lw s7 , 0x44 ( sp ) lw s6 , 0x40 ( sp ) lw s5 , 0x3c ( sp ) lw s3 , 0x34 ( sp ) lw s2 , 0x30 ( sp ) lw s1 , 0x2c ( sp ) lw s0 , 0x28 ( sp ) sw v0 , 0x10 ( s4 ) addiu v0 , zero , - 0x1 sw fp , ( s4 ) sw zero , 0x1c ( s4 ) sw v0 , 0x20 ( s4 ) lw fp , 0x48 ( sp ) lw s4 , 0x38 ( sp ) jr ra addiu sp , sp , 0x50 lw v1 , 0x28 ( s4 ) sltu a1 , s3 , v1 bnez a1 , 0x2ec nop beqz v1 , 0x2ec nop move fp , v0 lw a1 , 0x24 ( s4 ) beqz a1 , 0x2c4 sltu a2 , a1 , v1 beqz a2 , 0x2c4 subu v1 , v1 , a1 srl v1 , v1 , 0x1 beqz v1 , 0x344 nop b 0x2c8 subu s3 , s3 , v1 lw v1 , 0x24 ( s4 ) sltu a0 , v1 , s3 beqz a0 , 0x330 lw v0 , 0x1c ( s5 ) sw s3 , 0x24 ( s4 ) move v1 , s3 lw fp , 0x1c ( s5 ) beqz v1 , 0x2fc nop lw a0 , 0x28 ( s4 ) sltu a1 , v1 , a0 beqz a1 , 0x2fc subu v1 , a0 , v1 srl v1 , v1 , 0x1 bnez v1 , 0x34c nop addiu s3 , s3 , 0x1 bnez v0 , 0x310 addiu v0 , v0 , 0x1 beqz s3 , 0x320 nop addu s7 , s7 , s0 b 0x1b8 subu s7 , s7 , fp srl s3 , s3 , 0x1 beqz v0 , 0x2dc sltu v0 , a0 , s3 bnez v0 , 0x1b8 nop move s3 , a0 bnez s3 , 0x1b8 nop b 0x1b8 addiu s3 , zero , 0x1 sw s3 , 0x28 ( s4 ) move v1 , s3 b 0x23c lw fp , 0x1c ( s5 ) beq s3 , s2 , 0x308 nop addiu s3 , s3 , 0x1 beqz v0 , 0x2b8 addiu v0 , v0 , 0x1 sltu v1 , s3 , v0 movn s3 , v0 , v1 bnez s3 , 0x2b8 nop addu s7 , s7 , s0 addiu s3 , zero , 0x1 b 0x1b8 subu s7 , s7 , fp b 0x280 move fp , v0 move s0 , zero b 0xe4 move a0 , s7 b 0x2c8 addiu s3 , s3 , - 0x1 b 0x2a8 addu s3 , s3 , v1 lw t9 , - 0x7c70 ( gp ) lui a1 , 0x45 lui a0 , 0x46 addiu a3 , a3 , - 0x7e10 addiu a2 , zero , 0x102 addiu a1 , a1 , 0x7fd0 jalr t9 addiu a0 , a0 , - 0x7f64 lui a3 , 0x46 lw t9 , - 0x7c70 ( gp ) lui a1 , 0x45 lui a0 , 0x46 addiu a3 , a3 , - 0x7e04 addiu a2 , zero , 0x116 addiu a1 , a1 , 0x7fd0 jalr t9 addiu a0 , a0 , - 0x7f90 lui a3 , 0x46 lw t9 , - 0x7c70 ( gp ) lui a1 , 0x45 lui a0 , 0x46 addiu a3 , a3 , - 0x7e04 addiu a2 , zero , 0x115 addiu a1 , a1 , 0x7fd0 jalr t9 addiu a0 , a0 , - 0x7fa4
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two code snippets are from different architectures (x86 and MIPS) and exhibit no significant structural or functional similarities. The instruction sets, register usage, and calling conventions are entirely different, indicating that the codes are not similar.
------------------------------------------------------------

------------------------------------------------------------
Code1: push ebx sub esp , 0x8 call 0xffecf280 add eax , 0x1acc58 sub esp , 0x8 push dword ptr [ esp + 0x24 ] push dword ptr [ esp + 0x24 ] push dword ptr [ esp + 0x24 ] push dword ptr [ esp + 0x24 ] lea edx , [ eax - 0xd2179 ] push edx lea edx , [ eax - 0x1c1c6b ] push edx mov ebx , eax call 0x2f4 add esp , 0x20 add esp , 0x8 pop ebx ret
Code2: push ebx call 0xffed2a50 add ebx , 0x1bc606 sub esp , 0x10 lea eax , [ ebx - 0xe1a4e ] push dword ptr [ esp + 0x24 ] push dword ptr [ esp + 0x24 ] push dword ptr [ esp + 0x24 ] push dword ptr [ esp + 0x24 ] push eax push dword ptr [ ebx + 0x3fc ] call 0x300 add esp , 0x28 pop ebx ret lea esi , [ esi ] lea edi , [ edi ]
Similarity: -1
Label: 1
Similarity Score: 0.4
Explanation: Both code snippets share structural similarities: they start by pushing EBX,
------------------------------------------------------------

------------------------------------------------------------
Code1: ldr r3 , [ r1 , 0x10 ] and r3 , r3 , 0xf000 cmp r3 , 0xa000 beq 0x18 mov r0 , 0x0 bx lr add r1 , r2 , 0x28 mov r2 , 0x1 b 0xffffff84
Code2: push rbp mov rbp , rsp sub rsp , 0x20 mov qword ptr [ rbp - 0x8 ] , rdi mov qword ptr [ rbp - 0x10 ] , rsi mov qword ptr [ rbp - 0x18 ] , rdx mov rdx , qword ptr [ rbp - 0x18 ] mov rsi , qword ptr [ rbp - 0x10 ] mov rax , qword ptr [ rbp - 0x8 ] mov ecx , 0x1 mov rdi , rax call 0x275 leave ret
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two code snippets are fundamentally dissimilar due to differences in architecture and functionality. Code1 uses ARM-specific instructions (ldr, and, bx lr) and lacks a standard stack frame, focusing on conditional branching and register operations. Code2 employs x86_64 conventions (push rbp, mov rbp, rsp, leave) with stack-based memory stores (qword ptr) and a function call (call 0x275). No overlapping instructions, structural patterns, or logical sequences exist between them, indicating completely unrelated purposes and execution flows.
------------------------------------------------------------

------------------------------------------------------------
Code1: push ebp mov ebp , esp push ebx push edi push esi sub esp , 0x2c mov eax , dword ptr [ ebp + 0x10 ] mov ecx , dword ptr [ ebp + 0xc ] mov edx , dword ptr [ ebp + 0x8 ] mov esi , dword ptr [ ebp + 0xc ] mov edi , dword ptr [ ebp + 0x10 ] mov ebx , dword ptr [ ebp + 0x8 ] mov dword ptr [ ebp - 0x18 ] , eax mov eax , esp mov dword ptr [ eax + 0x8 ] , ebx mov dword ptr [ eax + 0x4 ] , edi mov dword ptr [ eax ] , esi mov dword ptr [ ebp - 0x1c ] , ecx mov dword ptr [ ebp - 0x20 ] , edx call 0x3520 mov dword ptr [ ebp - 0x14 ] , eax mov eax , dword ptr [ ebp - 0x14 ] test eax , eax setne al movzx ecx , al mov ecx , dword ptr [ ecx * 0x4 + 0x80d961c ] jmp ecx mov eax , dword ptr [ ebp - 0x14 ] mov dword ptr [ eax + 0x1c ] , 0x358637bd mov eax , dword ptr [ ebp - 0x14 ] mov byte ptr [ eax + 0x14 ] , 0x1 mov eax , dword ptr [ ebp - 0x14 ] mov byte ptr [ eax + 0x12 ] , 0x0 mov eax , dword ptr [ ebp - 0x14 ] mov byte ptr [ eax + 0x13 ] , 0x0 mov byte ptr [ ebp - 0xd ] , 0x1 mov eax , dword ptr [ 0x80d8d90 ] jmp eax mov eax , dword ptr [ ebp + 0x10 ] mov ecx , dword ptr [ eax ] dec ecx mov dword ptr [ eax ] , ecx mov byte ptr [ ebp - 0xd ] , 0x0 mov eax , dword ptr [ 0x80d8d90 ] jmp eax mov al , byte ptr [ ebp - 0xd ] and al , 0x1 movzx eax , al add esp , 0x2c pop esi pop edi pop ebx pop ebp ret nop word ptr [ eax + eax ]
Code2: lui gp , 0x48 lw v0 , ( a2 ) addiu sp , sp , - 0x50 addiu gp , gp , - 0x1a80 sw s1 , 0x3c ( sp ) lw s1 , - 0x7a38 ( gp ) sw s3 , 0x44 ( sp ) move s3 , a2 sw ra , 0x4c ( sp ) sw s4 , 0x48 ( sp ) sw s2 , 0x40 ( sp ) sw s0 , 0x38 ( sp ) sw gp , 0x18 ( sp ) lw v1 , ( s1 ) sw v1 , 0x34 ( sp ) beqz a1 , 0x13c sll v1 , v0 , 0x2 addu a1 , a1 , v1 lw s0 , ( a1 ) beqz s0 , 0x13c addiu v1 , zero , 0x2b addiu v0 , v0 , 0x1 sw v0 , ( a2 ) lb v0 , ( s0 ) beq v0 , v1 , 0x194 move s2 , a0 addiu v1 , zero , 0x2d beq v0 , v1 , 0x130 addiu a0 , s0 , 0x1 addiu s4 , zero , 0x2 move a0 , s0 lui v0 , 0x46 lw t9 , - 0x7e68 ( gp ) addiu a3 , sp , 0x28 addiu v0 , v0 , 0xf00 addiu a2 , zero , 0xa addiu a1 , sp , 0x24 bal 0x1a9f8 sw v0 , 0x10 ( sp ) bnez v0 , 0x138 lw gp , 0x18 ( sp ) lw t9 , - 0x7e70 ( gp ) move a1 , s0 bal - 0xb884 move a0 , s2 lw gp , 0x18 ( sp ) move s0 , v0 sw s4 , 0x28 ( v0 ) lw v0 , 0x28 ( sp ) lw v1 , 0x2c ( sp ) sw v0 , 0x30 ( s0 ) lw v0 , - 0x7fc0 ( gp ) sw v1 , 0x34 ( s0 ) lw v0 , 0x2c ( v0 ) andi v0 , v0 , 0x1 bnez v0 , 0x14c lui a2 , 0x46 lui v1 , 0x46 sb zero , 0x12 ( s0 ) addiu a0 , zero , 0x1 sb zero , 0x13 ( s0 ) lwc1 f0 , 0x7e8 ( v1 ) addiu v0 , zero , 0x1 sb a0 , 0x14 ( s0 ) swc1 f0 , 0x1c ( s0 ) lw a0 , 0x34 ( sp ) lw v1 , ( s1 ) bne a0 , v1 , 0x210 lw ra , 0x4c ( sp ) lw s4 , 0x48 ( sp ) lw s3 , 0x44 ( sp ) lw s2 , 0x40 ( sp ) lw s1 , 0x3c ( sp ) lw s0 , 0x38 ( sp ) jr ra addiu sp , sp , 0x50 b 0x7c addiu s4 , zero , 0x1 lw v0 , ( s3 ) addiu v1 , v0 , - 0x1 move v0 , zero b 0x104 sw v1 , ( s3 ) lw s2 , - 0x7a0c ( gp ) lw t9 , - 0x7bec ( gp ) addiu a1 , zero , 0x1 lw a3 , 0x4 ( s0 ) addiu a2 , a2 , - 0x90 jalr t9 lw a0 , ( s2 ) lw gp , 0x18 ( sp ) beqz s4 , 0x1a0 lw a0 , ( s2 ) addiu v0 , zero , 0x1 beq s4 , v0 , 0x1fc nop lui a3 , 0x46 lui v0 , 0x46 addiu a3 , a3 , - 0x5c b 0x1b0 addiu v0 , v0 , - 0x38 addiu a0 , s0 , 0x1 b 0x7c move s4 , zero lui a3 , 0x46 lui v0 , 0x46 addiu a3 , a3 , - 0x80 addiu v0 , v0 , - 0x64 lui a2 , 0x46 lw t9 , - 0x7bec ( gp ) addiu a1 , zero , 0x1 sw v0 , 0x10 ( sp ) jalr t9 addiu a2 , a2 , - 0x7c lui a2 , 0x46 lw gp , 0x18 ( sp ) addiu a1 , zero , 0x1 lw v1 , 0x34 ( s0 ) addiu a2 , a2 , - 0x34 lw v0 , 0x30 ( s0 ) lw a0 , ( s2 ) lw t9 , - 0x7bec ( gp ) sw v1 , 0x14 ( sp ) jalr t9 sw v0 , 0x10 ( sp ) b 0xe4 lw gp , 0x18 ( sp ) lui a3 , 0x46 lui v0 , 0x46 addiu a3 , a3 , 0x14bc b 0x1b0 addiu v0 , v0 , - 0x60 lw t9 , - 0x7a78 ( gp ) jalr t9 nop
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly codes are for entirely different architectures (x86 vs MIPS) with no overlapping instructions, registers, or calling conventions. Code1 uses x86-specific operations (e.g., `push ebp`, `mov ebp, esp`, `call`) and registers (e.g., `eax`, `ecx`), while Code2 uses MIPS-specific operations (e.g., `lui`, `lw`, `addiu`, `jalr`) and registers (e.g., `v0`, `a0`, `s0`). The control flow, stack management, and instruction patterns show
------------------------------------------------------------

------------------------------------------------------------
Code1: lui gp , 0x2f addiu gp , gp , 0x2a58 addu gp , gp , t9 addiu sp , sp , - 0xa0 sw ra , 0x9c ( sp ) sw fp , 0x98 ( sp ) sw s7 , 0x94 ( sp ) sw s6 , 0x90 ( sp ) sw s5 , 0x8c ( sp ) sw s4 , 0x88 ( sp ) sw s3 , 0x84 ( sp ) sw s2 , 0x80 ( sp ) sw s1 , 0x7c ( sp ) sw s0 , 0x78 ( sp ) sw gp , 0x18 ( sp ) sw a2 , 0x28 ( sp ) lw v0 , - 0x7670 ( gp ) lw v0 , ( v0 ) sw v0 , 0x74 ( sp ) beqz a0 , 0xcc lw a3 , - 0x7fc8 ( gp ) move s0 , a0 lw v1 , 0x336c ( a0 ) lui v0 , 0xabac ori v0 , v0 , 0xadab bne v1 , v0 , 0xf0 move s6 , a1 lw v0 , 0x3350 ( a0 ) bnez v0 , 0x114 addiu v0 , a0 , 0x340 lw v0 , 0x28 ( sp ) beqz v0 , 0x154 lw v0 , 0x28 ( sp ) lw v1 , 0x1c ( v0 ) lui v0 , 0xabac ori v0 , v0 , 0xadab bne v1 , v0 , 0x17c move a0 , s0 lw s3 , 0x2bc ( s0 ) lw s7 , 0x18 ( s0 ) lw s1 , 0x1c ( s0 ) lw s2 , 0x20 ( s0 ) lw t9 , - 0x7430 ( gp ) jalr t9 nop lw gp , 0x18 ( sp ) beqz v0 , 0x218 addiu s5 , zero , 0x1 lw fp , 0x4 ( s0 ) b 0x1d4 addiu s4 , zero , 0x1 addiu a3 , a3 , - 0x6260 addiu a2 , zero , 0x1ce lw a1 , - 0x7fc8 ( gp ) addiu a1 , a1 , - 0x6b7c lw a0 , - 0x7fd0 ( gp ) addiu a0 , a0 , 0xb6c lw t9 , - 0x7298 ( gp ) jalr t9 nop addiu a3 , a3 , - 0x6260 addiu a2 , zero , 0x1cf lw a1 , - 0x7fc8 ( gp ) addiu a1 , a1 , - 0x6b7c lw a0 , - 0x7fd0 ( gp ) addiu a0 , a0 , 0xb88 lw t9 , - 0x7298 ( gp ) jalr t9 nop sw v0 , 0x14 ( sp ) lw v0 , - 0x7fc8 ( gp ) addiu v0 , v0 , - 0x7308 sw v0 , 0x10 ( sp ) addiu a3 , zero , 0x1d1 lw a2 , - 0x7fc8 ( gp ) addiu a2 , a2 , - 0x6270 lw a1 , - 0x7fc8 ( gp ) addiu a1 , a1 , - 0x6b7c ori a0 , zero , 0x8000 lw t9 , - 0x76c0 ( gp ) jalr t9 nop lw gp , 0x18 ( sp ) b 0x7c lw v0 , 0x28 ( sp ) lw a3 , - 0x7fc8 ( gp ) addiu a3 , a3 , - 0x6260 addiu a2 , zero , 0x1d2 lw a1 , - 0x7fc8 ( gp ) addiu a1 , a1 , - 0x6b7c lw a0 , - 0x7fd0 ( gp ) addiu a0 , a0 , 0x9d0 lw t9 , - 0x7298 ( gp ) jalr t9 nop lw a3 , - 0x7fc8 ( gp ) addiu a3 , a3 , - 0x6260 addiu a2 , zero , 0x1d3 lw a1 , - 0x7fc8 ( gp ) addiu a1 , a1 , - 0x6b7c lw a0 , - 0x7fd0 ( gp ) addiu a0 , a0 , 0x16ac lw t9 , - 0x7298 ( gp ) jalr t9 nop lw v1 , 0x18 ( v0 ) sltu a0 , s7 , v1 movn s7 , v1 , a0 lw v1 , 0x1c ( v0 ) addu s1 , s1 , v1 move a0 , v0 lw t9 , - 0x7430 ( gp ) jalr t9 nop lw gp , 0x18 ( sp ) beqz v0 , 0x21c nop lw v1 , 0x20 ( v0 ) sltu a0 , s2 , v1 movn s2 , v1 , a0 lw v1 , 0x4 ( v0 ) xor v1 , v1 , fp movn s4 , zero , v1 lw v1 , 0x2bc ( v0 ) addiu a0 , zero , 0x4 movn s3 , a0 , v1 bnez s6 , 0x1a4 addiu s5 , s5 , 0x1 lw v1 , 0x18 ( v0 ) addu s7 , s7 , v1 lw v1 , 0x1c ( v0 ) sltu a0 , s1 , v1 b 0x1b8 movn s1 , v1 , a0 addiu s4 , zero , 0x1 lw fp , 0x28 ( sp ) sw fp , 0x10 ( sp ) addiu a3 , zero , 0x1 move a2 , s1 move a1 , s7 move a0 , s0 lw t9 , - 0x7074 ( gp ) jalr t9 nop lw gp , 0x18 ( sp ) beqz v0 , 0x6b8 move s1 , v0 move a2 , fp addiu a1 , zero , 0x1 move a0 , v0 lw t9 , - 0x7080 ( gp ) jalr t9 nop lw gp , 0x18 ( sp ) beqz v0 , 0x31c move a0 , s1 beqz s4 , 0x334 lw a2 , 0x28 ( sp ) sw s2 , 0x20 ( s1 ) sw s3 , 0x2bc ( s1 ) lw a1 , 0x228 ( s0 ) lw a0 , 0x22c ( s0 ) lw v1 , 0x230 ( s0 ) lw v0 , 0x234 ( s0 ) sw a1 , 0x228 ( s1 ) sw a0 , 0x22c ( s1 ) sw v1 , 0x230 ( s1 ) sw v0 , 0x234 ( s1 ) lw s2 , 0x28 ( sp ) move a1 , s2 move a0 , s1 lw t9 , - 0x7a10 ( gp ) jalr t9 nop lw gp , 0x18 ( sp ) move a1 , s2 move a0 , s1 lw t9 , - 0x79cc ( gp ) jalr t9 nop lw gp , 0x18 ( sp ) sw v0 , 0x30 ( sp ) beqz s5 , 0x714 sw s5 , 0x3c ( sp ) move s4 , zero move s3 , zero move s2 , zero sw zero , 0x20 ( sp ) addiu v0 , zero , 0x1 sw v0 , 0x2c ( sp ) addiu s7 , sp , 0x44 addiu fp , sp , 0x54 lw v0 , - 0x7e68 ( gp ) addiu v0 , v0 , 0x4580 sw v0 , 0x34 ( sp ) lw v0 , - 0x7fc8 ( gp ) addiu v0 , v0 , - 0x6ac0 b 0x4a4 sw v0 , 0x38 ( sp ) lw t9 , - 0x7954 ( gp ) jalr t9 nop lw gp , 0x18 ( sp ) b 0x6b8 move s1 , zero addiu a1 , zero , 0x17 move a0 , s1 lw t9 , - 0x7b5c ( gp ) jalr t9 nop lw gp , 0x18 ( sp ) b 0x27c sw s2 , 0x20 ( s1 ) b 0x4ec subu s4 , s4 , v0 lw t9 , - 0x73ec ( gp ) jalr t9 nop lw gp , 0x18 ( sp ) addiu v1 , zero , 0x4 beq v0 , v1 , 0x5bc lw t9 , - 0x73ec ( gp ) move a0 , s0 jalr t9 nop lw gp , 0x18 ( sp ) addiu v1 , zero , 0x3 beq v0 , v1 , 0x5c0 addiu a0 , zero , 0x7 addiu a0 , zero , 0x7 lw t9 , - 0x7764 ( gp ) jalr t9 nop lw gp , 0x18 ( sp ) beqz v0 , 0x54c addiu a0 , zero , 0x7 lw t9 , - 0x7764 ( gp ) jalr t9 nop lw gp , 0x18 ( sp ) beqz v0 , 0x590 nop addiu a2 , zero , 0x2 lw v0 , 0x24 ( sp ) sw v0 , 0x6c ( sp ) sw s4 , 0x68 ( sp ) sw s3 , 0x64 ( sp ) sw s0 , 0x60 ( sp ) sw s1 , 0x5c ( sp ) lw v1 , 0x30 ( sp ) sw v1 , 0x58 ( sp ) lw v1 , 0x28 ( sp ) sw v1 , 0x54 ( sp ) lw v1 , 0x2c ( sp ) sw v1 , 0x70 ( sp ) move a3 , zero move a1 , fp lw a0 , 0x34 ( sp ) lw t9 , - 0x7708 ( gp ) jalr t9 nop lw gp , 0x18 ( sp ) lw v1 , 0x70 ( sp ) sw v1 , 0x2c ( sp ) lw a0 , 0x24 ( sp ) lw t9 , - 0x79ac ( gp ) jalr t9 nop lw gp , 0x18 ( sp ) bnez s6 , 0x67c nop lw v0 , 0x18 ( s0 ) addu s3 , s3 , v0 move s4 , zero sw s5 , 0x14 ( sp ) sw zero , 0x10 ( sp ) move a2 , s2 lw a3 , 0x20 ( sp ) lw a1 , 0x38 ( sp ) move a0 , s1 lw t9 , - 0x7be8 ( gp ) jalr t9 nop lw gp , 0x18 ( sp ) beqz v0 , 0x698 move a0 , s0 lw t9 , - 0x7430 ( gp ) jalr t9 nop lw gp , 0x18 ( sp ) move s0 , v0 lw v1 , 0x20 ( sp ) addiu v0 , v1 , 0x1 sltu v1 , v0 , v1 addu s2 , v1 , s2 beqz s2 , 0x68c sw v0 , 0x20 ( sp ) move a1 , s7 move a0 , s1 lw t9 , - 0x727c ( gp ) jalr t9 nop lw gp , 0x18 ( sp ) move a3 , s7 lw a2 , 0x260 ( s0 ) lw a1 , 0x1c ( s0 ) lw a0 , 0x18 ( s0 ) lw t9 , - 0x7ba4 ( gp ) jalr t9 nop lw gp , 0x18 ( sp ) beqz s6 , 0x354 lw v0 , 0x50 ( sp ) lw v0 , 0x4c ( sp ) subu s3 , s3 , v0 lw a1 , 0x28 ( sp ) move a0 , s0 lw t9 , - 0x714c ( gp ) jalr t9 nop lw gp , 0x18 ( sp ) sw v0 , 0x24 ( sp ) move a0 , s0 lw t9 , - 0x73ec ( gp ) jalr t9 nop lw gp , 0x18 ( sp ) addiu v1 , zero , 0x4 beq v0 , v1 , 0x35c move a0 , s0 lw t9 , - 0x73ec ( gp ) jalr t9 nop lw gp , 0x18 ( sp ) addiu v1 , zero , 0x3 bne v0 , v1 , 0x394 move a0 , s0 b 0x360 lw t9 , - 0x73ec ( gp ) bnez v0 , 0x55c sltiu v1 , v1 , 0x2 beqz v1 , 0x3b0 addiu a0 , zero , 0x7 addiu a0 , zero , 0x7 lw t9 , - 0x7764 ( gp ) jalr t9 nop lw gp , 0x18 ( sp ) bnez v0 , 0x3b0 addiu a0 , zero , 0x7 bnez v0 , 0x588 sltiu v1 , v1 , 0x2 beqz v1 , 0x3b4 lw t9 , - 0x7764 ( gp ) b 0x3cc addiu a2 , zero , 0x1 bnez v0 , 0x5a0 sltiu v1 , v1 , 0x2 beqz v1 , 0x3c8 nop addiu a0 , zero , 0x7 lw t9 , - 0x7764 ( gp ) jalr t9 nop lw gp , 0x18 ( sp ) b 0x3cc move a2 , v1 addiu a0 , zero , 0x7 lw t9 , - 0x7764 ( gp ) jalr t9 nop lw gp , 0x18 ( sp ) lw v0 , 0x1c ( s0 ) bltz v0 , 0x604 move a0 , v0 sra a0 , a0 , 0x6 slt v1 , v1 , a0 bnez v1 , 0x60c addiu a0 , zero , 0x7 slti v0 , v0 , 0x80 xori v0 , v0 , 0x1 bnez v0 , 0x628 addiu a2 , zero , 0x1 b 0x3d0 lw v0 , 0x24 ( sp ) b 0x5dc addiu a0 , v0 , 0x3f lw t9 , - 0x7764 ( gp ) jalr t9 nop lw gp , 0x18 ( sp ) slti v0 , v1 , 0x2 b 0x5f4 xori v0 , v0 , 0x1 addiu a0 , zero , 0x7 lw t9 , - 0x7764 ( gp ) jalr t9 nop lw gp , 0x18 ( sp ) lw a2 , 0x1c ( s0 ) bltz a2 , 0x674 nop sra a2 , a2 , 0x6 slt v1 , v1 , a2 beqz v1 , 0x3d0 lw v0 , 0x24 ( sp ) addiu a0 , zero , 0x7 lw t9 , - 0x7764 ( gp ) jalr t9 nop lw gp , 0x18 ( sp ) b 0x3cc move a2 , v1 b 0x648 addiu a2 , a2 , 0x3f lw v0 , 0x1c ( s0 ) addu s4 , s4 , v0 b 0x448 move s3 , zero lw v1 , 0x3c ( sp ) bne v0 , v1 , 0x4a8 move a1 , s7 lw a0 , 0x30 ( sp ) lw t9 , - 0x79ac ( gp ) jalr t9 nop lw gp , 0x18 ( sp ) lw v0 , 0x2c ( sp ) beqz v0 , 0x6fc move a0 , s1 move v0 , s1 lw a0 , 0x74 ( sp ) lw v1 , - 0x7670 ( gp ) lw v1 , ( v1 ) bne a0 , v1 , 0x730 lw ra , 0x9c ( sp ) lw fp , 0x98 ( sp ) lw s7 , 0x94 ( sp ) lw s6 , 0x90 ( sp ) lw s5 , 0x8c ( sp ) lw s4 , 0x88 ( sp ) lw s3 , 0x84 ( sp ) lw s2 , 0x80 ( sp ) lw s1 , 0x7c ( sp ) lw s0 , 0x78 ( sp ) jr ra addiu sp , sp , 0xa0 lw t9 , - 0x7954 ( gp ) jalr t9 nop lw gp , 0x18 ( sp ) b 0x6b8 move s1 , v0 lw a0 , 0x30 ( sp ) lw t9 , - 0x79ac ( gp ) jalr t9 nop lw gp , 0x18 ( sp ) b 0x6bc move v0 , s1 lw t9 , - 0x7838 ( gp ) jalr t9 nop
Code2: push r14 push r13 push r12 push rbp push rbx sub rsp , 0x30 mov rax , qword ptr fs : [ 0x28 ] mov qword ptr [ rsp + 0x28 ] , rax xor eax , eax test rdi , rdi je 0x12c mov rbx , rdi mov rbp , rsi mov r13 , rdx cmp dword ptr [ rdi + 0x3418 ] , 0x0 jne 0x14b mov eax , 0xabacadab cmp qword ptr [ rbx + 0x3450 ] , rax jne 0x179 cmp rbp , 0xf ja 0x198 mov r12d , 0x0 test rbp , rbp je 0x7f cmp rbp , 0x40 mov ecx , 0x40 cmovbe rcx , rbp sub ecx , 0x1 mov r12d , 0x2 shl r12 , cl sub r12 , 0x1 cmp dword ptr [ rbx ] , 0x2 je 0x1c6 mov rsi , r13 mov rdi , rbx call 0xfffffffffffeea71 mov r14 , rax mov rdi , rbx call 0xfffffffffffece71 cmp eax , 0x4 je 0x2fc mov rdi , rbx call 0xfffffffffffece71 cmp eax , 0x3 je 0x2fc mov edi , 0x7 call 0xfffffffffffedec1 cmp rax , 0x1 jbe 0x38b mov edi , 0x7 call 0xfffffffffffedec1 mov edx , 0x2 cmp rax , 0x1 jbe 0x3a9 mov qword ptr [ rsp + 0x18 ] , r12 mov qword ptr [ rsp + 0x10 ] , r14 mov qword ptr [ rsp + 0x8 ] , r13 mov qword ptr [ rsp ] , rbx mov dword ptr [ rsp + 0x20 ] , 0x1 mov rsi , rsp mov ecx , 0x0 lea rdi , [ rip - 0x4bf4 ] call 0xfffffffffffedcd1 mov r12d , dword ptr [ rsp + 0x20 ] mov rdi , r14 call 0xfffffffffffee991 test r12d , r12d je 0x1a2 mov qword ptr [ rbx + 0x30 ] , rbp jmp 0x1a2 lea rcx , [ rip + 0x29822e ] mov edx , 0x763 lea rsi , [ rip + 0x29803c ] lea rdi , [ rip + 0x2be56c ] call 0xfffffffffffec0c1 lea r8 , [ rip + 0x29bbab ] mov ecx , 0x765 lea rdx , [ rip + 0x2981f3 ] lea rsi , [ rip + 0x298016 ] mov edi , 0x8000 mov eax , 0x0 call 0xfffffffffffedb81 jmp 0x3b lea rcx , [ rip + 0x2981e1 ] mov edx , 0x766 lea rsi , [ rip + 0x297fef ] lea rdi , [ rip + 0x29799e ] call 0xfffffffffffec0c1 mov qword ptr [ rbx + 0x30 ] , rbp mov r12d , 0x1 mov eax , r12d mov rsi , qword ptr [ rsp + 0x28 ] xor rsi , qword ptr fs : [ 0x28 ] jne 0x3d1 add rsp , 0x30 pop rbx pop rbp pop r12 pop r13 pop r14 ret mov rdi , rbx call 0xfffffffffffece71 cmp eax , 0x4 je 0x22f mov rdi , rbx call 0xfffffffffffece71 cmp eax , 0x3 je 0x22f mov edi , 0x7 call 0xfffffffffffedec1 cmp rax , 0x1 jbe 0x2b6 mov edi , 0x7 call 0xfffffffffffedec1 mov edx , 0x2 cmp rax , 0x1 jbe 0x2d4 mov qword ptr [ rsp + 0x8 ] , r12 mov qword ptr [ rsp ] , rbx mov rsi , rsp mov ecx , 0x0 lea rdi , [ rip - 0x542d ] call 0xfffffffffffedcd1 jmp 0x88 mov rdi , rbx call 0xfffffffffffece71 cmp eax , 0x4 je 0x249 mov rdi , rbx call 0xfffffffffffece71 cmp eax , 0x3 jne 0x1e0 mov edi , 0x7 call 0xfffffffffffedec1 mov rcx , qword ptr [ rbx + 0x38 ] lea rdx , [ rcx + 0x3f ] test rcx , rcx cmovns rdx , rcx sar rdx , 0x6 cmp rcx , 0x7f setg cl cmp rax , rdx jl 0x2e6 mov edx , 0x1 test cl , cl je 0x20d mov edi , 0x7 call 0xfffffffffffedec1 mov rdx , qword ptr [ rbx + 0x38 ] lea rcx , [ rdx + 0x3f ] test rdx , rdx cmovns rcx , rdx sar rcx , 0x6 mov rdx , rcx cmp rax , rcx jge 0x20d mov edi , 0x7 call 0xfffffffffffedec1 mov rdx , rax jmp 0x20d mov edi , 0x7 call 0xfffffffffffedec1 mov edx , 0x1 cmp rax , 0x1 ja 0x1f4 jmp 0x20d mov edi , 0x7 call 0xfffffffffffedec1 mov rdx , rax jmp 0x20d mov edi , 0x7 call 0xfffffffffffedec1 cmp rax , 0x1 setg cl jmp 0x272 mov rdi , rbx call 0xfffffffffffece71 cmp eax , 0x4 je 0x31a mov rdi , rbx call 0xfffffffffffece71 cmp eax , 0x3 jne 0xb8 mov edi , 0x7 call 0xfffffffffffedec1 mov rcx , qword ptr [ rbx + 0x28 ] lea rdx , [ rcx + 0x3f ] test rcx , rcx cmovns rdx , rcx sar rdx , 0x6 cmp rcx , 0x7f setg cl cmp rax , rdx jl 0x3bb mov edx , 0x1 test cl , cl je 0xe5 mov edi , 0x7 call 0xfffffffffffedec1 mov rdx , qword ptr [ rbx + 0x28 ] lea rcx , [ rdx + 0x3f ] test rdx , rdx cmovns rcx , rdx sar rcx , 0x6 mov rdx , rcx cmp rax , rcx jge 0xe5 mov edi , 0x7 call 0xfffffffffffedec1 mov rdx , rax jmp 0xe5 mov edi , 0x7 call 0xfffffffffffedec1 mov edx , 0x1 cmp rax , 0x1 ja 0xcc jmp 0xe5 mov edi , 0x7 call 0xfffffffffffedec1 mov rdx , rax jmp 0xe5 mov edi , 0x7 call 0xfffffffffffedec1 cmp rax , 0x1 setg cl jmp 0x343 call 0xfffffffffffee301
Similarity: 1
Label: -1
Similarity Score: 0.85
Explanation: The codes share significant structural similarities despite different architectures (MIPS vs x86_64). Both exhibit: identical magic constant 0xABACADAB used for validation; similar control flow with initial null checks and error handling; comparable stack management (adjusting SP, saving registers); parallel function call patterns; and equivalent conditional branching logic. The core validation routine and memory access patterns align closely, suggesting they implement the same underlying algorithm for different processors. The 0.85 score accounts for architectural differences in register usage and instruction syntax.
------------------------------------------------------------

------------------------------------------------------------
Code1: push { r4 , lr } mov r2 , r1 add r1 , r0 , 0x8 ldm r1 , { r0 , r1 } mov r3 , 0x0 bl 0x7728 mov r0 , r2 pop { r4 , pc }
Code2: push ebp mov ebp , esp push ebx push edi push esi sub esp , 0x1c mov eax , dword ptr [ ebp + 0xc ] mov ecx , dword ptr [ ebp + 0x8 ] mov edx , dword ptr [ ebp + 0x8 ] mov dword ptr [ ebp - 0x10 ] , edx mov edx , dword ptr [ ebp - 0x10 ] mov esi , dword ptr [ edx + 0x4 ] mov edx , dword ptr [ edx + 0x8 ] mov edi , dword ptr [ ebp + 0xc ] mov ebx , esp mov dword ptr [ ebx + 0x8 ] , edi mov dword ptr [ ebx + 0x4 ] , edx mov dword ptr [ ebx ] , esi mov dword ptr [ ebx + 0xc ] , 0x0 mov dword ptr [ ebp - 0x14 ] , eax mov dword ptr [ ebp - 0x18 ] , ecx call 0x9990 add esp , 0x1c pop esi pop edi pop ebx pop ebp ret nop word ptr cs : [ eax + eax ] nop
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two code snippets are fundamentally dissimilar due to architectural differences (ARM vs x86) and implementation approaches. The ARM code is concise, using register-based operations and a single function call. The x86 code employs stack-based memory operations with complex pointer arithmetic and a different function call target. No structural or functional equivalence exists beyond basic function call patterns, which differ in setup and execution. The architectural mismatch alone makes meaningful similarity impossible.
------------------------------------------------------------

------------------------------------------------------------
Code1: push { r4 , r5 , r6 , lr } subs r5 , r1 , 0x0 moveq r4 , 0x0 beq 0x50 mov r4 , r0 ldr r3 , [ r0 ] cmp r3 , 0x0 beq 0x58 mov r0 , r5 bl 0x7885c bl 0x657b4 subs r5 , r0 , 0x0 moveq r4 , 0x0 beq 0x50 mov r1 , r5 ldr r0 , [ r4 ] bl 0x5032c subs r4 , r0 , 0x0 movne r4 , 0x1 beq 0x70 mov r0 , r4 pop { r4 , r5 , r6 , pc } bl 0x5015c str r0 , [ r4 ] cmp r0 , 0x0 moveq r4 , 0x0 bne 0x20 b 0x50 mov r0 , r5 bl 0x655c4 b 0x50
Code2: push rbp push r15 push r14 push r13 push r12 push rbx push rax mov r14 , rsi mov r15 , rdi test rsi , rsi mov eax , 0xdd963b0d mov ebx , 0xfeb4d39a cmove ebx , eax mov eax , 0x34ea23b4 mov r12d , 0x3f0ef2e5 mov r13d , 0x3bfa6b41 jmp 0x40 mov eax , 0x77a98973 xor ebp , ebp nop dword ptr [ rax + rax ] mov ecx , eax cmp eax , 0x34a4f5e8 jle 0x80 cmp ecx , 0x3f0ef2e4 jg 0xc0 cmp ecx , 0x34a4f5e9 je 0x120 mov eax , ebx cmp ecx , 0x34ea23b4 je 0x40 mov eax , ecx cmp ecx , 0x3bfa6b41 jne 0x40 mov rdi , qword ptr [ rsp ] call 0x111360 jmp 0x34 nop dword ptr [ rax ] cmp ecx , 0xa800be3 jle 0xf0 cmp ecx , 0xa800be4 je 0x13c cmp ecx , 0x1115102b je 0x167 mov eax , ecx cmp ecx , 0x11ade307 jne 0x40 mov eax , 0x77a98973 mov ebp , 0x1 jmp 0x40 nop word ptr cs : [ rax + rax ] cmp ecx , 0x3f0ef2e5 je 0x34 cmp ecx , 0x6cc75d7d je 0x34 mov eax , ecx cmp ecx , 0x77a98973 jne 0x40 jmp 0x180 nop dword ptr [ rax + rax ] cmp ecx , 0xdd963b0d je 0x34 mov eax , ecx cmp ecx , 0xfeb4d39a jne 0x40 cmp qword ptr [ r15 ] , 0x0 mov eax , 0xa800be4 mov ecx , 0x1115102b cmove eax , ecx jmp 0x40 mov rdi , qword ptr [ r15 ] mov rsi , qword ptr [ rsp ] call 0xd1620 test eax , eax mov eax , 0x11ade307 cmove eax , r13d jmp 0x40 mov rdi , r14 call 0x146e40 mov rdi , rax call 0x111370 mov qword ptr [ rsp ] , rax cmp qword ptr [ rsp ] , 0x0 mov eax , 0x34a4f5e9 mov ecx , 0x6cc75d7d cmove eax , ecx jmp 0x40 call 0xd0ac0 mov qword ptr [ r15 ] , rax test rax , rax mov eax , 0xa800be4 cmove eax , r12d jmp 0x40 mov eax , ebp add rsp , 0x8 pop rbx pop r12 pop r13 pop r14 pop r15 pop rbp ret nop word ptr cs : [ rax + rax ] nop dword ptr [ rax + rax ]
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The codes are fundamentally dissimilar due to architectural differences (ARM vs x86-64), distinct register usage, and completely different control flow patterns. Code1 uses ARM-specific instructions (e.g., `bl`, `subs`, `movne`) with simple conditional branching, while Code2 features x86-64-specific operations (e.g., `call`, complex jump tables with hexadecimal constants) and more intricate logic. No overlapping instructions, structural parallels, or functional equivalences were observed.
------------------------------------------------------------

------------------------------------------------------------
Code1: ldr r3 , [ r0 , 0x24 ] push { r4 , r5 , r6 , lr } cmn r3 , 0xe0000002 bhi 0x104 ldr r2 , [ r0 , 0x30 ] lsl r3 , r3 , 0x1 cmp r3 , r2 movge r3 , r2 cmp r3 , r1 movge r1 , r3 mov r4 , r0 bl 0xfffff534 subs r5 , r0 , 0x0 bne 0xec ldr r0 , [ r4 , 0x64 ] cmp r0 , 0x0 beq 0x60 ldr r1 , [ r4 , 0x24 ] add r1 , r1 , 0x1 lsl r1 , r1 , 0x2 bl 0xffff5c04 cmp r0 , 0x0 beq 0x104 str r0 , [ r4 , 0x64 ] ldrb r2 , [ r4 , 0x48 ] ldr r3 , [ r4 , 0x50 ] cmp r2 , 0x0 beq 0x84 cmp r3 , 0x1 mov r0 , r4 ble 0x110 pop { r4 , r5 , r6 , lr } b 0xfffffa54 cmp r3 , 0x1 bgt 0xf4 ldr r1 , [ r4 , 0x40 ] cmp r1 , 0x0 beq 0xec ldr ip , [ r4 , 0x24 ] ldr r2 , [ r4 , 0x30 ] ldr r3 , [ r4 , 0x1c ] cmp ip , r2 movge ip , r2 cmp ip , r3 bgt 0xbc b 0xe4 ldr r1 , [ r4 , 0x40 ] ldr r2 , [ r4 ] ldr r0 , [ r4 , 0x18 ] add r2 , r2 , r3 ldrb r0 , [ r2 , r0 ] ldr r2 , [ r4 , 0x4 ] ldrb r1 , [ r1 , r0 ] strb r1 , [ r2 , r3 ] add r3 , r3 , 0x1 cmp ip , r3 bne 0xb8 str r3 , [ r4 , 0x1c ] str r3 , [ r4 , 0x20 ] mov r0 , r5 pop { r4 , r5 , r6 , pc } mov r0 , r4 bl 0xfffff8ac mov r0 , r5 pop { r4 , r5 , r6 , pc } mov r5 , 0xc mov r0 , r5 pop { r4 , r5 , r6 , pc } bl 0xfffff840 mov r0 , r5 pop { r4 , r5 , r6 , pc }
Code2: push ebp mov ebp , esp push esi sub esp , 0x34 mov eax , dword ptr [ ebp + 0xc ] mov ecx , dword ptr [ ebp + 0x8 ] mov edx , dword ptr [ ebp + 0x8 ] mov dword ptr [ ebp - 0x10 ] , edx mov edx , dword ptr [ ebp - 0x10 ] mov esi , 0x1fffffff cmp esi , dword ptr [ edx + 0x24 ] mov dword ptr [ ebp - 0x18 ] , eax mov dword ptr [ ebp - 0x1c ] , ecx ja 0x36 mov dword ptr [ ebp - 0x8 ] , 0xc jmp 0x1d2 mov eax , dword ptr [ ebp - 0x10 ] mov ecx , dword ptr [ ebp + 0xc ] mov edx , dword ptr [ ebp - 0x10 ] mov edx , dword ptr [ edx + 0x30 ] mov esi , dword ptr [ ebp - 0x10 ] mov esi , dword ptr [ esi + 0x24 ] shl esi , 0x1 cmp edx , esi mov dword ptr [ ebp - 0x20 ] , eax mov dword ptr [ ebp - 0x24 ] , ecx jge 0x67 mov eax , dword ptr [ ebp - 0x10 ] mov eax , dword ptr [ eax + 0x30 ] mov dword ptr [ ebp - 0x28 ] , eax jmp 0x73 mov eax , dword ptr [ ebp - 0x10 ] mov eax , dword ptr [ eax + 0x24 ] shl eax , 0x1 mov dword ptr [ ebp - 0x28 ] , eax mov eax , dword ptr [ ebp - 0x28 ] mov ecx , dword ptr [ ebp - 0x24 ] cmp ecx , eax jge 0xbd mov eax , dword ptr [ ebp - 0x10 ] mov eax , dword ptr [ eax + 0x30 ] mov ecx , dword ptr [ ebp - 0x10 ] mov ecx , dword ptr [ ecx + 0x24 ] shl ecx , 0x1 cmp eax , ecx jge 0xa6 mov eax , dword ptr [ ebp - 0x10 ] mov eax , dword ptr [ eax + 0x30 ] mov dword ptr [ ebp - 0x2c ] , eax jmp 0xb2 mov eax , dword ptr [ ebp - 0x10 ] mov eax , dword ptr [ eax + 0x24 ] shl eax , 0x1 mov dword ptr [ ebp - 0x2c ] , eax mov eax , dword ptr [ ebp - 0x2c ] mov dword ptr [ ebp - 0x30 ] , eax jmp 0xc3 mov eax , dword ptr [ ebp + 0xc ] mov dword ptr [ ebp - 0x30 ] , eax mov eax , dword ptr [ ebp - 0x30 ] mov ecx , dword ptr [ ebp - 0x20 ] mov dword ptr [ esp ] , ecx mov dword ptr [ esp + 0x4 ] , eax call 0xffff51d0 mov dword ptr [ ebp - 0xc ] , eax cmp dword ptr [ ebp - 0xc ] , 0x0 je 0xed mov eax , dword ptr [ ebp - 0xc ] mov dword ptr [ ebp - 0x8 ] , eax jmp 0x1d2 mov eax , dword ptr [ ebp + 0x8 ] cmp dword ptr [ eax + 0x64 ] , 0x0 je 0x13a mov eax , dword ptr [ ebp + 0x8 ] mov eax , dword ptr [ eax + 0x64 ] mov ecx , dword ptr [ ebp - 0x10 ] mov ecx , dword ptr [ ecx + 0x24 ] add ecx , 0x1 shl ecx , 0x2 mov dword ptr [ esp ] , eax mov dword ptr [ esp + 0x4 ] , ecx call 0xfffe7360 mov dword ptr [ ebp - 0x14 ] , eax cmp dword ptr [ ebp - 0x14 ] , 0x0 jne 0x131 mov dword ptr [ ebp - 0x8 ] , 0xc jmp 0x1d2 mov eax , dword ptr [ ebp - 0x14 ] mov ecx , dword ptr [ ebp + 0x8 ] mov dword ptr [ ecx + 0x64 ] , eax mov eax , dword ptr [ ebp - 0x10 ] cmp byte ptr [ eax + 0x48 ] , 0x0 je 0x18c mov eax , dword ptr [ ebp - 0x10 ] cmp dword ptr [ eax + 0x50 ] , 0x1 jle 0x17c mov eax , dword ptr [ ebp - 0x10 ] mov dword ptr [ esp ] , eax call 0xffff5300 mov dword ptr [ ebp - 0xc ] , eax cmp dword ptr [ ebp - 0xc ] , 0x0 je 0x177 mov eax , dword ptr [ ebp - 0xc ] mov dword ptr [ ebp - 0x8 ] , eax jmp 0x1d2 jmp 0x187 mov eax , dword ptr [ ebp - 0x10 ] mov dword ptr [ esp ] , eax call 0xffff5c80 jmp 0x1cb mov eax , dword ptr [ ebp - 0x10 ] cmp dword ptr [ eax + 0x50 ] , 0x1 jle 0x1a9 mov eax , dword ptr [ ebp - 0x10 ] mov dword ptr [ esp ] , eax call 0xffff5d40 jmp 0x1c6 mov eax , dword ptr [ ebp - 0x10 ] cmp dword ptr [ eax + 0x40 ] , 0x0 je 0x1c1 mov eax , dword ptr [ ebp - 0x10 ] mov dword ptr [ esp ] , eax call 0xffff5fc0 jmp 0x1c6 jmp 0x1cb mov dword ptr [ ebp - 0x8 ] , 0x0 mov eax , dword ptr [ ebp - 0x8 ] add esp , 0x34 pop esi pop ebp ret nop dword ptr [ eax + eax ]
Similarity: -1
Label: 1
Similarity Score: -0.5
Explanation: The two assembly codes show significant differences due to being written for different architectures (ARM vs x86), with distinct register usage, instruction sets, and stack management. While some high-level structural similarities exist (e.g., memory offset patterns like 0x24/0x30, conditional branching logic, and arithmetic operations), the implementations diverge fundamentally. The ARM code uses direct register operations with relative branching, while the x86 code relies heavily on stack frames and absolute addressing. Core functionality overlaps partially (e.g., memory comparisons and error handling), but architectural differences and varied control flow outweigh these parallels, resulting in low similarity.
------------------------------------------------------------

------------------------------------------------------------
Code1: push { r4 , r5 , r6 , lr } subs r4 , r0 , 0x0 beq 0x7c mov r1 , 0x2f bl 0xffffeb30 subs r5 , r0 , 0x0 beq 0x68 add r6 , r5 , 0x1 sub r3 , r6 , r4 cmp r3 , 0x6 ble 0x68 mov r2 , 0x7 ldr r1 , [ pc , 0x60 ] sub r0 , r5 , 0x6 bl 0xffffeb84 cmp r0 , 0x0 bne 0x68 mov r2 , 0x3 ldr r1 , [ pc , 0x4c ] mov r0 , r6 bl 0xffffeb84 cmp r0 , 0x0 movne r4 , r6 ldreq r3 , [ pc , 0x3c ] addeq r4 , r5 , 0x4 streq r4 , [ r3 ] ldr r2 , [ pc , 0x34 ] ldr r3 , [ pc , 0x34 ] str r4 , [ r2 ] str r4 , [ r3 ] pop { r4 , r5 , r6 , pc } ldr r3 , [ pc , 0x28 ] mov r2 , 0x37 ldr r3 , [ r3 ] mov r1 , 0x1 ldr r0 , [ pc , 0x1c ] bl 0xffffea04 bl 0xffffeb90 andeq r7 , r1 , r0 , lsr r4 andeq r7 , r1 , r8 , lsr r4 andeq r8 , r2 , r8 , asr 0x2 andeq r8 , r2 , ip , ror 0x2 andeq r8 , r2 , ip , asr 0x2 andeq r8 , r2 , r0 , asr r1 strdeq r7 , r8 , [ r1 ] , -r8
Code2: push ebp mov ebp , esp push esi sub esp , 0x24 mov eax , dword ptr [ ebp + 0x8 ] cmp dword ptr [ 0x805db74 ] , 0x0 mov dword ptr [ ebp - 0x8 ] , eax jne 0x34a mov al , byte ptr [ 0x805d100 ] xor al , 0xed mov byte ptr [ 0x805d140 ] , al mov al , byte ptr [ 0x805d101 ] xor al , 0x31 mov byte ptr [ 0x805d141 ] , al mov al , byte ptr [ 0x805d102 ] xor al , 0x5a mov byte ptr [ 0x805d142 ] , al mov al , byte ptr [ 0x805d103 ] xor al , 0x9 mov byte ptr [ 0x805d143 ] , al mov al , byte ptr [ 0x805d104 ] xor al , 0x5c mov byte ptr [ 0x805d144 ] , al mov al , byte ptr [ 0x805d105 ] xor al , 0xcc mov byte ptr [ 0x805d145 ] , al mov al , byte ptr [ 0x805d106 ] xor al , 0xb mov byte ptr [ 0x805d146 ] , al mov al , byte ptr [ 0x805d107 ] xor al , 0x12 mov byte ptr [ 0x805d147 ] , al mov al , byte ptr [ 0x805d108 ] xor al , 0x20 mov byte ptr [ 0x805d148 ] , al mov al , byte ptr [ 0x805d109 ] xor al , 0x71 mov byte ptr [ 0x805d149 ] , al mov al , byte ptr [ 0x805d10a ] xor al , 0x28 mov byte ptr [ 0x805d14a ] , al mov al , byte ptr [ 0x805d10b ] xor al , 0xa8 mov byte ptr [ 0x805d14b ] , al mov al , byte ptr [ 0x805d10c ] xor al , 0xa3 mov byte ptr [ 0x805d14c ] , al mov al , byte ptr [ 0x805d10d ] xor al , 0xe7 mov byte ptr [ 0x805d14d ] , al mov al , byte ptr [ 0x805d10e ] xor al , 0x26 mov byte ptr [ 0x805d14e ] , al mov al , byte ptr [ 0x805d10f ] xor al , 0xbe mov byte ptr [ 0x805d14f ] , al mov al , byte ptr [ 0x805d110 ] xor al , 0xbc mov byte ptr [ 0x805d150 ] , al mov al , byte ptr [ 0x805d111 ] xor al , 0x6a mov byte ptr [ 0x805d151 ] , al mov al , byte ptr [ 0x805d112 ] xor al , 0xfb mov byte ptr [ 0x805d152 ] , al mov al , byte ptr [ 0x805d113 ] xor al , 0xc9 mov byte ptr [ 0x805d153 ] , al mov al , byte ptr [ 0x805d114 ] xor al , 0xc4 mov byte ptr [ 0x805d154 ] , al mov al , byte ptr [ 0x805d115 ] xor al , 0x6d mov byte ptr [ 0x805d155 ] , al mov al , byte ptr [ 0x805d116 ] xor al , 0x1a mov byte ptr [ 0x805d156 ] , al mov al , byte ptr [ 0x805d117 ] xor al , 0x14 mov byte ptr [ 0x805d157 ] , al mov al , byte ptr [ 0x805d118 ] xor al , 0xd9 mov byte ptr [ 0x805d158 ] , al mov al , byte ptr [ 0x805d119 ] xor al , 0x61 mov byte ptr [ 0x805d159 ] , al mov al , byte ptr [ 0x805d11a ] xor al , 0x60 mov byte ptr [ 0x805d15a ] , al mov al , byte ptr [ 0x805d11b ] xor al , 0x4c mov byte ptr [ 0x805d15b ] , al mov al , byte ptr [ 0x805d11c ] xor al , 0xaa mov byte ptr [ 0x805d15c ] , al mov al , byte ptr [ 0x805d11d ] xor al , 0xe4 mov byte ptr [ 0x805d15d ] , al mov al , byte ptr [ 0x805d11e ] xor al , 0x7f mov byte ptr [ 0x805d15e ] , al mov al , byte ptr [ 0x805d11f ] xor al , 0x49 mov byte ptr [ 0x805d15f ] , al mov al , byte ptr [ 0x805d120 ] xor al , 0x96 mov byte ptr [ 0x805d160 ] , al mov al , byte ptr [ 0x805d121 ] xor al , 0x82 mov byte ptr [ 0x805d161 ] , al mov al , byte ptr [ 0x805d122 ] xor al , 0x48 mov byte ptr [ 0x805d162 ] , al mov al , byte ptr [ 0x805d123 ] xor al , 0xeb mov byte ptr [ 0x805d163 ] , al mov al , byte ptr [ 0x805d124 ] xor al , 0xbe mov byte ptr [ 0x805d164 ] , al mov al , byte ptr [ 0x805d125 ] xor al , 0xcd mov byte ptr [ 0x805d165 ] , al mov al , byte ptr [ 0x805d126 ] xor al , 0xdd mov byte ptr [ 0x805d166 ] , al mov al , byte ptr [ 0x805d127 ] xor al , 0x3c mov byte ptr [ 0x805d167 ] , al mov al , byte ptr [ 0x805d128 ] xor al , 0x77 mov byte ptr [ 0x805d168 ] , al mov al , byte ptr [ 0x805d129 ] xor al , 0x3f mov byte ptr [ 0x805d169 ] , al mov al , byte ptr [ 0x805d12a ] xor al , 0x71 mov byte ptr [ 0x805d16a ] , al mov al , byte ptr [ 0x805d12b ] xor al , 0xbc mov byte ptr [ 0x805d16b ] , al mov al , byte ptr [ 0x805d12c ] xor al , 0xf6 mov byte ptr [ 0x805d16c ] , al mov al , byte ptr [ 0x805d12d ] xor al , 0x63 mov byte ptr [ 0x805d16d ] , al mov al , byte ptr [ 0x805d12e ] xor al , 0x63 mov byte ptr [ 0x805d16e ] , al mov al , byte ptr [ 0x805d12f ] xor al , 0x71 mov byte ptr [ 0x805d16f ] , al mov al , byte ptr [ 0x805d130 ] xor al , 0x57 mov byte ptr [ 0x805d170 ] , al mov al , byte ptr [ 0x805d131 ] xor al , 0x9f mov byte ptr [ 0x805d171 ] , al mov al , byte ptr [ 0x805d132 ] xor al , 0xe8 mov byte ptr [ 0x805d172 ] , al mov al , byte ptr [ 0x805d133 ] xor al , 0x4f mov byte ptr [ 0x805d173 ] , al mov al , byte ptr [ 0x805d134 ] xor al , 0x9a mov byte ptr [ 0x805d174 ] , al mov al , byte ptr [ 0x805d135 ] xor al , 0x60 mov byte ptr [ 0x805d175 ] , al mov al , byte ptr [ 0x805d136 ] xor al , 0xe mov byte ptr [ 0x805d176 ] , al mov al , byte ptr [ 0x805d137 ] xor al , 0x45 mov byte ptr [ 0x805d177 ] , al mov al , byte ptr [ 0x805d178 ] xor al , 0xbc mov byte ptr [ 0x805d180 ] , al mov al , byte ptr [ 0x805d179 ] xor al , 0xc6 mov byte ptr [ 0x805d181 ] , al mov al , byte ptr [ 0x805d17a ] xor al , 0x49 mov byte ptr [ 0x805d182 ] , al mov al , byte ptr [ 0x805d17b ] xor al , 0xa2 mov byte ptr [ 0x805d183 ] , al mov al , byte ptr [ 0x805d17c ] xor al , 0xbb mov byte ptr [ 0x805d184 ] , al mov al , byte ptr [ 0x805d17d ] xor al , 0xe1 mov byte ptr [ 0x805d185 ] , al mov al , byte ptr [ 0x805d17e ] xor al , 0x9b mov byte ptr [ 0x805d186 ] , al mov al , byte ptr [ 0x805d17f ] xor al , 0xf3 mov byte ptr [ 0x805d187 ] , al mov al , byte ptr [ 0x805d188 ] xor al , 0x5d mov byte ptr [ 0x805d18c ] , al mov al , byte ptr [ 0x805d189 ] xor al , 0xb5 mov byte ptr [ 0x805d18d ] , al mov al , byte ptr [ 0x805d18a ] xor al , 0x1d mov byte ptr [ 0x805d18e ] , al mov al , byte ptr [ 0x805d18b ] xor al , 0x6f mov byte ptr [ 0x805d18f ] , al mov dword ptr [ 0x805db74 ] , 0x1 mov eax , esp add eax , - 0x10 mov esp , eax mov ecx , esp add ecx , - 0x10 mov esp , ecx mov edx , esp add edx , - 0x10 mov esp , edx mov esi , dword ptr [ ebp - 0x8 ] mov dword ptr [ eax ] , esi cmp dword ptr [ eax ] , 0x0 mov dword ptr [ ebp - 0xc ] , eax mov dword ptr [ ebp - 0x10 ] , ecx mov dword ptr [ ebp - 0x14 ] , edx jne 0x3a6 lea eax , [ 0x805d140 ] mov ecx , dword ptr [ 0x805dac8 ] sub esp , 0x10 mov dword ptr [ esp ] , eax mov dword ptr [ esp + 0x4 ] , ecx call 0xffff7b00 add esp , 0x10 mov dword ptr [ ebp - 0x18 ] , eax call 0xffff7af0 mov eax , dword ptr [ ebp - 0xc ] mov ecx , dword ptr [ eax ] sub esp , 0x10 mov dword ptr [ esp ] , ecx mov dword ptr [ esp + 0x4 ] , 0x2f call 0xffff7a90 add esp , 0x10 mov ecx , dword ptr [ ebp - 0x10 ] mov dword ptr [ ecx ] , eax cmp dword ptr [ ecx ] , 0x0 je 0x3df mov eax , dword ptr [ ebp - 0x10 ] mov ecx , dword ptr [ eax ] add ecx , 0x1 mov dword ptr [ ebp - 0x1c ] , ecx jmp 0x3e7 mov eax , dword ptr [ ebp - 0xc ] mov ecx , dword ptr [ eax ] mov dword ptr [ ebp - 0x1c ] , ecx mov eax , dword ptr [ ebp - 0x1c ] mov ecx , dword ptr [ ebp - 0x14 ] mov dword ptr [ ecx ] , eax mov eax , dword ptr [ ecx ] mov edx , dword ptr [ ebp - 0xc ] mov esi , dword ptr [ edx ] sub eax , esi cmp eax , 0x7 jl 0x481 lea eax , [ 0x805d180 ] mov ecx , dword ptr [ ebp - 0x14 ] mov edx , dword ptr [ ecx ] add edx , - 0x7 sub esp , 0x10 mov dword ptr [ esp ] , edx mov dword ptr [ esp + 0x4 ] , eax mov dword ptr [ esp + 0x8 ] , 0x7 call 0xffff7ad0 add esp , 0x10 cmp eax , 0x0 jne 0x481 lea eax , [ 0x805d18c ] mov ecx , dword ptr [ ebp - 0x14 ] mov edx , dword ptr [ ecx ] mov esi , dword ptr [ ebp - 0xc ] mov dword ptr [ esi ] , edx mov edx , dword ptr [ ecx ] sub esp , 0x10 mov dword ptr [ esp ] , edx mov dword ptr [ esp + 0x4 ] , eax mov dword ptr [ esp + 0x8 ] , 0x3 call 0xffff7ad0 add esp , 0x10 cmp eax , 0x0 jne 0x47c mov eax , dword ptr [ ebp - 0x14 ] mov ecx , dword ptr [ eax ] add ecx , 0x3 mov edx , dword ptr [ ebp - 0xc ] mov dword ptr [ edx ] , ecx mov ecx , dword ptr [ edx ] mov dword ptr [ 0x805dac0 ] , ecx jmp 0x481 mov eax , dword ptr [ ebp - 0xc ] mov ecx , dword ptr [ eax ] mov dword ptr [ 0x805db70 ] , ecx mov ecx , dword ptr [ eax ] mov dword ptr [ 0x805dad0 ] , ecx lea esp , [ ebp - 0x4 ] pop esi pop ebp ret nop nop nop
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly codes show no significant similarity due to fundamental differences:
1. **Architecture**: Code1 uses ARM syntax (e.g., `push {r4,r5,r6,lr}`, `bl` instructions), while Code2 uses x86 syntax (e.g., `mov ebp,esp`, `dword ptr`).
2. **Operations**: 
   - Code1 focuses on register operations, conditional branches (`beq`, `bne`), and memory access (`ldr`, `str`).
   - Code2 is dominated by byte-level XOR operations and stack manipulation (e.g., repeated `xor al, ...` sequences and `esp` adjustments).
3. **Structure**: 
   - Code1 has short blocks with arithmetic/logic ops.
   - Code2 contains extensive data processing (100+ XOR ops) and complex stack frames (`sub esp, 0x24`).
4. **Functionality**: No overlapping logic or patterns suggest equivalent purposes. The absence of shared mnemonics, registers, or control flow confirms dissimilarity.
------------------------------------------------------------

------------------------------------------------------------
Code1: push rbp mov rbp , rsp sub rsp , 0x10 xor eax , eax mov ecx , eax mov qword ptr [ rbp - 0x8 ] , rdi mov dword ptr [ rbp - 0xc ] , esi mov rsi , qword ptr [ rbp - 0x8 ] mov edx , dword ptr [ rbp - 0xc ] mov rdi , rcx call 0xfffffffffffea4e0 movabs rdi , 0x7a2744 mov rsi , rax mov al , 0x0 call 0xfffffffffff98860 mov dword ptr [ rbp - 0x10 ] , eax add rsp , 0x10 pop rbp ret nop
Code2: ldr r3 , [ pc , 0xdc ] push { r4 , r5 , r6 , r7 , r8 , lr } ldr r4 , [ r3 , 0x1ec ] ldr r5 , [ pc , 0xd4 ] subs r8 , r2 , 0x0 add r2 , r4 , 0x1 and r2 , r2 , 0xf str r2 , [ r3 , 0x1ec ] ldr r2 , [ r5 ] sub sp , sp , 0x38 add r3 , r3 , 0x1f0 mov r6 , r0 mov r7 , r1 add r4 , r3 , r4 , lsl 0x6 str r2 , [ sp , 0x34 ] bne 0xa8 ldr r3 , [ pc , 0xa4 ] add r8 , sp , 0x14 str r3 , [ sp ] mov r2 , 0x20 ldr r3 , [ pc , 0x98 ] mov r1 , 0x1 mov r0 , r8 bl 0xfffec9f4 mov r3 , 0x40 str r8 , [ sp ] str r6 , [ sp , 0x8 ] str r7 , [ sp , 0xc ] mov r1 , r3 mov r2 , 0x1 mov r0 , r4 bl 0xfffecbec mov r2 , r4 ldr r1 , [ pc , 0x68 ] mov r0 , 0x1 bl 0xfffeca48 ldr r2 , [ sp , 0x34 ] ldr r3 , [ r5 ] cmp r2 , r3 bne 0xe0 add sp , sp , 0x38 pop { r4 , r5 , r6 , r7 , r8 , pc } mov r3 , 0x40 ldr r2 , [ pc , 0x44 ] mov r0 , r4 str r2 , [ sp ] str r6 , [ sp , 0x8 ] str r7 , [ sp , 0xc ] mov r1 , r3 mov r2 , 0x1 bl 0xfffecbec cmp r8 , 0x8 movhs r8 , 0x8 sub r4 , r4 , r8 , lsl 0x1 add r4 , r4 , 0x10 b 0x80 bl 0xfffec79c andseq sl , r8 , r0 , asr 0x6 andseq r7 , r8 , r0 , lsl 0x30 andseq r2 , r3 , r0 , asr sp andseq ip , r2 , r0 , lsr 0x7 andseq sp , r2 , r0 , asr r7 mulseq r2 , r4 , r3
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly code snippets show no meaningful similarity due to fundamental differences: 
1. Architecture - Code1 uses x86_64 instructions (push/mov/sub) while Code2 uses ARM (ldr/push/bl)
2. Structure - Code1 has standard x86 stack management (rbp/rsp) while Code2 uses ARM register banking and different stack handling
3. Operations - Code1 features call instructions and register-based arithmetic, while Code2 uses conditional branching (bne) and shifted addressing modes
4. Purpose - Code1 appears to be a simple function with two calls, while Code2 shows complex memory operations and multiple condition checks
The architectures are completely incompatible with zero overlapping instructions or patterns.
------------------------------------------------------------

------------------------------------------------------------
Code1: push ebp push edi push esi push ebx call 0x5 add ebx , 0x2 sub esp , 0x9ec mov eax , dword ptr gs : [ 0x14 ] mov dword ptr [ esp + 0x9dc ] , eax xor eax , eax lea ebp , [ esp + 0x20c ] mov dword ptr [ esp + 0x1cc ] , 0x3020100 mov dword ptr [ esp + 0x1d0 ] , 0x7060504 mov dword ptr [ esp + 0x1d4 ] , 0xb0a0908 mov dword ptr [ esp + 0x1d8 ] , 0xf0e0d0c mov dword ptr [ esp + 0x1dc ] , 0x13121110 mov dword ptr [ esp + 0x1e0 ] , 0x17161514 mov dword ptr [ esp + 0x1e4 ] , 0x1b1a1918 mov dword ptr [ esp + 0x1e8 ] , 0x1f1e1d1c mov dword ptr [ esp + 0x1ec ] , 0x23222120 mov dword ptr [ esp + 0x1f0 ] , 0x27262524 mov dword ptr [ esp + 0x1f4 ] , 0x2b2a2928 mov dword ptr [ esp + 0x1f8 ] , 0x2f2e2d2c mov dword ptr [ esp + 0x1fc ] , 0x33323130 mov dword ptr [ esp + 0x200 ] , 0x37363534 mov dword ptr [ esp + 0x204 ] , 0x3b3a3938 mov dword ptr [ esp + 0x208 ] , 0x3f3e3d3c nop lea esi , [ esi ] lea edx , [ eax + 0x1 ] lea ecx , [ eax + 0x2 ] mov byte ptr [ ebp + eax ] , al mov byte ptr [ ebp + eax + 0x1 ] , dl lea edx , [ eax + 0x3 ] mov byte ptr [ ebp + eax + 0x2 ] , cl lea ecx , [ eax + 0x4 ] mov byte ptr [ ebp + eax + 0x3 ] , dl lea edx , [ eax + 0x5 ] mov byte ptr [ ebp + eax + 0x4 ] , cl lea ecx , [ eax + 0x6 ] mov byte ptr [ ebp + eax + 0x5 ] , dl lea edx , [ eax + 0x7 ] mov byte ptr [ ebp + eax + 0x6 ] , cl mov byte ptr [ ebp + eax + 0x7 ] , dl add eax , 0x8 cmp eax , 0x100 jne 0xe0 lea ecx , [ esp + 0x1cc ] lea edx , [ esp + 0x28 ] lea esi , [ ebx ] mov dword ptr [ esp + 0x28 ] , 0x40 mov eax , 0x40 xor edi , edi mov dword ptr [ esp + 0x4 ] , ecx mov dword ptr [ esp + 0xc ] , edx lea ecx , [ esp + 0x5f4 ] lea edx , [ ebx ] mov dword ptr [ esp ] , esi mov dword ptr [ esp + 0x10 ] , ebp mov dword ptr [ esp + 0x8 ] , ecx lea ecx , [ esp + 0x211 ] lea esi , [ esp + 0x2c ] mov dword ptr [ esp + 0x14 ] , edx lea edx , [ esp + 0x215 ] mov dword ptr [ esp + 0x18 ] , ecx mov dword ptr [ esp + 0x1c ] , edx jmp 0x25b lea esi , [ esi ] lea ebp , [ edi + 0x1 ] cmp ebp , 0x100 je 0x2af add dword ptr [ esp ] , 0x40 cmp ebp , 0xf mov dword ptr [ esp + 0x28 ] , 0x40 jbe 0x255 push 0x40 push dword ptr [ esp + 0x8 ] sub edi , 0xe push 0x40 push esi call 0x1b9 add esp , 0xc push 0x5 push dword ptr [ esp + 0x18 ] push esi call 0x1c8 add esp , 0xc push 0x4 push dword ptr [ esp + 0x20 ] push esi call 0x1d7 add esp , 0xc push 0x3 push dword ptr [ esp + 0x24 ] push esi call 0x1e6 add esp , 0xc push 0x2 lea eax , [ esp + 0x220 ] push eax push esi call 0x1f9 add esp , 0xc push 0x1 lea ecx , [ esp + 0x222 ] push ecx push esi call 0x20c add esp , 0xc push edi lea edi , [ esp + 0x223 ] push edi push esi call 0x21e add esp , 0xc push dword ptr [ esp + 0x10 ] mov edi , dword ptr [ esp + 0x10 ] push edi push esi call 0x230 pop ecx lea edx , [ ebx ] pop eax push ebp push edx push 0x40 push dword ptr [ esp + 0x14 ] push dword ptr [ esp + 0x40 ] push edi call 0x24a add esp , 0x20 test eax , eax jne 0x2aa mov eax , dword ptr [ esp + 0x28 ] mov edi , ebp push 0x40 push dword ptr [ esp + 0x8 ] push eax push esi call 0x264 add esp , 0xc push edi push dword ptr [ esp + 0x18 ] push esi call 0x272 add esp , 0xc push dword ptr [ esp + 0x10 ] mov ebp , dword ptr [ esp + 0x10 ] push ebp push esi call 0x284 pop eax pop edx push edi push dword ptr [ esp + 0x20 ] push 0x40 push dword ptr [ esp + 0x14 ] push dword ptr [ esp + 0x40 ] push ebp call 0x29b add esp , 0x20 test eax , eax je 0x188 mov eax , 0x5 mov ecx , dword ptr [ esp + 0x9dc ] xor ecx , dword ptr gs : [ 0x14 ] jne 0x2ca add esp , 0x9ec pop ebx pop esi pop edi pop ebp ret call 0x2cb
Code2: mov eax , dword ptr [ rip ] test eax , eax jne 0xd2 movaps xmm0 , xmmword ptr [ rip ] xorps xmm0 , xmmword ptr [ rip ] movaps xmmword ptr [ rip ] , xmm0 mov al , byte ptr [ rip ] xor al , 0xa3 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x75 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x7b movaps xmm0 , xmmword ptr [ rip ] xorps xmm0 , xmmword ptr [ rip ] movaps xmmword ptr [ rip ] , xmm0 movaps xmm0 , xmmword ptr [ rip ] xorps xmm0 , xmmword ptr [ rip ] movaps xmmword ptr [ rip ] , xmm0 movaps xmm0 , xmmword ptr [ rip ] xorps xmm0 , xmmword ptr [ rip ] movaps xmmword ptr [ rip ] , xmm0 movaps xmm0 , xmmword ptr [ rip ] xorps xmm0 , xmmword ptr [ rip ] movaps xmmword ptr [ rip ] , xmm0 movaps xmm0 , xmmword ptr [ rip ] xorps xmm0 , xmmword ptr [ rip ] mov byte ptr [ rip ] , al movaps xmmword ptr [ rip ] , xmm0 mov al , byte ptr [ rip ] xor al , 0x8b mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xe6 mov byte ptr [ rip ] , al push rbp mov rbp , rsp push r15 push r14 push r13 push r12 push rbx sub rsp , 0x38 mov dword ptr [ rip ] , 0x1 mov rax , rsp lea rcx , [ rax - 0x3f0 ] mov qword ptr [ rbp - 0x38 ] , rcx mov rsp , rcx mov r12 , rsp add r12 , - 0x3f0 mov rsp , r12 mov rcx , rsp lea rdx , [ rcx - 0x40 ] mov qword ptr [ rbp - 0x30 ] , rdx mov rsp , rdx mov rbx , rsp add rbx , - 0x1a0 mov rsp , rbx mov r13 , rsp add r13 , - 0x10 mov rsp , r13 movaps xmm0 , xmmword ptr [ rip ] movaps xmmword ptr [ rcx - 0x10 ] , xmm0 movaps xmm0 , xmmword ptr [ rip ] movaps xmmword ptr [ rcx - 0x20 ] , xmm0 movaps xmm0 , xmmword ptr [ rip ] movaps xmmword ptr [ rcx - 0x30 ] , xmm0 movaps xmm0 , xmmword ptr [ rip ] movaps xmmword ptr [ rcx - 0x40 ] , xmm0 movaps xmm0 , xmmword ptr [ rip ] movaps xmmword ptr [ rax - 0x3f0 ] , xmm0 movaps xmm0 , xmmword ptr [ rip ] movaps xmmword ptr [ rax - 0x3e0 ] , xmm0 movaps xmm0 , xmmword ptr [ rip ] movaps xmmword ptr [ rax - 0x3d0 ] , xmm0 movaps xmm0 , xmmword ptr [ rip ] movaps xmmword ptr [ rax - 0x3c0 ] , xmm0 movaps xmm0 , xmmword ptr [ rip ] movaps xmmword ptr [ rax - 0x3b0 ] , xmm0 movaps xmm0 , xmmword ptr [ rip ] movaps xmmword ptr [ rax - 0x3a0 ] , xmm0 movaps xmm0 , xmmword ptr [ rip ] movaps xmmword ptr [ rax - 0x390 ] , xmm0 movaps xmm0 , xmmword ptr [ rip ] movaps xmmword ptr [ rax - 0x380 ] , xmm0 movaps xmm0 , xmmword ptr [ rip ] movaps xmmword ptr [ rax - 0x370 ] , xmm0 movaps xmm0 , xmmword ptr [ rip ] movaps xmmword ptr [ rax - 0x360 ] , xmm0 movaps xmm0 , xmmword ptr [ rip ] movaps xmmword ptr [ rax - 0x350 ] , xmm0 movaps xmm0 , xmmword ptr [ rip ] movaps xmmword ptr [ rax - 0x340 ] , xmm0 movaps xmm0 , xmmword ptr [ rip ] movaps xmmword ptr [ rax - 0x330 ] , xmm0 movaps xmm0 , xmmword ptr [ rip ] movaps xmmword ptr [ rax - 0x320 ] , xmm0 movaps xmm0 , xmmword ptr [ rip ] movaps xmmword ptr [ rax - 0x310 ] , xmm0 movaps xmm0 , xmmword ptr [ rip ] movaps xmmword ptr [ rax - 0x300 ] , xmm0 lea rcx , [ rax - 0x3eb ] mov qword ptr [ rbp - 0x60 ] , rcx lea rcx , [ rax - 0x3e7 ] mov qword ptr [ rbp - 0x58 ] , rcx lea rcx , [ rax - 0x3e4 ] mov qword ptr [ rbp - 0x50 ] , rcx lea rcx , [ rax - 0x3e2 ] mov qword ptr [ rbp - 0x48 ] , rcx lea rax , [ rax - 0x3e1 ] mov qword ptr [ rbp - 0x40 ] , rax mov r14d , 0x0 xor r15d , r15d nop dword ptr [ rax ] mov qword ptr [ r13 ] , 0x40 mov esi , 0x40 cmp r15 , 0xf jbe 0x340 mov ecx , 0x40 mov rdi , rbx mov rdx , qword ptr [ rbp - 0x30 ] call 0x2a8 mov edx , 0x5 mov rdi , rbx mov rsi , qword ptr [ rbp - 0x38 ] call 0x2b9 mov edx , 0x4 mov rdi , rbx mov rsi , qword ptr [ rbp - 0x60 ] call 0x2ca mov edx , 0x3 mov rdi , rbx mov rsi , qword ptr [ rbp - 0x58 ] call 0x2db mov edx , 0x2 mov rdi , rbx mov rsi , qword ptr [ rbp - 0x50 ] call 0x2ec mov edx , 0x1 mov rdi , rbx mov rsi , qword ptr [ rbp - 0x48 ] call 0x2fd lea rdx , [ r15 - 0xf ] mov rdi , rbx mov rsi , qword ptr [ rbp - 0x40 ] call 0x30d mov rdi , rbx mov rsi , r12 mov rdx , r13 call 0x31b mov rsi , qword ptr [ r13 ] mov ecx , 0x40 mov r8d , 0x0 mov rdi , r12 mov rdx , r14 mov r9d , r15d call 0x338 test eax , eax jne 0x3a8 mov rsi , qword ptr [ r13 ] mov ecx , 0x40 mov rdi , rbx mov rdx , qword ptr [ rbp - 0x30 ] call 0x351 mov rdi , rbx mov rsi , qword ptr [ rbp - 0x38 ] mov rdx , r15 call 0x360 mov rdi , rbx mov rsi , r12 mov rdx , r13 call 0x36e mov rsi , qword ptr [ r13 ] mov ecx , 0x40 mov r8d , 0x0 mov rdi , r12 mov rdx , r14 mov r9d , r15d call 0x38b test eax , eax jne 0x3a8 add r15 , 0x1 add r14 , 0x40 cmp r15 , 0xff jbe 0x280 xor eax , eax jmp 0x3ad mov eax , 0x5 lea rsp , [ rbp - 0x28 ] pop rbx pop r12 pop r13 pop r14 pop r15 pop rbp ret
Similarity: -1
Label: 1
Similarity Score: -0.95
Explanation: The two assembly codes show fundamental differences in architecture, structure, and operations. Code1 uses 32-bit registers (ebp, esp, eax) and focuses on byte-level stack manipulation with sequential dword initializations, while Code2 employs 64-bit registers (rbp, rsp, r15) and SSE instructions (movaps, xorps) for bulk data operations. Code1's loop counter (0x100) and stack-based function calls differ significantly from Code2's larger stack allocation and RDI/RSI-based calls. No overlapping logic patterns or matching instruction sequences exist, indicating distinct functionalities. The architectural mismatch and absence of shared implementation approaches result in minimal similarity.
------------------------------------------------------------

------------------------------------------------------------
Code1: push rbp push r15 push r14 push r13 push r12 push rbx sub rsp , 0x88 mov rbx , rcx mov r15 , rdx mov ebp , esi mov r12 , rdi lea rdi , [ rsp + 0x70 ] call 0xfffffffffff38910 mov rdi , qword ptr [ rbx + 0x18 ] mov esi , dword ptr [ rdi + 0x8 ] cmp esi , dword ptr [ rsp + 0x7c ] jle 0x4a lea rdi , [ rsp + 0x70 ] call 0xfffffffffff38bf0 test rax , rax je 0x201 mov rdi , qword ptr [ rbx + 0x18 ] call 0xfffffffffff38790 mov dword ptr [ rsp + 0x14 ] , eax mov rdi , r12 mov esi , ebp call qword ptr [ rip + 0x37d562 ] mov r13d , eax mov edi , 0x63f32f call qword ptr [ rip + 0x37d52c ] test eax , eax jle 0x1b9 mov r14d , eax mov dword ptr [ rsp + 0xc ] , ebp mov rax , qword ptr [ rip + 0x37d54e ] mov qword ptr [ rsp + 0x68 ] , rax mov rdi , qword ptr [ rbx + 0x18 ] mov rax , qword ptr [ rdi ] mov qword ptr [ rsp + 0x40 ] , rax call 0xfffffffffff38790 mov dword ptr [ rsp + 0x10 ] , eax mov rdi , qword ptr [ rbx + 0x20 ] mov rax , qword ptr [ rdi ] mov qword ptr [ rsp + 0x60 ] , rax call 0xfffffffffff38790 mov qword ptr [ rsp + 0x58 ] , rax mov rdi , qword ptr [ rbx + 0x28 ] mov rax , qword ptr [ rdi ] mov qword ptr [ rsp + 0x50 ] , rax call 0xfffffffffff38790 mov qword ptr [ rsp + 0x48 ] , rax mov rdi , qword ptr [ rbx + 0x30 ] mov rax , qword ptr [ rdi ] mov qword ptr [ rsp + 0x38 ] , rax call 0xfffffffffff38790 mov qword ptr [ rsp + 0x30 ] , rax mov rdi , qword ptr [ r15 ] mov rbp , r12 mov rax , qword ptr [ rdi ] mov qword ptr [ rsp + 0x28 ] , rax call 0xfffffffffff38790 mov r12d , eax mov qword ptr [ rsp + 0x20 ] , r15 mov rdi , qword ptr [ r15 + 0x8 ] mov r15 , qword ptr [ rdi ] call 0xfffffffffff38790 lea r10 , [ rsp + 0x14 ] mov edi , r14d xor esi , esi mov qword ptr [ rsp + 0x18 ] , rbp mov rdx , rbp mov ecx , r13d mov r8 , qword ptr [ rsp + 0x40 ] mov r9d , dword ptr [ rsp + 0x10 ] push r10 push qword ptr [ rsp + 0x78 ] push rax push r15 push r12 push qword ptr [ rsp + 0x50 ] push qword ptr [ rsp + 0x60 ] push qword ptr [ rsp + 0x70 ] push qword ptr [ rsp + 0x88 ] push qword ptr [ rsp + 0x98 ] push qword ptr [ rsp + 0xa8 ] push qword ptr [ rsp + 0xb8 ] call qword ptr [ rsp + 0xc8 ] add rsp , 0x60 test eax , eax je 0x236 mov edi , dword ptr [ rip + 0x37d420 ] test edi , edi jne 0x181 call 0xfffffffffff71b30 mov edi , eax mov dword ptr [ rip + 0x37d40f ] , eax mov ecx , 0x63f325 mov esi , 0x67 mov edx , 0x6a mov r8d , 0x371 call 0xfffffffffff70610 mov edi , r14d call qword ptr [ rip + 0x37d404 ] call 0xfffffffffff56840 mov rdi , qword ptr [ rsp + 0x18 ] mov esi , dword ptr [ rsp + 0xc ] mov rdx , qword ptr [ rsp + 0x20 ] jmp 0x1f7 mov edi , dword ptr [ rip + 0x37d3d1 ] test edi , edi jne 0x1d0 call 0xfffffffffff71b30 mov edi , eax mov dword ptr [ rip + 0x37d3c0 ] , eax mov ecx , 0x63f325 mov esi , 0x67 mov edx , 0x6c mov r8d , 0x35b call 0xfffffffffff70610 call 0xfffffffffff56840 mov rdi , r12 mov esi , ebp mov rdx , r15 mov rcx , rbx call qword ptr [ rax + 0x18 ] mov ebx , eax jmp 0x244 mov edi , dword ptr [ rip + 0x37d389 ] test edi , edi jne 0x218 call 0xfffffffffff71b30 mov edi , eax mov dword ptr [ rip + 0x37d378 ] , eax mov ecx , 0x63f325 mov esi , 0x67 mov edx , 0x65 mov r8d , 0x350 call 0xfffffffffff70610 xor ebx , ebx jmp 0x244 mov edi , r14d call qword ptr [ rip + 0x37d369 ] mov ebx , 0x1 lea rdi , [ rsp + 0x70 ] call 0xfffffffffff38870 mov eax , ebx add rsp , 0x88 pop rbx pop r12 pop r13 pop r14 pop r15 pop rbp ret nop word ptr cs : [ rax + rax ] nop dword ptr [ rax ]
Code2: push ebp push edi push esi push ebx sub esp , 0x7c call 0xffe79b6e add ebx , 0x15963e mov eax , dword ptr [ esp + 0x90 ] mov dword ptr [ esp + 0x2c ] , eax mov eax , dword ptr [ esp + 0x98 ] mov dword ptr [ esp + 0x28 ] , eax mov eax , dword ptr [ esp + 0x9c ] mov dword ptr [ esp + 0x24 ] , eax mov eax , dword ptr gs : [ 0x14 ] mov dword ptr [ esp + 0x6c ] , eax xor eax , eax mov dword ptr [ esp + 0x40 ] , 0x0 lea eax , [ esp + 0x58 ] mov dword ptr [ esp + 0x44 ] , eax sub esp , 0xc lea eax , [ esp + 0x64 ] push eax call 0xfff43323 add esp , 0x10 mov eax , dword ptr [ esp + 0x24 ] mov eax , dword ptr [ eax + 0xc ] mov edx , dword ptr [ eax + 0x4 ] mov eax , dword ptr [ esp + 0x44 ] mov eax , dword ptr [ eax + 0x8 ] cmp edx , eax jg 0x7e cmp dword ptr [ esp + 0x44 ] , 0x0 sete al jmp 0x9d mov eax , dword ptr [ esp + 0x24 ] mov eax , dword ptr [ eax + 0xc ] mov eax , dword ptr [ eax + 0x4 ] sub esp , 0x8 push eax push dword ptr [ esp + 0x50 ] call 0xfff4364d add esp , 0x10 test eax , eax sete al test al , al je 0xbe push 0x350 lea eax , [ ebx - 0xca96d ] push eax push 0x65 push 0x67 call 0xffffeb7a add esp , 0x10 jmp 0x2fa mov eax , dword ptr [ esp + 0x24 ] mov eax , dword ptr [ eax + 0xc ] sub esp , 0xc push eax call 0xfff431a5 add esp , 0x10 mov dword ptr [ esp + 0x3c ] , eax mov eax , dword ptr [ ebx + 0x11220 ] sub esp , 0x8 push dword ptr [ esp + 0x9c ] push dword ptr [ esp + 0x38 ] call eax add esp , 0x10 mov dword ptr [ esp + 0x48 ] , eax mov eax , dword ptr [ ebx + 0x11228 ] sub esp , 0xc lea edx , [ ebx - 0xca963 ] push edx call eax add esp , 0x10 mov dword ptr [ esp + 0x4c ] , eax cmp dword ptr [ esp + 0x4c ] , 0x0 jg 0x163 mov dword ptr [ esp + 0x4c ] , 0x0 push 0x35b lea eax , [ ebx - 0xca96d ] push eax push 0x6c push 0x67 call 0xffffeb7a add esp , 0x10 call 0xfff6466b mov dword ptr [ esp + 0x54 ] , eax mov eax , dword ptr [ esp + 0x54 ] mov eax , dword ptr [ eax + 0xc ] push dword ptr [ esp + 0x24 ] push dword ptr [ esp + 0x2c ] push dword ptr [ esp + 0x9c ] push dword ptr [ esp + 0x38 ] call eax add esp , 0x10 mov dword ptr [ esp + 0x40 ] , eax jmp 0x2fa mov eax , dword ptr [ ebx + 0x11244 ] mov dword ptr [ esp ] , eax mov ecx , dword ptr [ esp + 0x58 ] mov dword ptr [ esp + 0x4 ] , ecx mov eax , dword ptr [ esp + 0x28 ] mov eax , dword ptr [ eax + 0x4 ] sub esp , 0xc push eax call 0xfff431a5 add esp , 0x10 mov dword ptr [ esp + 0x8 ] , eax mov eax , dword ptr [ esp + 0x28 ] mov eax , dword ptr [ eax + 0x4 ] mov esi , dword ptr [ eax ] mov dword ptr [ esp + 0xc ] , esi mov eax , dword ptr [ esp + 0x28 ] mov eax , dword ptr [ eax ] sub esp , 0xc push eax call 0xfff431a5 add esp , 0x10 mov dword ptr [ esp + 0x10 ] , eax mov eax , dword ptr [ esp + 0x28 ] mov eax , dword ptr [ eax ] mov edi , dword ptr [ eax ] mov dword ptr [ esp + 0x14 ] , edi mov eax , dword ptr [ esp + 0x24 ] mov eax , dword ptr [ eax + 0x18 ] sub esp , 0xc push eax call 0xfff431a5 add esp , 0x10 mov dword ptr [ esp + 0x18 ] , eax mov eax , dword ptr [ esp + 0x24 ] mov eax , dword ptr [ eax + 0x18 ] mov edx , dword ptr [ eax ] mov dword ptr [ esp + 0x1c ] , edx mov eax , dword ptr [ esp + 0x24 ] mov eax , dword ptr [ eax + 0x14 ] sub esp , 0xc push eax call 0xfff431a5 add esp , 0x10 mov dword ptr [ esp + 0x20 ] , eax mov eax , dword ptr [ esp + 0x24 ] mov eax , dword ptr [ eax + 0x14 ] mov edi , dword ptr [ eax ] mov eax , dword ptr [ esp + 0x24 ] mov eax , dword ptr [ eax + 0x10 ] sub esp , 0xc push eax call 0xfff431a5 add esp , 0x10 mov ebp , eax mov eax , dword ptr [ esp + 0x24 ] mov eax , dword ptr [ eax + 0x10 ] mov esi , dword ptr [ eax ] mov eax , dword ptr [ esp + 0x24 ] mov eax , dword ptr [ eax + 0xc ] sub esp , 0xc push eax call 0xfff431a5 add esp , 0x10 mov ecx , eax mov eax , dword ptr [ esp + 0x24 ] mov eax , dword ptr [ eax + 0xc ] mov edx , dword ptr [ eax ] sub esp , 0x8 lea eax , [ esp + 0x44 ] push eax push dword ptr [ esp + 0x10 ] push dword ptr [ esp + 0x18 ] push dword ptr [ esp + 0x20 ] push dword ptr [ esp + 0x28 ] push dword ptr [ esp + 0x30 ] push dword ptr [ esp + 0x38 ] push dword ptr [ esp + 0x40 ] push dword ptr [ esp + 0x48 ] push edi push ebp push esi push ecx push edx push dword ptr [ esp + 0x88 ] push dword ptr [ esp + 0x70 ] push 0x0 push dword ptr [ esp + 0x98 ] mov eax , dword ptr [ esp + 0x50 ] call eax add esp , 0x50 test eax , eax je 0x2e0 push 0x371 lea eax , [ ebx - 0xca96d ] push eax push 0x6a push 0x67 call 0xffffeb7a add esp , 0x10 mov eax , dword ptr [ ebx + 0x1122c ] sub esp , 0xc push dword ptr [ esp + 0x58 ] call eax add esp , 0x10 call 0xfff6466b mov dword ptr [ esp + 0x50 ] , eax mov eax , dword ptr [ esp + 0x50 ] mov eax , dword ptr [ eax + 0xc ] push dword ptr [ esp + 0x24 ] push dword ptr [ esp + 0x2c ] push dword ptr [ esp + 0x9c ] push dword ptr [ esp + 0x38 ] call eax add esp , 0x10 mov dword ptr [ esp + 0x40 ] , eax jmp 0x2fa mov eax , dword ptr [ ebx + 0x1122c ] sub esp , 0xc push dword ptr [ esp + 0x58 ] call eax add esp , 0x10 mov dword ptr [ esp + 0x40 ] , 0x1 sub esp , 0xc lea eax , [ esp + 0x64 ] push eax call 0xfff431fd add esp , 0x10 mov eax , dword ptr [ esp + 0x40 ] mov ecx , dword ptr [ esp + 0x6c ] xor ecx , dword ptr gs : [ 0x14 ] je 0x320 call 0x492ee add esp , 0x7c pop ebx pop esi pop edi pop ebp ret
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly codes show fundamental differences indicating they are not similar:
1. **Architecture**: Code1 uses 64-bit registers (rax, rbx, rsp, rip) and operations, while Code2 uses 32-bit registers (eax, ebx, esp) and lacks RIP-relative addressing.
2. **Stack Management**: Code1 reserves 0x88 bytes on the stack and uses 64-bit memory offsets, while Code2 reserves 0x7c bytes with 32-bit offsets.
3. **Function Calls**: Code1 makes calls via absolute addresses (e.g., `call 0xfffffffffff38910`), while Code2 uses position-independent calls (e.g., `call 0xffe79b6e`) and adjusts EBX for base addressing.
4. **Control Flow**: Code1 uses complex multi-register operations and conditional jumps (jle/je) with 64-bit operands, whereas Code2 relies on 32-bit comparisons and simpler conditional logic.
5. **Register Usage**: Code1 extensively uses R12-R15 registers (absent in 32-bit), while Code2 depends on segment registers (GS) and lacks 64-bit register capabilities.
These architectural and structural disparities confirm the codes are functionally dissimilar.

[[ ## completed ##
------------------------------------------------------------

------------------------------------------------------------
Code1: lui gp , 0x6c lui a3 , 0x6b addiu gp , gp , 0x3de0 lw t9 , - 0x6768 ( gp ) b - 0x3520 addiu a3 , a3 , - 0x699c
Code2: addiu sp , sp , - 0x20 sw ra , 0x1c ( sp ) lui gp , 0x76 addiu gp , gp , 0x1270 sw gp , 0x10 ( sp ) sw a0 , 0x20 ( sp ) sw a1 , 0x24 ( sp ) sw a2 , 0x28 ( sp ) lui v0 , 0x74 addiu a3 , v0 , 0x69e0 lw a2 , 0x28 ( sp ) lw a1 , 0x24 ( sp ) lw a0 , 0x20 ( sp ) lw v0 , - 0x6784 ( gp ) move t9 , v0 bal - 0x54b8 nop lw gp , 0x10 ( sp ) lw ra , 0x1c ( sp ) addiu sp , sp , 0x20 jr ra nop
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two code snippets are fundamentally different in structure and purpose. Code1 is a short sequence of instructions without function prologue or epilogue, focusing on setting up registers and branching. Code2 is a complete function with stack management, saving and restoring registers, and includes a function call. The only commonality is the use of lui and addiu for the gp register, which is a common MIPS pattern but insufficient for similarity.
------------------------------------------------------------

------------------------------------------------------------
Code1: push rbp push r15 push r14 push r13 push r12 push rbx sub rsp , 0x18 mov r15 , rdi call 0xfffffffffffffe00 mov esi , 0x593908 mov edi , 0x30 mov edx , 0x256 call 0x25b80 mov rcx , qword ptr [ r15 + 0x80 ] mov qword ptr [ rcx + 0x1c0 ] , rax xorps xmm0 , xmm0 movups xmmword ptr [ rax + 0x20 ] , xmm0 movups xmmword ptr [ rax + 0x10 ] , xmm0 movups xmmword ptr [ rax ] , xmm0 mov rax , qword ptr [ r15 + 0x80 ] mov rdi , qword ptr [ rax + 0x1b8 ] xor ebx , ebx lea rcx , [ rsp + 0x10 ] mov esi , 0x3 xor edx , edx call 0x68ef0 test rax , rax jle 0x170 mov r14 , rax lea rsi , [ rsp + 0x8 ] mov rdx , rsp xor edi , edi call 0x1ca20 test eax , eax je 0x13f xor ebx , ebx lea r12 , [ rsp + 0x8 ] mov r13 , rsp nop word ptr cs : [ rax + rax ] nop mov rbp , qword ptr [ rsp + 0x8 ] mov rdi , r15 call 0xfffffffffffff1d0 test rax , rbp je 0x110 mov rax , qword ptr [ rsp ] test rax , rax je 0x110 call 0x75ec0 mov rcx , qword ptr [ r15 + 0x80 ] mov rcx , qword ptr [ rcx + 0x1c0 ] mov qword ptr [ rcx + rbx * 0x8 ] , rax mov rax , qword ptr [ r15 + 0x80 ] mov rax , qword ptr [ rax + 0x1c0 ] mov rdi , qword ptr [ rax + rbx * 0x8 ] mov rsi , qword ptr [ rsp ] xor edx , edx call 0x75f10 mov rax , qword ptr [ r15 + 0x80 ] mov rax , qword ptr [ rax + 0x1c0 ] mov rdi , qword ptr [ rax + rbx * 0x8 ] mov rsi , qword ptr [ rsp + 0x10 ] mov rdx , r14 call 0x76110 jmp 0x126 mov rax , qword ptr [ r15 + 0x80 ] mov rax , qword ptr [ rax + 0x1c0 ] mov qword ptr [ rax + rbx * 0x8 ] , 0x0 add rbx , 0x1 mov edi , ebx mov rsi , r12 mov rdx , r13 call 0x1ca20 test eax , eax jne 0xa0 mov rax , qword ptr [ r15 + 0x80 ] mov ebx , 0x1 test byte ptr [ rax ] , 0x20 jne 0x18f mov rdi , qword ptr [ rax + 0x1b8 ] call 0x688c0 mov rax , qword ptr [ r15 + 0x80 ] mov qword ptr [ rax + 0x1b8 ] , 0x0 jmp 0x18f mov ecx , 0x593908 mov edi , 0x14 mov esi , 0x125 mov edx , 0x14c mov r8d , 0x25b call 0x73c80 mov eax , ebx add rsp , 0x18 pop rbx pop r12 pop r13 pop r14 pop r15 pop rbp ret
Code2: push { r4 , r5 , r6 , r7 , r8 , sb , sl , lr } ldr r4 , [ r0 , 0x58 ] ldr r8 , [ pc , 0x1a8 ] ldr r3 , [ r4 , 0x17c ] ldr r2 , [ r8 ] sub sp , sp , 0x18 cmp r3 , 0x0 mov r5 , r0 str r2 , [ sp , 0x14 ] beq 0x64 mov r4 , 0x0 ldr r0 , [ r3 , r4 ] cmp r0 , 0x0 beq 0x44 bl 0x8b9a8 ldr r3 , [ r5 , 0x58 ] ldr r3 , [ r3 , 0x17c ] add r4 , r4 , 0x4 cmp r4 , 0x18 bne 0x2c mov r0 , r3 bl 0x2ac90 mov r3 , 0x0 ldr r4 , [ r5 , 0x58 ] str r3 , [ r4 , 0x17c ] ldr r2 , [ pc , 0x150 ] ldr r1 , [ pc , 0x150 ] mov r0 , 0x18 bl 0x2a85c ldr r3 , [ r5 , 0x58 ] str r0 , [ r4 , 0x17c ] ldr r0 , [ r3 , 0x17c ] mov r2 , 0x18 mov r1 , 0x0 bl 0xfffa8214 ldr r2 , [ r5 , 0x58 ] add r3 , sp , 0x10 ldr r0 , [ r2 , 0x178 ] mov r1 , 0x3 mov r2 , 0x0 bl 0x79a4c subs sb , r0 , 0x0 movgt r4 , 0x0 movgt r7 , r4 bgt 0x10c b 0x190 ldr r2 , [ r5 , 0x58 ] ldr r3 , [ sp , 0xc ] ldr sl , [ r2 , 0x17c ] cmp r3 , 0x0 add r3 , sl , r6 beq 0x148 bl 0x8aecc ldr r3 , [ r5 , 0x58 ] str r0 , [ sl , r6 ] ldr r3 , [ r3 , 0x17c ] mov r2 , 0x0 ldr r0 , [ r3 , r6 ] ldr r1 , [ sp , 0xc ] bl 0x8b128 ldr r3 , [ r5 , 0x58 ] mov r2 , sb ldr r3 , [ r3 , 0x17c ] ldr r1 , [ sp , 0x10 ] ldr r0 , [ r3 , r6 ] bl 0x8b384 add r4 , r4 , 0x1 add r2 , sp , 0xc add r1 , sp , 0x8 mov r0 , r4 bl 0x20750 cmp r0 , 0x0 beq 0x150 mov r0 , r5 bl 0xfffff370 ldr r3 , [ sp , 0x8 ] lsl r6 , r4 , 0x2 tst r0 , r3 bne 0xb8 ldr r3 , [ r5 , 0x58 ] ldr r3 , [ r3 , 0x17c ] add r3 , r3 , r6 str r7 , [ r3 ] b 0x108 ldr r2 , [ r5 , 0x58 ] ldr r3 , [ r2 ] ands r4 , r3 , 0x20 movne r0 , 0x1 bne 0x178 ldr r0 , [ r2 , 0x178 ] bl 0x790dc mov r0 , 0x1 ldr r3 , [ r5 , 0x58 ] str r4 , [ r3 , 0x178 ] ldr r2 , [ sp , 0x14 ] ldr r3 , [ r8 ] cmp r2 , r3 bne 0x1b4 add sp , sp , 0x18 pop { r4 , r5 , r6 , r7 , r8 , sb , sl , pc } ldr r2 , [ pc , 0x2c ] mov r0 , 0x14 str r2 , [ sp ] ldr r3 , [ pc , 0x1c ] mov r2 , 0x14c ldr r1 , [ pc , 0x1c ] bl 0x89d38 mov r0 , 0x0 b 0x178 bl 0xfffa7f8c eoreq pc , r1 , r0 , lsl 0x30 andeq r0 , r0 , r6 , asr r2 andseq sp , ip , r4 , asr 0x18 andeq r0 , r0 , fp , asr r2 andeq r0 , r0 , r5 , lsr 0x2
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly codes are for different processor architectures (x86-64 vs ARM) and use entirely different instruction sets and registers. While both exhibit generic function structure elements like register saving and stack adjustment, the specific operations, memory access patterns, and function calls show no significant similarities. The architectural differences and lack of matching
------------------------------------------------------------

------------------------------------------------------------
Code1: push { r4 , r5 , r6 , r7 , r8 , sb , sl , fp , lr } ldr r3 , [ pc , 0x2dc ] sub sp , sp , 0x1c ldr r3 , [ r3 , r1 , lsl 0x2 ] subs r6 , r0 , 0x0 str r3 , [ sp ] beq 0x2a8 mov r5 , 0x0 bl 0xffff40b0 mov fp , r5 mov r7 , r0 str r5 , [ sp , 0x10 ] mov sb , r5 str r5 , [ sp , 0x8 ] mov sl , r5 mov r8 , r5 b 0x68 ldrb r1 , [ r4 , 0x13 ] add r3 , r4 , 0x13 cmp r1 , 0x2e bne 0x60 ldrb r1 , [ r4 , 0x14 ] cmp r1 , 0x2e ldrbeq r1 , [ r4 , 0x15 ] cmp r1 , 0x0 bne 0xcc str r8 , [ r7 ] mov r0 , r6 bl 0xffff41d0 subs r4 , r0 , 0x0 bne 0x44 ldr r6 , [ r7 ] cmp r6 , 0x0 bne 0x28c ldr r3 , [ sp ] cmp r3 , 0x0 beq 0x188 cmp fp , 0x0 add r5 , r5 , 0x1 bne 0x130 mov r0 , r5 bl 0x1a28 mov sl , r0 mov r5 , r0 mov r0 , sb bl 0xffff3e70 mov r3 , 0x0 strb r3 , [ r5 ] mov r0 , sl add sp , sp , 0x1c pop { r4 , r5 , r6 , r7 , r8 , sb , sl , fp , pc } mov r0 , r3 str r3 , [ sp , 0xc ] bl 0xffff4068 ldr r3 , [ sp ] cmp r3 , 0x0 add r3 , r0 , 0x1 str r3 , [ sp , 0x4 ] ldr r3 , [ sp , 0xc ] beq 0x1b4 ldr r2 , [ sp , 0x10 ] cmp fp , r2 beq 0x22c add r2 , fp , 0x1 str r2 , [ sp , 0xc ] mov r0 , r3 bl 0x1c50 ldm r4 , { r2 , r3 } str r0 , [ sb , fp , lsl 0x4 ] ldr r0 , [ sp , 0x4 ] add r1 , sb , fp , lsl 0x4 add r5 , r5 , r0 ldr fp , [ sp , 0xc ] str r2 , [ r1 , 0x8 ] str r3 , [ r1 , 0xc ] b 0x68 mov r2 , 0x10 mov r1 , fp mov r0 , sb bl 0xffff4230 mov r0 , r5 bl 0x1a28 mov r5 , r6 mov sl , r0 add r4 , sl , r5 ldr r1 , [ sb , r6 , lsl 0x4 ] mov r0 , r4 bl 0xffff3ed0 sub r4 , r0 , r4 ldr r0 , [ sb , r6 , lsl 0x4 ] add r6 , r6 , 0x1 add r4 , r4 , 0x1 bl 0xffff3e70 cmp fp , r6 add r5 , r5 , r4 bne 0x150 add r5 , sl , r5 b 0xb0 ldr r3 , [ sp , 0x8 ] cmp r3 , r5 addne r5 , sl , r5 bne 0xb8 ldr r4 , [ sp , 0x8 ] mov r0 , sl add r1 , r4 , 0x1 bl 0x1a88 mov sl , r0 add r5 , r0 , r4 b 0xb8 ldr r0 , [ sp , 0x4 ] ldr r2 , [ sp , 0x8 ] adds r4 , r5 , r0 sub r2 , r2 , r5 movhs r1 , 0x1 movlo r1 , 0x0 cmp r2 , r0 bhi 0x214 cmp r1 , 0x0 bne 0x27c cmp sl , 0x0 beq 0x26c ldr r2 , [ pc , 0x100 ] cmp r4 , r2 bhi 0x27c add r2 , r4 , 0x1 add r2 , r2 , r4 , lsr 0x1 str r2 , [ sp , 0x8 ] mov r0 , sl ldr r1 , [ sp , 0x8 ] str r3 , [ sp , 0xc ] bl 0x1a88 mov sl , r0 ldr r3 , [ sp , 0xc ] add r0 , sl , r5 ldr r2 , [ sp , 0x4 ] mov r1 , r3 bl 0xffff3e94 mov r5 , r4 b 0x68 cmp sb , 0x0 beq 0x2b0 ldr r2 , [ pc , 0xb4 ] cmp fp , r2 bhi 0x27c add r2 , fp , 0x1 str r2 , [ sp , 0xc ] add r2 , r2 , fp , lsr 0x1 str r2 , [ sp , 0x10 ] lsl r1 , r2 , 0x4 mov r0 , sb str r3 , [ sp , 0x14 ] bl 0x1a88 ldr r3 , [ sp , 0x14 ] mov sb , r0 b 0x104 cmp r4 , 0x0 beq 0x280 str r4 , [ sp , 0x8 ] bge 0x1fc bl 0x1c6c mov r2 , 0x40 str r2 , [ sp , 0x8 ] b 0x1fc mov r0 , sb bl 0xffff3e70 mov r0 , sl bl 0xffff3e70 mov sl , r4 str r6 , [ r7 ] b 0xc0 mov sl , r6 b 0xc0 cmp fp , 0x0 movne r2 , fp moveq r2 , 0x4 lsrs r1 , r2 , 0x1c moveq r0 , sb movne r0 , 0x1 lsls r1 , r2 , 0x4 str r2 , [ sp , 0x10 ] bmi 0x27c cmp r0 , 0x0 bne 0x27c add r2 , fp , 0x1 str r2 , [ sp , 0xc ] b 0x254 andeq r5 , r2 , ip , lsl 0x12 ldrbpl r5 , [ r5 , - 0x553 ] ldrbeq r5 , [ r5 , - 0x554 ]
Code2: push ebp mov ebp , esp sub esp , 0x68 mov eax , dword ptr [ ebp + 0xc ] mov ecx , dword ptr [ ebp + 0x8 ] mov dword ptr [ ebp - 0x8 ] , 0x0 mov dword ptr [ ebp - 0xc ] , 0x0 mov dword ptr [ ebp - 0x10 ] , 0x0 mov dword ptr [ ebp - 0x14 ] , 0x0 mov dword ptr [ ebp - 0x18 ] , 0x0 mov dword ptr [ ebp - 0x1c ] , 0x0 mov edx , dword ptr [ ebp + 0xc ] mov edx , dword ptr [ edx * 0x4 + 0x806d7e0 ] mov dword ptr [ ebp - 0x24 ] , edx cmp dword ptr [ ebp + 0x8 ] , 0x0 mov dword ptr [ ebp - 0x44 ] , eax mov dword ptr [ ebp - 0x48 ] , ecx jne 0x5f mov dword ptr [ ebp - 0x4 ] , 0x0 jmp 0x328 jmp 0x64 call 0x4b0 mov dword ptr [ eax ] , 0x0 mov eax , dword ptr [ ebp + 0x8 ] mov dword ptr [ esp ] , eax call 0x4e0 mov dword ptr [ ebp - 0x28 ] , eax cmp dword ptr [ ebp - 0x28 ] , 0x0 jne 0x8c jmp 0x1e7 mov eax , dword ptr [ ebp - 0x28 ] add eax , 0x13 mov dword ptr [ ebp - 0x2c ] , eax mov eax , dword ptr [ ebp - 0x2c ] mov ecx , dword ptr [ ebp - 0x2c ] movsx ecx , byte ptr [ ecx ] cmp ecx , 0x2e mov dword ptr [ ebp - 0x4c ] , eax je 0xb4 xor eax , eax mov dword ptr [ ebp - 0x50 ] , eax jmp 0xce mov eax , dword ptr [ ebp - 0x2c ] movsx eax , byte ptr [ eax + 0x1 ] cmp eax , 0x2e mov eax , 0x1 mov ecx , 0x2 cmovne ecx , eax mov dword ptr [ ebp - 0x50 ] , ecx mov eax , dword ptr [ ebp - 0x50 ] mov ecx , dword ptr [ ebp - 0x4c ] movsx eax , byte ptr [ ecx + eax ] cmp eax , 0x0 je 0x1e2 mov eax , dword ptr [ ebp - 0x28 ] add eax , 0x13 mov ecx , esp mov dword ptr [ ecx ] , eax call 0xfffe6f10 add eax , 0x1 mov dword ptr [ ebp - 0x30 ] , eax cmp dword ptr [ ebp - 0x24 ] , 0x0 je 0x171 mov eax , dword ptr [ ebp - 0x14 ] cmp eax , dword ptr [ ebp - 0x18 ] jne 0x135 mov eax , dword ptr [ ebp - 0x14 ] mov dword ptr [ ebp - 0x34 ] , eax mov eax , dword ptr [ ebp - 0x10 ] mov dword ptr [ esp ] , eax lea eax , [ ebp - 0x34 ] mov dword ptr [ esp + 0x4 ] , eax mov dword ptr [ esp + 0x8 ] , 0xc call 0x3e60 mov dword ptr [ ebp - 0x10 ] , eax mov eax , dword ptr [ ebp - 0x34 ] mov dword ptr [ ebp - 0x14 ] , eax mov eax , dword ptr [ ebp - 0x2c ] mov ecx , esp mov dword ptr [ ecx ] , eax call 0x4060 mov ecx , dword ptr [ ebp - 0x10 ] mov edx , dword ptr [ ebp - 0x18 ] lea edx , [ edx + edx * 0x2 ] mov dword ptr [ ecx + edx * 0x4 ] , eax mov eax , dword ptr [ ebp - 0x28 ] movsd xmm0 , qword ptr [ eax ] mov eax , dword ptr [ ebp - 0x10 ] mov ecx , dword ptr [ ebp - 0x18 ] lea ecx , [ ecx + ecx * 0x2 ] movsd qword ptr [ eax + ecx * 0x4 + 0x4 ] , xmm0 mov eax , dword ptr [ ebp - 0x18 ] add eax , 0x1 mov dword ptr [ ebp - 0x18 ] , eax jmp 0x1d9 mov eax , dword ptr [ ebp - 0xc ] sub eax , dword ptr [ ebp - 0x1c ] cmp eax , dword ptr [ ebp - 0x30 ] ja 0x1bd mov eax , dword ptr [ ebp - 0x1c ] add eax , dword ptr [ ebp - 0x30 ] mov dword ptr [ ebp - 0x38 ] , eax mov eax , dword ptr [ ebp - 0x38 ] cmp eax , dword ptr [ ebp - 0x1c ] jae 0x19a call 0x4260 mov eax , dword ptr [ ebp - 0x8 ] mov dword ptr [ esp ] , eax lea eax , [ ebp - 0x38 ] mov dword ptr [ esp + 0x4 ] , eax mov dword ptr [ esp + 0x8 ] , 0x1 call 0x3e60 mov dword ptr [ ebp - 0x8 ] , eax mov eax , dword ptr [ ebp - 0x38 ] mov dword ptr [ ebp - 0xc ] , eax mov eax , dword ptr [ ebp - 0x8 ] add eax , dword ptr [ ebp - 0x1c ] mov ecx , dword ptr [ ebp - 0x2c ] mov edx , dword ptr [ ebp - 0x30 ] mov dword ptr [ esp ] , eax mov dword ptr [ esp + 0x4 ] , ecx mov dword ptr [ esp + 0x8 ] , edx call 0xfffe6c90 mov eax , dword ptr [ ebp - 0x30 ] add eax , dword ptr [ ebp - 0x1c ] mov dword ptr [ ebp - 0x1c ] , eax jmp 0x64 call 0xfffe6fe0 mov eax , dword ptr [ eax ] mov dword ptr [ ebp - 0x20 ] , eax cmp dword ptr [ ebp - 0x20 ] , 0x0 je 0x22d mov eax , dword ptr [ ebp - 0x10 ] mov dword ptr [ esp ] , eax call 0xfffe6c80 mov eax , dword ptr [ ebp - 0x8 ] mov dword ptr [ esp ] , eax call 0x520 mov eax , dword ptr [ ebp - 0x20 ] mov dword ptr [ ebp - 0x54 ] , eax call 0xfffe6fe0 mov ecx , dword ptr [ ebp - 0x54 ] mov dword ptr [ eax ] , ecx mov dword ptr [ ebp - 0x4 ] , 0x0 jmp 0x328 cmp dword ptr [ ebp - 0x24 ] , 0x0 je 0x2ef cmp dword ptr [ ebp - 0x18 ] , 0x0 je 0x262 mov eax , dword ptr [ ebp - 0x10 ] mov ecx , dword ptr [ ebp - 0x18 ] mov edx , dword ptr [ ebp - 0x24 ] mov dword ptr [ esp ] , eax mov dword ptr [ esp + 0x4 ] , ecx mov dword ptr [ esp + 0x8 ] , 0xc mov dword ptr [ esp + 0xc ] , edx call 0x570 mov eax , dword ptr [ ebp - 0x1c ] add eax , 0x1 mov dword ptr [ esp ] , eax call 0x3d40 mov dword ptr [ ebp - 0x8 ] , eax mov dword ptr [ ebp - 0x1c ] , 0x0 mov dword ptr [ ebp - 0x3c ] , 0x0 mov eax , dword ptr [ ebp - 0x3c ] cmp eax , dword ptr [ ebp - 0x18 ] jae 0x2df mov eax , dword ptr [ ebp - 0x8 ] add eax , dword ptr [ ebp - 0x1c ] mov dword ptr [ ebp - 0x40 ] , eax mov eax , dword ptr [ ebp - 0x40 ] mov ecx , dword ptr [ ebp - 0x10 ] imul edx , dword ptr [ ebp - 0x3c ] , 0xc add ecx , edx mov ecx , dword ptr [ ecx ] mov edx , esp mov dword ptr [ edx + 0x4 ] , ecx mov dword ptr [ edx ] , eax call 0xfffe6d20 mov ecx , dword ptr [ ebp - 0x40 ] sub eax , ecx add eax , 0x1 add eax , dword ptr [ ebp - 0x1c ] mov dword ptr [ ebp - 0x1c ] , eax mov eax , dword ptr [ ebp - 0x10 ] imul ecx , dword ptr [ ebp - 0x3c ] , 0xc add eax , ecx mov eax , dword ptr [ eax ] mov dword ptr [ esp ] , eax call 0xfffe6c80 mov eax , dword ptr [ ebp - 0x3c ] add eax , 0x1 mov dword ptr [ ebp - 0x3c ] , eax jmp 0x281 mov eax , dword ptr [ ebp - 0x10 ] mov dword ptr [ esp ] , eax call 0x5c0 jmp 0x318 mov eax , dword ptr [ ebp - 0x1c ] cmp eax , dword ptr [ ebp - 0xc ] jne 0x313 mov eax , dword ptr [ ebp - 0x8 ] mov ecx , dword ptr [ ebp - 0x1c ] add ecx , 0x1 mov dword ptr [ esp ] , eax mov dword ptr [ esp + 0x4 ] , ecx call 0x600 mov dword ptr [ ebp - 0x8 ] , eax jmp 0x318 mov eax , dword ptr [ ebp - 0x8 ] mov ecx , dword ptr [ ebp - 0x1c ] mov byte ptr [ eax + ecx ] , 0x0 mov eax , dword ptr [ ebp - 0x8 ] mov dword ptr [ ebp - 0x4 ] , eax mov eax , dword ptr [ ebp - 0x4 ] add esp , 0x68 pop ebp ret
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly codes show fundamental differences in architecture, structure, and functionality. Code1 uses ARM-specific instructions (e.g., `ldr`, `str`, `bl`, ARM registers like `r4-r8/sb/sl/fp`) with a Thumb-like instruction set, while Code2 is x86 assembly (e.g., `mov dword ptr`, `ebp/esp` usage, Intel syntax). Key dissimilarities include:  
- **Register usage**: ARM utilizes banked registers (`sb`, `sl`, `fp`) and conditional execution, whereas x86 relies on `ebp/esp` offsets for stack operations.  
- **Control flow**: Code1 has ARM-specific branching (`beq 0x2a8`, `bne 0xcc`), while Code2 uses x86 jumps (`jne 0x5f`, `je 0x1e2`).  
- **Stack management**: Code1 uses `sub sp, sp, 0x1c` and push/pop multiple registers; Code2 uses `sub esp, 0x68` and `ebp`-based local variables.  
- **Function calls**: Code1 calls via `bl` with absolute offsets (e.g., `bl 0xffff40b0`), while Code2 uses `call` with relative addresses.  
No overlapping logic, data handling, or structural patterns suggest similarity. The architectural divergence and lack of common algorithmic sequences result in no meaningful similarity.
------------------------------------------------------------

------------------------------------------------------------
Code1: lui gp , 0x6c addiu sp , sp , - 0x270 addiu gp , gp , 0x2ee0 sw ra , 0x26c ( sp ) lw v0 , - 0x52f0 ( gp ) lw t9 , - 0x756c ( gp ) sw fp , 0x268 ( sp ) sw v0 , 0x2c ( sp ) sw s6 , 0x260 ( sp ) sw s2 , 0x250 ( sp ) move s2 , a1 sw s0 , 0x248 ( sp ) move s0 , a0 sw gp , 0x18 ( sp ) sw s7 , 0x264 ( sp ) sw s5 , 0x25c ( sp ) sw s4 , 0x258 ( sp ) sw s3 , 0x254 ( sp ) sw s1 , 0x24c ( sp ) lw v0 , ( v0 ) lw s6 , - 0x7fa4 ( gp ) sw v0 , 0x244 ( sp ) jalr t9 nop addiu a1 , zero , 0x1 lw gp , 0x18 ( sp ) addiu a0 , zero , 0xd lw t9 , - 0x5300 ( gp ) jalr t9 move fp , v0 lw v0 , ( s6 ) beqz v0 , 0x388 lw gp , 0x18 ( sp ) lw v0 , - 0x540c ( gp ) move a1 , zero lw t9 , - 0x7b58 ( gp ) jalr t9 lw a0 , ( v0 ) move a1 , zero lw gp , 0x18 ( sp ) move s7 , v0 lw t9 , - 0x7f80 ( gp ) bal - 0x69c4 lw a0 , ( s6 ) beqz v0 , 0x2d4 lw gp , 0x18 ( sp ) addiu s0 , s0 , - 0x1 blez s0 , 0x478 addiu s2 , s2 , 0x4 lui v0 , 0x65 sw zero , 0x38 ( sp ) lui s5 , 0x65 sw zero , 0x24 ( sp ) addiu v0 , v0 , - 0x13b0 move s4 , zero sw v0 , 0x28 ( sp ) lui v0 , 0x65 lui s3 , 0x64 sw v0 , 0x30 ( sp ) lui v0 , 0x65 addiu s5 , s5 , 0x47fc addiu v0 , v0 , - 0x13a0 sw v0 , 0x34 ( sp ) lui v0 , 0x65 b 0x1b8 sw v0 , 0x3c ( sp ) lw t9 , - 0x52c0 ( gp ) move a1 , s5 jalr t9 move a0 , s1 beqz v0 , 0x330 lw gp , 0x18 ( sp ) lw t9 , - 0x52c0 ( gp ) move a0 , s1 jalr t9 lw a1 , 0x28 ( sp ) beqz v0 , 0x340 lw gp , 0x18 ( sp ) lw v0 , 0x30 ( sp ) move a0 , s1 lw t9 , - 0x52c0 ( gp ) jalr t9 addiu a1 , v0 , - 0x13a8 beqz v0 , 0x358 lw gp , 0x18 ( sp ) lw t9 , - 0x52c0 ( gp ) move a0 , s1 jalr t9 lw a1 , 0x34 ( sp ) beqz v0 , 0x370 lw gp , 0x18 ( sp ) lw v0 , 0x3c ( sp ) addiu a2 , zero , 0x2 lw t9 , - 0x5460 ( gp ) move a0 , s1 jalr t9 addiu a1 , v0 , 0x4800 beqz v0 , 0x3f8 lw gp , 0x18 ( sp ) lui a1 , 0x65 lw t9 , - 0x52c0 ( gp ) move a0 , s1 jalr t9 addiu a1 , a1 , 0x4804 beqz v0 , 0x3f8 lw gp , 0x18 ( sp ) sw s1 , 0x38 ( sp ) addiu s0 , s0 , - 0x1 beqz s0 , 0x1e4 addiu s2 , s2 , 0x4 lw s1 , ( s2 ) addiu a1 , s3 , 0x7b78 lw t9 , - 0x52c0 ( gp ) jalr t9 move a0 , s1 bnez v0 , 0x108 lw gp , 0x18 ( sp ) addiu s4 , zero , 0x1 addiu s0 , s0 , - 0x1 bnez s0 , 0x1b8 addiu s2 , s2 , 0x4 lw t9 , - 0x7564 ( gp ) jalr t9 nop lw gp , 0x18 ( sp ) lw t9 , - 0x755c ( gp ) jalr t9 move a0 , fp lw gp , 0x18 ( sp ) beqz v0 , 0x2b4 move s0 , v0 lw a1 , 0x38 ( sp ) beqz a1 , 0x228 lw t9 , - 0x7514 ( gp ) jalr t9 move a0 , s0 beqz v0 , 0x3a8 lw gp , 0x18 ( sp ) lw t9 , - 0x7618 ( gp ) jalr t9 move a0 , s0 lw gp , 0x18 ( sp ) beqz v0 , 0x3c0 move s1 , v0 bnez s4 , 0x4ac lw t9 , - 0x7590 ( gp ) lui s3 , 0x68 lui s2 , 0x68 addiu s3 , s3 , - 0x5a58 b 0x274 addiu s2 , s2 , 0x4dcc lw t9 , - 0x7fa8 ( gp ) move a1 , s2 move a0 , s7 jalr t9 addiu s4 , s4 , 0x1 lw gp , 0x18 ( sp ) lw t9 , - 0x7164 ( gp ) move a1 , s4 jalr t9 move a0 , s1 lw gp , 0x18 ( sp ) beqz v0 , 0x438 move a2 , v0 beqz s4 , 0x260 lw t9 , - 0x7fa8 ( gp ) move a1 , s3 sw v0 , 0x24 ( sp ) jalr t9 move a0 , s7 lw gp , 0x18 ( sp ) b 0x25c lw a2 , 0x24 ( sp ) lw t9 , - 0x7864 ( gp ) jalr t9 nop lw gp , 0x18 ( sp ) lw t9 , - 0x7fa0 ( gp ) jalr t9 lw a0 , ( s6 ) lw gp , 0x18 ( sp ) addiu s0 , zero , 0x1 beqz s7 , 0x2ec lw t9 , - 0x7f70 ( gp ) jalr t9 move a0 , s7 lw gp , 0x18 ( sp ) lw v1 , 0x2c ( sp ) move v0 , s0 lw a0 , 0x244 ( sp ) lw v1 , ( v1 ) bne a0 , v1 , 0x5d8 lw ra , 0x26c ( sp ) lw fp , 0x268 ( sp ) lw s7 , 0x264 ( sp ) lw s6 , 0x260 ( sp ) lw s5 , 0x25c ( sp ) lw s4 , 0x258 ( sp ) lw s3 , 0x254 ( sp ) lw s2 , 0x250 ( sp ) lw s1 , 0x24c ( sp ) lw s0 , 0x248 ( sp ) jr ra addiu sp , sp , 0x270 addiu v0 , zero , 0x1 addiu s4 , zero , 0x1 b 0x1d8 sw v0 , 0x24 ( sp ) lw t9 , - 0x7418 ( gp ) bal 0x18fe0 addiu s0 , s0 , - 0x1 lw gp , 0x18 ( sp ) b 0x1b0 move fp , v0 lw t9 , - 0x7414 ( gp ) jalr t9 addiu s0 , s0 , - 0x1 lw gp , 0x18 ( sp ) b 0x1b0 move fp , v0 lw t9 , - 0x7428 ( gp ) jalr t9 addiu s0 , s0 , - 0x1 lw gp , 0x18 ( sp ) b 0x1b0 move fp , v0 lw v0 , - 0x52e0 ( gp ) move a1 , zero lw t9 , - 0x7b58 ( gp ) jalr t9 lw a0 , ( v0 ) lw gp , 0x18 ( sp ) b 0x84 sw v0 , ( s6 ) lui a1 , 0x65 lw t9 , - 0x7fa8 ( gp ) lw a0 , ( s6 ) jalr t9 addiu a1 , a1 , 0x4808 lw gp , 0x18 ( sp ) lw t9 , - 0x7864 ( gp ) jalr t9 nop lw gp , 0x18 ( sp ) lw t9 , - 0x7fa0 ( gp ) jalr t9 lw a0 , ( s6 ) move a0 , s0 lw gp , 0x18 ( sp ) lw t9 , - 0x752c ( gp ) jalr t9 addiu s0 , zero , 0x1 b 0x2d8 lw gp , 0x18 ( sp ) lui s0 , 0x6b lw a2 , 0x11d0 ( s0 ) beqz a2 , 0x2d4 lui s1 , 0x68 addiu s0 , s0 , 0x11d0 addiu s1 , s1 , 0x4dcc lw t9 , - 0x7fa8 ( gp ) addiu s0 , s0 , 0x4 lw a0 , ( s6 ) jalr t9 move a1 , s1 lw a2 , ( s0 ) bnez a2 , 0x410 lw gp , 0x18 ( sp ) b 0x2d8 addiu s0 , zero , 0x1 lui a1 , 0x65 lw t9 , - 0x7fa8 ( gp ) move a0 , s7 jalr t9 addiu a1 , a1 , - 0x1948 lw gp , 0x18 ( sp ) lw t9 , - 0x752c ( gp ) move a0 , s0 jalr t9 move s0 , zero lw gp , 0x18 ( sp ) lw t9 , - 0x75d0 ( gp ) jalr t9 move a0 , s1 b 0x2d8 lw gp , 0x18 ( sp ) lw t9 , - 0x7564 ( gp ) jalr t9 nop lw gp , 0x18 ( sp ) lw t9 , - 0x755c ( gp ) jalr t9 move a0 , fp lw gp , 0x18 ( sp ) beqz v0 , 0x2b4 move s0 , v0 move s4 , zero b 0x228 sw zero , 0x24 ( sp ) move a0 , v0 lui s4 , 0x65 jalr t9 lui s5 , 0x65 move s2 , zero lw gp , 0x18 ( sp ) move s3 , v0 addiu s4 , s4 , 0x485c addiu s5 , s5 , 0x4840 b 0x508 lui s6 , 0x65 lw t9 , - 0x7160 ( gp ) addiu a2 , zero , 0x200 addiu a1 , sp , 0x44 jalr t9 move a0 , fp move a0 , s7 lw gp , 0x18 ( sp ) move a1 , v0 lw t9 , - 0x7e60 ( gp ) jalr t9 addiu s2 , s2 , 0x1 lw gp , 0x18 ( sp ) lw t9 , - 0x7fb4 ( gp ) jalr t9 move a0 , s3 slt v0 , s2 , v0 beqz v0 , 0x450 lw gp , 0x18 ( sp ) lw t9 , - 0x7fbc ( gp ) move a1 , s2 jalr t9 move a0 , s3 move fp , v0 lw v0 , 0x24 ( sp ) beqz v0 , 0x4d8 lw gp , 0x18 ( sp ) lw t9 , - 0x715c ( gp ) jalr t9 move a0 , fp lui v1 , 0xff00 lui a0 , 0x200 lw gp , 0x18 ( sp ) and v1 , v0 , v1 ext t1 , v0 , 0x10 , 0x8 ext t0 , v0 , 0x8 , 0x8 beq v1 , a0 , 0x5b4 andi a3 , v0 , 0xff lui a0 , 0x300 beq v1 , a0 , 0x59c lw t9 , - 0x7fa8 ( gp ) srl a2 , v0 , 0x18 sw a3 , 0x14 ( sp ) sw t0 , 0x10 ( sp ) move a3 , t1 move a1 , s4 jalr t9 move a0 , s7 b 0x4d8 lw gp , 0x18 ( sp ) move a2 , t0 move a1 , s5 jalr t9 move a0 , s7 b 0x4d8 lw gp , 0x18 ( sp ) lw t9 , - 0x7fa8 ( gp ) addiu a1 , s6 , 0x4820 sw a3 , 0x10 ( sp ) move a2 , t1 move a3 , t0 jalr t9 move a0 , s7 b 0x4d8 lw gp , 0x18 ( sp ) lw t9 , - 0x5328 ( gp ) jalr t9 nop
Code2: push r15 push r14 push r13 push r12 mov r13d , edi push rbp push rbx mov rbx , rsi sub rsp , 0x228 mov rax , qword ptr fs : [ 0x28 ] mov qword ptr [ rsp + 0x218 ] , rax xor eax , eax call 0x30a10 mov esi , 0x1 mov edi , 0xd mov qword ptr [ rsp ] , rax call 0xfffffffffffc5550 cmp qword ptr [ rip + 0x458a56 ] , 0x0 je 0x2f8 mov rdi , qword ptr [ rip + 0x458a09 ] xor esi , esi call 0xb1b00 mov rdi , qword ptr [ rip + 0x458a3b ] xor esi , esi mov rbp , rax call 0xffffffffffffafa0 test eax , eax je 0x270 cmp r13d , 0x1 lea r12 , [ rbx + 0x8 ] jle 0x3ba lea eax , [ r13 - 0x2 ] mov qword ptr [ rsp + 0x8 ] , 0x0 xor r13d , r13d xor r15d , r15d lea r14 , [ rip + 0x1a23d5 ] lea rbx , [ rbx + rax * 0x8 + 0x10 ] mov rax , qword ptr [ rsp ] jmp 0x178 nop dword ptr [ rax ] lea rdi , [ rip + 0x1aef88 ] mov ecx , 0x3 mov rsi , r8 repe cmpsb byte ptr [ rsi ] , byte ptr [ rdi ] seta dl sbb dl , 0x0 test dl , dl je 0x2b0 lea rdi , [ rip + 0x1aa867 ] mov ecx , 0x6 mov rsi , r8 repe cmpsb byte ptr [ rsi ] , byte ptr [ rdi ] seta dl sbb dl , 0x0 test dl , dl je 0x2c8 lea rdi , [ rip + 0x1aa84e ] mov ecx , 0x6 mov rsi , r8 repe cmpsb byte ptr [ rsi ] , byte ptr [ rdi ] seta dl sbb dl , 0x0 test dl , dl je 0x2d8 lea rdi , [ rip + 0x1aa835 ] mov ecx , 0x6 mov rsi , r8 repe cmpsb byte ptr [ rsi ] , byte ptr [ rdi ] seta dl sbb dl , 0x0 test dl , dl je 0x2e8 lea rdi , [ rip + 0x1aef0f ] mov ecx , 0x2 mov rsi , r8 repe cmpsb byte ptr [ rsi ] , byte ptr [ rdi ] seta dl sbb dl , 0x0 test dl , dl je 0x348 lea rdi , [ rip + 0x1aeef3 ] mov ecx , 0x3 mov rsi , r8 repe cmpsb byte ptr [ rsi ] , byte ptr [ rdi ] seta dl sbb dl , 0x0 test dl , dl je 0x348 mov qword ptr [ rsp + 0x8 ] , r8 add r12 , 0x8 cmp rbx , r12 je 0x1a6 mov r8 , qword ptr [ r12 ] mov ecx , 0x3 mov rdi , r14 mov rsi , r8 repe cmpsb byte ptr [ rsi ] , byte ptr [ rdi ] seta dl sbb dl , 0x0 test dl , dl jne 0xb0 mov r15d , 0x1 add r12 , 0x8 cmp rbx , r12 jne 0x178 mov qword ptr [ rsp ] , rax call 0x56e30 mov rdi , qword ptr [ rsp ] call 0x477c0 test rax , rax mov rbx , rax je 0x258 mov rax , qword ptr [ rsp + 0x8 ] test rax , rax je 0x1e1 mov rsi , rax mov rdi , rbx call 0x46fa0 test eax , eax je 0x312 mov rdi , rbx call 0x450d0 test rax , rax mov r12 , rax je 0x325 test r15d , r15d jne 0x3df lea r13 , [ rip + 0x1cdefd ] jmp 0x225 nop word ptr [ rax + rax ] lea rsi , [ rip + 0x1d7d1e ] mov rdi , rbp xor eax , eax add r15d , 0x1 call 0xb6be0 mov esi , r15d mov rdi , r12 call 0x46f30 test rax , rax mov rdx , rax je 0x392 test r15d , r15d je 0x210 mov qword ptr [ rsp ] , rax mov rsi , r13 mov rdi , rbp xor eax , eax call 0xb6be0 mov rdx , qword ptr [ rsp ] jmp 0x210 call 0x4aa50 mov rdi , qword ptr [ rip + 0x45883c ] call 0xc28f0 nop dword ptr [ rax ] mov ebx , 0x1 test rbp , rbp je 0x282 mov rdi , rbp call 0xaff10 mov eax , ebx mov rbx , qword ptr [ rsp + 0x218 ] xor rbx , qword ptr fs : [ 0x28 ] jne 0x4d8 add rsp , 0x228 pop rbx pop rbp pop r12 pop r13 pop r14 pop r15 ret nop dword ptr [ rax ] mov r13d , 0x1 mov r15d , 0x1 jmp 0x19d nop dword ptr [ rax ] call 0x18e00 jmp 0x16f nop word ptr [ rax + rax ] call 0x21ba0 jmp 0x16f nop word ptr [ rax + rax ] call 0x32a00 jmp 0x16f nop word ptr [ rax + rax ] mov rdi , qword ptr [ rip + 0x458781 ] xor esi , esi call 0xb1b00 mov qword ptr [ rip + 0x458793 ] , rax jmp 0x50 mov rdi , qword ptr [ rip + 0x458787 ] lea rsi , [ rip + 0x1aed28 ] call 0xb6be0 call 0x4aa50 mov rdi , qword ptr [ rip + 0x45876f ] call 0xc28f0 mov rdi , rbx mov ebx , 0x1 call 0x47db0 jmp 0x275 mov rdx , qword ptr [ rip + 0x4465b1 ] lea rbx , [ rip + 0x4465aa ] lea r12 , [ rip + 0x1d7bd8 ] test rdx , rdx je 0x270 nop word ptr cs : [ rax + rax ] mov rdi , qword ptr [ rip + 0x458729 ] xor eax , eax add rbx , 0x8 mov rsi , r12 call 0xb6be0 mov rdx , qword ptr [ rbx ] test rdx , rdx jne 0x370 jmp 0x270 lea rsi , [ rip + 0x1a6a5e ] mov rdi , rbp xor eax , eax call 0xb6be0 mov rdi , rbx xor ebx , ebx call 0x47db0 mov rdi , r12 call 0x458e0 jmp 0x275 call 0x56e30 mov rdi , qword ptr [ rsp ] call 0x477c0 test rax , rax mov rbx , rax je 0x258 xor r15d , r15d xor r13d , r13d jmp 0x1e1 mov rdi , rax xor r14d , r14d call 0x46eb0 mov r15 , rax lea rax , [ rsp + 0x10 ] mov qword ptr [ rsp ] , rbx mov qword ptr [ rsp + 0x8 ] , r12 mov rbx , rax jmp 0x41f mov edx , 0x200 mov rsi , rbx mov rdi , r12 call 0x4fd50 add r14d , 0x1 mov rsi , rax mov rdi , rbp call 0xaf3f0 mov rdi , r15 call 0xbd310 cmp eax , r14d jle 0x494 mov esi , r14d mov rdi , r15 call 0xbd320 test r13d , r13d mov r12 , rax je 0x400 mov rdi , rax call 0x50350 mov rsi , rax mov rdx , rax movzx edi , ah and esi , 0xff000000 shr rdx , 0x10 movzx r9d , al cmp rsi , 0x2000000 movzx edx , dl je 0x4bd cmp rsi , 0x3000000 je 0x4a2 shr rax , 0x18 lea rsi , [ rip + 0x1aec82 ] mov r8d , edi mov ecx , edx mov rdi , rbp mov edx , eax xor eax , eax call 0xb6be0 jmp 0x400 mov rbx , qword ptr [ rsp ] mov r12 , qword ptr [ rsp + 0x8 ] jmp 0x3a3 lea rsi , [ rip + 0x1aebd2 ] mov edx , edi mov ecx , r9d mov rdi , rbp xor eax , eax call 0xb6be0 jmp 0x400 lea rsi , [ rip + 0x1aeb9a ] mov ecx , edi mov r8d , r9d mov rdi , rbp xor eax , eax call 0xb6be0 jmp 0x400 call 0xfffffffffffc5380 nop dword ptr [ rax ]
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly codes are fundamentally dissimilar due to architectural differences and functional purposes. The first code is MIPS assembly with instructions like `lui`, `addiu`, `sw`, and register names like `gp`, `sp`, `t9`, showing stack manipulation and function calls via `jalr`. The second code is x86_64 assembly using registers like `rdi`, `rsi`, `rbp`, and instructions like `push`, `mov`, `call`, with a focus on string comparisons (`repe cmpsb`) and Linux ABI conventions. There is no overlapping logic, register usage, or structural similarity. The MIPS code appears to handle low-level system tasks, while the x86_64 code involves higher-level string/argument processing. The complete architectural mismatch and absence of equivalent code patterns result in maximal dissimilarity.
------------------------------------------------------------

------------------------------------------------------------
Code1: mov r8d , ecx test ecx , ecx mov eax , 0x54e2c8f7 mov r9d , 0xa22a3936 cmovle r9d , eax mov ecx , 0xd00e9423 jmp 0x20 mov ecx , r9d nop cmp ecx , 0x504afe51 jg 0x40 cmp ecx , 0xa22a3936 je 0x59 cmp ecx , 0xd00e9423 jne 0x20 jmp 0x1b nop word ptr [ rax + rax ] cmp ecx , 0x504afe52 je 0x7f cmp ecx , 0x54e2c8f7 jne 0x20 mov ecx , 0x504afe52 xor eax , eax jmp 0x20 mov ecx , r8d sub r10 , r10 nop mov rax , qword ptr [ rsi + r10 * 0x8 ] sbb rax , qword ptr [ rdx + r10 * 0x8 ] mov qword ptr [ rdi + r10 * 0x8 ] , rax lea r10 , [ r10 + 0x1 ] loop 0x60 sbb rax , rax and eax , 0x1 mov ecx , 0x504afe52 jmp 0x20 ret
Code2: addiu sp , sp , - 0x10 sw a0 , 0x10 ( sp ) sw a1 , 0x14 ( sp ) sw a2 , 0x18 ( sp ) sw a3 , 0x1c ( sp ) sw zero , 0x4 ( sp ) lw v0 , 0x1c ( sp ) bgtz v0 , 0x1cc nop move v0 , zero b 0x280 nop lw v0 , 0x14 ( sp ) lw v0 , ( v0 ) sw v0 , 0x8 ( sp ) lw v0 , 0x18 ( sp ) lw v0 , ( v0 ) sw v0 , 0xc ( sp ) lw v1 , 0x8 ( sp ) lw v0 , 0xc ( sp ) subu v1 , v1 , v0 lw v0 , 0x4 ( sp ) subu v1 , v1 , v0 lw v0 , 0x10 ( sp ) sw v1 , ( v0 ) lw v1 , 0x8 ( sp ) lw v0 , 0xc ( sp ) beq v1 , v0 , 0x88 nop lw v1 , 0x8 ( sp ) lw v0 , 0xc ( sp ) sltu v0 , v1 , v0 andi v0 , v0 , 0xff sw v0 , 0x4 ( sp ) lw v0 , 0x14 ( sp ) lw v0 , 0x4 ( v0 ) sw v0 , 0x8 ( sp ) lw v0 , 0x18 ( sp ) lw v0 , 0x4 ( v0 ) sw v0 , 0xc ( sp ) lw v1 , 0x8 ( sp ) lw v0 , 0xc ( sp ) subu a0 , v1 , v0 lw v1 , 0x4 ( sp ) lw v0 , 0x10 ( sp ) addiu v0 , v0 , 0x4 subu v1 , a0 , v1 sw v1 , ( v0 ) lw v1 , 0x8 ( sp ) lw v0 , 0xc ( sp ) beq v1 , v0 , 0xe4 nop lw v1 , 0x8 ( sp ) lw v0 , 0xc ( sp ) sltu v0 , v1 , v0 andi v0 , v0 , 0xff sw v0 , 0x4 ( sp ) lw v0 , 0x14 ( sp ) lw v0 , 0x8 ( v0 ) sw v0 , 0x8 ( sp ) lw v0 , 0x18 ( sp ) lw v0 , 0x8 ( v0 ) sw v0 , 0xc ( sp ) lw v1 , 0x8 ( sp ) lw v0 , 0xc ( sp ) subu a0 , v1 , v0 lw v1 , 0x4 ( sp ) lw v0 , 0x10 ( sp ) addiu v0 , v0 , 0x8 subu v1 , a0 , v1 sw v1 , ( v0 ) lw v1 , 0x8 ( sp ) lw v0 , 0xc ( sp ) beq v1 , v0 , 0x140 nop lw v1 , 0x8 ( sp ) lw v0 , 0xc ( sp ) sltu v0 , v1 , v0 andi v0 , v0 , 0xff sw v0 , 0x4 ( sp ) lw v0 , 0x14 ( sp ) lw v0 , 0xc ( v0 ) sw v0 , 0x8 ( sp ) lw v0 , 0x18 ( sp ) lw v0 , 0xc ( v0 ) sw v0 , 0xc ( sp ) lw v1 , 0x8 ( sp ) lw v0 , 0xc ( sp ) subu a0 , v1 , v0 lw v1 , 0x4 ( sp ) lw v0 , 0x10 ( sp ) addiu v0 , v0 , 0xc subu v1 , a0 , v1 sw v1 , ( v0 ) lw v1 , 0x8 ( sp ) lw v0 , 0xc ( sp ) beq v1 , v0 , 0x19c nop lw v1 , 0x8 ( sp ) lw v0 , 0xc ( sp ) sltu v0 , v1 , v0 andi v0 , v0 , 0xff sw v0 , 0x4 ( sp ) lw v0 , 0x14 ( sp ) addiu v0 , v0 , 0x10 sw v0 , 0x14 ( sp ) lw v0 , 0x18 ( sp ) addiu v0 , v0 , 0x10 sw v0 , 0x18 ( sp ) lw v0 , 0x10 ( sp ) addiu v0 , v0 , 0x10 sw v0 , 0x10 ( sp ) lw v0 , 0x1c ( sp ) addiu v0 , v0 , - 0x4 sw v0 , 0x1c ( sp ) lw v1 , 0x1c ( sp ) addiu v0 , zero , - 0x4 and v0 , v1 , v0 bnez v0 , 0x30 nop b 0x270 nop lw v0 , 0x14 ( sp ) lw v0 , ( v0 ) sw v0 , 0x8 ( sp ) lw v0 , 0x18 ( sp ) lw v0 , ( v0 ) sw v0 , 0xc ( sp ) lw v1 , 0x8 ( sp ) lw v0 , 0xc ( sp ) subu v1 , v1 , v0 lw v0 , 0x4 ( sp ) subu v1 , v1 , v0 lw v0 , 0x10 ( sp ) sw v1 , ( v0 ) lw v1 , 0x8 ( sp ) lw v0 , 0xc ( sp ) beq v1 , v0 , 0x240 nop lw v1 , 0x8 ( sp ) lw v0 , 0xc ( sp ) sltu v0 , v1 , v0 andi v0 , v0 , 0xff sw v0 , 0x4 ( sp ) lw v0 , 0x14 ( sp ) addiu v0 , v0 , 0x4 sw v0 , 0x14 ( sp ) lw v0 , 0x18 ( sp ) addiu v0 , v0 , 0x4 sw v0 , 0x18 ( sp ) lw v0 , 0x10 ( sp ) addiu v0 , v0 , 0x4 sw v0 , 0x10 ( sp ) lw v0 , 0x1c ( sp ) addiu v0 , v0 , - 0x1 sw v0 , 0x1c ( sp ) lw v0 , 0x1c ( sp ) bnez v0 , 0x1e8 nop lw v0 , 0x4 ( sp ) addiu sp , sp , 0x10 jr ra nop
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly codes show no meaningful similarity due to fundamental differences:  
1. Architecture - Code1 uses x86_64 instructions (e.g., `mov`, `cmovle`, `jmp`, `sbb`) and registers (rax, rdi, r10), while Code2 uses MIPS instructions (e.g., `addiu`, `lw`, `sw`, `beq`) and registers (sp, v0, a0).  
2. Purpose - Code1 appears to perform arithmetic operations with conditional jumps and carry handling (sbb), while Code2 manages stack operations and memory accesses with multi-step conditional branching.  
3. Structure - Code1 has a compact loop with pointer arithmetic (`r10 * 0x8`), whereas Code2 uses sequential memory blocks and explicit stack management.  
No overlapping logic, registers, or operations suggest similarity.
------------------------------------------------------------

------------------------------------------------------------
Code1: push ebp mov ebp , esp push ebx push esi sub esp , 0x30 mov eax , dword ptr [ ebp + 0x10 ] mov ecx , dword ptr [ ebp + 0xc ] mov edx , dword ptr [ ebp + 0x8 ] mov esi , dword ptr [ ebp + 0x8 ] mov dword ptr [ ebp - 0x10 ] , esi mov esi , dword ptr [ 0x8075048 ] mov dword ptr [ ebp - 0x1c ] , eax mov dword ptr [ ebp - 0x20 ] , ecx mov dword ptr [ ebp - 0x24 ] , edx jmp esi mov eax , dword ptr [ 0x807504c ] jmp eax mov eax , dword ptr [ ebp - 0x10 ] mov eax , dword ptr [ eax + 0x4 ] test eax , eax setne cl movzx eax , cl mov eax , dword ptr [ eax * 0x4 + 0x8078b84 ] mov cl , 0x1 mov byte ptr [ ebp - 0x25 ] , cl jmp eax mov eax , dword ptr [ ebp - 0x10 ] mov eax , dword ptr [ eax + 0x8 ] test eax , eax setne cl mov eax , dword ptr [ 0x8075054 ] mov byte ptr [ ebp - 0x25 ] , cl jmp eax mov al , byte ptr [ ebp - 0x25 ] movzx ecx , al and ecx , 0x1 mov ecx , dword ptr [ ecx * 0x4 + 0x8078b8c ] jmp ecx mov eax , dword ptr [ ebp - 0x10 ] mov eax , dword ptr [ eax + 0x4 ] test eax , eax setne cl movzx eax , cl mov eax , dword ptr [ eax * 0x4 + 0x8078b94 ] jmp eax mov eax , dword ptr [ ebp - 0x10 ] mov eax , dword ptr [ eax + 0x4 ] mov dword ptr [ ebp - 0x10 ] , eax mov eax , dword ptr [ 0x8075064 ] jmp eax mov eax , dword ptr [ ebp - 0x10 ] mov eax , dword ptr [ eax + 0x8 ] mov dword ptr [ ebp - 0x10 ] , eax mov eax , dword ptr [ 0x8075064 ] jmp eax mov eax , dword ptr [ 0x807504c ] jmp eax mov eax , dword ptr [ 0x807506c ] jmp eax mov eax , dword ptr [ ebp + 0xc ] mov ecx , dword ptr [ ebp + 0x10 ] mov edx , dword ptr [ ebp - 0x10 ] mov esi , esp mov dword ptr [ esi + 0x4 ] , edx mov dword ptr [ esi ] , ecx call eax mov dword ptr [ ebp - 0x18 ] , eax mov eax , dword ptr [ ebp - 0x18 ] test eax , eax setne bl movzx eax , bl mov eax , dword ptr [ eax * 0x4 + 0x8078b9c ] jmp eax mov eax , dword ptr [ ebp - 0x18 ] mov dword ptr [ ebp - 0xc ] , eax mov eax , dword ptr [ 0x8075090 ] jmp eax mov eax , dword ptr [ ebp - 0x10 ] mov eax , dword ptr [ eax ] test eax , eax sete cl movzx eax , cl mov eax , dword ptr [ eax * 0x4 + 0x8078ba4 ] jmp eax mov dword ptr [ ebp - 0xc ] , 0x0 mov eax , dword ptr [ 0x8075090 ] jmp eax mov eax , dword ptr [ ebp - 0x10 ] mov dword ptr [ ebp - 0x14 ] , eax mov eax , dword ptr [ ebp - 0x10 ] mov eax , dword ptr [ eax ] mov dword ptr [ ebp - 0x10 ] , eax mov eax , dword ptr [ 0x8075080 ] jmp eax mov eax , dword ptr [ ebp - 0x10 ] mov eax , dword ptr [ eax + 0x8 ] mov ecx , dword ptr [ ebp - 0x14 ] sub eax , ecx sete dl movzx ecx , dl mov ecx , dword ptr [ ecx * 0x4 + 0x8078bac ] mov dl , 0x1 mov dword ptr [ ebp - 0x2c ] , eax mov byte ptr [ ebp - 0x2d ] , dl jmp ecx mov eax , dword ptr [ ebp - 0x10 ] mov eax , dword ptr [ eax + 0x8 ] test eax , eax sete cl mov eax , dword ptr [ 0x8075088 ] mov byte ptr [ ebp - 0x2d ] , cl jmp eax mov al , byte ptr [ ebp - 0x2d ] movzx ecx , al and ecx , 0x1 mov ecx , dword ptr [ ecx * 0x4 + 0x8078bb4 ] jmp ecx mov eax , dword ptr [ ebp - 0x10 ] mov eax , dword ptr [ eax + 0x8 ] mov dword ptr [ ebp - 0x10 ] , eax mov eax , dword ptr [ 0x8075048 ] jmp eax mov eax , dword ptr [ ebp - 0xc ] add esp , 0x30 pop esi pop ebx pop ebp ret nop dword ptr [ eax ]
Code2: push rbp mov rbp , rsp sub rsp , 0x10 mov qword ptr [ rbp - 0x8 ] , rdi mov rdi , qword ptr [ rbp - 0x8 ] movzx eax , word ptr [ rdi ] mov edi , eax mov eax , edi and eax , 0x1 mov edi , eax mov rdi , qword ptr [ rdi * 0x8 + 0x8b5c08 ] jmp rdi mov rax , qword ptr [ rbp - 0x8 ] mov rax , qword ptr [ rax + 0x8 ] mov rcx , qword ptr [ rip + 0x530acb ] sub rax , rcx sete dl movzx esi , dl mov ecx , esi mov rcx , qword ptr [ rcx * 0x8 + 0x8b5c18 ] mov qword ptr [ rbp - 0x10 ] , rax jmp rcx mov rax , qword ptr [ rbp - 0x8 ] mov rax , qword ptr [ rax + 0x18 ] mov qword ptr [ rbp - 0x8 ] , rax mov rax , qword ptr [ rip + 0x46f017 ] jmp rax mov rax , qword ptr [ rip + 0x46f026 ] jmp rax mov rax , qword ptr [ rip + 0x46f025 ] jmp rax movabs rdi , 0x5f85f0 mov esi , 0xa1e movabs rdx , 0x5f89eb call 0xfffffffffffe6b20 mov rax , qword ptr [ rbp - 0x8 ] mov rax , qword ptr [ rax + 0x38 ] add rsp , 0x10 pop rbp ret nop word ptr cs : [ rax + rax ] nop dword ptr [ rax + rax ]
Similarity: 1
Label: -1
Similarity Score: 0.35
Explanation: Both codes share structural similarities including stack frame setup (push ebp/rbp), stack allocation (sub esp/rsp), and indirect control flow via jump tables (jmp esi/jmp rdi). They also feature conditional tests (test/setne) and similar cleanup sequences (add esp/rsp, pop, ret). However, significant differences exist: code1 uses 32-bit registers/offsets and complex linked list traversal, while code2 uses 64-bit architecture with different memory offsets and constants. The shared control flow patterns and stack management indicate moderate algorithmic similarity despite architectural differences.
------------------------------------------------------------

------------------------------------------------------------
Code1: lui gp , 0x65 addiu sp , sp , - 0x38 addiu gp , gp , 0x3ee0 sw s0 , 0x2c ( sp ) move s0 , a0 sw s1 , 0x30 ( sp ) move s1 , a1 sw gp , 0x18 ( sp ) sw ra , 0x34 ( sp ) lw t9 , - 0x7cb4 ( gp ) jalr t9 lw a0 , 0x10 ( a0 ) addiu v1 , zero , 0x16 beq v0 , v1 , 0x48 lw gp , 0x18 ( sp ) addiu v1 , zero , 0x18 bne v0 , v1 , 0xbc lui a3 , 0x61 lw v0 , 0x14 ( s0 ) addiu s0 , v0 , 0xc lw v0 , 0xc ( v0 ) beqz v0 , 0x134 lw t9 , - 0x7e5c ( gp ) lw v0 , ( s0 ) beqz v0 , 0xf4 addiu a1 , zero , 0x1 lui a3 , 0x61 lw t9 , - 0x6e60 ( gp ) addiu v0 , zero , 0x165 addiu a3 , a3 , 0x3b34 addiu a2 , zero , 0x6 sw v0 , 0x10 ( sp ) jalr t9 addiu a0 , s1 , 0xc move a1 , s1 lw gp , 0x18 ( sp ) lw t9 , - 0x7e58 ( gp ) jalr t9 lw a0 , ( s0 ) beqz v0 , 0x10c lw gp , 0x18 ( sp ) lw ra , 0x34 ( sp ) addiu v0 , zero , 0x1 lw s1 , 0x30 ( sp ) lw s0 , 0x2c ( sp ) jr ra addiu sp , sp , 0x38 lw t9 , - 0x6ebc ( gp ) addiu a2 , zero , 0x71 addiu a3 , a3 , 0x3b34 addiu v0 , zero , 0x159 addiu a1 , zero , 0x65 sw v0 , 0x10 ( sp ) jalr t9 addiu a0 , zero , 0x21 move v0 , zero lw ra , 0x34 ( sp ) lw s1 , 0x30 ( sp ) lw s0 , 0x2c ( sp ) jr ra addiu sp , sp , 0x38 lui a3 , 0x61 lw t9 , - 0x6ebc ( gp ) addiu a2 , zero , 0x41 addiu a3 , a3 , 0x3b34 b 0xcc addiu v0 , zero , 0x161 lw t9 , - 0x7d80 ( gp ) move a0 , s1 jalr t9 sw v0 , 0x24 ( sp ) lw ra , 0x34 ( sp ) lw v0 , 0x24 ( sp ) lw s1 , 0x30 ( sp ) lw s0 , 0x2c ( sp ) jr ra addiu sp , sp , 0x38 jalr t9 nop lw gp , 0x18 ( sp ) b 0x5c sw v0 , ( s0 )
Code2: push rbp push r15 push r14 push r12 push rbx sub rsp , 0x10 mov r14 , rsi mov r12 , rdi mov rdi , qword ptr [ rdi + 0x18 ] call 0xffffffffffea1b20 mov dword ptr [ rsp + 0x4 ] , eax lea r15 , [ r14 + 0x18 ] mov ecx , 0x3c1c33aa jmp 0x40 mov ecx , 0x47f20ab7 xor ebp , ebp nop word ptr cs : [ rax + rax ] nop dword ptr [ rax + rax ] cmp ecx , 0x1068a2b8 jle 0xa0 cmp ecx , 0x3ee48e8c jg 0x100 cmp ecx , 0x2ce9589a jg 0x17b cmp ecx , 0x1068a2b9 je 0x1fd cmp ecx , 0x2ab98ae6 jne 0x40 mov ecx , 0x80acd8 mov edi , 0x21 mov esi , 0x65 mov edx , 0x71 mov r8d , 0x159 jmp 0x2a4 nop word ptr cs : [ rax + rax ] nop dword ptr [ rax ] cmp ecx , 0xd19f137d jle 0x140 cmp ecx , 0xf658dcd2 jg 0x1ab cmp ecx , 0xd19f137e je 0x241 cmp ecx , 0xd9837a1c jne 0x40 mov qword ptr [ rsp + 0x8 ] , rbx mov rax , qword ptr [ rsp + 0x8 ] cmp qword ptr [ rax ] , 0x0 mov ecx , 0xac070548 je 0x40 mov ecx , 0x953b9e97 jmp 0x40 nop word ptr cs : [ rax + rax ] nop dword ptr [ rax ] cmp ecx , 0x5d9620d2 jle 0x1cd cmp ecx , 0x5d9620d3 je 0x25d cmp ecx , 0x790ac2b7 jne 0x40 mov eax , dword ptr [ rsp + 0x4 ] mov ecx , 0x2ce9589b cmp eax , 0x16 je 0x40 mov ecx , 0x695bfab jmp 0x40 cmp ecx , 0x80678b63 je 0x1ea cmp ecx , 0x953b9e97 je 0x26c cmp ecx , 0xac070548 jne 0x40 call 0xfffffffffff43790 mov rcx , qword ptr [ rsp + 0x8 ] mov qword ptr [ rcx ] , rax mov ecx , 0x953b9e97 jmp 0x40 cmp ecx , 0x2ce9589b je 0x1ea cmp ecx , 0x3c1c33aa jne 0x40 mov eax , dword ptr [ rsp + 0x4 ] mov ecx , 0x790ac2b7 cmp eax , 0x18 jl 0x40 mov ecx , 0xd19f137e jmp 0x40 cmp ecx , 0xf658dcd3 je 0x28a cmp ecx , 0x695bfab jne 0x40 mov ecx , 0x2ab98ae6 jmp 0x40 cmp ecx , 0x3ee48e8d je 0x2ae cmp ecx , 0x47f20ab7 jne 0x40 jmp 0x2bb mov rbx , qword ptr [ r12 + 0x20 ] add rbx , 0x18 mov ecx , 0xd9837a1c jmp 0x40 mov ecx , 0x80acd8 mov rdi , r15 mov esi , 0x1 mov edx , 0x6 mov r8d , 0x165 call 0xffffffffffe991f0 mov rax , qword ptr [ rsp + 0x8 ] mov rdi , qword ptr [ rax ] mov rsi , r14 call 0xfffffffffff44330 mov ecx , 0x3ee48e8d test eax , eax je 0x40 mov ecx , 0x5d9620d3 jmp 0x40 mov eax , dword ptr [ rsp + 0x4 ] mov ecx , 0x80678b63 cmp eax , 0x18 je 0x40 mov ecx , 0x695bfab jmp 0x40 mov ecx , 0x47f20ab7 mov ebp , 0x1 jmp 0x40 mov rax , qword ptr [ rsp + 0x8 ] cmp qword ptr [ rax ] , 0x0 mov ecx , 0xf658dcd3 je 0x40 mov ecx , 0x1068a2b9 jmp 0x40 mov ecx , 0x80acd8 mov edi , 0x21 mov esi , 0x65 mov edx , 0x41 mov r8d , 0x161 call 0xfffffffffff49270 jmp 0x2a mov rdi , r14 call 0xfffffffffff850f0 jmp 0x2a mov eax , ebp add rsp , 0x10 pop rbx pop r12 pop r14 pop r15 pop rbp ret nop word ptr [ rax + rax ]
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly codes are fundamentally dissimilar due to multiple factors:
1. Architecture difference: Code1 uses MIPS instructions (e.g., lui, addiu, sw) while Code2 uses x86-64 instructions (e.g., push, mov, call).
2. Register sets: Code1 employs MIPS registers (gp, sp, s0, s1) whereas Code2 uses x86-64 registers (rbp, r15, r14, r12, rbx).
3. Control flow patterns: Code1 uses fixed branch offsets (e.g., 0x48, 0xbc) and direct function calls (jalr), while Code2 relies on constant-based state jumps (ecx comparisons) and indirect calls.
4. Stack management: Code1 adjusts the stack with fixed offsets (addiu sp, sp, -0x38) while Code2 uses multi-register pushes and a smaller stack adjustment (sub rsp, 0x10).
5. Constant usage: Code1 uses small immediates (0x16, 0x18) while Code2 employs large magic numbers (0x3c1c33aa, 0x47f20ab7) for state transitions.
------------------------------------------------------------

------------------------------------------------------------
Code1: addiu sp , sp , - 0x48 sw ra , 0x44 ( sp ) sw fp , 0x40 ( sp ) sw s0 , 0x3c ( sp ) move fp , sp lui gp , 0x42 addiu gp , gp , 0x2060 sw gp , 0x18 ( sp ) sw a0 , 0x24 ( fp ) sw a1 , 0x4c ( fp ) sw a2 , 0x50 ( fp ) sw a3 , 0x54 ( fp ) lw v0 , - 0x7e9c ( gp ) lw v0 , ( v0 ) sw v0 , 0x34 ( fp ) addiu v0 , fp , 0x2c addiu a2 , zero , 0xa move a1 , v0 lw a0 , 0x24 ( fp ) lw v0 , - 0x7f54 ( gp ) move t9 , v0 jalr t9 nop lw gp , 0x18 ( fp ) sw v0 , 0x30 ( fp ) lw v0 , 0x2c ( fp ) lw v1 , 0x24 ( fp ) beq v1 , v0 , 0x84 nop lw v0 , 0x2c ( fp ) lb v0 , ( v0 ) beqz v0 , 0x104 nop lw v0 , - 0x7e8c ( gp ) lw s0 , ( v0 ) lui v0 , 0x41 addiu a0 , v0 , - 0x7334 lw v0 , - 0x7ef8 ( gp ) move t9 , v0 jalr t9 nop lw gp , 0x18 ( fp ) move v1 , v0 lw v0 , - 0x7fd4 ( gp ) lw v0 , ( v0 ) lw a3 , 0x4c ( fp ) move a2 , v0 move a1 , v1 move a0 , s0 lw v0 , - 0x7f0c ( gp ) move t9 , v0 jalr t9 nop lw gp , 0x18 ( fp ) lw v0 , - 0x7e8c ( gp ) lw v0 , ( v0 ) move a0 , v0 jal 0x4042f4 nop lw gp , 0x18 ( fp ) addiu a0 , zero , 0x1 lw v0 , - 0x7ef4 ( gp ) move t9 , v0 jalr t9 nop lw v1 , 0x30 ( fp ) lw v0 , 0x50 ( fp ) slt v0 , v1 , v0 beqz v0 , 0x1bc nop lw v0 , - 0x7e8c ( gp ) lw s0 , ( v0 ) lui v0 , 0x41 addiu a0 , v0 , - 0x7310 lw v0 , - 0x7ef8 ( gp ) move t9 , v0 jalr t9 nop lw gp , 0x18 ( fp ) move a0 , v0 lw v0 , - 0x7fd4 ( gp ) lw v1 , ( v0 ) lw v0 , 0x50 ( fp ) sw v0 , 0x10 ( sp ) lw a3 , 0x4c ( fp ) move a2 , v1 move a1 , a0 move a0 , s0 lw v0 , - 0x7f0c ( gp ) move t9 , v0 jalr t9 nop lw gp , 0x18 ( fp ) lw v0 , 0x58 ( fp ) beqz v0 , 0x1ac nop lw v0 , - 0x7e8c ( gp ) lw v0 , ( v0 ) move a0 , v0 jal 0x4042f4 nop lw gp , 0x18 ( fp ) addiu a0 , zero , 0x1 lw v0 , - 0x7ef4 ( gp ) move t9 , v0 jalr t9 nop lw v0 , 0x50 ( fp ) sw v0 , 0x30 ( fp ) b 0x278 nop lw v0 , 0x54 ( fp ) bltz v0 , 0x278 nop lw v1 , 0x30 ( fp ) lw v0 , 0x54 ( fp ) slt v0 , v0 , v1 beqz v0 , 0x278 nop lw v0 , - 0x7e8c ( gp ) lw s0 , ( v0 ) lui v0 , 0x41 addiu a0 , v0 , - 0x72e4 lw v0 , - 0x7ef8 ( gp ) move t9 , v0 jalr t9 nop lw gp , 0x18 ( fp ) move a0 , v0 lw v0 , - 0x7fd4 ( gp ) lw v1 , ( v0 ) lw v0 , 0x54 ( fp ) sw v0 , 0x10 ( sp ) lw a3 , 0x4c ( fp ) move a2 , v1 move a1 , a0 move a0 , s0 lw v0 , - 0x7f0c ( gp ) move t9 , v0 jalr t9 nop lw gp , 0x18 ( fp ) lw v0 , 0x58 ( fp ) beqz v0 , 0x270 nop lw v0 , - 0x7e8c ( gp ) lw v0 , ( v0 ) move a0 , v0 jal 0x4042f4 nop lw gp , 0x18 ( fp ) addiu a0 , zero , 0x1 lw v0 , - 0x7ef4 ( gp ) move t9 , v0 jalr t9 nop lw v0 , 0x54 ( fp ) sw v0 , 0x30 ( fp ) lw v0 , 0x30 ( fp ) lw v1 , - 0x7e9c ( gp ) lw a0 , 0x34 ( fp ) lw v1 , ( v1 ) beq a0 , v1 , 0x2a0 nop lw v0 , - 0x7eb0 ( gp ) move t9 , v0 jalr t9 nop move sp , fp lw ra , 0x44 ( sp ) lw fp , 0x40 ( sp ) lw s0 , 0x3c ( sp ) addiu sp , sp , 0x48 jr ra nop
Code2: push ebp mov ebp , esp push ebx push edi push esi sub esp , 0xac mov eax , dword ptr [ ebp + 0x1c ] mov ecx , dword ptr [ ebp + 0x18 ] mov edx , dword ptr [ ebp + 0x14 ] mov esi , dword ptr [ ebp + 0x10 ] mov edi , dword ptr [ ebp + 0xc ] mov ebx , dword ptr [ ebp + 0x8 ] mov dword ptr [ ebp - 0x3c ] , eax mov dword ptr [ ebp - 0x40 ] , ecx mov dword ptr [ ebp - 0x44 ] , edx mov dword ptr [ ebp - 0x48 ] , esi mov dword ptr [ ebp - 0x4c ] , edi mov dword ptr [ ebp - 0x50 ] , ebx mov eax , esp add eax , - 0x10 mov esp , eax mov ecx , esp add ecx , - 0x10 mov esp , ecx mov edx , esp add edx , - 0x10 mov esp , edx mov dword ptr [ ebp - 0x54 ] , eax mov dword ptr [ ebp - 0x58 ] , ecx mov dword ptr [ ebp - 0x5c ] , edx mov eax , esp add eax , - 0x10 mov esp , eax mov ecx , dword ptr [ ebp - 0x50 ] mov dword ptr [ ebp - 0x10 ] , ecx mov edx , dword ptr [ ebp - 0x4c ] mov dword ptr [ ebp - 0x14 ] , edx mov esi , dword ptr [ ebp - 0x48 ] mov dword ptr [ ebp - 0x18 ] , esi mov edi , dword ptr [ ebp - 0x44 ] mov dword ptr [ ebp - 0x1c ] , edi mov ebx , dword ptr [ ebp - 0x40 ] mov dword ptr [ ebp - 0x20 ] , ebx mov ecx , dword ptr [ ebp - 0x3c ] mov dword ptr [ ebp - 0x24 ] , ecx mov ecx , dword ptr [ ebp - 0x18 ] mov dword ptr [ ebp - 0x28 ] , ecx mov ecx , dword ptr [ ebp - 0x24 ] mov dword ptr [ ebp - 0x34 ] , ecx mov ecx , dword ptr [ ebp - 0x10 ] mov dword ptr [ ebp - 0x30 ] , ecx mov dword ptr [ ebp - 0x2c ] , 0x0 mov dword ptr [ ebp - 0x60 ] , eax mov eax , dword ptr [ ebp - 0x14 ] xor ecx , ecx mov dword ptr [ ebp - 0x64 ] , eax mov dword ptr [ ebp - 0x68 ] , ecx mov eax , dword ptr [ ebp - 0x30 ] mov ecx , dword ptr [ ebp - 0x2c ] mov edx , dword ptr [ ebp - 0x64 ] sub edx , eax mov eax , dword ptr [ ebp - 0x68 ] sbb eax , ecx setb bl mov dword ptr [ ebp - 0x6c ] , edx mov dword ptr [ ebp - 0x70 ] , eax mov byte ptr [ ebp - 0x71 ] , bl mov al , byte ptr [ ebp - 0x71 ] test al , 0x1 jne 0xcc jmp 0x28f mov eax , dword ptr [ ebp - 0x24 ] mov ecx , eax sar ecx , 0x1f mov edx , dword ptr [ ebp - 0x30 ] mov esi , dword ptr [ ebp - 0x2c ] add edx , - 0x1 adc esi , - 0x1 mov dword ptr [ ebp - 0x78 ] , eax mov dword ptr [ ebp - 0x7c ] , edx mul edx mov edi , dword ptr [ ebp - 0x78 ] imul edi , esi add edx , edi mov esi , dword ptr [ ebp - 0x7c ] imul ecx , esi add edx , ecx mov dword ptr [ ebp - 0x80 ] , edx mov dword ptr [ ebp - 0x84 ] , eax mov eax , dword ptr [ ebp - 0x10 ] xor ecx , ecx mov dword ptr [ ebp - 0x88 ] , eax mov dword ptr [ ebp - 0x8c ] , ecx sub esp , 0x10 mov eax , esp mov ecx , dword ptr [ ebp - 0x8c ] mov dword ptr [ eax + 0xc ] , ecx mov edx , dword ptr [ ebp - 0x88 ] mov dword ptr [ eax + 0x8 ] , edx mov esi , dword ptr [ ebp - 0x80 ] mov dword ptr [ eax + 0x4 ] , esi mov edi , dword ptr [ ebp - 0x84 ] mov dword ptr [ eax ] , edi call 0xac20 add esp , 0x10 mov dword ptr [ ebp - 0x38 ] , eax mov eax , dword ptr [ ebp - 0x34 ] sub eax , dword ptr [ ebp - 0x38 ] add eax , dword ptr [ ebp - 0x20 ] mov ecx , dword ptr [ ebp - 0x54 ] mov dword ptr [ ecx ] , eax test byte ptr [ 0x805f245 ] , 0x1 je 0x208 mov eax , dword ptr [ ebp - 0x5c ] mov dword ptr [ eax ] , 0x0 jmp 0x16b mov eax , dword ptr [ ebp - 0x5c ] mov ecx , dword ptr [ eax ] mov dword ptr [ ebp - 0x90 ] , ecx mov eax , dword ptr [ ebp - 0x90 ] cmp eax , 0x4 setb cl mov byte ptr [ ebp - 0x91 ] , cl mov al , byte ptr [ ebp - 0x91 ] test al , 0x1 jne 0x19b jmp 0x1ed mov eax , dword ptr [ ebp - 0x28 ] mov ecx , 0x3 mov edx , dword ptr [ ebp - 0x5c ] sub ecx , dword ptr [ edx ] add eax , ecx mov dword ptr [ ebp - 0x98 ] , eax mov eax , dword ptr [ ebp - 0x98 ] mov cl , byte ptr [ eax ] mov byte ptr [ ebp - 0x99 ] , cl mov eax , dword ptr [ ebp - 0x5c ] mov ecx , dword ptr [ eax ] mov edx , dword ptr [ ebp - 0x60 ] mov bl , byte ptr [ ebp - 0x99 ] mov byte ptr [ edx + ecx ] , bl mov eax , dword ptr [ ebp - 0x5c ] mov ecx , dword ptr [ eax ] mov dword ptr [ ebp - 0xa0 ] , ecx mov eax , dword ptr [ ebp - 0xa0 ] add eax , 0x1 mov ecx , dword ptr [ ebp - 0x5c ] mov dword ptr [ ecx ] , eax jmp 0x16b mov eax , dword ptr [ ebp - 0x60 ] mov dword ptr [ ebp - 0xa4 ] , eax mov eax , dword ptr [ ebp - 0xa4 ] mov ecx , dword ptr [ eax ] mov edx , dword ptr [ ebp - 0x58 ] mov dword ptr [ edx ] , ecx jmp 0x223 mov eax , dword ptr [ ebp - 0x28 ] mov dword ptr [ ebp - 0xa8 ] , eax mov eax , dword ptr [ ebp - 0xa8 ] mov ecx , dword ptr [ eax ] mov edx , dword ptr [ ebp - 0x58 ] mov dword ptr [ edx ] , ecx jmp 0x223 mov eax , dword ptr [ ebp - 0x28 ] add eax , 0x4 mov dword ptr [ ebp - 0x28 ] , eax mov eax , dword ptr [ ebp - 0x1c ] mov ecx , dword ptr [ ebp - 0x54 ] mov edx , dword ptr [ ecx ] mov esi , dword ptr [ ebp - 0x58 ] mov edi , dword ptr [ esi ] sub esp , 0x10 mov dword ptr [ esp ] , eax mov dword ptr [ esp + 0x4 ] , edx mov dword ptr [ esp + 0x8 ] , edi call 0x8c60 add esp , 0x10 mov ecx , dword ptr [ ebp - 0x38 ] mov dword ptr [ ebp - 0x34 ] , ecx mov dword ptr [ ebp - 0xac ] , eax jmp 0x260 mov eax , dword ptr [ ebp - 0x30 ] mov ecx , dword ptr [ ebp - 0x2c ] mov dword ptr [ ebp - 0xb0 ] , eax mov dword ptr [ ebp - 0xb4 ] , ecx mov eax , dword ptr [ ebp - 0xb0 ] add eax , - 0x1 mov ecx , dword ptr [ ebp - 0xb4 ] adc ecx , - 0x1 mov dword ptr [ ebp - 0x30 ] , eax mov dword ptr [ ebp - 0x2c ] , ecx jmp 0x95 lea esp , [ ebp - 0xc ] pop esi pop edi pop ebx pop ebp ret nop word ptr [ eax + eax ]
Similarity: 1
Label: -1
Similarity Score: 0.8
Explanation: Both codes exhibit similar structural patterns despite being for different architectures (MIPS vs x86). Key similarities include:
- Standard function prologue/epilogue sequences (stack adjustment, register preservation)
- Heavy stack usage for local variables and argument handling
- Multiple conditional branches controlling complex logic flows
- External function calls (jalr in MIPS, call in x86)
- Similar memory access patterns for parameters and globals
- Comparable control structures with nested conditionals
The architectural differences account for the minor dissimilarities in register usage and instruction syntax, but the overall control flow and structural organization indicate they implement closely related functionality.
------------------------------------------------------------

------------------------------------------------------------
Code1: push { fp , lr } add fp , sp , 0x4 sub sp , sp , 0x28 str r0 , [ fp , - 0x10 ] str r1 , [ fp , - 0x14 ] str r2 , [ fp , - 0x18 ] str r3 , [ fp , - 0x1c ] ldr r3 , [ pc , 0x3c ] str r3 , [ fp , - 0x8 ] ldr r3 , [ fp , 0x4 ] str r3 , [ sp , 0x8 ] ldr r3 , [ fp , - 0x1c ] str r3 , [ sp , 0x4 ] mov r3 , 0x2 str r3 , [ sp ] ldr r3 , [ fp , - 0x8 ] ldr r2 , [ fp , - 0x18 ] ldr r1 , [ fp , - 0x14 ] ldr r0 , [ fp , - 0x10 ] bl 0xfffff978 mov r3 , r0 mov r0 , r3 sub sp , fp , 0x4 pop { fp , pc } strdeq ip , sp , [ pc ] , -r8
Code2: sub rsp , 0x10 mov r9 , rcx lea rcx , [ rip + 0x821bf ] push r8 mov r8d , 0x2 call 0xfffffffffffff720 add rsp , 0x18 ret
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two code snippets are from different processor architectures (ARM for the first and x86_64 for the second). They use entirely different instruction sets, registers, and calling conventions. The first code uses ARM-specific instructions like push, ldr, str, bl, and pop with registers r0-r3, sp, fp, lr, and pc. The second uses x86_64 instructions like sub, mov, lea, push, call, add, and ret with registers rsp, rcx, r9, r8d, and rip. Due to these fundamental differences, the codes are not similar at all.
------------------------------------------------------------

------------------------------------------------------------
Code1: push ebp push edi xor ebp , ebp push esi push ebx mov esi , eax call 0xfffa0c20 add ebx , 0x7a5fb sub esp , 0x2c mov edi , edx mov eax , dword ptr [ esp + 0x40 ] mov edx , dword ptr gs : [ 0x14 ] mov dword ptr [ esp + 0x1c ] , edx xor edx , edx test eax , eax jne 0x48 mov edi , dword ptr [ esp + 0x1c ] xor edi , dword ptr gs : [ 0x14 ] mov eax , ebp jne 0x9f add esp , 0x2c pop ebx pop esi pop edi pop ebp ret lea esi , [ esi ] mov dword ptr [ esp + 0xc ] , ecx sub esp , 0x8 push eax push esi call 0x3510 mov ecx , dword ptr [ esp + 0x1c ] mov dword ptr [ esp ] , eax lea eax , [ ebx - 0x314aa ] push ecx push eax push 0x1 lea eax , [ esp + 0x34 ] push eax call 0xfff9eee0 add esp , 0x20 test eax , eax js 0x88 mov edx , dword ptr [ esp + 0x18 ] mov eax , edi call 0xfffffd90 jmp 0x2d lea esi , [ esi ] call 0xfff9f050 sub esp , 0x8 push dword ptr [ eax ] push esi call 0x6490 add esp , 0x10 mov ebp , eax jmp 0x2d call 0x1cd00 lea esi , [ esi ] lea edi , [ edi ]
Code2: push r12 push rbp push rbx sub rsp , 0x10 mov rax , qword ptr fs : [ 0x28 ] mov qword ptr [ rsp + 0x8 ] , rax xor eax , eax test ecx , ecx jne 0x35 mov rdx , qword ptr [ rsp + 0x8 ] xor rdx , qword ptr fs : [ 0x28 ] jne 0x8c add rsp , 0x10 pop rbx pop rbp pop r12 ret mov rbx , rdi mov r12 , rsi mov rbp , rdx mov esi , ecx call 0x3c22 mov r8 , rax mov rdi , rsp mov rcx , rbp lea rdx , [ rip + 0x48617 ] mov esi , 0x1 mov eax , 0x0 call 0xfffffffffffa3a0a test eax , eax js 0x7b mov rsi , qword ptr [ rsp ] mov rdi , r12 call 0xfffffffffffffc6b mov eax , 0x0 jmp 0x1c call 0xfffffffffffa37ba mov esi , dword ptr [ rax ] mov rdi , rbx call 0x6723 jmp 0x1c call 0xfffffffffffa38ca
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly codes show fundamental differences in architecture and implementation. Code1 uses 32-bit registers (ebp/edi/esi/ebx) with dword operations and 32-bit memory addressing, while Code2 uses 64-bit registers (r12/rbp/rbx) with qword operations and RIP-relative addressing. Their stack management differs significantly - Code1 uses direct stack pointer manipulation (add/sub esp) while Code2 uses x86_64 red-zone conventions. The function call patterns are incompatible (32-bit vs 64-bit calling conventions), security implementations differ (GS vs FS segment checks), and there's no overlapping functionality in the instruction sequences. The architectural mismatch and lack of equivalent operations result in no meaningful similarity.
------------------------------------------------------------

------------------------------------------------------------
Code1: push ebp push edi push esi push ebx sub esp , 0x1c call 0xfffd1155 add ebx , 0x86911 mov ebp , eax mov edi , edx mov dword ptr [ esp + 0xc ] , edx call 0x3eda5 mov esi , eax mov eax , dword ptr [ ebp + 0x130 ] sub esp , 0x8 mov edx , dword ptr [ eax ] push 0x1 push eax call dword ptr [ edx + 0x44 ] add esp , 0x10 test al , al jne 0x6f sub esp , 0x4 push dword ptr [ esp + 0x10 ] lea eax , [ ebx - 0x3c7a1 ] push eax push esi call 0x3ee36 add esp , 0x10 cmp dword ptr [ esi + 0x8 ] , 0x4d ja 0x99 lea edi , [ esi + 0xc ] sub esp , 0x8 push 0x2d push edi call 0xfffda6fa add esp , 0x10 cmp dword ptr [ esi + 0x8 ] , 0x4d jbe 0x59 jmp 0x99 mov ecx , 0xffffffff mov eax , 0x0 mov dword ptr [ esp + 0xc ] , edi repne scasb al , byte ptr es : [ edi ] not ecx mov eax , dword ptr [ esp + 0xc ] lea edx , [ ecx - 0x1 ] sub esp , 0x4 push edx push eax lea eax , [ esi + 0xc ] push eax call 0xfffda670 add esp , 0x10 lea eax , [ ebx - 0x3f232 ] mov edx , 0x2 sub esp , 0x4 push edx push eax lea eax , [ esi + 0xc ] push eax call 0xfffda670 mov eax , dword ptr [ ebp + 0x130 ] mov edx , dword ptr [ eax ] push dword ptr [ esi + 0x8 ] push dword ptr [ esi + 0x4 ] push 0x1 push eax call dword ptr [ edx ] add esp , 0x14 push esi call 0x3f4fe add esp , 0x2c pop ebx pop esi pop edi pop ebp ret
Code2: push rbp mov rbp , rsp sub rsp , 0xa0 mov qword ptr [ rbp - 0x18 ] , rdi mov qword ptr [ rbp - 0x20 ] , rsi call 0x7bc00 mov qword ptr [ rbp - 0x28 ] , rax mov rax , qword ptr [ rbp - 0x18 ] mov rax , qword ptr [ rax + 0x248 ] mov qword ptr [ rbp - 0x10 ] , rax mov dword ptr [ rbp - 0x5c ] , 0x14403562 mov eax , dword ptr [ rbp - 0x5c ] mov ecx , eax sub ecx , 0x989d35e7 mov dword ptr [ rbp - 0x60 ] , eax mov dword ptr [ rbp - 0x64 ] , ecx je 0x1a9 jmp 0x4e mov eax , dword ptr [ rbp - 0x60 ] sub eax , 0xccf1610a mov dword ptr [ rbp - 0x68 ] , eax je 0x144 jmp 0x64 mov eax , dword ptr [ rbp - 0x60 ] sub eax , 0xf2ec8987 mov dword ptr [ rbp - 0x6c ] , eax je 0x21a jmp 0x7a mov eax , dword ptr [ rbp - 0x60 ] sub eax , 0xa174dfb mov dword ptr [ rbp - 0x70 ] , eax je 0x26a jmp 0x90 mov eax , dword ptr [ rbp - 0x60 ] sub eax , 0x14403562 mov dword ptr [ rbp - 0x74 ] , eax je 0x11f jmp 0xa6 mov eax , dword ptr [ rbp - 0x60 ] sub eax , 0x14d5066a mov dword ptr [ rbp - 0x78 ] , eax je 0x184 jmp 0xbc mov eax , dword ptr [ rbp - 0x60 ] sub eax , 0x1b1cea3e mov dword ptr [ rbp - 0x7c ] , eax je 0x1c7 jmp 0xd2 mov eax , dword ptr [ rbp - 0x60 ] sub eax , 0x29b60f95 mov dword ptr [ rbp - 0x80 ] , eax je 0x1e8 jmp 0xe8 mov eax , dword ptr [ rbp - 0x60 ] sub eax , 0x437f55bf mov dword ptr [ rbp - 0x84 ] , eax je 0x242 jmp 0x101 mov eax , dword ptr [ rbp - 0x60 ] sub eax , 0x5221607f mov dword ptr [ rbp - 0x88 ] , eax je 0x1f4 jmp 0x11a jmp 0x2ce mov rdi , qword ptr [ rbp - 0x10 ] mov esi , 0x1 call 0x2e0 test al , 0x1 mov esi , 0xccf1610a mov ecx , 0x14d5066a cmovne ecx , esi mov dword ptr [ rbp - 0x5c ] , ecx jmp 0x2ce mov rax , qword ptr [ rbp - 0x28 ] add rax , 0x18 mov rdi , qword ptr [ rbp - 0x20 ] mov qword ptr [ rbp - 0x90 ] , rax call 0xf10 mov qword ptr [ rbp - 0x38 ] , rax mov qword ptr [ rbp - 0x30 ] , rdx mov rsi , qword ptr [ rbp - 0x38 ] mov rdx , qword ptr [ rbp - 0x30 ] mov rdi , qword ptr [ rbp - 0x90 ] call 0xfffffffffff9efe0 mov dword ptr [ rbp - 0x5c ] , 0x5221607f jmp 0x2ce mov rdi , qword ptr [ rbp - 0x28 ] mov rdx , qword ptr [ rbp - 0x20 ] movabs rsi , 0x50600f mov al , 0x0 call 0x7be90 mov dword ptr [ rbp - 0x5c ] , 0x989d35e7 jmp 0x2ce mov rax , qword ptr [ rbp - 0x28 ] cmp qword ptr [ rax + 0x10 ] , 0x4e mov ecx , 0x1b1cea3e mov edx , 0x29b60f95 cmovb edx , ecx mov dword ptr [ rbp - 0x5c ] , edx jmp 0x2ce mov rax , qword ptr [ rbp - 0x28 ] add rax , 0x18 mov rdi , rax mov esi , 0x2d call 0xfffffffffff9f180 mov dword ptr [ rbp - 0x5c ] , 0x989d35e7 jmp 0x2ce mov dword ptr [ rbp - 0x5c ] , 0x5221607f jmp 0x2ce mov rax , qword ptr [ rbp - 0x28 ] add rax , 0x18 mov qword ptr [ rbp - 0x8 ] , rax mov cl , 0x1 test cl , 0x1 mov edx , 0xf2ec8987 mov esi , 0x437f55bf cmovne esi , edx mov dword ptr [ rbp - 0x5c ] , esi jmp 0x2ce movabs rdi , 0x5057b0 mov esi , 0x2 call 0x360 mov qword ptr [ rbp - 0x48 ] , rax mov qword ptr [ rbp - 0x40 ] , rdx mov dword ptr [ rbp - 0x5c ] , 0xa174dfb jmp 0x2ce movabs rdi , 0x5057b0 mov esi , 0x2 call 0x360 mov qword ptr [ rbp - 0x48 ] , rax mov qword ptr [ rbp - 0x40 ] , rdx mov dword ptr [ rbp - 0x5c ] , 0xa174dfb jmp 0x2ce mov rsi , qword ptr [ rbp - 0x48 ] mov rdx , qword ptr [ rbp - 0x40 ] mov rdi , qword ptr [ rbp - 0x8 ] call 0xfffffffffff9efe0 mov rdx , qword ptr [ rbp - 0x18 ] mov rdi , qword ptr [ rdx + 0x248 ] mov rdx , qword ptr [ rbp - 0x28 ] mov qword ptr [ rbp - 0x98 ] , rdi mov rdi , rdx call 0xfffffffffffffef0 mov qword ptr [ rbp - 0x58 ] , rax mov qword ptr [ rbp - 0x50 ] , rdx mov rsi , qword ptr [ rbp - 0x58 ] mov rdx , qword ptr [ rbp - 0x50 ] mov rdi , qword ptr [ rbp - 0x98 ] call 0x330 mov rdi , qword ptr [ rbp - 0x28 ] mov qword ptr [ rbp - 0xa0 ] , rax call 0x7bce0 add rsp , 0xa0 pop rbp ret jmp 0x32 nop word ptr cs : [ rax + rax ] nop dword ptr [ rax ]
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The codes are fundamentally dissimilar due to significant differences in architecture, structure, and operations:
1. Architecture: Code1 uses 32-bit registers (ebp/edi/esi) and stack operations, while Code2 uses 64-bit registers (rbp/rdi/rsi) and larger memory offsets.
2. Control Flow: Code1 has linear conditional jumps (jne/jbe/ja) and string operations (repne scasb).
------------------------------------------------------------

------------------------------------------------------------
Code1: push ebp mov ebp , esp push ebx sub esp , 0x14 call 0xfffe746e add ebx , 0x378da2 call 0xffffd633 mov dword ptr [ ebp - 0x10 ] , eax cmp dword ptr [ ebp + 0x8 ] , 0x0 jne 0x3f lea eax , [ ebx - 0xcf140 ] push eax push 0x4b4 lea eax , [ ebx - 0xcf944 ] push eax lea eax , [ ebx - 0xcf90c ] push eax call 0xfffe4dfe mov eax , dword ptr [ ebp + 0x8 ] mov eax , dword ptr [ eax + 0x3344 ] cmp eax , 0xabacadab je 0x6e lea eax , [ ebx - 0xcf140 ] push eax push 0x4b5 lea eax , [ ebx - 0xcf944 ] push eax lea eax , [ ebx - 0xcf8ec ] push eax call 0xfffe4dfe mov eax , dword ptr [ ebp + 0x8 ] mov eax , dword ptr [ eax + 0x2ac ] test eax , eax jne 0x9a lea eax , [ ebx - 0xcf140 ] push eax push 0x4b6 lea eax , [ ebx - 0xcf944 ] push eax lea eax , [ ebx - 0xcf874 ] push eax call 0xfffe4dfe mov eax , dword ptr [ ebp + 0x8 ] mov eax , dword ptr [ eax + 0x2ac ] mov dword ptr [ ebp - 0xc ] , eax mov eax , dword ptr [ ebp - 0xc ] mov eax , dword ptr [ eax + 0x2278 ] cmp eax , 0xabacadab je 0xd5 lea eax , [ ebx - 0xcf140 ] push eax push 0x4b8 lea eax , [ ebx - 0xcf944 ] push eax lea eax , [ ebx - 0xcf854 ] push eax call 0xfffe4dfe mov eax , dword ptr [ ebp - 0xc ] mov eax , dword ptr [ eax + 0x214 ] cmp dword ptr [ ebp - 0x10 ] , eax jl 0x102 lea eax , [ ebx - 0xcf140 ] push eax push 0x4b9 lea eax , [ ebx - 0xcf944 ] push eax lea eax , [ ebx - 0xcf724 ] push eax call 0xfffe4dfe mov eax , dword ptr [ ebp - 0xc ] mov eax , dword ptr [ eax + 0x218 ] mov edx , dword ptr [ ebp - 0x10 ] shl edx , 0x2 add eax , edx mov eax , dword ptr [ eax ] mov eax , dword ptr [ eax + 0x28 ] mov ebx , dword ptr [ ebp - 0x4 ] leave ret
Code2: push { r4 , lr } mov r4 , r0 bl 0xfffded30 cmp r4 , 0x0 beq 0x60 add r3 , r4 , 0x3000 ldr r2 , [ r3 , 0x36c ] ldr r3 , [ pc , 0xf0 ] cmp r2 , r3 bne 0xf0 ldr r3 , [ r4 , 0x2d4 ] cmp r3 , 0x0 beq 0xcc add r1 , r3 , 0x2000 ldr r1 , [ r1 , 0x284 ] cmp r1 , r2 bne 0xa8 ldr r2 , [ r3 , 0x220 ] cmp r2 , r0 ble 0x84 ldr r3 , [ r3 , 0x224 ] ldr r3 , [ r3 , r0 , lsl 0x2 ] ldr r0 , [ r3 , 0x2c ] pop { r4 , pc } ldr r3 , [ pc , 0xb0 ] ldr r1 , [ pc , 0xb0 ] ldr r0 , [ pc , 0xb0 ] add r3 , pc , r3 ldr r2 , [ pc , 0xac ] add r3 , r3 , 0x1c add r1 , pc , r1 add r0 , pc , r0 bl 0xfffdeac0 ldr r3 , [ pc , 0x9c ] ldr r1 , [ pc , 0x9c ] ldr r0 , [ pc , 0x9c ] add r3 , pc , r3 ldr r2 , [ pc , 0x98 ] add r3 , r3 , 0x1c add r1 , pc , r1 add r0 , pc , r0 bl 0xfffdeac0 ldr r3 , [ pc , 0x88 ] ldr r1 , [ pc , 0x88 ] ldr r0 , [ pc , 0x88 ] add r3 , pc , r3 ldr r2 , [ pc , 0x84 ] add r3 , r3 , 0x1c add r1 , pc , r1 add r0 , pc , r0 bl 0xfffdeac0 ldr r3 , [ pc , 0x74 ] ldr r1 , [ pc , 0x74 ] ldr r0 , [ pc , 0x74 ] add r3 , pc , r3 ldr r2 , [ pc , 0x70 ] add r3 , r3 , 0x1c add r1 , pc , r1 add r0 , pc , r0 bl 0xfffdeac0 ldr r3 , [ pc , 0x60 ] ldr r1 , [ pc , 0x60 ] ldr r0 , [ pc , 0x60 ] add r3 , pc , r3 ldr r2 , [ pc , 0x5c ] add r3 , r3 , 0x1c add r1 , pc , r1 add r0 , pc , r0 bl 0xfffdeac0 blge 0xfeb2b7c8 eoreq r5 , lr , ip , lsr 0x9 eoreq r5 , lr , r4 , asr 0x27 eoreq lr , lr , r0 , asr r8 strheq r0 , [ r0 ] , -r4 eoreq r5 , lr , r8 , lsl 0x9 eoreq r5 , lr , r0 , lsr 0x27 eoreq r5 , lr , r0 , ror 0x27 strheq r0 , [ r0 ] , -sb eoreq r5 , lr , r4 , ror 0x8 eoreq r5 , lr , ip , ror sp eoreq r5 , lr , ip , lsl 0x27 strheq r0 , [ r0 ] , -r8 eoreq r5 , lr , r0 , asr 0x8 eoreq r5 , lr , r8 , asr sp eoreq r6 , lr , r0 , asr 0x12 strheq r0 , [ r0 ] , -r6 eoreq r5 , lr , ip , lsl r4 eoreq r5 , lr , r4 , lsr sp eoreq lr , lr , ip , ror 0x15 strheq r0 , [ r0 ] , -r5
Similarity: -1
Label: 1
Similarity Score: 0.25
Explanation: The codes show fundamental differences:  
1. Architecture - Code1 uses x86 instructions (ebp/esp/eax) while Code2 uses ARM (r0/r1/pop/pc).  
2. Control flow - Code1 relies on jne/je jumps after cmp, while Code2 uses beq/bne/ble.  
3. Error handling - Both call functions after failed checks, but Code2 has repetitive bl blocks (likely inlined) while Code1 uses conditional call patterns.  
4. Key operations - Code1 uses shl/edx for offset calculation, while Code2 uses lsl for shifts.  
5. Epilogue - Code1 uses leave/ret, Code2 uses pop {r4, pc}.  
The limited similarity (error-check pattern) is outweighed by architectural/structural differences. The trailing ARM data (eoreq/strheq) further reduces alignment.
------------------------------------------------------------

------------------------------------------------------------
Code1: push rbx test rdi , rdi je 0x2b mov rbx , rdi lea rdi , [ rdi + 0x8 ] mov ecx , 0x5cf3bd mov esi , 0xffffffff mov edx , 0xa mov r8d , 0x17f call 0xfffffffffffa6e60 test eax , eax jle 0x2d pop rbx ret mov rax , qword ptr [ rbx + 0x10 ] test rax , rax je 0x4f mov rax , qword ptr [ rax + 0xa0 ] test rax , rax je 0x4f mov rdi , rbx call rax mov qword ptr [ rbx + 0x20 ] , 0x0 mov rdi , qword ptr [ rbx + 0x18 ] test rdi , rdi je 0x65 call 0xfffffffffffe6f80 mov qword ptr [ rbx + 0x18 ] , 0x0 mov rdi , qword ptr [ rbx + 0x30 ] test rdi , rdi je 0x78 mov esi , 0x4e60f0 call 0xffffffffffff4f70 mov rdi , rbx pop rbx jmp 0xfffffffffffa7a60 nop word ptr cs : [ rax + rax ] nop dword ptr [ rax + rax ]
Code2: addiu sp , sp , - 0x30 sw ra , 0x2c ( sp ) lui gp , 0x76 addiu gp , gp , 0x1270 sw gp , 0x18 ( sp ) sw a0 , 0x30 ( sp ) lw v0 , 0x30 ( sp ) beqz v0 , 0xd0 nop lw v0 , 0x30 ( sp ) addiu v1 , v0 , 0x8 addiu v0 , zero , 0x17f sw v0 , 0x10 ( sp ) lui v0 , 0x71 addiu a3 , v0 , 0x75f0 addiu a2 , zero , 0xa addiu a1 , zero , - 0x1 move a0 , v1 lw v0 , - 0x6d80 ( gp ) move t9 , v0 jalr t9 nop lw gp , 0x18 ( sp ) sw v0 , 0x24 ( sp ) lw v0 , 0x24 ( sp ) bgtz v0 , 0xdc nop lw a0 , 0x30 ( sp ) jal 0x5ae084 nop lw gp , 0x18 ( sp ) lw v0 , 0x30 ( sp ) lw v0 , 0x1c ( v0 ) beqz v0 , 0xb0 nop lw v0 , 0x30 ( sp ) lw v0 , 0x1c ( v0 ) lw a1 , - 0x62f4 ( gp ) move a0 , v0 lw v0 , - 0x7e94 ( gp ) move t9 , v0 bal - 0x12858 nop lw gp , 0x18 ( sp ) lw a0 , 0x30 ( sp ) lw v0 , - 0x7f64 ( gp ) move t9 , v0 jalr t9 nop lw gp , 0x18 ( sp ) b 0xe0 nop nop b 0xe0 nop nop lw ra , 0x2c ( sp ) addiu sp , sp , 0x30 jr ra nop
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two code snippets are written for entirely different architectures (x86_64 assembly vs MIPS assembly), resulting in fundamentally dissimilar instruction sets, register usage, and memory access patterns. The first uses x86-specific operations like `push`/`pop`, `test`/`je`, and `call` with 64-bit registers (`rax`, `rbx`, `rdi`), while the second relies on MIPS conventions like `addiu`, `lw`/`sw`, and `jalr` with 32-bit registers (`v0`, `a0`, `gp`). Control flow structures, function call mechanisms, and stack management differ completely. No overlapping algorithmic patterns or equivalent operations are identifiable, indicating no meaningful similarity.
------------------------------------------------------------

------------------------------------------------------------
Code1: push ebp mov ebp , esp push ebx push edi push esi sub esp , 0x4c mov eax , dword ptr [ ebp + 0x10 ] mov ecx , dword ptr [ ebp + 0xc ] mov edx , dword ptr [ ebp + 0x8 ] mov esi , dword ptr [ ebp + 0x10 ] mov esi , dword ptr [ esi ] mov dword ptr [ ebp - 0x18 ] , esi mov esi , dword ptr [ ebp + 0xc ] mov edi , dword ptr [ ebp + 0x10 ] mov ebx , esp mov dword ptr [ ebp - 0x34 ] , eax lea eax , [ ebp - 0x14 ] mov dword ptr [ ebx + 0x8 ] , eax mov dword ptr [ ebx + 0x4 ] , edi mov dword ptr [ ebx ] , esi mov dword ptr [ ebp - 0x38 ] , ecx mov dword ptr [ ebp - 0x3c ] , edx call 0x1670 movzx ecx , al mov ecx , dword ptr [ ecx * 0x4 + 0x808e380 ] jmp ecx mov eax , esp lea ecx , [ ebp - 0x30 ] mov dword ptr [ eax ] , ecx mov dword ptr [ ebp - 0x40 ] , ecx call 0xffffd190 mov eax , dword ptr [ ebp + 0x8 ] mov ecx , dword ptr [ ebp - 0x14 ] mov edx , esp mov dword ptr [ edx + 0x8 ] , ecx mov dword ptr [ edx + 0x4 ] , eax mov eax , dword ptr [ ebp - 0x40 ] mov dword ptr [ edx ] , eax call 0xffff95d0 movzx ecx , al mov ecx , dword ptr [ ecx * 0x4 + 0x808e388 ] jmp ecx mov byte ptr [ ebp - 0xd ] , 0x1 mov eax , dword ptr [ 0x808db1c ] jmp eax mov eax , dword ptr [ ebp - 0x18 ] mov ecx , dword ptr [ ebp + 0x10 ] mov dword ptr [ ecx ] , eax mov byte ptr [ ebp - 0xd ] , 0x0 mov eax , dword ptr [ 0x808db1c ] jmp eax mov byte ptr [ ebp - 0xd ] , 0x0 mov eax , dword ptr [ 0x808db1c ] jmp eax mov al , byte ptr [ ebp - 0xd ] and al , 0x1 movzx eax , al add esp , 0x4c pop esi pop edi pop ebx pop ebp ret nop word ptr cs : [ eax + eax ] nop dword ptr [ eax ]
Code2: push ebp mov ebp , esp push esi sub esp , 0x64 mov eax , dword ptr [ ebp + 0x10 ] mov ecx , dword ptr [ ebp + 0xc ] mov edx , dword ptr [ ebp + 0x8 ] mov esi , dword ptr [ ebp + 0x10 ] mov esi , dword ptr [ esi ] mov dword ptr [ ebp - 0x18 ] , esi mov esi , dword ptr [ ebp + 0xc ] mov dword ptr [ ebp - 0xc ] , esi mov esi , dword ptr [ ebp + 0x10 ] mov dword ptr [ ebp - 0x8 ] , esi mov dword ptr [ ebp - 0x34 ] , 0xcdc727bd mov dword ptr [ ebp - 0x38 ] , eax mov dword ptr [ ebp - 0x3c ] , ecx mov dword ptr [ ebp - 0x40 ] , edx mov eax , dword ptr [ ebp - 0x34 ] mov ecx , eax sub ecx , 0x86ffa702 mov dword ptr [ ebp - 0x44 ] , eax mov dword ptr [ ebp - 0x48 ] , ecx je 0xf3 jmp 0x50 mov eax , dword ptr [ ebp - 0x44 ] sub eax , 0xb468e98e mov dword ptr [ ebp - 0x4c ] , eax je 0x166 jmp 0x66 mov eax , dword ptr [ ebp - 0x44 ] sub eax , 0xb699bfd3 mov dword ptr [ ebp - 0x50 ] , eax je 0x13e jmp 0x7c mov eax , dword ptr [ ebp - 0x44 ] sub eax , 0xc519d00c mov dword ptr [ ebp - 0x54 ] , eax je 0x156 jmp 0x92 mov eax , dword ptr [ ebp - 0x44 ] sub eax , 0xcdc727bd mov dword ptr [ ebp - 0x58 ] , eax je 0xc3 jmp 0xa8 mov eax , dword ptr [ ebp - 0x44 ] sub eax , 0xfddc6e74 mov dword ptr [ ebp - 0x5c ] , eax je 0x12e jmp 0xbe jmp 0x174 mov eax , dword ptr [ ebp - 0xc ] mov ecx , dword ptr [ ebp - 0x8 ] mov dword ptr [ esp ] , eax mov dword ptr [ esp + 0x4 ] , ecx lea eax , [ ebp - 0x14 ] mov dword ptr [ esp + 0x8 ] , eax call 0x2150 test al , 0x1 mov ecx , 0x86ffa702 mov edx , 0xc519d00c cmovne edx , ecx mov dword ptr [ ebp - 0x34 ] , edx jmp 0x174 lea eax , [ ebp - 0x30 ] mov dword ptr [ esp ] , eax call 0xffffb670 mov eax , dword ptr [ ebp + 0x8 ] mov ecx , dword ptr [ ebp - 0x14 ] lea edx , [ ebp - 0x30 ] mov dword ptr [ esp ] , edx mov dword ptr [ esp + 0x4 ] , eax mov dword ptr [ esp + 0x8 ] , ecx call 0xffff4550 test al , 0x1 mov ecx , 0xfddc6e74 mov edx , 0xb699bfd3 cmovne edx , ecx mov dword ptr [ ebp - 0x34 ] , edx jmp 0x174 mov byte ptr [ ebp - 0xd ] , 0x1 mov dword ptr [ ebp - 0x34 ] , 0xb468e98e jmp 0x174 mov eax , dword ptr [ ebp - 0x18 ] mov ecx , dword ptr [ ebp + 0x10 ] mov dword ptr [ ecx ] , eax mov byte ptr [ ebp - 0xd ] , 0x0 mov dword ptr [ ebp - 0x34 ] , 0xb468e98e jmp 0x174 mov byte ptr [ ebp - 0xd ] , 0x0 mov dword ptr [ ebp - 0x34 ] , 0xb468e98e jmp 0x174 mov al , byte ptr [ ebp - 0xd ] and al , 0x1 movzx eax , al add esp , 0x64 pop esi pop ebp ret jmp 0x34 nop dword ptr [ eax ]
Similarity: -1
Label: 1
Similarity Score: 0.25
Explanation: Both codes share structural similarities in function prologue/epilogue patterns, parameter handling via EBP offsets, and register usage. However, significant differences exist: 
1. Stack adjustment differs (0x4c vs 0x64)
2. Core logic uses distinct approaches (direct jump table vs constant-based branching)
3. Register preservation varies (code1 preserves EBX/EDI/ESI vs code2 preserves only ESI)
4. Constant values and branching logic show no overlap
5. Call targets differ completely (0x1670/0xffffd190 vs 0x2150/0xffffb670)
The shared patterns suggest similar foundational structure, but divergent implementations and unique logic sequences indicate they perform different operations.
------------------------------------------------------------

------------------------------------------------------------
Code1: push ebp push edi push esi push ebx call 0xfffef230 add ebx , 0x52237 sub esp , 0x1c lea edi , [ ebx - 0x60780 ] cmp dword ptr [ esp + 0x30 ] , edi lea ebp , [ ebx - 0x1932c ] lea esi , [ ebx - 0x19333 ] cmovne esi , ebp test eax , eax mov dword ptr [ esp + 0xc ] , esi je 0x170 mov ebp , dword ptr [ edx ] mov esi , dword ptr [ eax + ebp * 0x4 ] test esi , esi je 0x170 add ebp , 0x1 mov dword ptr [ edx ] , ebp cmp byte ptr [ esi ] , 0x0 je 0x21f sub esp , 0x4 push esi push dword ptr [ esp + 0x38 ] push ecx call 0xffffb6c0 add esp , 0x10 mov dword ptr [ eax + 0x1c ] , 0x0 cmp dword ptr [ esp + 0x30 ] , edi setne dl sete byte ptr [ eax + 0x12 ] mov byte ptr [ eax + 0x13 ] , dl movzx edx , byte ptr [ esi ] test dl , dl je 0x180 nop lea esi , [ esi ] movsx edi , dl sub edx , 0x44 cmp dl , 0x2f ja 0x1b5 movzx edx , dl mov ecx , dword ptr [ ebx + edx * 0x4 - 0x18388 ] add ecx , ebx jmp ecx lea esi , [ esi ]
Code2: push ebp mov ebp , esp push ebx push edi push esi sub esp , 0x5c mov eax , dword ptr [ ebp + 0x14 ] mov ecx , dword ptr [ ebp + 0x10 ] mov edx , dword ptr [ ebp + 0xc ] mov esi , dword ptr [ ebp + 0x8 ] mov edi , dword ptr [ ebp + 0x14 ] lea ebx , [ 0x80503b0 ] cmp edi , ebx lea edi , [ 0x81482bc ] lea ebx , [ 0x81482c3 ] cmove ebx , edi mov dword ptr [ ebp - 0x1c ] , ebx mov edi , dword ptr [ ebp + 0x8 ] mov ebx , dword ptr [ ebp + 0xc ] mov dword ptr [ esp ] , edi mov dword ptr [ esp + 0x4 ] , ebx lea edi , [ ebp - 0x18 ] mov dword ptr [ esp + 0x8 ] , edi mov dword ptr [ ebp - 0x28 ] , eax mov dword ptr [ ebp - 0x2c ] , ecx mov dword ptr [ ebp - 0x30 ] , edx mov dword ptr [ ebp - 0x34 ] , esi call 0xffffd6a0 test al , 0x1 jne 0x68 mov byte ptr [ ebp - 0xd ] , 0x0 jmp 0x42d mov eax , dword ptr [ ebp - 0x18 ] cmp byte ptr [ eax ] , 0x0 jne 0xa6 lea eax , [ 0x81482c9 ] mov dword ptr [ esp ] , eax call 0xfffe0300 xor ecx , ecx mov edx , dword ptr [ ebp - 0x1c ] mov dword ptr [ esp ] , 0x1 mov dword ptr [ esp + 0x4 ] , 0x0 mov dword ptr [ esp + 0x8 ] , eax mov dword ptr [ esp + 0xc ] , edx mov dword ptr [ ebp - 0x38 ] , ecx call 0xfffe0260 mov eax , dword ptr [ ebp + 0x10 ] mov ecx , dword ptr [ ebp + 0x14 ] mov edx , dword ptr [ ebp - 0x18 ] mov dword ptr [ esp ] , eax mov dword ptr [ esp + 0x4 ] , ecx mov dword ptr [ esp + 0x8 ] , edx call 0xfffee560 mov dword ptr [ ebp - 0x14 ] , eax mov eax , dword ptr [ ebp - 0x14 ] xorps xmm0 , xmm0 movss dword ptr [ eax + 0x1c ] , xmm0 lea eax , [ 0x80503b0 ] cmp dword ptr [ ebp + 0x14 ] , eax jne 0xef mov eax , dword ptr [ ebp - 0x14 ] mov byte ptr [ eax + 0x12 ] , 0x1 mov eax , dword ptr [ ebp - 0x14 ] mov byte ptr [ eax + 0x13 ] , 0x0 jmp 0xfd mov eax , dword ptr [ ebp - 0x14 ] mov byte ptr [ eax + 0x12 ] , 0x0 mov eax , dword ptr [ ebp - 0x14 ] mov byte ptr [ eax + 0x13 ] , 0x1 jmp 0x102 mov eax , dword ptr [ ebp - 0x18 ] cmp byte ptr [ eax ] , 0x0 je 0x429 movss xmm0 , dword ptr [ 0x81472c0 ] movss dword ptr [ ebp - 0x24 ] , xmm0 mov eax , dword ptr [ ebp - 0x18 ] movsx eax , byte ptr [ eax ] mov dword ptr [ ebp - 0x3c ] , eax mov eax , dword ptr [ ebp - 0x3c ] cmp eax , 0x66 jl 0x198 mov eax , dword ptr [ ebp - 0x3c ] cmp eax , 0x70 jl 0x16a mov eax , dword ptr [ ebp - 0x3c ] cmp eax , 0x73 jl 0x159 mov eax , dword ptr [ ebp - 0x3c ] cmp eax , 0x73 je 0x274 jmp 0x2d0 mov eax , dword ptr [ ebp - 0x3c ] cmp eax , 0x70 je 0x25b jmp 0x2d0 mov eax , dword ptr [ ebp - 0x3c ] cmp eax , 0x6c jl 0x187 mov eax , dword ptr [ ebp - 0x3c ] cmp eax , 0x6c je 0x242 jmp 0x2d0 mov eax , dword ptr [ ebp - 0x3c ] cmp eax , 0x66 je 0x229 jmp 0x2d0 mov eax , dword ptr [ ebp - 0x3c ] cmp eax , 0x63 jl 0x1c1 mov eax , dword ptr [ ebp - 0x3c ] cmp eax , 0x64 jl 0x1f7 mov eax , dword ptr [ ebp - 0x3c ] cmp eax , 0x64 je 0x210 jmp 0x2d0 mov eax , dword ptr [ ebp - 0x3c ] cmp eax , 0x62 jge 0x1de mov eax , dword ptr [ ebp - 0x3c ] cmp eax , 0x44 je 0x28d jmp 0x2d0 movss xmm0 , dword ptr [ 0x8147308 ] mov dword ptr [ ebp - 0x20 ] , 0x0 movss dword ptr [ ebp - 0x24 ] , xmm0 jmp 0x318 movss xmm0 , dword ptr [ 0x8147304 ] mov dword ptr [ ebp - 0x20 ] , 0x1 movss dword ptr [ ebp - 0x24 ] , xmm0 jmp 0x318 movss xmm0 , dword ptr [ 0x8147300 ] mov dword ptr [ ebp - 0x20 ] , 0x2 movss dword ptr [ ebp - 0x24 ] , xmm0 jmp 0x318 movss xmm0 , dword ptr [ 0x81472fc ] mov dword ptr [ ebp - 0x20 ] , 0x3 movss dword ptr [ ebp - 0x24 ] , xmm0 jmp 0x318 movss xmm0 , dword ptr [ 0x81472f8 ] mov dword ptr [ ebp - 0x20 ] , 0x4 movss dword ptr [ ebp - 0x24 ] , xmm0 jmp 0x318 movss xmm0 , dword ptr [ 0x81472f4 ] mov dword ptr [ ebp - 0x20 ] , 0x5 movss dword ptr [ ebp - 0x24 ] , xmm0 jmp 0x318 movss xmm0 , dword ptr [ 0x81472f0 ] mov dword ptr [ ebp - 0x20 ] , 0x6 movss dword ptr [ ebp - 0x24 ] , xmm0 jmp 0x318 mov dword ptr [ ebp - 0x20 ] , 0x0 lea eax , [ 0x81482fc ] mov dword ptr [ esp ] , eax call 0xfffe0300 xor ecx , ecx mov edx , dword ptr [ ebp - 0x1c ] mov esi , dword ptr [ ebp - 0x18 ] movsx esi , byte ptr [ esi ] mov dword ptr [ esp ] , 0x1 mov dword ptr [ esp + 0x4 ] , 0x0 mov dword ptr [ esp + 0x8 ] , eax mov dword ptr [ esp + 0xc ] , edx mov dword ptr [ esp + 0x10 ] , esi mov dword ptr [ ebp - 0x40 ] , ecx call 0xfffe0260 jmp 0x2d5 mov dword ptr [ ebp - 0x20 ] , 0x0 lea eax , [ 0x8148361 ] mov dword ptr [ esp ] , eax call 0xfffe0300 xor ecx , ecx mov edx , dword ptr [ ebp - 0x1c ] mov esi , dword ptr [ ebp - 0x18 ] movsx esi , byte ptr [ esi ] mov dword ptr [ esp ] , 0x1 mov dword ptr [ esp + 0x4 ] , 0x0 mov dword ptr [ esp + 0x8 ] , eax mov dword ptr [ esp + 0xc ] , edx mov dword ptr [ esp + 0x10 ] , esi mov dword ptr [ ebp - 0x44 ] , ecx call 0xfffe0260 mov eax , dword ptr [ ebp - 0x14 ] mov ecx , dword ptr [ ebp - 0x20 ] test byte ptr [ eax + ecx + 0x28 ] , 0x1 je 0x365 lea eax , [ 0x814837c ] mov dword ptr [ esp ] , eax call 0xfffe0300 xor ecx , ecx mov edx , dword ptr [ ebp - 0x18 ] movsx edx , byte ptr [ edx ] mov esi , dword ptr [ ebp - 0x1c ] mov dword ptr [ esp ] , 0x1 mov dword ptr [ esp + 0x4 ] , 0x0 mov dword ptr [ esp + 0x8 ] , eax mov dword ptr [ esp + 0xc ] , edx mov dword ptr [ esp + 0x10 ] , esi mov dword ptr [ ebp - 0x48 ] , ecx call 0xfffe0260 movss xmm0 , dword ptr [ ebp - 0x24 ] mov eax , dword ptr [ ebp - 0x14 ] addss xmm0 , dword ptr [ eax + 0x1c ] movss dword ptr [ eax + 0x1c ] , xmm0 mov eax , dword ptr [ ebp - 0x14 ] mov ecx , dword ptr [ ebp - 0x20 ] mov byte ptr [ eax + ecx + 0x28 ] , 0x1 mov eax , dword ptr [ ebp - 0x18 ] add eax , 0x1 mov dword ptr [ ebp - 0x18 ] , eax mov eax , dword ptr [ ebp - 0x18 ] cmp byte ptr [ eax ] , 0x0 je 0x424 mov eax , dword ptr [ ebp - 0x18 ] movsx eax , byte ptr [ eax ] cmp eax , 0x2c je 0x3d8 lea eax , [ 0x81483b1 ] mov dword ptr [ esp ] , eax call 0xfffe0300 xor ecx , ecx mov edx , dword ptr [ ebp - 0x1c ] mov dword ptr [ esp ] , 0x1 mov dword ptr [ esp + 0x4 ] , 0x0 mov dword ptr [ esp + 0x8 ] , eax mov dword ptr [ esp + 0xc ] , edx mov dword ptr [ ebp - 0x4c ] , ecx call 0xfffe0260 mov eax , dword ptr [ ebp - 0x18 ] add eax , 0x1 mov dword ptr [ ebp - 0x18 ] , eax mov eax , dword ptr [ ebp - 0x18 ] cmp byte ptr [ eax ] , 0x0 jne 0x41f lea eax , [ 0x81483e3 ] mov dword ptr [ esp ] , eax call 0xfffe0300 xor ecx , ecx mov edx , dword ptr [ ebp - 0x1c ] mov dword ptr [ esp ] , 0x1 mov dword ptr [ esp + 0x4 ] , 0x0 mov dword ptr [ esp + 0x8 ] , eax mov dword ptr [ esp + 0xc ] , edx mov dword ptr [ ebp - 0x50 ] , ecx call 0xfffe0260 jmp 0x424 jmp 0x102 mov byte ptr [ ebp - 0xd ] , 0x1 mov al , byte ptr [ ebp - 0xd ] and al , 0x1 movzx eax , al add esp , 0x5c pop esi pop edi pop ebx pop ebp ret nop nop
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly codes show significant structural and functional differences. Code1 uses position-independent addressing with EBX adjustments and focuses on character processing with conditional moves and direct memory operations. Code2 employs a standard stack frame setup with EBP, handles floating-point operations (movss, addss), and implements a complex state machine with multiple comparison branches. The register usage patterns, instruction sets (Code2 uses SSE instructions while Code1 doesn't), and control flow complexity differ substantially. Both codes process strings, but their approaches to memory management, parameter handling, and conditional logic are fundamentally dissimilar.
------------------------------------------------------------

------------------------------------------------------------
Code1: push ebp mov ebp , esp push ebx sub esp , 0x34 call 0xfff90d59 add ebx , 0x6a09d mov dword ptr [ ebp - 0x2c ] , 0x0 mov dword ptr [ ebp - 0x28 ] , 0x0 mov eax , dword ptr [ ebp + 0x10 ] mov eax , dword ptr [ eax + 0x14 ] mov dword ptr [ ebp - 0x14 ] , eax mov eax , dword ptr [ ebp + 0x10 ] mov eax , dword ptr [ eax + 0x28 ] mov dword ptr [ ebp - 0x10 ] , eax cmp dword ptr [ ebp - 0x14 ] , 0x1 jne 0x90 mov eax , dword ptr [ ebp + 0xc ] movzx eax , word ptr [ eax + 0x28 ] test ax , ax js 0xcf cmp dword ptr [ ebp - 0x10 ] , 0x0 jne 0x58 mov eax , 0x0 jmp 0x2fc mov eax , dword ptr [ ebp + 0xc ] mov ecx , dword ptr [ eax + 0x4 ] mov eax , dword ptr [ ebp + 0xc ] movzx eax , word ptr [ eax + 0x28 ] movsx edx , ax mov eax , edx shl eax , 0x2 add eax , edx shl eax , 0x2 add eax , ecx mov eax , dword ptr [ eax ] push dword ptr [ ebp - 0x10 ] push eax call 0xfff9aa30 add esp , 0x8 test eax , eax jne 0xcf mov eax , 0x0 jmp 0x2fc cmp dword ptr [ ebp + 0x18 ] , 0x0 je 0xcf mov eax , dword ptr [ ebp - 0x14 ] shl eax , 0x2 mov edx , 0x0 mov ecx , dword ptr [ ebp + 0x8 ] mov ecx , dword ptr [ ecx ] sub esp , 0x4 push edx push eax push ecx call 0xfff95ff3 add esp , 0x10 mov dword ptr [ ebp - 0x28 ] , eax cmp dword ptr [ ebp - 0x28 ] , 0x0 jne 0xc7 mov eax , 0x1 jmp 0x2fc mov eax , dword ptr [ ebp + 0x18 ] mov edx , dword ptr [ ebp - 0x28 ] mov dword ptr [ eax ] , edx mov eax , dword ptr [ ebp + 0xc ] mov eax , dword ptr [ eax + 0x8 ] mov dword ptr [ ebp - 0x2c ] , eax jmp 0x28f mov eax , dword ptr [ ebp - 0x2c ] movzx eax , word ptr [ eax + 0x32 ] movzx eax , ax cmp dword ptr [ ebp - 0x14 ] , eax jne 0x286 mov eax , dword ptr [ ebp - 0x2c ] movzx eax , byte ptr [ eax + 0x36 ] test al , al je 0x286 mov eax , dword ptr [ ebp - 0x2c ] mov eax , dword ptr [ eax + 0x24 ] test eax , eax jne 0x286 cmp dword ptr [ ebp - 0x10 ] , 0x0 jne 0x167 mov eax , dword ptr [ ebp - 0x2c ] movzx eax , byte ptr [ eax + 0x37 ] and eax , 0x3 cmp al , 0x2 jne 0x286 cmp dword ptr [ ebp - 0x28 ] , 0x0 je 0x29b mov dword ptr [ ebp - 0x24 ] , 0x0 jmp 0x15a mov eax , dword ptr [ ebp - 0x24 ] lea edx , [ eax * 0x4 ] mov eax , dword ptr [ ebp - 0x28 ] add edx , eax mov eax , dword ptr [ ebp + 0x10 ] mov ecx , dword ptr [ ebp - 0x24 ] add ecx , 0x4 mov eax , dword ptr [ eax + ecx * 0x8 + 0x4 ] mov dword ptr [ edx ] , eax add dword ptr [ ebp - 0x24 ] , 0x1 mov eax , dword ptr [ ebp - 0x24 ] cmp eax , dword ptr [ ebp - 0x14 ] jl 0x138 jmp 0x29b mov dword ptr [ ebp - 0x20 ] , 0x0 jmp 0x269 mov eax , dword ptr [ ebp - 0x2c ] mov eax , dword ptr [ eax + 0x4 ] mov edx , dword ptr [ ebp - 0x20 ] add edx , edx add eax , edx movzx eax , word ptr [ eax ] mov word ptr [ ebp - 0x2e ] , ax cmp word ptr [ ebp - 0x2e ] , 0x0 js 0x277 mov eax , dword ptr [ ebp + 0xc ] mov ecx , dword ptr [ eax + 0x4 ] movsx edx , word ptr [ ebp - 0x2e ] mov eax , edx shl eax , 0x2 add eax , edx shl eax , 0x2 add eax , ecx mov eax , dword ptr [ eax + 0x8 ] mov dword ptr [ ebp - 0x18 ] , eax cmp dword ptr [ ebp - 0x18 ] , 0x0 jne 0x1bd lea eax , [ ebx - 0x24e30 ] mov dword ptr [ ebp - 0x18 ] , eax mov eax , dword ptr [ ebp - 0x2c ] mov eax , dword ptr [ eax + 0x20 ] mov edx , dword ptr [ ebp - 0x20 ] shl edx , 0x2 add eax , edx mov eax , dword ptr [ eax ] sub esp , 0x8 push dword ptr [ ebp - 0x18 ] push eax call 0xfff9aa30 add esp , 0x10 test eax , eax jne 0x27a mov eax , dword ptr [ ebp + 0xc ] mov ecx , dword ptr [ eax + 0x4 ] movsx edx , word ptr [ ebp - 0x2e ] mov eax , edx shl eax , 0x2 add eax , edx shl eax , 0x2 add eax , ecx mov eax , dword ptr [ eax ] mov dword ptr [ ebp - 0xc ] , eax mov dword ptr [ ebp - 0x1c ] , 0x0 jmp 0x252 mov eax , dword ptr [ ebp + 0x10 ] mov edx , dword ptr [ ebp - 0x1c ] add edx , 0x4 mov eax , dword ptr [ eax + edx * 0x8 + 0x8 ] sub esp , 0x8 push dword ptr [ ebp - 0xc ] push eax call 0xfff9aa30 add esp , 0x10 test eax , eax jne 0x24e cmp dword ptr [ ebp - 0x28 ] , 0x0 je 0x25c mov eax , dword ptr [ ebp - 0x20 ] lea edx , [ eax * 0x4 ] mov eax , dword ptr [ ebp - 0x28 ] add edx , eax mov eax , dword ptr [ ebp + 0x10 ] mov ecx , dword ptr [ ebp - 0x1c ] add ecx , 0x4 mov eax , dword ptr [ eax + ecx * 0x8 + 0x4 ] mov dword ptr [ edx ] , eax jmp 0x25c add dword ptr [ ebp - 0x1c ] , 0x1 mov eax , dword ptr [ ebp - 0x1c ] cmp eax , dword ptr [ ebp - 0x14 ] jl 0x208 jmp 0x25d nop mov eax , dword ptr [ ebp - 0x1c ] cmp eax , dword ptr [ ebp - 0x14 ] je 0x27d add dword ptr [ ebp - 0x20 ] , 0x1 mov eax , dword ptr [ ebp - 0x20 ] cmp eax , dword ptr [ ebp - 0x14 ] jl 0x173 jmp 0x27e nop jmp 0x27e nop jmp 0x27e nop mov eax , dword ptr [ ebp - 0x20 ] cmp eax , dword ptr [ ebp - 0x14 ] je 0x29e mov eax , dword ptr [ ebp - 0x2c ] mov eax , dword ptr [ eax + 0x14 ] mov dword ptr [ ebp - 0x2c ] , eax cmp dword ptr [ ebp - 0x2c ] , 0x0 jne 0xdd jmp 0x29f nop jmp 0x29f nop cmp dword ptr [ ebp - 0x2c ] , 0x0 jne 0x2ef mov eax , dword ptr [ ebp + 0x8 ] movzx eax , byte ptr [ eax + 0x96 ] test al , al jne 0x2d4 mov eax , dword ptr [ ebp + 0x10 ] mov edx , dword ptr [ eax + 0x8 ] mov eax , dword ptr [ ebp + 0x10 ] mov eax , dword ptr [ eax ] mov eax , dword ptr [ eax ] push edx push eax lea eax , [ ebx - 0x2116c ] push eax push dword ptr [ ebp + 0x8 ] call 0xfff9a798 add esp , 0x10 mov eax , dword ptr [ ebp + 0x8 ] mov eax , dword ptr [ eax ] sub esp , 0x8 push dword ptr [ ebp - 0x28 ] push eax call 0xfff95c2d add esp , 0x10 mov eax , 0x1 jmp 0x2fc mov eax , dword ptr [ ebp + 0x14 ] mov edx , dword ptr [ ebp - 0x2c ] mov dword ptr [ eax ] , edx mov eax , 0x0 mov ebx , dword ptr [ ebp - 0x4 ] leave ret
Code2: lui gp , 0xb addiu gp , gp , - 0x29d0 addu gp , gp , t9 addiu sp , sp , - 0x50 sw ra , 0x4c ( sp ) sw fp , 0x48 ( sp ) sw s7 , 0x44 ( sp ) sw s6 , 0x40 ( sp ) sw s5 , 0x3c ( sp ) sw s4 , 0x38 ( sp ) sw s3 , 0x34 ( sp ) sw s2 , 0x30 ( sp ) sw s1 , 0x2c ( sp ) sw s0 , 0x28 ( sp ) sw gp , 0x10 ( sp ) sw a0 , 0x50 ( sp ) sw a2 , 0x58 ( sp ) sw a3 , 0x5c ( sp ) lw s5 , 0x14 ( a2 ) lw v0 , 0x28 ( a2 ) sw v0 , 0x24 ( sp ) addiu v0 , zero , 0x1 beq s5 , v0 , 0xa0 move fp , a1 lw v0 , 0x60 ( sp ) beqz v0 , 0xf4 move a2 , zero sll a3 , s5 , 0x2 lw v0 , 0x50 ( sp ) lw a0 , ( v0 ) lw t9 , - 0x7f9c ( gp ) addiu t9 , t9 , 0x7604 bal - 0x1966c nop lw gp , 0x10 ( sp ) beqz v0 , 0x358 sw v0 , 0x20 ( sp ) lw v1 , 0x60 ( sp ) b 0xf8 sw v0 , ( v1 ) lh v0 , 0x28 ( a1 ) bltz v0 , 0xec lw a1 , 0x24 ( sp ) beqz a1 , 0x350 lw t9 , - 0x7fd8 ( gp ) lw a0 , 0x4 ( fp ) sll v1 , v0 , 0x2 addu v0 , v1 , v0 sll v0 , v0 , 0x2 addu v0 , a0 , v0 lw a0 , ( v0 ) addiu t9 , t9 , 0x6e6c jalr t9 nop lw gp , 0x10 ( sp ) beqz v0 , 0x1c4 lw ra , 0x4c ( sp ) b 0xf8 sw zero , 0x20 ( sp ) b 0xf8 sw zero , 0x20 ( sp ) sw zero , 0x20 ( sp ) lw s0 , 0x8 ( fp ) beqz s0 , 0x2e0 lw v0 , - 0x7fcc ( gp ) addiu v0 , v0 , 0x35b4 sw v0 , 0x1c ( sp ) lw s4 , - 0x7fd8 ( gp ) b 0x134 addiu s4 , s4 , 0x6e6c lbu v1 , 0x37 ( s0 ) andi v1 , v1 , 0xc0 beq v1 , a0 , 0x180 lw a1 , 0x20 ( sp ) lw s0 , 0x14 ( s0 ) beqz s0 , 0x2e4 lw v0 , 0x50 ( sp ) lhu v0 , 0x32 ( s0 ) bne v0 , s5 , 0x128 move s3 , v0 lbu v1 , 0x36 ( s0 ) beqz v1 , 0x128 nop lw v1 , 0x24 ( s0 ) bnez v1 , 0x128 lw v1 , 0x24 ( sp ) beqz v1 , 0x118 addiu a0 , zero , 0x80 blez s5 , 0x2c8 move s6 , zero lw v0 , 0x4 ( s0 ) lh v0 , ( v0 ) bgez v0 , 0x240 nop b 0x2c8 nop beqz a1 , 0x1b0 move v1 , a1 blez v0 , 0x1b0 sll v0 , v0 , 0x2 lw a0 , 0x58 ( sp ) addiu a0 , a0 , 0x24 addu v0 , v0 , a1 lw a1 , ( a0 ) sw a1 , ( v1 ) addiu v1 , v1 , 0x4 bne v1 , v0 , 0x19c addiu a0 , a0 , 0x8 beqz s0 , 0x2e0 lw v0 , 0x5c ( sp ) sw s0 , ( v0 ) move v0 , zero lw ra , 0x4c ( sp ) lw fp , 0x48 ( sp ) lw s7 , 0x44 ( sp ) lw s6 , 0x40 ( sp ) lw s5 , 0x3c ( sp ) lw s4 , 0x38 ( sp ) lw s3 , 0x34 ( sp ) lw s2 , 0x30 ( sp ) lw s1 , 0x2c ( sp ) lw s0 , 0x28 ( sp ) jr ra addiu sp , sp , 0x50 beqz a0 , 0x214 addiu v0 , s1 , 0x4 sll v0 , v0 , 0x3 lw v1 , 0x58 ( sp ) addu v0 , v1 , v0 lw v1 , 0x4 ( v0 ) lw v0 , 0x18 ( sp ) addu v0 , a0 , v0 sw v1 , ( v0 ) beq s5 , s1 , 0x2c8 nop addiu s6 , s6 , 0x1 beq s3 , s6 , 0x1b0 nop lw v0 , 0x4 ( s0 ) sll v1 , s6 , 0x1 addu v0 , v0 , v1 lh v0 , ( v0 ) bltz v0 , 0x128 nop sll s2 , v0 , 0x2 addu s2 , s2 , v0 sll v0 , s2 , 0x2 lw s2 , 0x4 ( fp ) addu s2 , s2 , v0 lw a1 , 0x8 ( s2 ) lw v0 , 0x1c ( sp ) movz a1 , v0 , a1 sll v0 , s6 , 0x2 move v1 , v0 sw v0 , 0x18 ( sp ) lw v0 , 0x20 ( s0 ) addu v0 , v0 , v1 lw a0 , ( v0 ) move t9 , s4 jalr t9 nop lw gp , 0x10 ( sp ) bnez v0 , 0x2c8 move s1 , v0 lw s7 , ( s2 ) lw v0 , 0x58 ( sp ) addiu s2 , v0 , 0x28 move a1 , s7 lw a0 , ( s2 ) move t9 , s4 jalr t9 nop lw gp , 0x10 ( sp ) beqz v0 , 0x1f0 lw a0 , 0x20 ( sp ) addiu s1 , s1 , 0x1 bne s3 , s1 , 0x29c addiu s2 , s2 , 0x8 bne s5 , s6 , 0x128 nop b 0x1b0 nop b 0x2c8 move s6 , zero lw v0 , 0x50 ( sp ) lbu v0 , 0x96 ( v0 ) beqz v0 , 0x318 lw a1 , - 0x7fcc ( gp ) lw a1 , 0x20 ( sp ) lw v0 , 0x50 ( sp ) lw a0 , ( v0 ) lw t9 , - 0x7f9c ( gp ) addiu t9 , t9 , - 0x2eec jalr t9 nop lw gp , 0x10 ( sp ) b 0x1c0 addiu v0 , zero , 0x1 lw v0 , 0x58 ( sp ) lw v0 , ( v0 ) lw v1 , 0x58 ( sp ) lw a3 , 0x8 ( v1 ) lw a2 , ( v0 ) addiu a1 , a1 , - 0x731c lw a0 , 0x50 ( sp ) lw t9 , - 0x7fb0 ( gp ) addiu t9 , t9 , - 0x2b28 bal - 0x3798 nop lw gp , 0x10 ( sp ) b 0x2f4 lw a1 , 0x20 ( sp ) b 0x1c0 move v0 , zero b 0x1c0 addiu v0 , zero , 0x1
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly codes are for fundamentally different architectures (x86 vs MIPS) with no discernible functional or structural similarities. Key differences include:
- Instruction sets: x86 uses instructions like `push`, `mov`, `call`, while MIPS uses `lui`, `addiu`, `sw`, `jalr`
- Register conventions: x86 relies on ebp/esp/ebx/eax, while MIPS uses gp/sp/ra/t9
- Control flow: x86 uses `jne`/`je` jumps with hex offsets, MIPS uses branches like `beq`/`bnez` with labels
- Stack management: Different prologues/epilogues and stack adjustment methods
- Calling conventions: Parameter passing and function calls differ significantly
- No overlapping logic blocks, data handling patterns, or algorithmic flows were identified

The architectural divergence and lack of shared patterns result in no meaningful similarity.
------------------------------------------------------------

------------------------------------------------------------
Code1: push r15 push r14 movabs rax , 0x3fffffffffffffff push r13 push r12 mov r15 , rdi push rbp push rbx mov r12 , rsi mov rbp , rcx sub rsp , 0x38 cmp rcx , rax mov qword ptr [ rsp + 0x10 ] , rdx jbe 0xdf lea rax , [ rdi + 0x58 ] mov rsi , rdx lea rdi , [ rdi + 0x28 ] mov qword ptr [ rsp + 0x20 ] , r12 mov qword ptr [ rsp + 0x28 ] , rcx mov qword ptr [ rsp + 0x8 ] , rax movabs rax , 0xc000000000000000 mov r14 , rdi add rax , rcx shr rax , 0x3e mov qword ptr [ rsp + 0x18 ] , rax shl rax , 0x3e mov rdx , rax movabs rax , 0x4000000000000000 add rdx , r12 mov r13 , rax add rdx , rax mov rax , r15 mov r15 , r12 mov rbp , rdx mov r12 , rsi mov rbx , rax mov rcx , qword ptr [ rbx + 0x78 ] mov r9 , qword ptr [ rsp + 0x8 ] mov rsi , r15 mov rdi , r12 mov r8 , r14 mov rdx , r13 add r15 , r13 add r12 , r13 call 0x18370 cmp r15 , rbp jne 0x8b mov rbp , qword ptr [ rsp + 0x28 ] movabs rax , 0x3fffffffffffffff mov r12 , qword ptr [ rsp + 0x20 ] mov r15 , rbx and rbp , rax mov rax , qword ptr [ rsp + 0x18 ] add rax , 0x1 shl rax , 0x3e add qword ptr [ rsp + 0x10 ] , rax add r12 , rax test rbp , rbp je 0x100 mov rcx , qword ptr [ r15 + 0x78 ] lea r9 , [ r15 + 0x58 ] lea r8 , [ r15 + 0x28 ] mov rdi , qword ptr [ rsp + 0x10 ] mov rdx , rbp mov rsi , r12 call 0x18370 add rsp , 0x38 mov eax , 0x1 pop rbx pop rbp pop r12 pop r13 pop r14 pop r15 ret nop nop word ptr cs : [ rax + rax ]
Code2: lui gp , 0x6c addiu sp , sp , - 0x48 lui v0 , 0x4000 addiu gp , gp , 0x3de0 sltu v0 , a3 , v0 sw s4 , 0x30 ( sp ) sw s3 , 0x2c ( sp ) move s4 , a3 sw s2 , 0x28 ( sp ) move s3 , a1 sw ra , 0x44 ( sp ) move s2 , a0 sw fp , 0x40 ( sp ) sw s7 , 0x3c ( sp ) sw s6 , 0x38 ( sp ) sw s5 , 0x34 ( sp ) sw s1 , 0x24 ( sp ) sw s0 , 0x20 ( sp ) sw gp , 0x18 ( sp ) bnez v0 , 0x12c sw a2 , 0x50 ( sp ) addiu s7 , a0 , 0x20 addiu s6 , a0 , 0x50 lui s5 , 0xc000 move fp , a3 move s1 , a2 move s0 , a1 lw a3 , 0x60 ( s2 ) lui a2 , 0x4000 lw t9 , - 0x5630 ( gp ) move a0 , s1 move a1 , s0 sw s6 , 0x14 ( sp ) sw s7 , 0x10 ( sp ) bal 0x1cd70 addu fp , fp , s5 lui v0 , 0x4000 lw gp , 0x18 ( sp ) sltu a0 , fp , v0 addu s1 , s1 , v0 beqz a0 , 0x6c addu s0 , s0 , v0 subu v0 , s4 , v0 lw v1 , 0x50 ( sp ) ext a2 , s4 , 0x0 , 0x1e srl v0 , v0 , 0x1e addiu v0 , v0 , 0x1 sll v0 , v0 , 0x1e addu v1 , v1 , v0 addu s3 , s3 , v0 sw v1 , 0x50 ( sp ) beqz a2 , 0xfc lw ra , 0x44 ( sp ) lw a3 , 0x60 ( s2 ) addiu v0 , s2 , 0x50 lw t9 , - 0x5630 ( gp ) addiu v1 , s2 , 0x20 lw a0 , 0x50 ( sp ) move a1 , s3 sw v0 , 0x14 ( sp ) bal 0x1cd70 sw v1 , 0x10 ( sp ) lw ra , 0x44 ( sp ) addiu v0 , zero , 0x1 lw fp , 0x40 ( sp ) lw s7 , 0x3c ( sp ) lw s6 , 0x38 ( sp ) lw s5 , 0x34 ( sp ) lw s4 , 0x30 ( sp ) lw s3 , 0x2c ( sp ) lw s2 , 0x28 ( sp ) lw s1 , 0x24 ( sp ) lw s0 , 0x20 ( sp ) jr ra addiu sp , sp , 0x48 b 0xcc move a2 , a3
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly codes are fundamentally dissimilar due to architectural differences (x86_64 vs MIPS), completely distinct instruction sets, and lack of overlapping operations. The first code uses x86_64-specific registers (rax, rdi, rsi) and instructions (push, movabs, call), while the second uses MIPS-specific conventions (lui, addiu, sw, bal) and registers (gp, sp, v0). No structural or functional correspondence exists in register usage, constant values, or control flow patterns. The operations (e.g., stack management and function calls) differ syntactically and semantically, with no translatable logic between architectures.
------------------------------------------------------------

------------------------------------------------------------
Code1: push rbp mov rbp , rsp sub rsp , 0x50 mov qword ptr [ rbp - 0x28 ] , rdi mov qword ptr [ rbp - 0x30 ] , rsi mov qword ptr [ rbp - 0x38 ] , rdx mov dword ptr [ rbp - 0x3c ] , ecx mov qword ptr [ rbp - 0x48 ] , r8 mov dword ptr [ rbp - 0x40 ] , r9d mov dword ptr [ rbp - 0xc ] , 0x0 mov dword ptr [ rbp - 0x14 ] , 0x0 jmp 0xeb mov dword ptr [ rbp - 0x10 ] , 0x0 jmp 0xc8 mov edx , dword ptr [ rbp - 0x14 ] mov rax , qword ptr [ rbp - 0x38 ] add rax , rdx movzx edx , byte ptr [ rax ] mov ecx , dword ptr [ rbp - 0x10 ] mov rax , qword ptr [ rbp - 0x48 ] add rax , rcx movzx eax , byte ptr [ rax ] cmp dl , al jne 0xb1 mov edx , dword ptr [ rbp - 0x14 ] mov rax , qword ptr [ rbp - 0x38 ] add rax , rdx movzx eax , byte ptr [ rax ] movzx eax , al mov edx , dword ptr [ rbp - 0x10 ] add edx , 0x1 mov ecx , edx mov rdx , qword ptr [ rbp - 0x48 ] lea rsi , [ rcx + rdx ] mov edx , dword ptr [ rbp - 0x14 ] add edx , 0x1 mov ecx , edx mov rdx , qword ptr [ rbp - 0x38 ] add rcx , rdx mov rdx , rax mov rdi , rcx call 0xfffffffffff67621 test eax , eax jne 0xb1 mov edx , dword ptr [ rbp - 0x14 ] mov rax , qword ptr [ rbp - 0x38 ] add rax , rdx mov qword ptr [ rbp - 0x8 ] , rax mov dword ptr [ rbp - 0xc ] , 0x1 jmp 0x106 mov edx , dword ptr [ rbp - 0x10 ] mov rax , qword ptr [ rbp - 0x48 ] add rax , rdx movzx eax , byte ptr [ rax ] movzx eax , al add dword ptr [ rbp - 0x10 ] , eax add dword ptr [ rbp - 0x10 ] , 0x1 mov eax , dword ptr [ rbp - 0x10 ] cmp eax , dword ptr [ rbp - 0x40 ] jb 0x3e mov edx , dword ptr [ rbp - 0x14 ] mov rax , qword ptr [ rbp - 0x38 ] add rax , rdx movzx eax , byte ptr [ rax ] movzx eax , al add dword ptr [ rbp - 0x14 ] , eax add dword ptr [ rbp - 0x14 ] , 0x1 mov eax , dword ptr [ rbp - 0x14 ] cmp eax , dword ptr [ rbp - 0x3c ] jb 0x32 mov rax , qword ptr [ rbp - 0x48 ] mov qword ptr [ rbp - 0x8 ] , rax mov dword ptr [ rbp - 0xc ] , 0x2 mov rax , qword ptr [ rbp - 0x8 ] lea rdx , [ rax + 0x1 ] mov rax , qword ptr [ rbp - 0x28 ] mov qword ptr [ rax ] , rdx mov rax , qword ptr [ rbp - 0x8 ] movzx edx , byte ptr [ rax ] mov rax , qword ptr [ rbp - 0x30 ] mov byte ptr [ rax ] , dl mov eax , dword ptr [ rbp - 0xc ] leave ret
Code2: push { r4 , r5 , r6 , r7 , r8 , sb , sl , fp , lr } sub sp , sp , 0x14 str r0 , [ sp , 0x8 ] str r1 , [ sp , 0xc ] ldr r7 , [ sp , 0x38 ] ldr r8 , [ sp , 0x3c ] cmp r3 , 0x0 str r3 , [ sp , 0x4 ] streq r7 , [ sp ] moveq r0 , 0x2 beq 0x74 mov fp , r2 mov sb , 0x0 b 0xb0 add r4 , r4 , 0x1 add r5 , r5 , r4 cmp r8 , r5 bls 0x98 ldrb r4 , [ r7 , r5 ] cmp r6 , r4 bne 0x38 add r1 , r5 , 0x1 mov r2 , r6 add r1 , r7 , r1 mov r0 , sl bl 0xfff934bc cmp r0 , 0x0 bne 0x38 mov r0 , 0x1 ldr r2 , [ sp ] add r3 , r2 , 0x1 ldr r1 , [ sp , 0x8 ] str r3 , [ r1 ] ldrb r3 , [ r2 ] ldr r2 , [ sp , 0xc ] strb r3 , [ r2 ] add sp , sp , 0x14 pop { r4 , r5 , r6 , r7 , r8 , sb , sl , fp , pc } ldrb r3 , [ fp , sb ] add r3 , r3 , 0x1 add sb , sb , r3 ldr r3 , [ sp , 0x4 ] cmp r3 , sb bls 0xd4 cmp r8 , 0x0 beq 0x98 add r3 , fp , sb str r3 , [ sp ] ldrb r6 , [ fp , sb ] mov r5 , 0x0 add sl , sb , 0x1 add sl , fp , sl b 0x48 str r7 , [ sp ] mov r0 , 0x2 b 0x74
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The first code is for x86_64 architecture, using registers like rbp, rsp, and instructions such as mov, jmp, and call. The second code is for ARM architecture, using registers like r0-r8, and instructions like ldr, str, cmp, and b. The fundamental differences in instruction sets, register usage, and stack handling make the codes entirely dissimilar at the assembly level.
------------------------------------------------------------

------------------------------------------------------------
Code1: mov eax , dword ptr [ rip ] test eax , eax jne 0x13b mov al , byte ptr [ rip ] xor al , 0x3f mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x8 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xc mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x24 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x78 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xa0 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x28 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xf1 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x37 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x1b mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x3e mov byte ptr [ rip ] , al movaps xmm0 , xmmword ptr [ rip ] xorps xmm0 , xmmword ptr [ rip ] movaps xmmword ptr [ rip ] , xmm0 mov al , byte ptr [ rip ] xor al , 0x79 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x64 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xc0 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x82 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x16 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x4e mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x39 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x4d mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xfe mov byte ptr [ rip ] , al mov dword ptr [ rip ] , 0x1 test rdi , rdi je 0x19a movabs rax , 0xcbbb9d5dc1059ed8 movq xmm0 , rax pslldq xmm0 , 0x8 movdqu xmmword ptr [ rdi ] , xmm0 movaps xmm0 , xmmword ptr [ rip ] movups xmmword ptr [ rdi + 0x10 ] , xmm0 movaps xmm0 , xmmword ptr [ rip ] movups xmmword ptr [ rdi + 0x20 ] , xmm0 movaps xmm0 , xmmword ptr [ rip ] movups xmmword ptr [ rdi + 0x30 ] , xmm0 movabs rax , 0x47b5481dbefa4fa4 movq xmm0 , rax movdqu xmmword ptr [ rdi + 0x40 ] , xmm0 xor eax , eax ret push rax mov edi , 0x0 mov esi , 0x0 mov edx , 0x2b call 0x1af nop
Code2: beqz a0 , 0xe0 move a3 , zero sw zero , 0x48 ( a0 ) move a2 , zero lui t0 , 0xcbbb sw a3 , 0x4 ( a0 ) lui v1 , 0xc105 sw a2 , ( a0 ) ori t1 , t0 , 0x9d5d lui t2 , 0x367c sw t1 , 0x8 ( a0 ) lui t4 , 0x629a lui t6 , 0x3070 lui t8 , 0x9159 lui a3 , 0xf70e lui a2 , 0x152f lui t0 , 0xffc0 ori a1 , v1 , 0x9ed8 ori t3 , t2 , 0xd507 sw a1 , 0xc ( a0 ) ori t5 , t4 , 0x292a sw t3 , 0x14 ( a0 ) ori t7 , t6 , 0xdd17 sw t5 , 0x10 ( a0 ) ori t9 , t8 , 0x15a sw t7 , 0x1c ( a0 ) ori v1 , a3 , 0x5939 sw t9 , 0x18 ( a0 ) ori a1 , a2 , 0xecd8 sw v1 , 0x24 ( a0 ) ori t1 , t0 , 0xb31 sw a1 , 0x20 ( a0 ) lui t2 , 0x6733 sw t1 , 0x2c ( a0 ) lui t4 , 0x6858 lui t6 , 0x8eb4 lui t8 , 0x64f9 lui a3 , 0xdb0c lui a2 , 0xbefa lui t0 , 0x47b5 ori t3 , t2 , 0x2667 ori t5 , t4 , 0x1511 sw t3 , 0x28 ( a0 ) ori t7 , t6 , 0x4a87 sw t5 , 0x34 ( a0 ) ori t9 , t8 , 0x8fa7 sw t7 , 0x30 ( a0 ) ori v1 , a3 , 0x2e0d sw t9 , 0x3c ( a0 ) ori a1 , a2 , 0x4fa4 sw v1 , 0x38 ( a0 ) ori t1 , t0 , 0x481d sw a1 , 0x44 ( a0 ) move v0 , zero jr ra sw t1 , 0x40 ( a0 ) lui gp , 0x0 addiu sp , sp , - 0x20 addiu gp , gp , 0x0 lui v0 , 0x0 lui a0 , 0x0 sw ra , 0x1c ( sp ) sw gp , 0x10 ( sp ) addiu a2 , zero , 0x2b lw t9 , ( gp ) addiu a1 , v0 , 0x0 jalr t9 addiu a0 , a0 , 0x0
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two code snippets are for different architectures (x86-64 and MIPS) and implement entirely different functionality. The first code performs a series of byte-level XOR operations and SIMD operations, while the second code builds 32-bit constants and stores them to memory. There is no discernible similarity in the operations, structure, or purpose of the code.
------------------------------------------------------------

------------------------------------------------------------
Code1: push ebp push edi push esi push ebx sub esp , 0xbc call 0xfff9e2de add ebx , 0x2028ab mov eax , dword ptr [ esp + 0xd0 ] mov dword ptr [ esp + 0x18 ] , eax mov eax , dword ptr [ esp + 0xd4 ] mov dword ptr [ esp + 0x14 ] , eax mov ebp , dword ptr [ esp + 0xd8 ] mov ecx , dword ptr gs : [ 0x14 ] mov dword ptr [ esp + 0xac ] , ecx xor ecx , ecx mov eax , dword ptr [ eax + 0x4 ] mov dword ptr [ esp + 0x8 ] , eax sub eax , ebp mov dword ptr [ esp + 0xc ] , eax cmp ebp , dword ptr [ esp + 0xdc ] ja 0x19e cmp ebp , 0x40 ja 0x1c1 lea edx , [ esp + 0x2c ] mov eax , edx neg eax and eax , 0x3f lea ecx , [ edx + eax ] mov dword ptr [ esp + 0x10 ] , ecx lea eax , [ ebp + 0x100 ] mov edi , dword ptr [ esp + 0xdc ] sub edi , 0x100 sub edi , ebp cmp eax , dword ptr [ esp + 0xdc ] mov eax , 0x0 cmovae edi , eax mov eax , ebp shr eax , 0x1 shl eax , 0x18 add eax , dword ptr [ esp + 0xc ] sub eax , edi mov edx , 0x0 div ebp mov esi , edx sub esp , 0x4 push ebp push 0x0 push ecx call 0xfff9df8e add esp , 0x10 cmp edi , dword ptr [ esp + 0xdc ] jae 0x146 mov eax , dword ptr [ esp + 0x14 ] mov eax , dword ptr [ eax + 0xc ] mov dword ptr [ esp + 0x14 ] , eax mov ebx , 0x0 mov dword ptr [ esp + 0x1c ] , esi mov esi , dword ptr [ esp + 0x8 ] lea ecx , [ ebx + 0x1 ] mov eax , edi mov edx , dword ptr [ esp + 0xc ] sub eax , edx xor eax , edx xor edx , edi or eax , edx xor eax , edi sar eax , 0x1f not eax mov edx , dword ptr [ esp + 0x14 ] and al , byte ptr [ edx + edi ] mov byte ptr [ esp + 0x8 ] , al mov edx , edi sub edx , esi xor edx , esi mov eax , esi xor eax , edi or edx , eax xor edx , edi sar edx , 0x1f movzx eax , byte ptr [ esp + 0x8 ] and eax , edx mov edx , dword ptr [ esp + 0x10 ] or byte ptr [ edx + ebx ] , al mov ebx , ecx sub ebx , ebp xor ebx , ebp mov eax , ebp xor eax , ecx or ebx , eax xor ebx , ecx sar ebx , 0x1f and ebx , ecx add edi , 0x1 cmp dword ptr [ esp + 0xdc ] , edi jne 0xe1 mov esi , dword ptr [ esp + 0x1c ] test ebp , ebp je 0x183 mov ebx , dword ptr [ esp + 0x18 ] mov ecx , ebx add ebx , ebp mov edi , dword ptr [ esp + 0x10 ] mov eax , esi xor eax , 0x20 add eax , edi movzx eax , byte ptr [ eax ] lea eax , [ esi + 0x1 ] movzx edx , byte ptr [ edi + esi ] mov byte ptr [ ecx ] , dl mov esi , eax sub esi , ebp xor esi , ebp mov edx , ebp xor edx , eax or esi , edx xor esi , eax sar esi , 0x1f and esi , eax add ecx , 0x1 cmp ebx , ecx jne 0x156 mov eax , dword ptr [ esp + 0xac ] xor eax , dword ptr gs : [ 0x14 ] jne 0x1e4 add esp , 0xbc pop ebx pop esi pop edi pop ebp ret sub esp , 0x4 lea eax , [ ebx - 0xe722b ] push eax push 0xf8 lea eax , [ ebx - 0xe7217 ] push eax call 0x22ea8 add esp , 0x10 jmp 0x5c sub esp , 0x4 lea eax , [ ebx - 0xe720e ] push eax push 0xf9 lea eax , [ ebx - 0xe7217 ] push eax call 0x22ea8 add esp , 0x10 jmp 0x65 call 0x10645e
Code2: push rbp mov rbp , rsp sub rsp , 0xf0 mov qword ptr [ rbp - 0x8 ] , rdi mov qword ptr [ rbp - 0x10 ] , rsi mov dword ptr [ rbp - 0x14 ] , edx mov dword ptr [ rbp - 0x18 ] , ecx mov rsi , qword ptr [ rbp - 0x10 ] mov ecx , dword ptr [ rsi + 0x4 ] mov dword ptr [ rbp - 0xac ] , ecx mov ecx , dword ptr [ rbp - 0xac ] mov edx , dword ptr [ rbp - 0x14 ] sub ecx , edx mov dword ptr [ rbp - 0xb0 ] , ecx mov dword ptr [ rbp - 0xb4 ] , 0x0 mov ecx , dword ptr [ rbp - 0x18 ] mov edx , dword ptr [ rbp - 0x14 ] sub ecx , edx setae al movzx edx , al mov esi , edx mov rsi , qword ptr [ rsi * 0x8 + 0x98fe00 ] mov dword ptr [ rbp - 0xcc ] , ecx jmp rsi mov rax , qword ptr [ rip + 0x4ea570 ] jmp rax mov edi , 0x6c2208 mov edx , 0x6c2211 mov esi , 0xf8 call 0x461c0 mov rdx , qword ptr [ rip + 0x4ea553 ] jmp rdx mov eax , dword ptr [ rbp - 0x14 ] sub eax , 0x41 setb cl movzx edx , cl mov esi , edx mov rsi , qword ptr [ rsi * 0x8 + 0x98fe10 ] mov dword ptr [ rbp - 0xd0 ] , eax jmp rsi mov rax , qword ptr [ rip + 0x4ea544 ] jmp rax mov edi , 0x6c2208 mov edx , 0x6eb376 mov esi , 0xf9 call 0x461c0 mov rdx , qword ptr [ rip + 0x4ea527 ] jmp rdx lea rax , [ rbp - 0xa0 ] mov ecx , eax neg ecx mov eax , ecx mov ecx , eax and ecx , 0x30 mov eax , ecx lea rax , [ rbp + rax - 0xa0 ] mov qword ptr [ rbp - 0xa8 ] , rax mov ecx , dword ptr [ rbp - 0x18 ] mov edx , dword ptr [ rbp - 0x14 ] add edx , 0x100 sub ecx , edx seta sil movzx edx , sil mov eax , edx mov rax , qword ptr [ rax * 0x8 + 0x98fe20 ] mov dword ptr [ rbp - 0xd4 ] , ecx jmp rax mov eax , dword ptr [ rbp - 0x18 ] mov ecx , dword ptr [ rbp - 0x14 ] add ecx , 0x100 sub eax , ecx mov dword ptr [ rbp - 0xb4 ] , eax mov rdx , qword ptr [ rip + 0x4ea4cf ] jmp rdx mov eax , dword ptr [ rbp - 0x14 ] shr eax , 0x1 mov dword ptr [ rbp - 0xc0 ] , eax mov eax , dword ptr [ rbp - 0xc0 ] shl eax , 0x18 mov dword ptr [ rbp - 0xc0 ] , eax mov eax , dword ptr [ rbp - 0xc0 ] mov ecx , dword ptr [ rbp - 0xb0 ] add eax , ecx mov ecx , dword ptr [ rbp - 0xb4 ] sub eax , ecx mov ecx , dword ptr [ rbp - 0x14 ] xor edx , edx div ecx mov dword ptr [ rbp - 0xc4 ] , edx mov rdi , qword ptr [ rbp - 0xa8 ] mov eax , dword ptr [ rbp - 0x14 ] mov edx , eax xor esi , esi call 0xfffffffffff5ce50 mov ecx , dword ptr [ rbp - 0xb4 ] mov dword ptr [ rbp - 0xb8 ] , ecx mov dword ptr [ rbp - 0xbc ] , 0x0 mov rdx , qword ptr [ rip + 0x4ea468 ] mov qword ptr [ rbp - 0xe0 ] , rax jmp rdx mov eax , dword ptr [ rbp - 0xb8 ] mov ecx , dword ptr [ rbp - 0x18 ] sub eax , ecx setb dl movzx ecx , dl mov esi , ecx mov rsi , qword ptr [ rsi * 0x8 + 0x98fe30 ] mov dword ptr [ rbp - 0xe4 ] , eax jmp rsi mov edi , dword ptr [ rbp - 0xb8 ] mov esi , dword ptr [ rbp - 0xb0 ] call 0xffffffffffffffa0 mov byte ptr [ rbp - 0xc5 ] , al mov edi , dword ptr [ rbp - 0xb8 ] mov esi , dword ptr [ rbp - 0xac ] call 0xffffffffffffffa0 mov byte ptr [ rbp - 0xc6 ] , al mov rcx , qword ptr [ rbp - 0x10 ] mov rcx , qword ptr [ rcx + 0x10 ] mov esi , dword ptr [ rbp - 0xb8 ] mov edx , esi mov al , byte ptr [ rcx + rdx ] mov byte ptr [ rbp - 0xc7 ] , al movzx esi , byte ptr [ rbp - 0xc7 ] movzx edi , byte ptr [ rbp - 0xc5 ] and esi , edi movzx edi , byte ptr [ rbp - 0xc6 ] not edi and esi , edi mov rcx , qword ptr [ rbp - 0xa8 ] mov edi , dword ptr [ rbp - 0xbc ] mov edx , edi mov edi , edx add edi , 0x1 mov dword ptr [ rbp - 0xbc ] , edi movzx edi , byte ptr [ rcx + rdx ] or edi , esi mov al , dil mov byte ptr [ rcx + rdx ] , al mov edi , dword ptr [ rbp - 0xbc ] mov esi , dword ptr [ rbp - 0x14 ] call 0x370 mov esi , dword ptr [ rbp - 0xbc ] and esi , eax mov dword ptr [ rbp - 0xbc ] , esi mov rcx , qword ptr [ rip + 0x4ea3a1 ] jmp rcx mov eax , dword ptr [ rbp - 0xb8 ] add eax , 0x1 mov dword ptr [ rbp - 0xb8 ] , eax mov rcx , qword ptr [ rip + 0x4ea379 ] jmp rcx mov dword ptr [ rbp - 0xbc ] , 0x0 mov dword ptr [ rbp - 0xb8 ] , 0x0 mov rax , qword ptr [ rip + 0x4ea37c ] jmp rax mov eax , dword ptr [ rbp - 0xb8 ] mov ecx , dword ptr [ rbp - 0x14 ] sub eax , ecx setb dl movzx ecx , dl mov esi , ecx mov rsi , qword ptr [ rsi * 0x8 + 0x98fe40 ] mov dword ptr [ rbp - 0xe8 ] , eax jmp rsi mov rax , qword ptr [ rbp - 0xa8 ] mov ecx , dword ptr [ rbp - 0xc4 ] mov edx , ecx xor rdx , 0x20 mov sil , byte ptr [ rax + rdx ] mov rax , qword ptr [ rbp - 0xa8 ] mov ecx , dword ptr [ rbp - 0xc4 ] mov edx , ecx mov ecx , edx add ecx , 0x1 mov dword ptr [ rbp - 0xc4 ] , ecx mov dil , byte ptr [ rax + rdx ] mov rax , qword ptr [ rbp - 0x8 ] mov ecx , dword ptr [ rbp - 0xbc ] mov edx , ecx mov ecx , edx add ecx , 0x1 mov dword ptr [ rbp - 0xbc ] , ecx mov byte ptr [ rax + rdx ] , dil mov edi , dword ptr [ rbp - 0xc4 ] mov ecx , dword ptr [ rbp - 0x14 ] mov byte ptr [ rbp - 0xe9 ] , sil mov esi , ecx call 0x370 mov ecx , dword ptr [ rbp - 0xc4 ] and ecx , eax mov dword ptr [ rbp - 0xc4 ] , ecx mov rdx , qword ptr [ rip + 0x4ea2eb ] jmp rdx mov eax , dword ptr [ rbp - 0xb8 ] add eax , 0x1 mov dword ptr [ rbp - 0xb8 ] , eax mov rcx , qword ptr [ rip + 0x4ea2c3 ] jmp rcx add rsp , 0xf0 pop rbp ret
Similarity: -1
Label: 1
Similarity Score: -0.95
Explanation: The two assembly codes show significant differences in architecture (32-bit vs 64-bit), register usage, and control flow patterns. The first code uses 32-bit registers (ebp, esp, eax) with direct conditional jumps and simpler memory operations, while the second employs 64-bit registers (rbp, rsp, rsi) with complex jump tables and RIP-relative addressing. Key structural differences include stack management (0xbc vs 0xf0 allocation), loop implementations, and absence of shared constants or call targets. Though both manipulate bytes and use bitwise operations, the fundamental architecture divergence and lack of overlapping logic indicate these are functionally distinct routines.
------------------------------------------------------------

------------------------------------------------------------
Code1: sub esp , 0xc mov ecx , dword ptr [ esp + 0x18 ] test ecx , ecx je 0x18 mov edx , dword ptr [ esp + 0x14 ] mov eax , dword ptr [ esp + 0x10 ] call 0xfffffbd0 xor eax , eax add esp , 0xc ret nop
Code2: push r15 push r14 push r13 push r12 push rbx mov r15 , rdx mov r14 , rsi mov r13 , rdi mov eax , dword ptr [ rip ] test eax , eax je 0x2a0 mov dword ptr [ rip ] , 0x1 test r15 , r15 je 0x294 test r13 , r13 je 0x42b test r14 , r14 je 0x43f cmp word ptr [ r13 + 0x19e ] , 0x0 jne 0x171 mov cl , byte ptr [ r13 + 0x198 ] shl cl , 0x3 mov eax , 0x1f shl rax , cl movzx ecx , word ptr [ r13 + 0x19a ] lea rdi , [ r13 + 0x8 ] mov rdx , qword ptr [ r13 + rcx * 0x8 + 0x8 ] xor rdx , qword ptr [ r13 ] xor rdx , rax mov qword ptr [ r13 + rcx * 0x8 + 0x8 ] , rdx movzx eax , word ptr [ r13 + 0x19c ] mov ecx , 0x18 sub rcx , rax movabs rax , 0x8000000000000000 xor qword ptr [ r13 + rcx * 0x8 + 0x8 ] , rax call 0xfffffffffffff4e0 movups xmm0 , xmmword ptr [ r13 + 0x8 ] movups xmm1 , xmmword ptr [ r13 + 0x18 ] movups xmm2 , xmmword ptr [ r13 + 0x28 ] movups xmm3 , xmmword ptr [ r13 + 0x38 ] movups xmmword ptr [ r13 + 0xd0 ] , xmm0 movups xmmword ptr [ r13 + 0xe0 ] , xmm1 movups xmmword ptr [ r13 + 0xf0 ] , xmm2 movups xmmword ptr [ r13 + 0x100 ] , xmm3 movups xmm0 , xmmword ptr [ r13 + 0x48 ] movups xmmword ptr [ r13 + 0x110 ] , xmm0 movups xmm0 , xmmword ptr [ r13 + 0x58 ] movups xmmword ptr [ r13 + 0x120 ] , xmm0 movups xmm0 , xmmword ptr [ r13 + 0x68 ] movups xmmword ptr [ r13 + 0x130 ] , xmm0 movups xmm0 , xmmword ptr [ r13 + 0x78 ] movups xmmword ptr [ r13 + 0x140 ] , xmm0 movups xmm0 , xmmword ptr [ r13 + 0x88 ] movups xmmword ptr [ r13 + 0x150 ] , xmm0 movups xmm0 , xmmword ptr [ r13 + 0x98 ] movups xmmword ptr [ r13 + 0x160 ] , xmm0 movups xmm0 , xmmword ptr [ r13 + 0xa8 ] movups xmm1 , xmmword ptr [ r13 + 0xb8 ] movups xmmword ptr [ r13 + 0x170 ] , xmm0 movups xmmword ptr [ r13 + 0x180 ] , xmm1 mov rax , qword ptr [ r13 + 0xc8 ] mov qword ptr [ r13 + 0x190 ] , rax mov word ptr [ r13 + 0x198 ] , 0x0 mov word ptr [ r13 + 0x19e ] , 0x1 lea r12 , [ r13 + 0x8 ] xor ebx , ebx nop word ptr [ rax + rax ] movzx eax , word ptr [ r13 + 0x198 ] movzx ecx , word ptr [ r13 + 0x19c ] shl ecx , 0x3 mov edx , 0xc8 sub edx , ecx cmp edx , eax jg 0x26c mov rdi , r12 call 0xfffffffffffff4e0 movups xmm0 , xmmword ptr [ r13 + 0x8 ] movups xmm1 , xmmword ptr [ r13 + 0x18 ] movups xmm2 , xmmword ptr [ r13 + 0x28 ] movups xmm3 , xmmword ptr [ r13 + 0x38 ] movups xmmword ptr [ r13 + 0xd0 ] , xmm0 movups xmmword ptr [ r13 + 0xe0 ] , xmm1 movups xmmword ptr [ r13 + 0xf0 ] , xmm2 movups xmmword ptr [ r13 + 0x100 ] , xmm3 movups xmm0 , xmmword ptr [ r13 + 0x48 ] movups xmmword ptr [ r13 + 0x110 ] , xmm0 movups xmm0 , xmmword ptr [ r13 + 0x58 ] movups xmmword ptr [ r13 + 0x120 ] , xmm0 movups xmm0 , xmmword ptr [ r13 + 0x68 ] movups xmmword ptr [ r13 + 0x130 ] , xmm0 movups xmm0 , xmmword ptr [ r13 + 0x78 ] movups xmmword ptr [ r13 + 0x140 ] , xmm0 movups xmm0 , xmmword ptr [ r13 + 0x88 ] movups xmmword ptr [ r13 + 0x150 ] , xmm0 movups xmm0 , xmmword ptr [ r13 + 0x98 ] movups xmmword ptr [ r13 + 0x160 ] , xmm0 movups xmm0 , xmmword ptr [ r13 + 0xa8 ] movups xmm1 , xmmword ptr [ r13 + 0xb8 ] movups xmmword ptr [ r13 + 0x170 ] , xmm0 movups xmmword ptr [ r13 + 0x180 ] , xmm1 mov rax , qword ptr [ r13 + 0xc8 ] mov qword ptr [ r13 + 0x190 ] , rax mov word ptr [ r13 + 0x198 ] , 0x0 xor eax , eax lea ecx , [ rax + 0x1 ] mov word ptr [ r13 + 0x198 ] , cx movzx eax , ax movzx eax , byte ptr [ r13 + rax + 0xd0 ] mov byte ptr [ r14 + rbx ] , al add rbx , 0x1 cmp r15 , rbx jne 0x180 xor eax , eax pop rbx pop r12 pop r13 pop r14 pop r15 ret mov al , byte ptr [ rip ] xor al , 0x92 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xf6 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xa9 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xe6 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x68 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x44 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xc2 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xc6 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xd3 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xc9 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xa7 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xbe mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xc8 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xc8 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x30 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x3d mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x3a mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x56 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x51 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x6e mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xa8 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0xa7 mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x7d movaps xmm0 , xmmword ptr [ rip ] xorps xmm0 , xmmword ptr [ rip ] mov byte ptr [ rip ] , al movaps xmmword ptr [ rip ] , xmm0 mov al , byte ptr [ rip ] xor al , 0x5e mov byte ptr [ rip ] , al mov al , byte ptr [ rip ] xor al , 0x41 mov byte ptr [ rip ] , al mov dword ptr [ rip ] , 0x1 test r15 , r15 jne 0x33 jmp 0x294 mov edi , 0x0 mov esi , 0x0 mov edx , 0x103 call 0x43f mov edi , 0x0 mov esi , 0x0 mov edx , 0x104 call 0x453 nop word ptr cs : [ rax + rax ] nop dword ptr [ rax ]
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly codes show significant differences in architecture, structure, and functionality. Code1 uses 32-bit registers (esp, ecx, edx) and operates with a simple stack-based flow including one conditional jump and a call. Code2 employs 64-bit registers (r15, r14, r13), SIMD instructions (xmm0–xmm3), complex memory operations, multiple loops, and cryptographic-like XOR sequences. The register usage, instruction sets, and structural complexity are fundamentally incompatible, indicating entirely distinct purposes and implementations with no meaningful overlap.
------------------------------------------------------------

------------------------------------------------------------
Code1: push { r4 , r5 , r6 , r7 , r8 , fp , lr } add fp , sp , 0x18 sub sp , sp , 0x94 str r0 , [ fp , - 0xa0 ] ldr r5 , [ pc , 0x640 ] add r5 , pc , r5 ldr r3 , [ pc , 0x63c ] ldr r3 , [ r5 , r3 ] ldr r3 , [ r3 ] str r3 , [ fp , - 0x20 ] ldr r3 , [ fp , - 0xa0 ] ldr r3 , [ r3 , 0x34 ] str r3 , [ fp , - 0x80 ] ldr r3 , [ fp , - 0xa0 ] ldr r3 , [ r3 , 0x30 ] str r3 , [ fp , - 0x7c ] ldr r3 , [ fp , - 0xa0 ] ldr r3 , [ r3 , 0x20 ] str r3 , [ fp , - 0x78 ] ldr r3 , [ fp , - 0xa0 ] ldm r3 , { r3 , r4 } str r3 , [ fp , - 0x3c ] str r4 , [ fp , - 0x38 ] ldr r3 , [ fp , - 0xa0 ] ldr r3 , [ r3 , 0x1c ] str r3 , [ fp , - 0x74 ] ldr r3 , [ fp , - 0xa0 ] ldr r3 , [ r3 , 0x18 ] str r3 , [ fp , - 0x70 ] ldr r3 , [ fp , - 0xa0 ] ldr r3 , [ r3 , 0x14 ] str r3 , [ fp , - 0x6c ] ldr r3 , [ fp , - 0xa0 ] ldr r3 , [ r3 , 0x10 ] str r3 , [ fp , - 0x68 ] ldr r3 , [ fp , - 0xa0 ] ldr r3 , [ r3 , 0xc ] str r3 , [ fp , - 0x64 ] ldr r3 , [ fp , - 0xa0 ] ldr r3 , [ r3 , 0x8 ] str r3 , [ fp , - 0x60 ] ldr r7 , [ fp , - 0x80 ] bl 0xfffa2640 mov r8 , r0 bl 0xfffa3168 mov r6 , r0 mov r1 , r8 mov r0 , r7 bl 0x392d98 mov r3 , r0 mov r4 , r3 mov r1 , r8 mov r0 , r7 bl 0x392fb8 mov r3 , r1 cmp r6 , r3 blt 0x628 mul r2 , r6 , r4 add r3 , r2 , r3 add r4 , r3 , r4 cmp r3 , r4 bge 0x634 str r3 , [ fp , - 0x9c ] ldr r3 , [ fp , - 0xa0 ] ldr r3 , [ r3 , 0x38 ] cmp r3 , 0x0 bne 0x12c mov r0 , r0 ldr r3 , [ fp , - 0x9c ] add r3 , r3 , 0x1 str r3 , [ fp , - 0x9c ] ldr r3 , [ fp , - 0x9c ] cmp r3 , r4 blt 0xfc b 0x634 ldr r3 , [ fp , - 0x68 ] str r3 , [ sp , 0x4 ] mov r3 , 0x1 str r3 , [ sp ] ldr r3 , [ fp , - 0x7c ] ldr r2 , [ fp , - 0x9c ] mov r1 , 0x0 ldr r0 , [ fp , - 0x70 ] bl 0xfffa2da8 mov r3 , r0 str r3 , [ fp , - 0x98 ] ldr r3 , [ fp , - 0x68 ] str r3 , [ sp , 0x4 ] mov r3 , 0x1 str r3 , [ sp ] ldr r3 , [ fp , - 0x7c ] ldr r2 , [ fp , - 0x9c ] mov r1 , 0x0 ldr r0 , [ fp , - 0x74 ] bl 0xfffa2da8 mov r3 , r0 str r3 , [ fp , - 0x94 ] ldr r3 , [ fp , - 0x68 ] str r3 , [ sp , 0x4 ] mov r3 , 0x1 str r3 , [ sp ] ldr r3 , [ fp , - 0x7c ] ldr r2 , [ fp , - 0x9c ] mov r1 , 0x0 ldr r0 , [ fp , - 0x6c ] bl 0xfffa4b24 mov r3 , r0 str r3 , [ fp , - 0x90 ] ldr r3 , [ fp , - 0x98 ] cmp r3 , 0x0 bne 0x1cc ldr r3 , [ fp , - 0xa0 ] mov r2 , 0x0 str r2 , [ r3 , 0x38 ] b 0x110 ldr r3 , [ fp , - 0x94 ] cmp r3 , 0x0 beq 0x1bc ldr r3 , [ fp , - 0x90 ] cmp r3 , 0x0 beq 0x1bc mov r3 , 0x0 str r3 , [ fp , - 0x8c ] mov r0 , r0 ldr r3 , [ fp , - 0x7c ] ldr r2 , [ fp , - 0x8c ] cmp r2 , r3 blt 0x230 ldr r1 , [ fp , - 0x68 ] ldr r0 , [ fp , - 0x6c ] bl 0xfffa3198 mov r3 , r0 str r3 , [ fp , - 0x5c ] ldr r3 , [ fp , - 0x5c ] cmp r3 , 0x0 bne 0x110 ldr r3 , [ fp , - 0xa0 ] mov r2 , 0x0 str r2 , [ r3 , 0x38 ] b 0x110 ldr r1 , [ fp , - 0x98 ] ldr r0 , [ fp , - 0x60 ] bl 0xffffa4b8 mov r3 , r0 ldr r1 , [ pc , 0x418 ] mov r0 , r3 bl 0x3940c4 mov r3 , r0 cmp r3 , 0x0 bne 0x26c b 0x2dc ldr r3 , [ fp , - 0x8c ] add r3 , r3 , 0x1 str r3 , [ fp , - 0x8c ] b 0x1f0 ldr r3 , [ fp , - 0xa0 ] ldr r3 , [ r3 , 0x2c ] ldr r2 , [ fp , - 0x90 ] mov r1 , r3 ldr r0 , [ fp , - 0x78 ] bl 0xffffa5b0 ldr r0 , [ fp , - 0x60 ] bl 0xffffa3a8 mov r3 , r0 lsl r3 , r3 , 0x2 ldr r2 , [ fp , - 0x98 ] add r3 , r2 , r3 str r3 , [ fp , - 0x98 ] ldr r0 , [ fp , - 0x64 ] bl 0xffffa3a8 mov r3 , r0 lsl r3 , r3 , 0x2 ldr r2 , [ fp , - 0x94 ] add r3 , r2 , r3 str r3 , [ fp , - 0x94 ] ldr r0 , [ fp , - 0x78 ] bl 0xffffa3a8 mov r3 , r0 lsl r3 , r3 , 0x2 ldr r2 , [ fp , - 0x90 ] add r3 , r2 , r3 str r3 , [ fp , - 0x90 ] b 0x25c ldr r1 , [ fp , - 0x94 ] ldr r0 , [ fp , - 0x64 ] bl 0xffffa4b8 mov r3 , r0 ldr r1 , [ pc , 0x36c ] mov r0 , r3 bl 0x3940c4 mov r3 , r0 cmp r3 , 0x0 bne 0x26c mov r3 , 0x0 str r3 , [ fp , - 0x88 ] mov r2 , 0x0 mov r3 , 0x0 str r2 , [ fp , - 0x4c ] str r3 , [ fp , - 0x48 ] ldr r1 , [ fp , - 0x98 ] ldr r0 , [ fp , - 0x60 ] bl 0xffffa220 mov r3 , r0 mov r0 , r3 bl 0x3932dc ldr r2 , [ pc , 0x328 ] ldr r3 , [ pc , 0x328 ] bl 0x393398 mov r2 , r0 mov r3 , r1 str r2 , [ fp , - 0x34 ] str r3 , [ fp , - 0x30 ] ldr r1 , [ fp , - 0x94 ] ldr r0 , [ fp , - 0x64 ] bl 0xffffa220 mov r3 , r0 mov r0 , r3 bl 0x3932dc ldr r2 , [ pc , 0x2f4 ] ldr r3 , [ pc , 0x2f4 ] bl 0x393398 mov r2 , r0 mov r3 , r1 str r2 , [ fp , - 0x2c ] str r3 , [ fp , - 0x28 ] mov r3 , 0x0 str r3 , [ fp , - 0x84 ] mov r0 , r0 ldr r0 , [ fp , - 0x60 ] bl 0xffffa3a8 mov r3 , r0 mov r2 , r3 ldr r3 , [ fp , - 0x84 ] cmp r2 , r3 bgt 0x44c ldr r3 , [ fp , - 0x88 ] cmp r3 , 0x0 beq 0x430 b 0x414 ldr r0 , [ fp , - 0x60 ] bl 0xffffa3a8 mov r3 , r0 lsl r3 , r3 , 0x2 ldr r2 , [ fp , - 0x98 ] add r3 , r2 , r3 str r3 , [ fp , - 0x98 ] ldr r0 , [ fp , - 0x64 ] bl 0xffffa3a8 mov r3 , r0 lsl r3 , r3 , 0x2 ldr r2 , [ fp , - 0x94 ] add r3 , r2 , r3 str r3 , [ fp , - 0x94 ] ldr r0 , [ fp , - 0x78 ] bl 0xffffa3a8 mov r3 , r0 lsl r3 , r3 , 0x2 ldr r2 , [ fp , - 0x90 ] add r3 , r2 , r3 str r3 , [ fp , - 0x90 ] b 0x25c ldr r3 , [ fp , - 0xa0 ] ldr r3 , [ r3 , 0x24 ] ldr r2 , [ fp , - 0x90 ] mov r1 , r3 ldr r0 , [ fp , - 0x78 ] bl 0xffffa5b0 b 0x3bc ldr r3 , [ fp , - 0xa0 ] ldr r3 , [ r3 , 0x28 ] ldr r2 , [ fp , - 0x90 ] mov r1 , r3 ldr r0 , [ fp , - 0x78 ] bl 0xffffa5b0 b 0x3bc ldr r1 , [ fp , - 0x84 ] ldr r0 , [ fp , - 0x60 ] bl 0xffffa318 mov r3 , r0 str r3 , [ fp , - 0x58 ] ldr r1 , [ fp , - 0x58 ] ldr r0 , [ fp , - 0x60 ] bl 0xffffa360 mov r3 , r0 str r3 , [ fp , - 0x54 ] ldr r1 , [ fp , - 0x58 ] ldr r0 , [ fp , - 0x64 ] bl 0xffffa360 mov r3 , r0 str r3 , [ fp , - 0x50 ] ldr r3 , [ fp , - 0x54 ] cmp r3 , 0x0 bne 0x4a8 mov r0 , r0 ldr r3 , [ fp , - 0x84 ] add r3 , r3 , 0x1 str r3 , [ fp , - 0x84 ] b 0x390 ldr r3 , [ fp , - 0x50 ] cmp r3 , 0x0 beq 0x494 ldr r3 , [ fp , - 0x50 ] and r3 , r3 , 0x2 cmp r3 , 0x0 beq 0x494 ldr r3 , [ fp , - 0x58 ] cmp r3 , 0x4 beq 0x5c0 b 0x538 sub r3 , fp , 0x44 ldm r3 , { r2 , r3 } sub r1 , fp , 0x44 ldm r1 , { r0 , r1 } bl 0x393398 mov r2 , r0 mov r3 , r1 sub r1 , fp , 0x4c ldm r1 , { r0 , r1 } bl 0x392fe4 mov r2 , r0 mov r3 , r1 str r2 , [ fp , - 0x4c ] str r3 , [ fp , - 0x48 ] sub r3 , fp , 0x3c ldm r3 , { r2 , r3 } sub r1 , fp , 0x4c ldm r1 , { r0 , r1 } bl 0x39390c mov r3 , r0 cmp r3 , 0x0 beq 0x498 mov r3 , 0x1 str r3 , [ fp , - 0x88 ] b 0x3ac ldr r3 , [ fp , - 0x84 ] lsl r3 , r3 , 0x2 ldr r2 , [ fp , - 0x98 ] add r3 , r2 , r3 ldr r3 , [ r3 ] mov r0 , r3 bl 0x3932dc sub r3 , fp , 0x34 ldm r3 , { r2 , r3 } bl 0x393398 mov r2 , r0 mov r3 , r1 mov r6 , r2 mov r7 , r3 ldr r2 , [ fp , - 0x94 ] ldr r1 , [ fp , - 0x58 ] ldr r0 , [ fp , - 0x64 ] bl 0xffffa288 mov r3 , r0 mov r0 , r3 bl 0x3932dc sub r3 , fp , 0x2c ldm r3 , { r2 , r3 } bl 0x393398 mov r2 , r0 mov r3 , r1 mov r0 , r6 mov r1 , r7 bl 0x392fe0 mov r2 , r0 mov r3 , r1 str r2 , [ fp , - 0x44 ] str r3 , [ fp , - 0x40 ] b 0x4d4 ldr r3 , [ fp , - 0x84 ] lsl r3 , r3 , 0x2 ldr r2 , [ fp , - 0x98 ] add r3 , r2 , r3 ldr r3 , [ r3 ] mov r0 , r3 bl 0x3932dc mov r6 , r0 mov r7 , r1 ldr r2 , [ fp , - 0x94 ] ldr r1 , [ fp , - 0x58 ] ldr r0 , [ fp , - 0x64 ] bl 0xffffa288 mov r3 , r0 mov r0 , r3 bl 0x3932dc mov r2 , r0 mov r3 , r1 mov r0 , r6 mov r1 , r7 bl 0x392fe0 mov r2 , r0 mov r3 , r1 str r2 , [ fp , - 0x44 ] str r3 , [ fp , - 0x40 ] b 0x4d4 mov r3 , 0x0 add r4 , r4 , 0x1 b 0xe4 ldr r3 , [ pc , 0x20 ] ldr r3 , [ r5 , r3 ] ldr r2 , [ fp , - 0x20 ] ldr r3 , [ r3 ] cmp r2 , r3 beq 0x650 bl 0xfffa3f24 sub sp , fp , 0x18 pop { r4 , r5 , r6 , r7 , r8 , fp , pc } ldrdeq sl , fp , [ r4 ] , - 0x4 andeq r0 , r0 , ip , lsl 0x27 ldrbtmi pc , [ pc ] , r0 , lsl 0x30 andseq r0 , r0 , r0 , lsl r0 mrclo p0 , 0x7 , r0 , c0 , c0 , 0x0
Code2: lui gp , 0x34 addiu gp , gp , - 0x7274 addu gp , gp , t9 addiu sp , sp , - 0x90 lw t9 , - 0x6fb8 ( gp ) sdc1 f28 , 0x88 ( sp ) sw gp , 0x18 ( sp ) sdc1 f26 , 0x80 ( sp ) sw ra , 0x64 ( sp ) sdc1 f24 , 0x78 ( sp ) sw s3 , 0x4c ( sp ) move s3 , a0 sdc1 f22 , 0x70 ( sp ) sw s2 , 0x48 ( sp ) sdc1 f20 , 0x68 ( sp ) sw fp , 0x60 ( sp ) sw s7 , 0x5c ( sp ) sw s6 , 0x58 ( sp ) sw s5 , 0x54 ( sp ) sw s4 , 0x50 ( sp ) sw s1 , 0x44 ( sp ) jalr t9 sw s0 , 0x40 ( sp ) lw gp , 0x18 ( sp ) lw t9 , - 0x73b0 ( gp ) jalr t9 move s2 , v0 lw v1 , 0x34 ( s3 ) lw gp , 0x18 ( sp ) teq s2 , zero , 0x7 div zero , v1 , s2 mfhi s2 slt a0 , v0 , s2 beqz a0 , 0x94 mflo v1 addiu v1 , v1 , 0x1 move s2 , zero mul a0 , v1 , v0 addu s2 , a0 , s2 addu v0 , v1 , s2 sw v0 , 0x24 ( sp ) slt v0 , s2 , v0 beqz v0 , 0x4f0 lw v0 , - 0x7fd0 ( gp ) move s0 , s3 lw v1 , - 0x7fd0 ( gp ) lw a0 , - 0x7fd0 ( gp ) sw v0 , 0x34 ( sp ) lwc1 f28 , - 0x1e10 ( v0 ) lw v0 , 0x1c ( s3 ) ldc1 f22 , ( s3 ) lw s4 , 0x20 ( s3 ) ldc1 f20 , - 0x2428 ( v1 ) lw s5 , 0xc ( s3 ) ldc1 f24 , - 0x2420 ( a0 ) lw s7 , 0x8 ( s3 ) lw s6 , 0x30 ( s3 ) lw fp , 0x10 ( s3 ) sw v0 , 0x2c ( sp ) move s1 , s7 lw v0 , 0x18 ( s3 ) move s7 , s5 sw v1 , 0x38 ( sp ) move s5 , s4 sw a0 , 0x3c ( sp ) move s4 , s2 sw v0 , 0x30 ( sp ) lw v0 , 0x14 ( s3 ) sw v0 , 0x28 ( sp ) lw v0 , 0x38 ( s0 ) beqz v0 , 0x4e4 lw v0 , 0x24 ( sp ) addiu s3 , zero , 0x1 lw t9 , - 0x725c ( gp ) lw a0 , 0x30 ( sp ) move a1 , zero move a3 , s6 sw s3 , 0x10 ( sp ) move a2 , s4 jalr t9 sw fp , 0x14 ( sp ) move a1 , zero lw gp , 0x18 ( sp ) move a3 , s6 lw a0 , 0x2c ( sp ) move a2 , s4 sw s3 , 0x10 ( sp ) move s2 , v0 lw t9 , - 0x725c ( gp ) jalr t9 sw fp , 0x14 ( sp ) move a1 , zero lw gp , 0x18 ( sp ) move a3 , s6 lw a0 , 0x28 ( sp ) move a2 , s4 sw s3 , 0x10 ( sp ) move s3 , v0 lw t9 , - 0x7c64 ( gp ) jalr t9 sw fp , 0x14 ( sp ) beqz s2 , 0x4dc lw gp , 0x18 ( sp ) beqz s3 , 0x4dc nop beqz v0 , 0x4dc nop blez s6 , 0x4c4 lw v1 , 0x34 ( sp ) move t4 , zero lw t0 , 0x2d0 ( s1 ) addiu t7 , zero , 0x4 lw t5 , 0x2c ( s0 ) lwc1 f10 , - 0x1e10 ( v1 ) lw v1 , - 0x7fd0 ( gp ) lw t8 , 0x4c ( t0 ) lw t9 , 0x24 ( s0 ) lwc1 f6 , - 0x158 ( v1 ) lw v1 , 0x38 ( sp ) lw t6 , 0x28 ( s0 ) ldc1 f12 , - 0x2428 ( v1 ) mov.s f26 , f10 lw v1 , 0x3c ( sp ) mov.s f8 , f6 b 0x2dc ldc1 f14 , - 0x2420 ( v1 ) lw v1 , 0x50 ( t1 ) sll v1 , v1 , 0x2 addu v1 , s3 , v1 lwc1 f0 , ( v1 )
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two assembly codes show fundamental differences that indicate they are not similar. Code1 uses ARM architecture instructions (push, ldr, str, bl with ARM registers like r0-r8, fp, sp, lr) and employs a stack frame with negative offsets from fp. Code2 uses MIPS architecture instructions (lui, addiu, lw, sw, jalr with MIPS registers like gp, sp, t9, s0-s7) and features floating-point operations (sdc1, ldc1) absent in Code1. The register usage patterns, instruction sets, memory addressing modes, and absence of overlapping functional sequences confirm these are distinct programs targeting different processors. The architectural mismatch alone results in a -1 similarity score.
------------------------------------------------------------

------------------------------------------------------------
Code1: push rbp mov rbp , rsp movabs rdi , 0x6ee420 call 0x9320 pop rbp ret nop word ptr cs : [ rax + rax ] nop
Code2: lui gp , 0x6c lui a0 , 0x6b addiu gp , gp , 0x2ee0 lw t9 , - 0x6768 ( gp ) b 0x9454 addiu a0 , a0 , - 0x7bcc
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The two code snippets are from entirely different architectures (x86_64 vs MIPS) with no overlapping instructions or registers. Code1 uses x86_64-specific registers (rbp, rsp, rdi) and operations (push, movabs, call), while Code2 uses MIPS-specific registers (gp, a0, t9) and operations (lui, addiu, lw, b). The control flow patterns and instruction semantics are fundamentally different, with Code1 showing function call/return conventions and Code2 featuring immediate loading and branching. There are no equivalent operations or structural similarities.
------------------------------------------------------------

------------------------------------------------------------
Code1: push ebp mov ebp , esp push edi push esi sub esp , 0x90 mov eax , dword ptr [ ebp + 0x14 ] mov ecx , dword ptr [ ebp + 0x10 ] mov edx , dword ptr [ ebp + 0xc ] mov esi , dword ptr [ ebp + 0x8 ] cmp dword ptr [ ebp + 0x8 ] , 0x0 mov dword ptr [ ebp - 0x30 ] , eax mov dword ptr [ ebp - 0x34 ] , ecx mov dword ptr [ ebp - 0x38 ] , edx mov dword ptr [ ebp - 0x3c ] , esi je 0xa3 mov eax , dword ptr [ ebp + 0x8 ] mov dword ptr [ esp ] , eax call 0x7110 cmp eax , 0x0 je 0xa3 call 0xffffb2e0 mov eax , dword ptr [ eax ] mov dword ptr [ esp ] , eax call 0x1140 test al , 0x1 jne 0xa3 call 0xffffb2e0 xor ecx , ecx mov eax , dword ptr [ eax ] mov edx , dword ptr [ ebp + 0x14 ] mov dword ptr [ esp ] , 0x0 mov dword ptr [ esp + 0x4 ] , 0x3 mov dword ptr [ esp + 0x8 ] , edx mov dword ptr [ ebp - 0x40 ] , ecx mov dword ptr [ ebp - 0x44 ] , eax call 0x47a0 mov dword ptr [ esp ] , 0x1 mov ecx , dword ptr [ ebp - 0x44 ] mov dword ptr [ esp + 0x4 ] , ecx lea ecx , [ 0x805a16a ] mov dword ptr [ esp + 0x8 ] , ecx mov dword ptr [ esp + 0xc ] , eax call 0xffffb170 cmp dword ptr [ ebp + 0xc ] , 0x0 jl 0x183 cmp dword ptr [ ebp + 0x8 ] , 0x0 jne 0x116 mov eax , dword ptr [ ebp + 0xc ] mov dword ptr [ esp ] , eax call 0xffffb430 cmp eax , 0x0 jge 0x116 call 0xffffb2e0 xor ecx , ecx mov eax , dword ptr [ eax ] mov edx , dword ptr [ ebp + 0x14 ] mov dword ptr [ esp ] , 0x0 mov dword ptr [ esp + 0x4 ] , 0x3 mov dword ptr [ esp + 0x8 ] , edx mov dword ptr [ ebp - 0x48 ] , ecx mov dword ptr [ ebp - 0x4c ] , eax call 0x47a0 mov dword ptr [ esp ] , 0x1 mov ecx , dword ptr [ ebp - 0x4c ] mov dword ptr [ esp + 0x4 ] , ecx lea ecx , [ 0x805a16a ] mov dword ptr [ esp + 0x8 ] , ecx mov dword ptr [ esp + 0xc ] , eax call 0xffffb170 mov dword ptr [ ebp - 0xc ] , 0x0 mov eax , dword ptr [ ebp - 0xc ] cmp eax , dword ptr [ 0x805c520 ] jae 0x17e mov eax , dword ptr [ 0x805c524 ] mov ecx , dword ptr [ ebp - 0xc ] mov eax , dword ptr [ eax + ecx * 0x4 ] cmp eax , dword ptr [ ebp + 0xc ] jne 0x16b mov eax , dword ptr [ 0x805c524 ] mov ecx , dword ptr [ 0x805c520 ] mov edx , ecx add edx , - 0x1 mov dword ptr [ 0x805c520 ] , edx mov eax , dword ptr [ eax + ecx * 0x4 - 0x4 ] mov ecx , dword ptr [ 0x805c524 ] mov edx , dword ptr [ ebp - 0xc ] mov dword ptr [ ecx + edx * 0x4 ] , eax jmp 0x17e jmp 0x170 mov eax , dword ptr [ ebp - 0xc ] add eax , 0x1 mov dword ptr [ ebp - 0xc ] , eax jmp 0x11d jmp 0x183 cmp dword ptr [ ebp + 0x10 ] , 0x0 jle 0x3ab xor eax , eax mov dword ptr [ ebp - 0x10 ] , 0x0 mov ecx , dword ptr [ ebp + 0x10 ] mov dword ptr [ esp ] , ecx lea ecx , [ ebp - 0x10 ] mov dword ptr [ esp + 0x4 ] , ecx mov dword ptr [ esp + 0x8 ] , 0x0 mov dword ptr [ ebp - 0x50 ] , eax call 0xffffb120 cmp eax , - 0x1 jne 0x1f9 call 0xffffb2e0 cmp dword ptr [ eax ] , 0xa je 0x1f9 call 0xffffb2e0 mov eax , dword ptr [ eax ] lea ecx , [ 0x805a100 ] mov dword ptr [ esp ] , ecx mov dword ptr [ ebp - 0x54 ] , eax call 0xffffb1d0 mov dword ptr [ esp ] , 0x1 mov ecx , dword ptr [ ebp - 0x54 ] mov dword ptr [ esp + 0x4 ] , ecx mov dword ptr [ esp + 0x8 ] , eax call 0xffffb170 mov eax , dword ptr [ ebp - 0x10 ] and eax , 0x7f add eax , 0x1 mov cl , al movsx eax , cl sar eax , 0x1 cmp eax , 0x0 jle 0x2d5 mov eax , dword ptr [ ebp - 0x10 ] and eax , 0x7f mov dword ptr [ ebp - 0x14 ] , eax cmp dword ptr [ ebp - 0x14 ] , 0xd je 0x2d0 lea eax , [ ebp - 0x27 ] mov ecx , dword ptr [ ebp - 0x14 ] mov dword ptr [ esp ] , ecx mov dword ptr [ esp + 0x4 ] , eax call 0x7fb0 cmp eax , 0x0 je 0x260 lea eax , [ ebp - 0x27 ] mov ecx , dword ptr [ ebp - 0x14 ] mov dword ptr [ esp ] , eax lea eax , [ 0x805a11a ] mov dword ptr [ esp + 0x4 ] , eax mov dword ptr [ esp + 0x8 ] , ecx call 0xffffb3b0 mov dword ptr [ ebp - 0x58 ] , eax mov eax , dword ptr [ ebp - 0x14 ] add eax , 0x80 lea ecx , [ 0x805a11d ] mov dword ptr [ esp ] , ecx mov dword ptr [ ebp - 0x5c ] , eax call 0xffffb1d0 xor ecx , ecx mov edx , dword ptr [ ebp + 0x14 ] mov dword ptr [ esp ] , 0x0 mov dword ptr [ esp + 0x4 ] , 0x3 mov dword ptr [ esp + 0x8 ] , edx mov dword ptr [ ebp - 0x60 ] , eax mov dword ptr [ ebp - 0x64 ] , ecx call 0x47a0 xor ecx , ecx lea edx , [ ebp - 0x27 ] mov esi , dword ptr [ 0x805c39c ] mov edi , dword ptr [ ebp - 0x5c ] mov dword ptr [ esp ] , edi mov dword ptr [ esp + 0x4 ] , 0x0 mov edi , dword ptr [ ebp - 0x60 ] mov dword ptr [ esp + 0x8 ] , edi mov dword ptr [ esp + 0xc ] , eax mov dword ptr [ esp + 0x10 ] , edx mov dword ptr [ esp + 0x14 ] , esi mov dword ptr [ ebp - 0x68 ] , ecx call 0xffffb170 jmp 0x3a6 mov eax , dword ptr [ ebp - 0x10 ] and eax , 0x7f cmp eax , 0x0 jne 0x36c mov eax , dword ptr [ ebp - 0x10 ] and eax , 0xff00 sar eax , 0x8 mov dword ptr [ ebp - 0x2c ] , eax cmp dword ptr [ ebp - 0x2c ] , 0x0 je 0x367 mov eax , dword ptr [ ebp - 0x2c ] lea ecx , [ 0x805a146 ] mov dword ptr [ esp ] , ecx mov dword ptr [ ebp - 0x6c ] , eax call 0xffffb1d0 xor ecx , ecx mov edx , dword ptr [ ebp + 0x14 ] mov dword ptr [ esp ] , 0x0 mov dword ptr [ esp + 0x4 ] , 0x3 mov dword ptr [ esp + 0x8 ] , edx mov dword ptr [ ebp - 0x70 ] , eax mov dword ptr [ ebp - 0x74 ] , ecx call 0x47a0 xor ecx , ecx mov edx , dword ptr [ ebp - 0x2c ] mov esi , dword ptr [ 0x805c39c ] mov edi , dword ptr [ ebp - 0x6c ] mov dword ptr [ esp ] , edi mov dword ptr [ esp + 0x4 ] , 0x0 mov edi , dword ptr [ ebp - 0x70 ] mov dword ptr [ esp + 0x8 ] , edi mov dword ptr [ esp + 0xc ] , eax mov dword ptr [ esp + 0x10 ] , edx mov dword ptr [ esp + 0x14 ] , esi mov dword ptr [ ebp - 0x78 ] , ecx call 0xffffb170 jmp 0x3a1 lea eax , [ 0x805a16d ] mov dword ptr [ esp ] , eax call 0xffffb1d0 xor ecx , ecx mov edx , dword ptr [ ebp - 0x10 ] add edx , 0x0 mov dword ptr [ esp ] , 0x1 mov dword ptr [ esp + 0x4 ] , 0x0 mov dword ptr [ esp + 0x8 ] , eax mov dword ptr [ esp + 0xc ] , edx mov dword ptr [ ebp - 0x7c ] , ecx call 0xffffb170 jmp 0x3a6 jmp 0x3ab add esp , 0x90 pop esi pop edi pop ebp ret nop word ptr cs : [ eax + eax ] nop
Code2: push ebp mov ebp , esp push ebx push edi push esi sub esp , 0x8c mov eax , dword ptr [ ebp + 0x14 ] mov ecx , dword ptr [ ebp + 0x10 ] mov edx , dword ptr [ ebp + 0xc ] mov esi , dword ptr [ ebp + 0x8 ] mov edi , dword ptr [ ebp + 0x8 ] test edi , edi setne bl movzx edi , bl mov edi , dword ptr [ edi * 0x4 + 0x805b1d8 ] mov dword ptr [ ebp - 0x34 ] , eax mov dword ptr [ ebp - 0x38 ] , ecx mov dword ptr [ ebp - 0x3c ] , edx mov dword ptr [ ebp - 0x40 ] , esi jmp edi mov eax , dword ptr [ ebp + 0x8 ] mov ecx , esp mov dword ptr [ ecx ] , eax call 0x64c0 test eax , eax setne dl movzx eax , dl mov eax , dword ptr [ eax * 0x4 + 0x805b1e0 ] jmp eax call 0xffffb1d0 mov eax , dword ptr [ eax ] mov ecx , esp mov dword ptr [ ecx ] , eax call 0x12e0 movzx ecx , al mov ecx , dword ptr [ ecx * 0x4 + 0x805b1e8 ] jmp ecx call 0xffffb1d0 xor ecx , ecx mov eax , dword ptr [ eax ] mov edx , dword ptr [ ebp + 0x14 ] mov dword ptr [ esp ] , 0x0 mov dword ptr [ esp + 0x4 ] , 0x3 mov dword ptr [ esp + 0x8 ] , edx mov dword ptr [ ebp - 0x44 ] , ecx mov dword ptr [ ebp - 0x48 ] , eax call 0x46c0 mov dword ptr [ esp ] , 0x1 mov ecx , dword ptr [ ebp - 0x48 ] mov dword ptr [ esp + 0x4 ] , ecx lea ecx , [ 0x80573de ] mov dword ptr [ esp + 0x8 ] , ecx mov dword ptr [ esp + 0xc ] , eax call 0xffffb060 mov eax , dword ptr [ ebp + 0xc ] not eax shr eax , 0x1f mov eax , dword ptr [ eax * 0x4 + 0x805b1f0 ] jmp eax mov eax , dword ptr [ ebp + 0x8 ] test eax , eax sete cl movzx eax , cl mov eax , dword ptr [ eax * 0x4 + 0x805b1f8 ] jmp eax mov eax , dword ptr [ ebp + 0xc ] mov ecx , esp mov dword ptr [ ecx ] , eax call 0xffffb320 shr eax , 0x1f mov eax , dword ptr [ eax * 0x4 + 0x805b200 ] jmp eax call 0xffffb1d0 xor ecx , ecx mov eax , dword ptr [ eax ] mov edx , dword ptr [ ebp + 0x14 ] mov dword ptr [ esp ] , 0x0 mov dword ptr [ esp + 0x4 ] , 0x3 mov dword ptr [ esp + 0x8 ] , edx mov dword ptr [ ebp - 0x4c ] , ecx mov dword ptr [ ebp - 0x50 ] , eax call 0x46c0 mov dword ptr [ esp ] , 0x1 mov ecx , dword ptr [ ebp - 0x50 ] mov dword ptr [ esp + 0x4 ] , ecx lea ecx , [ 0x80573de ] mov dword ptr [ esp + 0x8 ] , ecx mov dword ptr [ esp + 0xc ] , eax call 0xffffb060 mov dword ptr [ ebp - 0x10 ] , 0x0 mov eax , dword ptr [ 0x805a928 ] jmp eax mov eax , dword ptr [ ebp - 0x10 ] mov ecx , dword ptr [ 0x805d020 ] sub eax , ecx setb dl movzx ecx , dl mov ecx , dword ptr [ ecx * 0x4 + 0x805b208 ] mov dword ptr [ ebp - 0x54 ] , eax jmp ecx mov eax , dword ptr [ 0x805d024 ] mov ecx , dword ptr [ ebp - 0x10 ] mov eax , dword ptr [ eax + ecx * 0x4 ] mov ecx , dword ptr [ ebp + 0xc ] sub eax , ecx sete dl movzx ecx , dl mov ecx , dword ptr [ ecx * 0x4 + 0x805b210 ] mov dword ptr [ ebp - 0x58 ] , eax jmp ecx mov eax , dword ptr [ 0x805d024 ] mov ecx , dword ptr [ 0x805d020 ] mov edx , ecx dec edx mov dword ptr [ 0x805d020 ] , edx mov eax , dword ptr [ eax + ecx * 0x4 - 0x4 ] mov ecx , dword ptr [ 0x805d024 ] mov edx , dword ptr [ ebp - 0x10 ] mov dword ptr [ ecx + edx * 0x4 ] , eax mov eax , dword ptr [ 0x805a93c ] jmp eax mov eax , dword ptr [ 0x805a938 ] jmp eax mov eax , dword ptr [ ebp - 0x10 ] inc eax mov dword ptr [ ebp - 0x10 ] , eax mov eax , dword ptr [ 0x805a928 ] jmp eax mov eax , dword ptr [ 0x805a940 ] jmp eax mov eax , dword ptr [ ebp + 0x10 ] test eax , eax setg cl movzx eax , cl mov eax , dword ptr [ eax * 0x4 + 0x805b218 ] jmp eax mov dword ptr [ ebp - 0x14 ] , 0x0 mov eax , dword ptr [ ebp + 0x10 ] mov ecx , esp lea edx , [ ebp - 0x14 ] mov dword ptr [ ecx + 0x4 ] , edx mov dword ptr [ ecx ] , eax mov dword ptr [ ecx + 0x8 ] , 0x0 call 0xffffb010 sub eax , - 0x1 sete bl movzx ecx , bl mov ecx , dword ptr [ ecx * 0x4 + 0x805b220 ] mov dword ptr [ ebp - 0x5c ] , eax jmp ecx call 0xffffb1d0 mov eax , dword ptr [ eax ] sub eax , 0xa setne cl movzx edx , cl mov edx , dword ptr [ edx * 0x4 + 0x805b228 ] mov dword ptr [ ebp - 0x60 ] , eax jmp edx call 0xffffb1d0 mov eax , dword ptr [ eax ] lea ecx , [ 0x8057374 ] mov dword ptr [ esp ] , ecx mov dword ptr [ ebp - 0x64 ] , eax call 0xffffb0c0 mov dword ptr [ esp ] , 0x1 mov ecx , dword ptr [ ebp - 0x64 ] mov dword ptr [ esp + 0x4 ] , ecx mov dword ptr [ esp + 0x8 ] , eax call 0xffffb060 mov eax , dword ptr [ ebp - 0x14 ] and eax , 0x7f inc eax mov cl , al movsx eax , cl sar eax , 0x1 test eax , eax setg cl movzx eax , cl mov eax , dword ptr [ eax * 0x4 + 0x805b230 ] jmp eax mov eax , dword ptr [ ebp - 0x14 ] and eax , 0x7f mov dword ptr [ ebp - 0x18 ] , eax mov eax , dword ptr [ ebp - 0x18 ] sub eax , 0xd setne cl movzx edx , cl mov edx , dword ptr [ edx * 0x4 + 0x805b238 ] mov dword ptr [ ebp - 0x68 ] , eax jmp edx mov eax , dword ptr [ ebp - 0x18 ] mov ecx , esp lea edx , [ ebp - 0x2b ] mov dword ptr [ ecx + 0x4 ] , edx mov dword ptr [ ecx ] , eax call 0x6be0 test eax , eax setne bl movzx eax , bl mov eax , dword ptr [ eax * 0x4 + 0x805b240 ] jmp eax mov eax , dword ptr [ ebp - 0x18 ] mov ecx , esp mov dword ptr [ ecx + 0x8 ] , eax lea eax , [ ebp - 0x2b ] mov dword ptr [ ecx ] , eax mov dword ptr [ ecx + 0x4 ] , 0x805738e call 0xffffb2a0 mov ecx , dword ptr [ 0x805a960 ] mov dword ptr [ ebp - 0x6c ] , eax jmp ecx mov eax , dword ptr [ ebp - 0x18 ] sub eax , - 0x80 mov ecx , esp mov dword ptr [ ecx ] , 0x8057391 mov dword ptr [ ebp - 0x70 ] , eax call 0xffffb0c0 mov ecx , dword ptr [ ebp + 0x14 ] mov edx , esp mov dword ptr [ edx + 0x8 ] , ecx mov dword ptr [ edx + 0x4 ] , 0x3 mov dword ptr [ edx ] , 0x0 mov dword ptr [ ebp - 0x74 ] , eax call 0x46c0 mov ecx , dword ptr [ 0x805ce9c ] mov edx , esp mov dword ptr [ edx + 0x14 ] , ecx lea ecx , [ ebp - 0x2b ] mov dword ptr [ edx + 0x10 ] , ecx mov dword ptr [ edx + 0xc ] , eax mov eax , dword ptr [ ebp - 0x74 ] mov dword ptr [ edx + 0x8 ] , eax mov ecx , dword ptr [ ebp - 0x70 ] mov dword ptr [ edx ] , ecx mov dword ptr [ edx + 0x4 ] , 0x0 call 0xffffb060 mov eax , dword ptr [ 0x805a964 ] jmp eax mov eax , dword ptr [ 0x805a980 ] jmp eax mov al , byte ptr [ ebp - 0x14 ] test al , 0x7f sete al movzx ecx , al mov ecx , dword ptr [ ecx * 0x4 + 0x805b248 ] jmp ecx movzx eax , byte ptr [ ebp - 0x13 ] mov dword ptr [ ebp - 0x30 ] , eax mov eax , dword ptr [ ebp - 0x30 ] test eax , eax setne cl movzx eax , cl mov eax , dword ptr [ eax * 0x4 + 0x805b250 ] jmp eax mov eax , dword ptr [ ebp - 0x30 ] mov ecx , esp mov dword ptr [ ecx ] , 0x80573ba mov dword ptr [ ebp - 0x78 ] , eax call 0xffffb0c0 mov ecx , dword ptr [ ebp + 0x14 ] mov edx , esp mov dword ptr [ edx + 0x8 ] , ecx mov dword ptr [ edx + 0x4 ] , 0x3 mov dword ptr [ edx ] , 0x0 mov dword ptr [ ebp - 0x7c ] , eax call 0x46c0 mov ecx , dword ptr [ ebp - 0x30 ] mov edx , dword ptr [ 0x805ce9c ] mov esi , esp mov dword ptr [ esi + 0x14 ] , edx mov dword ptr [ esi + 0x10 ] , ecx mov dword ptr [ esi + 0xc ] , eax mov eax , dword ptr [ ebp - 0x7c ] mov dword ptr [ esi + 0x8 ] , eax mov ecx , dword ptr [ ebp - 0x78 ] mov dword ptr [ esi ] , ecx mov dword ptr [ esi + 0x4 ] , 0x0 call 0xffffb060 mov eax , dword ptr [ 0x805a974 ] jmp eax mov eax , dword ptr [ 0x805a97c ] jmp eax lea eax , [ 0x80573e1 ] mov dword ptr [ esp ] , eax call 0xffffb0c0 xor ecx , ecx mov edx , dword ptr [ ebp - 0x14 ] add edx , 0x0 mov dword ptr [ esp ] , 0x1 mov dword ptr [ esp + 0x4 ] , 0x0 mov dword ptr [ esp + 0x8 ] , eax mov dword ptr [ esp + 0xc ] , edx mov dword ptr [ ebp - 0x80 ] , ecx call 0xffffb060 mov eax , dword ptr [ 0x805a980 ] jmp eax mov eax , dword ptr [ 0x805a984 ] jmp eax add esp , 0x8c pop esi pop edi pop ebx pop ebp ret nop word ptr cs : [ eax + eax ] nop
Similarity: -1
Label: 1
Similarity Score: 0.25
Explanation: Both codes share a similar function structure with prologue (push ebp, mov ebp,esp), register preservation, stack allocation, and epilogue (stack cleanup, pops, ret). However, they show significant differences: 
1. Register usage differs (code1 uses edi/esi, code2 uses ebx/edi/esi)
2. Control flow varies substantially - code1 uses direct conditional jumps (je/jne) while code2 uses jump tables and flag-based branching
3. Memory offsets and constants differ (e.g., stack allocations 0x90 vs 0x8c, address references like 0x805a16a vs 0x80573de)
4. Function calls target different addresses (e.g., call 0x7110 vs call 0x64c0)
5. Core logic operations (comparisons, bit manipulations) follow different patterns
The shared structural elements suggest both are function implementations, but the operational differences indicate distinct functionality.
------------------------------------------------------------

------------------------------------------------------------
Code1: addiu sp , sp , - 0x2050 sw ra , 0x204c ( sp ) sw fp , 0x2048 ( sp ) sw s5 , 0x2044 ( sp ) sw s4 , 0x2040 ( sp ) sw s3 , 0x203c ( sp ) sw s2 , 0x2038 ( sp ) sw s1 , 0x2034 ( sp ) sw s0 , 0x2030 ( sp ) move fp , sp lui gp , 0x43 addiu gp , gp , 0x4100 sw gp , 0x10 ( sp ) sw a0 , 0x1c ( fp ) sw a1 , 0x2054 ( fp ) sw a3 , 0x205c ( fp ) sw a2 , 0x2058 ( fp ) lw v0 , 0x2060 ( fp ) sw v0 , 0x18 ( fp ) lw v0 , - 0x7d8c ( gp ) lw v0 , ( v0 ) sw v0 , 0x202c ( fp ) b 0x224 nop addiu v0 , fp , 0x2c addiu a2 , zero , 0x2000 move a1 , v0 lw a0 , 0x2054 ( fp ) lw v0 , - 0x7fc8 ( gp ) move t9 , v0 bal 0xd070 nop lw gp , 0x10 ( fp ) sw v0 , 0x24 ( fp ) lw v0 , 0x24 ( fp ) bnez v0 , 0xa0 nop addiu v0 , zero , - 0x1 b 0x248 nop lw v1 , 0x24 ( fp ) addiu v0 , zero , - 0x1 bne v1 , v0 , 0x134 nop lw v0 , - 0x7e28 ( gp ) move t9 , v0 jalr t9 nop lw gp , 0x10 ( fp ) lw s0 , ( v0 ) lui v0 , 0x42 addiu a0 , v0 , - 0x5bc4 lw v0 , - 0x7df4 ( gp ) move t9 , v0 jalr t9 nop lw gp , 0x10 ( fp ) move s1 , v0 lw a1 , 0x1c ( fp ) addiu a0 , zero , 0x4 lw v0 , - 0x7fcc ( gp ) move t9 , v0 bal 0xca44 nop lw gp , 0x10 ( fp ) move a3 , v0 move a2 , s1 move a1 , s0 move a0 , zero lw v0 , - 0x7dd4 ( gp ) move t9 , v0 jalr t9 nop lw gp , 0x10 ( fp ) addiu v0 , zero , 0x1 b 0x248 nop lw v0 , 0x18 ( fp ) lw a1 , 0x4 ( v0 ) lw a0 , ( v0 ) lw v0 , 0x24 ( fp ) move s3 , v0 move s2 , zero addu v1 , a1 , s3 sltu a2 , v1 , a1 addu v0 , a0 , s2 addu a0 , a2 , v0 move v0 , a0 lw a0 , 0x18 ( fp ) sw v1 , 0x4 ( a0 ) sw v0 , ( a0 ) lw v0 , 0x24 ( fp ) move s1 , v0 move s0 , zero lw v0 , 0x2058 ( fp ) sltu v0 , v0 , s0 bnez v0 , 0x1e0 nop lw v0 , 0x2058 ( fp ) move v1 , s0 bne v0 , v1 , 0x1a8 nop lw v0 , 0x205c ( fp ) sltu v0 , v0 , s1 bnez v0 , 0x1e0 nop lw v0 , 0x24 ( fp ) move s5 , v0 move s4 , zero lw a1 , 0x205c ( fp ) lw a0 , 0x2058 ( fp ) subu v1 , a1 , s5 sltu a2 , a1 , v1 subu v0 , a0 , s4 subu a0 , v0 , a2 move v0 , a0 sw v1 , 0x205c ( fp ) sw v0 , 0x2058 ( fp ) b 0x224 nop lw v0 , 0x205c ( fp ) lw v1 , 0x24 ( fp ) subu v0 , v1 , v0 sw v0 , 0x28 ( fp ) lw v0 , 0x28 ( fp ) beqz v0 , 0x240 nop addiu v1 , fp , 0x2c lw v0 , 0x205c ( fp ) addu v0 , v1 , v0 lw a1 , 0x28 ( fp ) move a0 , v0 jal 0x40399c nop lw gp , 0x10 ( fp ) b 0x240 nop lw v0 , 0x2058 ( fp ) lw v1 , 0x205c ( fp ) or v0 , v0 , v1 bnez v0 , 0x60 nop b 0x244 nop nop move v0 , zero lw v1 , - 0x7d8c ( gp ) lw a0 , 0x202c ( fp ) lw v1 , ( v1 ) beq a0 , v1 , 0x26c nop lw v0 , - 0x7da4 ( gp ) move t9 , v0 jalr t9 nop move sp , fp lw ra , 0x204c ( sp ) lw fp , 0x2048 ( sp ) lw s5 , 0x2044 ( sp ) lw s4 , 0x2040 ( sp ) lw s3 , 0x203c ( sp ) lw s2 , 0x2038 ( sp ) lw s1 , 0x2034 ( sp ) lw s0 , 0x2030 ( sp ) addiu sp , sp , 0x2050 jr ra nop
Code2: push ebp mov ebp , esp push ebx push edi push esi sub esp , 0x4c mov eax , dword ptr [ ebp + 0x14 ] mov ecx , dword ptr [ ebp + 0x10 ] mov edx , dword ptr [ ebp + 0x18 ] mov esi , dword ptr [ ebp + 0xc ] mov edi , dword ptr [ ebp + 0x8 ] cmp dword ptr [ 0x8074b08 ] , 0x0 mov dword ptr [ ebp - 0x10 ] , eax mov dword ptr [ ebp - 0x14 ] , ecx mov dword ptr [ ebp - 0x18 ] , edx mov dword ptr [ ebp - 0x1c ] , esi mov dword ptr [ ebp - 0x20 ] , edi jne 0x100 mov al , byte ptr [ 0x80739c0 ] xor al , 0x42 mov byte ptr [ 0x80739e0 ] , al mov al , byte ptr [ 0x80739c1 ] xor al , 0x25 mov byte ptr [ 0x80739e1 ] , al mov al , byte ptr [ 0x80739c2 ] xor al , 0xba mov byte ptr [ 0x80739e2 ] , al mov al , byte ptr [ 0x80739c3 ] xor al , 0xa mov byte ptr [ 0x80739e3 ] , al mov al , byte ptr [ 0x80739c4 ] xor al , 0xce mov byte ptr [ 0x80739e4 ] , al mov al , byte ptr [ 0x80739c5 ] xor al , 0xe5 mov byte ptr [ 0x80739e5 ] , al mov al , byte ptr [ 0x80739c6 ] xor al , 0x63 mov byte ptr [ 0x80739e6 ] , al mov al , byte ptr [ 0x80739c7 ] xor al , 0x1a mov byte ptr [ 0x80739e7 ] , al mov al , byte ptr [ 0x80739c8 ] xor al , 0x2f mov byte ptr [ 0x80739e8 ] , al mov al , byte ptr [ 0x80739c9 ] xor al , 0x1b mov byte ptr [ 0x80739e9 ] , al mov al , byte ptr [ 0x80739ca ] xor al , 0x43 mov byte ptr [ 0x80739ea ] , al mov al , byte ptr [ 0x80739cb ] xor al , 0x41 mov byte ptr [ 0x80739eb ] , al mov al , byte ptr [ 0x80739cc ] xor al , 0x51 mov byte ptr [ 0x80739ec ] , al mov al , byte ptr [ 0x80739cd ] xor al , 0x48 mov byte ptr [ 0x80739ed ] , al mov al , byte ptr [ 0x80739ce ] xor al , 0x28 mov byte ptr [ 0x80739ee ] , al mov al , byte ptr [ 0x80739cf ] xor al , 0x81 mov byte ptr [ 0x80739ef ] , al mov al , byte ptr [ 0x80739d0 ] xor al , 0xec mov byte ptr [ 0x80739f0 ] , al mov dword ptr [ 0x8074b08 ] , 0x1 mov eax , esp add eax , - 0x10 mov esp , eax mov ecx , esp mov edx , ecx add edx , - 0x10 mov esp , edx mov esi , esp mov edi , esi add edi , - 0x10 mov esp , edi mov ebx , esp mov dword ptr [ ebp - 0x24 ] , eax mov eax , ebx add eax , - 0x10 mov esp , eax mov dword ptr [ ebp - 0x28 ] , eax mov eax , esp add eax , - 0x10 mov esp , eax mov dword ptr [ ebp - 0x2c ] , eax mov eax , esp add eax , 0xffffe000 mov esp , eax mov dword ptr [ ebp - 0x30 ] , eax mov eax , esp add eax , - 0x10 mov esp , eax mov dword ptr [ ebp - 0x34 ] , eax mov eax , esp add eax , - 0x10 mov esp , eax mov dword ptr [ ebp - 0x38 ] , eax mov eax , dword ptr [ ebp - 0x20 ] mov dword ptr [ ecx - 0x10 ] , eax mov ecx , dword ptr [ ebp - 0x1c ] mov dword ptr [ esi - 0x10 ] , ecx mov esi , dword ptr [ ebp - 0x10 ] mov dword ptr [ ebx - 0xc ] , esi mov eax , dword ptr [ ebp - 0x14 ] mov dword ptr [ ebx - 0x10 ] , eax mov ebx , dword ptr [ ebp - 0x2c ] mov eax , dword ptr [ ebp - 0x18 ] mov dword ptr [ ebx ] , eax mov dword ptr [ ebp - 0x3c ] , edx mov dword ptr [ ebp - 0x40 ] , edi mov eax , dword ptr [ ebp - 0x28 ] mov ecx , dword ptr [ eax ] mov edx , dword ptr [ eax + 0x4 ] or ecx , edx mov dword ptr [ ebp - 0x44 ] , ecx je 0x2f1 jmp 0x19a mov eax , dword ptr [ ebp - 0x40 ] mov ecx , dword ptr [ eax ] sub esp , 0x10 mov dword ptr [ esp ] , ecx mov ecx , dword ptr [ ebp - 0x30 ] mov dword ptr [ esp + 0x4 ] , ecx mov dword ptr [ esp + 0x8 ] , 0x2000 call 0xa280 add esp , 0x10 mov ecx , dword ptr [ ebp - 0x34 ] mov dword ptr [ ecx ] , eax cmp dword ptr [ ecx ] , 0x0 jne 0x1d8 mov eax , dword ptr [ ebp - 0x24 ] mov dword ptr [ eax ] , 0xffffffff jmp 0x2fa mov eax , dword ptr [ ebp - 0x34 ] cmp dword ptr [ eax ] , - 0x1 jne 0x257 call 0xfffeb630 lea ecx , [ 0x80739e0 ] mov eax , dword ptr [ eax ] sub esp , 0x10 mov dword ptr [ esp ] , ecx mov dword ptr [ ebp - 0x48 ] , eax call 0xfffeb560 add esp , 0x10 mov ecx , dword ptr [ ebp - 0x3c ] mov edx , dword ptr [ ecx ] sub esp , 0x10 mov dword ptr [ esp ] , 0x4 mov dword ptr [ esp + 0x4 ] , edx mov dword ptr [ ebp - 0x4c ] , eax call 0x9a60 add esp , 0x10 xor ecx , ecx sub esp , 0x10 mov dword ptr [ esp ] , 0x0 mov edx , dword ptr [ ebp - 0x48 ] mov dword ptr [ esp + 0x4 ] , edx mov edx , dword ptr [ ebp - 0x4c ] mov dword ptr [ esp + 0x8 ] , edx mov dword ptr [ esp + 0xc ] , eax mov dword ptr [ ebp - 0x50 ] , ecx call 0xfffeb4f0 add esp , 0x10 mov eax , dword ptr [ ebp - 0x24 ] mov dword ptr [ eax ] , 0x1 jmp 0x2fa mov eax , dword ptr [ ebp - 0x34 ] mov ecx , dword ptr [ eax ] mov edx , dword ptr [ ebp - 0x2c ] mov esi , dword ptr [ edx ] mov edi , dword ptr [ esi ] mov ebx , dword ptr [ esi + 0x4 ] add edi , ecx adc ebx , 0x0 mov dword ptr [ esi ] , edi mov dword ptr [ esi + 0x4 ] , ebx mov ecx , dword ptr [ eax ] mov esi , dword ptr [ ebp - 0x28 ] mov edi , dword ptr [ esi ] mov ebx , dword ptr [ esi + 0x4 ] sub edi , ecx sbb ebx , 0x0 mov dword ptr [ ebp - 0x54 ] , edi mov dword ptr [ ebp - 0x58 ] , ebx jb 0x2ac jmp 0x290 mov eax , dword ptr [ ebp - 0x34 ] mov ecx , dword ptr [ eax ] mov edx , dword ptr [ ebp - 0x28 ] mov esi , dword ptr [ edx ] mov edi , dword ptr [ edx + 0x4 ] sub esi , ecx sbb edi , 0x0 mov dword ptr [ edx ] , esi mov dword ptr [ edx + 0x4 ] , edi jmp 0x2ec mov eax , dword ptr [ ebp - 0x34 ] mov ecx , dword ptr [ eax ] mov edx , dword ptr [ ebp - 0x28 ] mov esi , dword ptr [ edx ] sub ecx , esi mov esi , dword ptr [ ebp - 0x38 ] mov dword ptr [ esi ] , ecx cmp dword ptr [ esi ] , 0x0 je 0x2e7 mov eax , dword ptr [ ebp - 0x28 ] mov ecx , dword ptr [ eax ] mov edx , dword ptr [ ebp - 0x30 ] add edx , ecx mov ecx , dword ptr [ ebp - 0x38 ] mov esi , dword ptr [ ecx ] sub esp , 0x10 mov dword ptr [ esp ] , edx mov dword ptr [ esp + 0x4 ] , esi call 0xfffffd70 add esp , 0x10 jmp 0x2f1 jmp 0x182 mov eax , dword ptr [ ebp - 0x24 ] mov dword ptr [ eax ] , 0x0 mov eax , dword ptr [ ebp - 0x24 ] mov eax , dword ptr [ eax ] lea esp , [ ebp - 0xc ] pop esi pop edi pop ebx pop ebp ret nop word ptr [ eax + eax ]
Similarity: -1
Label: 1
Similarity Score: -1.0
Explanation: The provided assembly codes are for entirely different architectures (MIPS and x86) with distinct instruction sets, register usage, and calling conventions. The MIPS code focuses on stack manipulation and function calls using MIPS-specific registers and instructions, while the x86 code includes byte-level XOR operations and complex stack adjustments not present in the MIPS code. Although both exhibit basic function prologue and epilogue patterns, these are generic and insufficient to establish similarity. The core logic, operations, and architecture-specific implementations are fundamentally different.
------------------------------------------------------------

